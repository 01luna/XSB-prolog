:- import bagReduce/4, bagPO/3, bagPOv/2, bagOf/2,
	bagMin/2, bagMax/2, bagSum/2, bagCount/2, bagAvg/2
	from aggregs.
:- import subsumes_chk/2 from subsumes.
:- import numbervars/3 from num_vars.

/***********************************************************************/
:- import abolish_table_info/0 from machine.
:- import abolish_table_pred/1 from tables.
:- import member/2 from basics.
at :- abolish_table_info.

/* test data and query: test. */
test :- at,fail.
test :- test1.
test :- test2.
test :- test3.
test :- test4.
test :- test5.
test :- test6.
test :- test7.
test :- test8.
test :- test9.
test :- test10.
test :- test11.
test :- test12.
test :- test13.


test1 :- 
	ainterp(app([a,b],[c,d],R),V),
	writeln([R,V]),fail.
test2 :- 
	ainterp(app(X,Y,[a,b,c,d]),V),
	writeln([X,Y,V]),fail.
test3 :- 
	bagPO(hi_call,p(X,Y),subsumed),
	numbervars(p(X,Y),0,_),writeln(p(X,Y)),fail.
test4 :- 
	bagOf(sal(Dept),M), sortbag(M,S),
	write('Dept'=Dept),write(', '),writeln('SalList'=S),fail.
test5 :- 
	% a funny way to do bagOf, inefficient! and not recommended!
	bagReduce(sal(Dept),M,cons,[]), sortbag(M,S),
	write('Dept'=Dept),write(', '), writeln('SalList(reduce)'=S),fail.
test6 :- 
	bagMin(sal(Dept),M),
	write('Dept'=Dept),write(', '),writeln('Minsal'=M),fail.
test7 :- 
	bagMax(sal(Dept),M),
	write('Dept'=Dept),write(', '),writeln('Maxsal'=M),fail.
test8 :- 
	bagAvg(sal(Dept),M),
	write('Dept'=Dept),write(', '),writeln('Avgsal'=M),fail.
test9 :- 
	bagCount(sal(Dept),M),
	write('Dept'=Dept),write(', '),writeln('Count'=M),fail.
test10 :- 
	bagSum(sal(Dept),M),
	write('Dept'=Dept),write(', '),writeln('Sumsal'=M),fail.
test11 :- 
	bagPO(tp(I),V,po),
	write('I'=I),write(', '),writeln('Val'=V),fail.
% bigger tests.
/****/
test12 :- 
	[edge_dag],	% data for testing shortest-path
	bagMin(sp(0,T),Dist), writeln([T,Dist]),fail.
test13 :- 
	bagCount(targsof(X),Count),
	write('Node'=X),write(', '),writeln('NumTargs'=Count),fail.


sortbag(B,S) :- 
	findall(p(X,_),member(X,B),L),
	sort(L,L1),
	findall(X,member(p(X,_),L1),S).


%%:- table empp/2.	% to eliminate duplicates
empp(Dept,Sal) :- emp(_,Dept,Sal).

emp(david,cse,20000).
emp(phil,cse,25000).
emp(iv,cse,22000).
emp(sas,cse,22000).
emp(richard,lin,21000).
emp(mark,lin,51000).

/* Have to put ALL hilog declarations together.  This is a serious
problem. */

% to use this table decl, must compile(aggregs,[unfold_off,spec_repr]).
%%:- table sal(_)(_).
sal(Dept)(Sal) :- empp(Dept,Sal).

:- hilog po.
po(false,top).
po(true,top).
po(bot,top).
po(bot,true).
po(bot,false).

/* test data for partial order */

tp(1)(bot).
tp(1)(false).
tp(1)(true).
tp(2)(bot).
tp(2)(true).
tp(2)(top).
tp(3)(false).
tp(3)(true).
tp(4)(bot).
tp(4)(true).
tp(4)(false).
tp(4)(top).

/* This defines sp(X,Y) as a set of (some short) distances from X to
Y.  Then one can find the shortest paths between points 0 and X, e.g.,
by calling bagMin(sp(0,X),Min). */

sp(X,Y)(D) :- edge(X,Y,D).
sp(X,Y)(D) :- bagMin(sp(X,Z),D1),edge(Z,Y,D2),D is D1+D2.

targsof(X)(Y) :- edge(X,Y,_).

:- hilog cons.		% for (badly) defining bagOf in terms of bagReduce
cons(Y,X,[X|Y]).

:- hilog minimum.
minimum(X,Y,Z) :- X @< Y -> Z=X ; Z=Y.
:- hilog maximum.
maximum(X,Y,Z) :- X @< Y -> Z=Y ; Z=X.
:- hilog sum.
sum(X,Y,Z) :- Z is X+Y.
:- hilog successor.
successor(X,_Y,Z) :- Z is X+1.
:- hilog sumcount.
sumcount([S|C],X,[S1|C1]) :- S1 is S+X, C1 is C+1.

/*******************************************************/
/* An annotated logic meta-interpreter */

ainterp(G,N) :- bagMax(ainterp(G),N).

ainterp(true)(100000) :- !.
ainterp((A,B))(N) :- !,
	ainterp(A,N1),ainterp(B,N2),
	minimum(N1,N2,N).
ainterp(A)(N) :- arule(A,B)(N1), ainterp(B,N2), N is floor(N1*N2).


arule(app([],L,L),true)(1.0).
arule(app([X|L1],L2,[X|L3]),app(L1,L2,L3))(0.9).

arule(a,true)(1.0).
arule(a,true)(0.5).
arule(b,(a,c))(0.9).
arule(c,true)(0.5).
arule(c,(b,a))(0.4).

% to use bagPOv to get lubs by subsumption.
:- hilog subsumed.
subsumed(X,Y) :- subsumes_chk(Y,X).

p(a,b).
p([a],[c,d]).
p([a,b,c],[c,d,e,f]).
p(a,_X).
p([_,_|_],[_|_]).

:- hilog hi_call.
hi_call(X) :- call(X).
