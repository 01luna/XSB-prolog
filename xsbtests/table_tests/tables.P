/************************************************************************/
/*                                                                      */
/* XSB System                                                           */
/* Copyright (C) SUNY at Stony Brook, 1993                              */
/*                                                                      */
/* Everyone is granted permission to copy, modify and redistribute XSB, */
/* but only under the conditions described in the XSB Licence Agreement.*/
/* A copy of this license is supposed to have been given to you along   */
/* with XSB so you can know your rights and responsibilities.           */
/* It should be in a file named LICENSE.                                */
/* Among other things, this notice must be preserved on all copies.     */
/*                                                                      */
/************************************************************************/

/*======================================================================
  File                  :  tables.P
  Author(s)		:  Swift, Rao, Sagonas
  Last modification	:  Oct 8, 1996
========================================================================*/

:- export 
	abolish_all_tables/0,
        abolish_table_call/1,
	abolish_table_pred/1,
	etnot/1,
	get_returns_for_call/2,
	get_calls_for_table/3,
	robust_term_psc/2,
	set_pil_on/0, set_pil_off/0, /* convenience */
	set_prof_on/1, set_prof_off/0, /* convenience */
	set_xtrace_on/0, set_xtrace_off/0, /* convenience */
	show_table/1,
	from_table/1,
	show_table0/1, 		% debugging.
	output_table/2,		% debugging.
	table_copy/2, 
	table_state/2,
	tfindall/3, tnot/1, 't not'/1,
	zero_out_profile_table/0, write_out_profile_table/0,
	make_list/4, %should not be used
	nth_var_reg/2,
	call_psc_tip/3,
	delete_return/2,
	not_most_general/1,
	get_calls/3,
	get_returns/2,
	get_returns/3,
	get_residual/2,
	get_delay_lists/2,
	delete_predicate_table/1,
	is_trie_asserted/1,
	(trie_dynamic)/1,
	trie_assert/1,
	trie_retract/1,
	trie_retract_nr/1,
	trie_retract_all/1,
	abolish_trie_asserted/1,
	breg_retskel/4,	
	tip_struct_disp/2,
	call_struct_disp/2,
	tip_call_trie_root/2,
	subgp_call_trie_leaf/2,
	get_subg_ptr/3,
	get_subg_ptr/2,
	trie_node_element/7.


:- import 
	abolish_table_info/0,
	buff_alloc/3, buff_cell/3, buff_dealloc/4, buff_set_word/3, buff_word/3,
	call_hash/5, conpsc/2, cut_if_leader/3, slg_not/1,
	is_incomplete/5, get_osp_breg/2, get_ptcp/1, get_subgoal_ptr/2,
	print_predicate_table/1,
        psc_tabled/2,
	stat_flag/2, stat_set_flag/3, 
	term_type/2, tip_prop/4, get_emu_dependent_const/2,
	conpsc/2, buff_byte/3, buff_set_byte/3, 
	zero_out_profile/0,write_out_profile/0
	from machine.

:- import nl/0, ttywritenl/1, call_expose/1, call/1, tcall/1,
	  warning/1, tell/1, told/0, alt_write_canonical/1,
	  abort/1, (=..)/2, write/1, writeln/1, arg/3, functor/3
	  from standard.  

:- import copyterm/6 from copyterm.
:- import numbervars/3 from num_vars.
:- import predicate_property/2  from curr_sym.
:- import ground/1, copy_term/2, member/2 from basics.
:- import variant/2 from subsumes.
:- import abolish/1 from assert.

/* need to come to a decision about F/A */

zero_out_profile_table:-
	zero_out_profile.

write_out_profile_table:-
	write_out_profile.

robust_term_psc(Term,Psc):-
	term_type(Term,Type),
	( Type =:= 1 -> conpsc(Term,Psc)
	; Type =:= 5 -> conpsc(Term,Psc)
	; abort('First arg to term_psc/1 is not a callable term')
	).

abolish_all_tables :- 
	abolish_table_info.

	
table_copy(Ptr,New):- Ptr = New. %doesn't do what its supposed to

tfindall(T, Call, Result) :-
	table_state(Call,Res),
	( Res == complete -> tfindall1(T,Call,Result)
	; Res == no_call_yet -> (call(Call),fail ; tfindall(T,Call,Result))
	; Res == incomplete ->
		is_incomplete(Call,0,0,0,_), tfindall1(T,Call,Result)
	).

tfindall1(T, Call, Result) :-
	buff_alloc(65536, Buff, 0),
	findall_1(T, Call, Result, Buff, 65536).

findall_1(T, Call, _Result, Buff, BuffLen) :-
	wordsize(Wordsize),
	copyterm([], Buff, 8, 8, _, BuffLen), /* init result list to empty */
	buff_set_word(Buff, 0, 8), /* init where to put next answer */
	FirstFree is 8 + Wordsize,
	buff_set_word(Buff, 4, FirstFree), /* init first free place */
        Place=Place, Start=Start,End=End,
	call_expose(Call),
	buff_word(Buff, 0, Place), /* get where to put answer */
	buff_word(Buff, 4, Start), /* get first free place */
	copyterm([T], Buff, Place, Start, End, BuffLen),
	Tailloc is Start+Wordsize,
	buff_set_word(Buff, 0, Tailloc), /* where to put next answer */
				/* point to the tail [] */
	buff_set_word(Buff, 4, End), /* next first free place */
	End > BuffLen, ttywritenl('Findall buffer overflow'),
	fail.
findall_1(_, _Call, Result, Buff, BuffLen) :-
	buff_word(Buff, 4, Length),	/* Length =\= 12 fail if [] */
	buff_dealloc(Buff, BuffLen, Length, 0),
	buff_cell(Buff, 8, Result0),
	Result = Result0.

wordsize(8) :- stat_flag(18, Word), Word = 3, !.
wordsize(4).

tnot(X):-
	( ground(X) -> 't not'(X)
	; abort('FLOUNDERING: tnot/1 used with a non-ground negative subgoal')
	).

't not'(X) :-
	get_ptcp(PTCP), get_subgoal_ptr(X, SubgPtr),
	( SubgPtr =:= 0, tcall(X), fail
	; is_incomplete(X, SubgPtr, PTCP, 1, Subg), slg_not(Subg)
	).

etnot(X):-
	get_ptcp(PTCP), get_osp_breg(Os, Breg),
	( call(X), cut_if_leader(X, Os, Breg), fail
	; Usage = 2, is_incomplete(X, 0, PTCP, Usage, Subg), slg_not(Subg)
	).

set_prof_on(Level):-
	stat_set_flag(52,Level,1).

set_prof_off:-
	stat_set_flag(52,0,1).

set_pil_on:-
	stat_set_flag(0,1,1).

set_pil_off:-
	stat_set_flag(0,0,1).

set_xtrace_on:-
	stat_set_flag(51,1,1).

set_xtrace_off:-
	stat_set_flag(51,0,1).

show_table0('/'(F,A)):-!,
	functor(Term,F,A),
	robust_term_psc(Term,Psc),
	print_predicate_table(Psc).

show_table(P/A) :-
	functor(Skel,P,A),
	get_calls_for_table(Skel,Call,Empty),
	(Empty == empty
	 ->	numbervars(Call,0,_),
		write('Call: '),write(Call),ttywritenl(': empty'),
		fail
	 ;	(numbervars(Call,0,_),
		 write('Call: '),write(Call),ttywritenl(':'),fail
		;
		 true
		),
		get_returns_for_call(Call,Ret),
		numbervars(Ret,0,_),
		write(' Ret: '),write(Ret),ttywritenl('.'),
		fail
	).


from_table(Skel) :-
	\+ get_calls_for_table(Skel,Call,_)
	 ->	warning('No unifying call in table.'),
		fail
	 ;	get_calls_for_table(Skel,Call,notempty),
		get_returns_for_call(Call,Skel).


output_table(Term,File) :-
	tell(File),
	output_table_1(Term),
	told.

output_table_1(Term) :-
	get_calls_for_table(Term,Call,Empty),
	Empty == notempty,
	get_returns_for_call(Call,Return),
	numbervars(Return,0,_),
	alt_write_canonical(Return),
	nl,
	fail.
output_table_1(_Term).

abolish_table_call(Call) :- 	
	call_psc_tip(Call,_Psc,Tip),
	get_subg_ptr(Call,Tip,SubgPtr),
        (SubgPtr = 0 ->
            	true
        ;
		call_struct_disp(call_leaf_ptr,LeafDisp),
		buff_word(SubgPtr,LeafDisp,CallLeafNode),
		trie_node_element(CallLeafNode,_S,Child,_Pt,_P,_T,_A),
		new_node(NewNode),
		trie_node_disp(child,ChildDisp),
		buff_set_word(NewNode,ChildDisp,Child),
		trie_node_disp(atom,AtomDisp),
		get_emu_dependent_const(escape,Escape),
		buff_set_word(NewNode,AtomDisp,Escape),
		delete_predicate_table(NewNode), % Using the routine in a diff way
		tip_struct_disp(call_trie_root,CallRootDisp),
		CallRootPtr is Tip + CallRootDisp,
		trie_delete_branch(CallLeafNode,CallRootPtr)).

abolish_table_pred(Spec):-
	(Spec = F/A
	 ->	functor(Term,F,A)
	 ;	Term = Spec
	),
	conpsc(Term,Psc),
	psc_tabled(Psc,Tip),
	(Tip =:= 0
	 ->	abort('Error: Cannot abolish table of predicate not tabled')
	 ;	tip_struct_disp(call_trie_root,Rootd),
		buff_word(Tip,Rootd,CallRoot),
		tip_prop(Tip,1,1,0),		% 1(tab_entry),1(set), to 0
		(CallRoot =:= 0
		 ->	true
		 ;	delete_predicate_table(CallRoot)
		)
	).


get_returns_for_call(Call,Return) :-
	copy_term(Call,Ocall),
	get_calls(Call,CallStr,RetSkel),
	variant(Call,Ocall),	% subsuming call
	\+ not_most_general(RetSkel),	% subsumed call, so variant
	Call = Return,		% bind vars to use in retrieval
	get_returns(CallStr,RetSkel).


get_calls_for_table(Skeleton,Call,Empty) :-
	functor(Skeleton,Fun,Arity),
	functor(Call,Fun,Arity),
	get_calls(Call,CallStr,_RetSkel),
	call_struct_disp(ans_root_ptr,Arpd),
	buff_word(CallStr,Arpd,RetTrie),
	(RetTrie =:= 0
	 ->	Empty = empty
	 ;	Empty = notempty
	).

call_psc_tip(Call,Psc,Tip):-
	conpsc(Call,Psc),
	psc_tabled(Psc,Tip),
	(Tip =\= 0 -> true; writeln(Call),writeln(':is not tabled'),fail).


get_subg_ptr(Call,Tip,SubgPtr):-
	get_emu_dependent_const(call_hash_addr,CHA_flag),
	tip_prop(Tip,CHA_flag,0 /*get*/,CHT),
        (CHT = 0 ->
        	SubgPtr = 0
	;
		functor(Call,_Funct,Arity),	
		call_hash(Call,CHT,Arity,_Dummy,SubgPtr)
	).

get_subg_ptr(Call,SubgPtr):-
	call_psc_tip(Call,_Psc,Tip),
	get_subg_ptr(Call,Tip,SubgPtr).


subgp_call_trie_leaf(SubgP,LeafNode):-
	call_struct_disp(call_leaf_ptr,LeafDisp),
	buff_word(SubgP,LeafDisp,LeafNode).


tip_call_trie_root(Tip,CallRootNode) :-
	tip_struct_disp(call_trie_root,CallRootDisp),
	buff_word(Tip,CallRootDisp,CallRootNode).



table_state(Call,Result) :-
	conpsc(Call,Psc),
	psc_tabled(Psc,Tip),
	(Tip =:= 0
	 ->	Result = undef
	 ;	tip_struct_disp(call_trie_root,Ctrd),
		buff_word(Tip,Ctrd,CallRoot),
		(CallRoot =:= 0
		 -> 	Result = no_call_yet
		 ;	((get_subg_ptr(Call,Tip,Callstr),
			 Callstr =\= 0)
			 ->	call_struct_disp(susp_ptr,Spd),
				buff_word(Callstr,Spd,CallStrSusPtr),
				(CallStrSusPtr =:= -1
				 ->	Result = complete
				 ;	Result = incomplete
				)
			 ;	Result = no_call_yet
			)
		)
	).

/******* internal predicates *************/

get_residual(CallSkel, DelayList) :-
	get_calls(CallSkel, S, R),
	get_returns(S, R, Leaf), 
	get_delay_lists(Leaf, DLs),
	( DLs == [] -> DelayList = []
	; DLs = [DL] -> DelayList = DL
	; member(DelayList, DLs)
	).

/* Given the address of the call structure for a return trie (Callstr)
and a return skeleton (Retskel), both as returned by get_calls, it
instantiates through backtracking the return skeleton, Retskel, for
all the returns in the specified trie. If Retskel is partially
instantiated, it returns only those answers that unify with it.
get_returns/3 returns in addition the leaf node of the reutrn.  It can
be passed to delete_return/2 (along with the callstr) to delete the
return.  */

get_returns(CallStr,RetSkel) :- gr_c(CallStr,RetSkel,_Leaf).
get_returns(CallStr,RetSkel,Rleaf) :- gr_c(CallStr,RetSkel,Rleaf),
	aux_call_info(Rleaf,_NumOfVars,_VarArrayPtr).

get_calls(CallSkel,CallStrPtr,RetSkel):- get_calls(CallSkel),
	aux_call_info(LastNode,NumOfVars,VarArrayPtr),
%	writeln(numofvars(NumOfVars,las(LastNode),vap(VarArrayPtr))),
	trie_node_element(LastNode,_S,CallStrPtr,_Pt,_P,_Tag,_A),
%	buff_word(Child,0,CallStrPtr),
	make_list(0,NumOfVars,VarArrayPtr,ArgList),
	RetSkel =.. [ret|ArgList].


make_list(X,X,_,[]).
make_list(N,M,Vp,[Hd|Tl]) :- N < M,
	nth_var_reg(N,Hd),
	N1 is N + 1,
	make_list(N1,M,Vp,Tl).


not_most_general(Term) :-
	functor(Term,_,Arity),
	not_most_gen(Term,1,Arity).
not_most_gen(Term,I,Arity) :-
	I =< Arity,
	arg(I,Term,Arg),
	(nonvar(Arg)
	 ->	true
	 ;	Arg = ground,
		I1 is I+1,
		not_most_gen(Term,I1,Arity)
	).

/********************trie assert related routines *******/

is_trie_asserted(Term) :- trie_asserted_fact(Term,_Psc,_Ep,_Rn).

trie_asserted_fact(Term,Psc,Eptr,RootNode) :-
	conpsc(Term,Psc),
	Psc =\= 0,
	psc_struct_disp(ep,Epdisp),
	buff_word(Psc,Epdisp,Eptr),
	Eptr =\= 0,
	buff_byte(Eptr,0,Instr),
	wam_opcode(trie_assert,TrInstr),
	Instr = TrInstr,
	trie_node_disp(child,ChildDisp),
	buff_word(Eptr,ChildDisp,RootNode).
	
abolish_trie_asserted(Functor/Arity) :-
	functor(Term,Functor,Arity),
	trie_asserted_fact(Term,Psc,_Ep,Rn),
	psc_struct_disp(ep,Epdisp),
	buff_set_word(Psc,Epdisp,0), 
	psc_struct_disp(entry_type,Typedisp),
	buff_set_byte(Psc,Typedisp,0),
	delete_predicate_table(Rn).


trie_dynamic(Functor/Arity) :-
	functor(Term,Functor,Arity),
	(Arity = 0 -> (
	(predicate_property(Term, unclassified) -> 
		trie_assert(Term),trie_retract(Term)
	;
        (predicate_property(Term, (dynamic)) -> 
	     warning('Redeclaration of dynamic to trie dynamic'(Functor/Arity)),
            (call(Term) -> 
		abolish(Functor/Arity),
		trie_assert(Term)
		;
		abolish(Functor/Arity),
		trie_assert(Term),
		trie_retract(Term));
	(predicate_property(Term, loaded) -> 
		warning('Redeclaration of a loaded predicate to trie_dynamic'(Functor/Arity)),
		abolish(Functor/Arity),
		trie_assert(Term),
		trie_retract(Term)
	;
		 true)))
        )
        ;
	(trie_asserted_fact(Term,_Psc,_Ep,_Rn) -> true
	;
		abolish(Functor/Arity),
		trie_assert(Term), 
		trie_retract(Term) % A way of making Functor/Arity trie_dynamic
	)).


repeat:- true;repeat.
% not exported in basics.
trie_retract(X) :- (predicate_property(X,(dynamic)) -> 
	'_$savecp'(Breg),
	(repeat,(call(X)->aux_call_info(LNode,_NumVar,_Something),
		%writeln(a(LNode,NumVar,Something)),
		trie_retract_exact(X,LNode)
		;
		'_$cutto'(Breg),fail))).


trie_retract_nr(X) :- (predicate_property(X,(dynamic)) -> 
	'_$savecp'(Breg),
	(repeat,(call(X)->aux_call_info(LNode,_NumVar,_Something),
		%writeln(a(LNode,NumVar,Something)),
		trie_retract_safe(X,LNode)
		;
		'_$cutto'(Breg),fail))).

trie_retract_all(X):- trie_retract(X),fail;true.

% aggregate stuff

nvars(Breg,Arity,Nvars) :- 	
	get_emu_dependent_const(tcp_size,TcpSize),
	Tmp2 is TcpSize +Arity,
	Tmp1 is 4*Tmp2,
	Ptr is Breg + Tmp1,
	buff_word(Ptr,0,Nvars).

breg_retskel(BregOffset,Arity,RetTerm,CallStr) :-
	get_emu_dependent_const(cp_base, CPBase),
	Breg is CPBase - BregOffset,
	nvars(Breg,Arity,Nvars),
	functor(RetTerm,ret,Nvars),
	breg_retskel_fillskel(RetTerm,Breg,Arity,Nvars,CallStr).

/* delete_return(Cs,N) takes a call structure pointer in Cs (returned
by get_calls) and the address of a node that is a leaf of the return
trie pointed to by the call structure. (Such a node address is
returned by get_returns/3.) It deletes the node and reclaims the
space. There is a potential efficiency problem in that it deletes it
from the chain of returns by running the chain, which may be long.
--------------------------------------------------
trie_delete_branch/2 brutally deletes a term  from the trie...
 */

trie_delete_branch(A,B):- trie_delete_branch_ret(A,B,0).
delete_return(CallStr,AnsNode):- trie_delete_branch_ret(AnsNode,CallStr,1).
/*======================================================================*/

% builtins to get (and change) trie nodes
trie_node_element(_N,_Sibling,_Child,_Ptag,_Parent,_Tag,_Atom):- '_$builtin'(140).
new_node(_N):- '_$builtin'(141).
delete_predicate_table(_N) :- '_$builtin'(145).
trie_assert(_Term) :- '_$builtin'(147).
trie_retract_exact(_Term,_LNode) :- '_$builtin'(148).
trie_retract_safe(_Term,_LNode) :- '_$builtin'(155).
trie_delete_branch_ret(_LeafNode,_Hook,_BranchOrRet) :- '_$builtin'(149).
gr_c(_CallStr,_RetSkel,_LeafNode) :- '_$builtin'(150).
get_calls(_CallSkel)  :- '_$builtin'(151).
aux_call_info(_LastNode,_NumOfVars,_VarArrayPtr) :- '_$builtin'(152). 
nth_var_reg(_Hd,_Tmp) :- '_$builtin'(153).
breg_retskel_fillskel(_RetTerm,_Breg,_Arity,_Nvars,_CallStr) :- '_$builtin'(154).
get_delay_lists(_LeafNode,_DL) :- '_$builtin'(144).

/*======================================================================*/
/*  Emulator-dependent constants (make sure they are kept up-to-date).	*/
/*======================================================================*/



% C structure definitions:
% call structure
%-------------------------
call_struct_disp(next_subgoal,0).
call_struct_disp(ans_root_ptr,4).
call_struct_disp(susp_ptr,8).
call_struct_disp(tip_ptr,12).
call_struct_disp(compl_stack_ptr,16).
call_struct_disp(compl_susp_ptr,20).
call_struct_disp(ans_list_ptr,24).
call_struct_disp(prev_sug_ptr,28).
call_struct_disp(call_leaf_ptr,32).
call_struct_disp(cp_ptr,36).
call_struct_disp(ans_list_tail,40).  %jf: 07/23/95
call_struct_disp(compl_flag,44).     %jf: 07/23/95

% table information structure
%----------------------------
tip_struct_disp(next_tip,0).
tip_struct_disp(call_trie_root,4).

% Trie node structure
%--------------------
trie_node_disp(sibling,4).
trie_node_disp(child,8).
trie_node_disp(parent,12).
trie_node_disp(atom,16).



% Psc structure 
%--------------
psc_struct_disp(entry_type,1).
psc_struct_disp(ep,8).

% WAM opcodes
%------------
wam_opcode(trie_assert,124).

/* ------------------- end of file trie_tables.P ---------------------- */


