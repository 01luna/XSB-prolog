/************************************************************************
*									*
* The XOLDT System							*
* Author: David S. Warren						*
* V1.0 Copyright SUNY Stony Brook, 1992					*
* This code is distributed WITHOUT ANY WARRANTY.			*
*									*
************************************************************************/


%%:- export oldp/1.

:- import numbervars/3 from num_vars.
:- import ground/1, copy_term/2, append/3, member/2 from basics.

:- op(900,xfx, (<-)).
:- op(1100,fx, [(table),(notable),(prolog),(default)]).
	
/* This is the XOLDT meta-interpretation subsystem. It is a
Quintus(R) Prolog source program. It supports the execution of
Prolog programs with tabling. For documentation on usage, please see
the xoldt_doc file.

This module assumes that programs have been ``loaded'' (compiled or
consulted) with the xoldt_load module. It is basically an OLDT
meta-interpreter, but it has a few enhancements to support a simple
kind of constraint handling. This mechanism can be used easily to
implement well-founded semantics and stable semantics. 

This has 3 external routines (that the user can re-define):

xand(+C1,+C2,-C3): combines and simplifies C1 and C2 returning C3.
	This could well be defined with:
	xand(A,B,C) :- append(A,B,D),simplify(D,C).
	for simplify a predicate that simplifies constraints.
	The simplest reasonable definition is:
		xand(C1,C2,C) :- append(C1,C2,C).
	Its default definition implements WFS.

xproj(+Ans,-Pans): This is called when an answer is found and is about
	to be checked as to whether it should be added to the table. 
	Ans is a term [Call_inst|Constraint]. This routine returns in Pans
	a (possibly) modified Answer. The intention is that it may
	create a new set of constraints by eliminating variables that
	do not appear in Call_inst. Its default definition is:
		xproj(C,C).

xcomp(-Op,+Ans1,+Ans2): Ans1 and Ans2 are computed answers, of the form
	[Call_inst|Constraint], thought of as an implication
		Call_inst <- Constraint.
	xcomp should return Op='le' if Ans1 implies Ans2 (which means 
	that Ans1 need not be kept), returns Op='gt' if Ans2 implies Ans1
	(and not vice versa) returns Op='nr' if no relationship obtains.
	This routine is used to determine whether new answers should be
	failed (Ans1 le Ans2), cause previous answer to be deleted
	(Ans1 gt Ans2), or is independent of a previous answer (nr).
	The simplest reasonable definition is:
		xcomp(le,A1,A2) :- variant(A1,A2).
	Its default definition implements WFS.

There are several ``predicates'' that the XOLDT meta-interpreter supports:

xconstraint(+C): This is built into the XOLDT system. It is called
	to add a constraint, C, to the current constraints. It
	results in a call to xand/3 to incorporate this new constraint 
	with the current ones.

xgetconstraint(-C): This is built in to the XOLDT system. When it is
	called, the current set of constraints are unified with C,
	and removed from the system. (I.e., after this is called,
	there are no ``current'' constraints.) The pair:
		(xgetconstraint(C),xconstraint(C))
	(for new variable C) should be a noop. It is a way of getting
	the current constraints into the object program (should one
	ever want to(?)).

There is one findall-type predicate: findall/3.

This supports undefined answers (?) through findall. Within a
findall, a subgoal Goal<-Con will succeed immediately with Con bound
to ? if there is a loop detected by the meta-interpreter through
findall. This provides a facility that can be used to calculate the
well founded semantics, and a stable model semantics. */ 

/* It does VARIANT call check (not subsumption check.) Answer check
is done in xcomp, and is definable by the user. */


%:- op(900,xfx,<-).
%:- op(1150,fx,[(table),(prolog),(notable),(default)]).

% top-call for debugging
oldp(Query) :- 
	%%statistics(runtime,[_,_]),
	findall([],Query,_Ans,[],Ctab),
	%%statistics(runtime,[_,Time]),
	%%write('CPU time: '), write(Time),nl,
	printtab(Ctab).

(Query <- Cons) :- 
	oldt_init,
	('xoldt$$type'(Query,(table))
	 ->	coldt(Query,[],[],Ctab,Answers),
		member([Query|Cons],Answers),
		(file_tab_print(List) ->
			file_printtab(Ctab,List)
		 ; true)
	 ;	coldt('xoldt$table'(Query),[],[],_Ctab,Answers),
		member(['xoldt$table'(Query)|Cons],Answers)
	).

xoldt(Query) :- (Query <- []).

findall(Temp,Goal,Anss,Ctab0,Ctab) :-
	oldt_init,
	findall(Temp,Goal,Anss,Ctab0,Ctab,[]).

findall(Temp,Goal,Anss,Ctab0,Ctab,Lp) :-
	(Goal = (Goal1<-Con)
	 ->	Rgoal=Goal1
	 ;	Rgoal=Goal,Con=[]
	),
	('xoldt$$type'(Rgoal,(Type))
	 ->	(Type == (table)
		 ->	coldt(Rgoal,Lp,Ctab0,Ctab,Answers1),
			copy_pats(Answers1,Temp,Rgoal,Con,Anss)
		 ;	coldt('xoldt$table'(Rgoal),[],Ctab0,Ctab,Anss1),
			copy_pats(Anss1,Temp,'xoldt$table'(Rgoal),Con,Anss)
		)
	 ;	findall(Temp,(Con=[],Rgoal),Anss),
%	 ;	findall(Temp,(Rgoal),Anss),
		Ctab=Ctab0
	).


copy_pats([],_,_,_,[]).
copy_pats([[Ans|Con]|Anss],Pat,Rgoal,Rcon,[Inst|Insts]) :-
	copy_term((Pat,Rgoal,Rcon),(Inst,Ans,Con)),!,
	copy_pats(Anss,Pat,Rgoal,Rcon,Insts).
copy_pats([_|Anss],Pat,Rgoal,Rcon,Insts) :-
	copy_pats(Anss,Pat,Rgoal,Rcon,Insts).

oldt_initialized(_) :- fail.

oldt_init :- 
	(oldt_initialized(_)
	 ->	true
	 ;	assert(oldt_initialized(_))
	).

/* tracing, supported levels, but not used anymore */
xtrace_flag(_):-fail.

xtrace(X) :- 
	retractall(xtrace_flag(_)),
	assert(xtrace_flag(X)).

xtrace :- xtrace(0).

xnotrace :- retractall(xtrace_flag(_)).


/* coldt(Goal,Loop,C_table_in,C_table_out) completely proves the
goal Goal with respect to the program Program and the completed ET
table C_table_in producing completed ET C_table_out. */ 

coldt(Goal,Lp,Ctab,Ctab,Answers) :-
	contained_in(Goal,Lp),!,
	Answers=[[Goal|?]].
coldt(Goal,Lp,Ctab0,Ctab,Answers) :-
 	ground(Goal,Ggoal),
	(find_c(Ctab0,Ggoal,Lp,Answers)
	 ->	Ctab = Ctab0
	 ;	addordto(Lp,Goal,Nlp),	%sort([Goal|Lp],Nlp), %fix
		oldt(Goal,[Goal],[],Nlp,Ctab0,Ctab1,[],Tab),
		mergetab(Tab,Lp,Ctab1,Ctab),
		find_c(Ctab,Ggoal,Lp,Answers)
	).

addordto(Ogoals,Goal,Ngoals) :-
	Ogoals == []
	 ->	Ngoals = [Goal]
	 ;	Ogoals = [Og|Ogoals1],
		(Goal @=< Og
		 ->	Ngoals = [Goal|Ogoals]
		 ;	Ngoals = [Og|Ngoals1],
			addordto(Ogoals1,Goal,Ngoals1)
		).

/* oldt(Body, Head, Continuation, Loop, C_table_in, C_table_out, 
Table_in, Table_out) if evaluating Continuation with program Program,
completed ET C_table_in, and open ET Table_in results in completed ET
C_table_out and partial (but now complete) ET Table_out.
Continuation (also known as a run stack) is a list of environments of
the form env(Goal,Goal_list). The SLD goal list is the concatenation
of the tails of all the Goal_list's in the Continuation. Each Goal
is a moded version (current instantiation of) the goal that
caused the goals of the corresponding Goal_list to be added. The
mode is `true' if all subgoals at this level have been proved; the
mode is `?' if one (or more) are undefined. So for any
env(Goal,Goal_list) on the continuation, (Goal :- [_|Goal_list]) is
an instance of some rule in the program. */ 

%%oldt(G,_,_,_,_,_,_,_) :- write(oldt(G)),nl,fail.
oldt('xoldt$ret',Ret,Contin,Lp,Ctab0,Ctab,Tab0,Tab) :- !,
	(Contin == []
	 ->	Ctab = Ctab0, Tab = Tab0
	 ;	Contin = [env(_,[Call|_])|_],
		('xoldt$$type'(Call,(notable))
		 ->	oldtret(Ret,Contin,Lp,Ctab0,Ctab,Tab0,Tab)
		 ; addret(Tab0,Call,Ret,Contins,Tab1)
		 ->	(xtrace_flag(_)
			 -> 	\+ (numbervars(Ret,0,_), Ret=[R|U0],
				 write(' Answer: '),write((R<-U0)),nl,
				 %write(' Tab: '),write(Tab1),nl,
				 fail)
			 ;	true),
			oldtret(Ret,Contin,Lp,Ctab0,Ctab1,Tab1,Tab2),
			applycontins(Contins,Ret,Lp,Ctab1,Ctab,Tab2,Tab)
		 ;	(xtrace_flag(_)
			 -> 	\+ (numbervars(Ret,0,_), Ret=[R|U0],
				 write('Dup-Ans: '),write((R<-U0)),nl,
				 %write(' Tab: '),write(Tab1),nl,
				 fail)
			 ;	true),

			Tab = Tab0, Ctab = Ctab0	% redundant return
		)).
oldt((Call,B),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab) :- !,
	oldt2(Call,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B).
oldt(Call,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab) :- 
	oldt2(Call,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,'xoldt$ret').


%%oldt2(G,_,_,_,_,_,_,_,_) :- write(oldt2(G)),nl,fail.
oldt2((G1,G2),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- !,
	oldt2(G1,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,(G2,B)).
oldt2((Con->Then;Else),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- !,
	(call(Con)		% condition must be Prolog
	 ->	oldt2(Then,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B)
	 ;	oldt2(Else,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B)
	).
oldt2((G1;G2),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- !,
	oldt2(G1,H,Cnt,Lp,Ctab0,Ctab1,Tab0,Tab1,B),
	oldt2(G2,H,Cnt,Lp,Ctab1,Ctab,Tab1,Tab,B).	% may need a copy
oldt2(findall(Pat,Goal,Anss),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- 
	nonvar(Goal), !,
	findall(Pat,Goal,Answers2,Ctab0,Ctab1,Lp),
	(Anss=Answers2
	 ->	oldt(B,H,Cnt,Lp,Ctab1,Ctab,Tab0,Tab)
	 ;	Tab = Tab0, Ctab = Ctab1
	).
oldt2(clause(Head,Body),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- !,
	oldt2_clause(Head,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B,Body).
oldt2(call(Goal),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- !,
	oldt2(Goal,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B).
oldt2((_X^Goal),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- !,
	oldt2(Goal,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B).
oldt2(xconstraint(G),[H|C0],Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- !,
	(xand(G,C0,C1)
	 ->	oldt(B,[H|C1],Cnt,Lp,Ctab0,Ctab,Tab0,Tab)
	 ;	Tab = Tab0, Ctab = Ctab0
	).
% does this following work? and is it a reasonable idea?
oldt2(xgetconstraint(C),[H|C0],Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- !,
	(C=C0
	 ->	oldt(B,[H],Cnt,Lp,Ctab0,Ctab,Tab0,Tab)
	 ;	Tab = Tab0, Ctab = Ctab0
	).
oldt2((_Goal<-_Con),_H,_Cnt,_Lp,_Ctab0,_Ctab,_Tab0,_Tab,_B) :- !,
	write('ERROR: Illegal use of (<-)/2'),nl,fail.
oldt2(xoldt(Goal),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- 
	'xoldt$$type'(Goal,(Type)), % Type \== (prolog), 
	!,
	(Type == (table)
	 ->	coldt(Goal,Lp,Ctab0,Ctab1,Answers),
		applyrets(Answers,[env(H,[Goal|B])|Cnt],Lp,Ctab1,Ctab,
								Tab0,Tab)
	 ; Type == (notable)
	 ->	functor(Goal,P,A),write('Error: Predicate '), 
		write(P/A), write(' not tabled.'), nl,fail
	).
oldt2(true,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- !,
	oldt(B,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab).
oldt2(Call,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :-
	'xoldt$$type'(Call,Type), % Type \== (prolog), 
	!,
	Contin = [env(H,[Call|B])|Cnt],
	(Type == (notable)
	 ->	findall(([Call]:-Body),'xoldt$$rule'(Call,Body),Irules),
		applyrules(Irules,Contin,Lp,Ctab0,Ctab,Tab0,Tab)
	 ; Type == (table)
	 ->	ground(Call,Gcall),
		(find_c(Ctab0,Gcall,Lp,Rets)	% in completed ET?
		 ->	applyrets(Rets,Contin,Lp,Ctab0,Ctab,Tab0,Tab)
		 ; addcontin(Tab0,Gcall,Contin,Rets,Tab1) %in regular ET?
		 ->	(xtrace_flag(_)
			 -> 	write('Lookup : '),write(Gcall),nl
			 ;	true),
			applyrets(Rets,Contin,Lp,Ctab0,Ctab,Tab1,Tab)
		 ;	(xtrace_flag(_)
			 -> 	write('Solution: '),write(Gcall),nl
			 ;	true),
			findall(([Call]:-Body),'xoldt$$rule'(Call,Body),
								Irules),
			addkey(Tab0,Gcall,[],Tab1),
			applyrules(Irules,Contin,Lp,Ctab0,Ctab,Tab1,Tab)
		)
	).
oldt2(Call,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B) :- 
	(xtrace_flag(_)
	 -> 	\+ (numbervars(Call,0,_), 
		 write(' Prolog: '),write(Call),nl,
		 fail)
	 ;	true),
	findall([Call],Call,Rets),
	applyrets(Rets,[env(H,[Call|B])|Cnt],Lp,Ctab0,Ctab,Tab0,Tab).

oldt2_clause(Head,_H,_Cnt,_Lp,Ctab,Ctab,Tab,Tab,_B,_Body) :-
	var(Head),!, write('Instantiation error in clause'),nl,abort.
oldt2_clause(clause(Head,Body),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B,true) :- !,
	oldt2(clause(Head,Body),H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B).
oldt2_clause(Head,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B,Body) :-
	'xoldt$$type'(Head,_Type), % Type \== (prolog), 
	!,
	findall([(Head,Body)],'xoldt$$rule'(Head,Body),Anss),
	applyrets(Anss,[env(H,[(Head,Body)|B])|Cnt],Lp,Ctab0,Ctab,
								Tab0,Tab).
oldt2_clause(Head,H,Cnt,Lp,Ctab0,Ctab,Tab0,Tab,B,Body) :-
	findall([(Head,Body)],clause(Head,Body),Rets),
	applyrets(Rets,[env(H,[(Head,Body)|B])|Cnt],Lp,Ctab0,Ctab,
								Tab0,Tab).

/* oldtret(Return, Continuation, Loop, C_table_in, C_table_out, 
Table_in, Table_out) applies the returning goal Return to the
Continuation and finishes its evaluation with respect to Program,
C_table_in, and Table_in, producing C_table_out and Table_out. */ 

%%oldtret(Ans,Envs,_,_,_,_,_) :- write(oldtret(Ans,Envs)),nl,fail.
oldtret([R|U0],[Env|Cont],Lp,Ctab0,Ctab,Tab0,Tab) :-
	copy_term(Env,env([Nh|Nu1],[Call|Calls])),
	new_copy([R|U0],[Call|Nu0]),
	(xand(Nu1,Nu0,U)
	 ->	oldt(Calls,[Nh|U],Cont,Lp,Ctab0,Ctab,Tab0,Tab)
	 ;	Tab = Tab0, Ctab = Ctab0
	).

xand(U0,U1,U) :- U0 == [] -> (U1 == [] -> U = [] ; U = ?) ; U = ? .
xcomp(Op,[H|V],[H1|V1]) :- 
	is_variant(H,H1),
	(V == ? 
	 ->	Op=le 
	 ; V1==[] 
	 -> 	Op=le
	 ; Op=gt
	).

xproj(X,X).

/* applyrules(Rules, Continuation, Loop, C_table_in,
C_table_out, Table_in, Table_out) extends the Continuation
(whose top goal is Goal) by trying all the rules in Rules and
finishes each of those extensions with respect to Program,
C_table_in, and Table_in producing C_table_out and Table_out. */ 

applyrules([],_C,_Lp,Ctab,Ctab,Tab,Tab).
applyrules([(Ihead:-Ibody)|Rules],Contin,Lp,Ctab0,Ctab,Tab0,Tab) :-
 	oldt(Ibody,Ihead,Contin,Lp,Ctab0,Ctab1,Tab0,Tab1),
	applyrules(Rules,Contin,Lp,Ctab1,Ctab,Tab1,Tab).


/* applyrets(Returns, Continuation, Loop, C_table_in, C_table_out,
Table_in, Table_out) extends the Continuation by returning each
return in the list Returns and finishes each of those extensions with
respect to Program, C_table_in, and Table_in producing C_table_out
and Table_out. */ 

applyrets([],_,_Lp,Ctab,Ctab,Tab,Tab).
applyrets([Ret|Rets],Contin,Lp,Ctab0,Ctab,Tab0,Tab) :-
	oldtret(Ret,Contin,Lp,Ctab0,Ctab1,Tab0,Tab1),
	applyrets(Rets,Contin,Lp,Ctab1,Ctab,Tab1,Tab).

/* applycontins(Continuations, Return, Loop, C_table_in,
C_table_out, Table_in, Table_out) extends each continuation in
the list Continuations by returning Return to each and then finishing
each with respect to Program, C_table_in, and Table_in producing
C_table_out and Table_out. */ 

applycontins([],_,_Lp,Ctab,Ctab,Tab,Tab).
applycontins([Contin|Contins],Ret,Lp,Ctab0,Ctab,Tab0,Tab) :-
	oldtret(Ret,Contin,Lp,Ctab0,Ctab1,Tab0,Tab1),
	applycontins(Contins,Ret,Lp,Ctab1,Ctab,Tab1,Tab).


/* A (partial) extension table consists of a 2-3 tree of key-value
entries. The key is the numbervar-ed call. A value is either [],
indicating no entries at all, or it is b(Continuations,Returns),
where Continuations is a list of continuations suspended on Call, and
Returns is a list of instantiations of Call provable from the
program. */ 

/* addret(Table_in,Call,Return,Continuations,Table_out) searches
partial ET Table_in to find the entry whose call is a variant of
Call. (One must be there.) If Return is a VARIANT of by a return
already in that table entry, then addret fails. Otherwise, addret
succeeds returning in Table_out a new table with that return added,
and in Continuations those suspended on that entry. A ? entry is
subsumed by true entry.
*/ 

addret(Tab0,Call,Ret,Contins,Tab) :-
	xproj(Ret,Pret),
	ground(Call,Gcall),
	updatevs(Tab0,Gcall,Ov,Nv,Tab),
	addret1(Ov,Nv,Pret,Contins).

addret1([],r([Nret]),Nret,[]).
addret1(r(Rets),r(Newrets),Nret,[]) :- 
	xretmerge(Rets,Nret,Newrets).
addret1(s(Contins),b(Contins,[Nret]),Nret,Contins).
addret1(b(Contins,Rets),b(Contins,Newrets),Nret,Contins) :-
	xretmerge(Rets,Nret,Newrets).


xretmerge([],Nret,[Nret]).
xretmerge([Oret|Rets],Nret,Nrets) :-
	xcomp(Op,Nret,Oret),
	!,
	(Op == le
	 ->	fail
	 ; Op == gt
	 ->	%%% write(deleting_from_table(Oret)),nl,
		xretmerge(Rets,Nret,Nrets)
	 ;	Nrets = [Oret|Nrets1],
		xretmerge(Rets,Nret,Nrets1)
	).
xretmerge([Oret|Rets],Nret,[Oret|Nrets]) :-
	xretmerge(Rets,Nret,Nrets).


/* addcontin(Table_in,Call,Continuation,Returns,Table_out) is similar
to addret except that it fails when it doesn't find a matching entry,
and when it does it adds Continuation to its continations (returning
the new table in Table_out) and returns the list of returns of that
entry in Returns. The table is kept at a 2-3 tree. */ 

addcontin(Tab0,Gcall,Contin,Rets,Tab) :-
	updatevs(Tab0,Gcall,Ov,Nv,Tab),
	addcont1(Ov,Nv,Contin,Rets).

addcont1([],s([Contin]),Contin,[]).
addcont1(r(Rets),b([Contin],Rets),Contin,Rets).
addcont1(s(Contins),s([Contin|Contins]),Contin,[]).
addcont1(b(Contins,Rets),b([Contin|Contins],Rets),Contin,Rets).

%map_copy_term([],[]).
%map_copy_term([E|L],[E|L1]) :- 
%	numbervars(E,0,0),!,map_copy_term(L,L1).
%map_copy_term([E|L],[E1|L1]) :- 
%	copy_term(E,E1), map_copy_term(L,L1).

only_defined([],[]) :- !.
only_defined([[Ans]|Anss],[Ans|Nanss]) :- !,only_defined(Anss,Nanss).
only_defined([_|Anss],Nanss) :- only_defined(Anss,Nanss).

/* contained_in(Element,List) checks if a variant of Element is in
List. (Essentially memberchk but using variant for the equality
check.) */ 

contained_in(X,[Y|_]) :- is_variant(X,Y),!.
contained_in(X,[_|R]) :- contained_in(X,R).


/* is_variant(X,Y) is an efficiency hack for variant. It first
checks if X and Y are nonunifiable, and fails if so since then X and
Y could not be variants; otherwise they are tested for ==, intended for 
ground terms; otherwise numbervar and test. */ 

is_variant(X,Y) :- 
	\+ X=Y
	 ->	fail
	 ; X == Y
	 ->	true
	 ; \+ \+ (numbervars(X,0,N),
		numbervars(Y,0,N),
		X==Y).

/* ground(+Term,-GroundTerm) creates a copy of Term and numbervars
the copy. */

ground(Term,Gterm) :-
	copy_term(Term,Gterm),numbervars(Gterm,0,_N).

/* make a copy if it's not already ground (opt?) */
new_copy(Term,Copy) :- ground(Term),!,Term=Copy.
new_copy(Term,Copy) :- copy_term(Term,Copy).

% find_c(+Tab,+Key,+Loop,-V) finds a value in a completed table.
% Value in completed table (first) is a list of
%	loop_list:Ret_list

find_c(T,K,Lp,V) :- 
	find(T,K,Lans),
	member(Lp1:V,Lans),is_subset(Lp1,Lp),!.

% slight hack.
is_subset([],_).
is_subset([X|L1],L2) :- member(X1,L2),is_variant(X,X1),!,is_subset(L1,L2).

% mergetab(Ot,Lp,T0,T) merges Ot into T0 yielding T.

mergetab([],_,T,T).
mergetab(l(X,V),Lp,T0,T) :- 
	getr(V,Rs),
	(addkey(T0,X,[Lpr:Rs],T)
	 ->	((member(An,Rs),\+ An=[_]) -> Lpr=Lp ; Lpr=[])
	 ;	updatevs(T0,X,Vold,Vnew,T),
		(Vold =[[]:_|_]
		 ->	Vnew=Vold
		 ; 	((member(An,Rs),\+ An=[_])
			 ->	merge_ans(Vold,Lp:Rs,Vnew)
			 ;	Vnew=[[]:Rs]
			)
		)
	).
mergetab(n2(Tree1,_M,Tree2),Lp,T0,T) :-
	mergetab(Tree1,Lp,T0,T1),
	mergetab(Tree2,Lp,T1,T).
mergetab(n3(Tree1,_M2,Tree2,_M3,Tree3),Lp,T0,T) :-
	mergetab(Tree1,Lp,T0,T1),
	mergetab(Tree2,Lp,T1,T2),
	mergetab(Tree3,Lp,T2,T).


new_answers(_,Vold,Vold) :- Vold=[[]:_|_],!.	% already known
new_answers([]:Rrs,_,[[]:Rrs]) :- !.		% now completely known
new_answers(Pair,Vold,Vnew) :- merge_ans(Vold,Pair,Vnew).

merge_ans([],Lp:Rrs,[Lp:Rrs]).
merge_ans([Olp:Ors|Vold],Lp:_Rs,[Olp:Ors|Vold]) :- is_subset(Olp,Lp), !.
merge_ans([Olp:_Ors|Vold],Lp:Rs,Vnew) :- is_subset(Lp,Olp), !, 
	merge_ans(Vold,Lp:Rs,Vnew).
merge_ans([Op|Vold],Np,[Op|Vnew]) :- merge_ans(Vold,Np,Vnew).


/* This is a set of routines that supports indexed tables. Tables
are sets of key-value_list pairs. With each key is associated a list
of values. It uses 2-3 trees for the index (modified by D.S. Warren
from Ivan Bratko: ``Prolog Programming for Artificial
Intelligence'', Addison Wesley, 1986). Operations are: 

addkey(Tree,Key,V,Tree1) adds a new Key with value V, returning 
	new Tree1. Fails if the key is already there.

find(Tree,Key,V) finds the entry with Key and returns associated
	values in V.
*/


find(l(X,V),Xs,V) :- X == Xs.
find(n2(T1,M,T2),X,V) :-
	M @=< X
	 ->	find(T2,X,V)
	 ;	find(T1,X,V).
find(n3(T1,M2,T2,M3,T3),X,V) :-
	M2 @=< X
	 ->	(M3 @=< X
		 ->	find(T3,X,V)
		 ;	find(T2,X,V)
		)
	 ;	find(T1,X,V).


% updatevs(Tab0,X,Ov,Nv,Tab) updates Tab0 to Tab, by replacing
% Ov of entry with key X by Nv.

updatevs(l(X,Ov),Xs,Ov,Nv,l(X,Nv)) :- X == Xs.
updatevs(n2(T1,M,T2),X,Ov,Nv,n2(NT1,M,NT2)) :-
	M @=< X
	 ->	updatevs(T2,X,Ov,Nv,NT2), NT1=T1
	 ;	updatevs(T1,X,Ov,Nv,NT1), NT2=T2.
updatevs(n3(T1,M2,T2,M3,T3),X,Ov,Nv,n3(NT1,M2,NT2,M3,NT3)) :-
	M2 @=< X
	 ->	(M3 @=< X
		 ->	updatevs(T3,X,Ov,Nv,NT3), NT2=T2, NT1=T1
		 ;	updatevs(T2,X,Ov,Nv,NT2), NT1=T1, NT3=T3
		)
	 ;	updatevs(T1,X,Ov,Nv,NT1), NT2=T2, NT3=T3.


% taken from Bratko

addkey(Tree,X,V,Tree1) :-
	ins2(Tree,X,V,Trees),
	cmb0(Trees,Tree1).
addkey([],X,V,l(X,V)).

ins2(n2(T1,M,T2),X,V,Tree) :- 
	M @=< X
	 ->	ins2(T2,X,V,Tree1),
		cmb2(Tree1,T1,M,Tree)
	 ;	ins2(T1,X,V,Tree1),
		cmb1(Tree1,M,T2,Tree).
ins2(n3(T1,M2,T2,M3,T3),X,V,Tree) :- 
	M2 @=< X
	 ->	(M3 @=< X
		 ->	ins2(T3,X,V,Tree1),
			cmb4(Tree1,T1,M2,T2,M3,Tree)
		 ;	ins2(T2,X,V,Tree1),
			cmb5(Tree1,T1,M2,M3,T3,Tree)
		)
	 ;	ins2(T1,X,V,Tree1),
		cmb3(Tree1,M2,T2,M3,T3,Tree).
ins2(l(A,V),X,Vn,Tree) :-
	A @=< X
	 ->	(X @=< A
		 ->	fail
		 ;	Tree = t(l(A,V),X,l(X,Vn))
		)
	 ;	Tree = t(l(X,Vn),A,l(A,V)).

cmb0(t(Tree),Tree).
cmb0(t(T1,M,T2),n2(T1,M,T2)).

cmb1(t(NT1),M,T2,t(n2(NT1,M,T2))).
cmb1(t(NT1a,Mb,NT1b),M,T2,t(n3(NT1a,Mb,NT1b,M,T2))).

cmb2(t(NT2),T1,M,t(n2(T1,M,NT2))).
cmb2(t(NT2a,Mb,NT2b),T1,M,t(n3(T1,M,NT2a,Mb,NT2b))).

cmb3(t(NT1),M2,T2,M3,T3,t(n3(NT1,M2,T2,M3,T3))).
cmb3(t(NT1a,Mb,NT1b),M2,T2,M3,T3,t(n2(NT1a,Mb,NT1b),M2,n2(T2,M3,T3))).

cmb4(t(NT3),T1,M2,T2,M3,t(n3(T1,M2,T2,M3,NT3))).
cmb4(t(NT3a,Mb,NT3b),T1,M2,T2,M3,t(n2(T1,M2,T2),M3,n2(NT3a,Mb,NT3b))).

cmb5(t(NT2),T1,M2,M3,T3,t(n3(T1,M2,NT2,M3,T3))).
cmb5(t(NT2a,Mb,NT2b),T1,M2,M3,T3,t(n2(T1,M2,NT2a),Mb,n2(NT2b,M3,T3))).


printtab([]).
printtab(l(X,V)) :- 
	(numbervars(X,0,_),write('Call: '),write(X),nl,fail;
	 member(C:As,V),
		(C==[]
		 ->	true
		 ;	numbervars(C,0,_),tab(6),
			write('Context: '),write(C),nl
		),
		member(A,As),
		numbervars(A,0,_),tab(8),write(A),nl,
		fail;
	 true).
printtab(n2(X,_,Y)) :- printtab(X), printtab(Y).
printtab(n3(X,_,Y,_,Z)) :- printtab(X), printtab(Y), printtab(Z).

file_printtab(Table,List):-
	printtab(Table,List).

printtab([],_).
printtab(l(X,V),Slist) :- 
	functor(X,F,A),
	(member(f(F/A,File),Slist) ->
		tell_append(File),
		printcalltab(X,V),
		told
	; true).
printtab(n2(X,_,Y),L) :- printtab(X,L), printtab(Y,L).
printtab(n3(X,_,Y,_,Z),L) :- printtab(X,L), printtab(Y,L), printtab(Z,L).

printcalltab(X,V):-
%	(copy_term(X,X1),
%	 numbervars(X1,0,_),write_canonical(X),write((':-')),nl,fail;
	 (member(C:As,V),
		(C==[]
		 ->	true
		 ;	numbervars(C,0,_),tab(6),
			write('Context: '),write(C),nl
		),
		member(A,As),
		print_answer(A),
		fail).
printcalltab(_X,_V).

print_answer([A]):-
	numbervars(A,0,_),
%	tab(8),
	write_canonical(A),nl.
print_ansert(A):-
	write(A),write('not proper form'),abort.

getr([],[]).
getr(r(Rets),Rets).
getr(s(_),[]).
getr(b(_,Rets),Rets).

