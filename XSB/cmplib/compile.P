/* File:      compile.P
** Author(s): Saumya Debray, Kostis Sagonas, Terrance Swift
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** Copyright (C) ECRC, Germany, 1990
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: compile.P,v 1.1.1.1 1998-11-05 17:00:04 sbprolog Exp $
** 
*/


mc(Modname, Options) :- compile(Modname, Modname, Options, _).

/*======================================================================*/
/* compile(+ModName, +BaseName, +CompilerOptions, -ExportedPredicates)	*/
/*	Compiles a module with the compiler options specified and	*/
/*	returns the list of exported predicates.			*/
/*======================================================================*/

compile(Modname, Basename, Options, ExportList) :- 
	file_names(Basename, PFile, HFile, OFile, AFile, DFile,
		   SpecFile, TIFile, TableFile, OptFile),
	setoptions(Options), initialize,
	message(('[Compiling ', Basename, ']')), cputime(TimeStart),
	db_preprocess(PFile, HFile, Options, OptFile, SourceFile),
	parse(Modname, SourceFile, HFile, Module_0),
    ( option(profile) -> 
		time_message(TimeStart, 'Parse finito'), cputime(TimeParse)
    ; TimeParse = TimeParse ),	% To avoid a silly lamp variable message!
	abort_if_syntax_errors(Modname), !,
	useinfer(Module_0, IsModule, ExportList), !,
    ( option(profile) -> 
		time_message(TimeParse, 'Useinfer finito'), cputime(TimeUse)
    ; TimeUse = TimeUse ),% To avoid a silly lamp variable message!
	modeinfer(Modname, Module_0, DFile),
	specialise(Module_0, Module0, SpecFile),
	table_process(Module0, Module, TableFile),
	hack_self_compile,
	get_symtab(Module, SymTab),
	compile1(Modname, Module, SymTab, AFile, OFile, TIFile, IsModule),
	dispose_symtab( SymTab ),
	( option(compile_off) -> print_result(Module) ; true ),
	( conget('error occurred', 1) ->
		str_cat('/bin/rm ', OFile, Command), system(Command), 
		message(('The file ', OFile, ' is removed')), abort
	; true
	), !,
	( IsModule =:= 0 -> IsModuleMsg = '' ; IsModuleMsg = 'Module ' ),
	time_message(TimeStart, (IsModuleMsg, Modname, ' compiled')), !,
	close_ti_file(TIFile).


file_names(Basename, PFile, HFile, OFile, AFile, DFile,
	   SpecFile, TIFile, TableFile, OptFile) :-
	str_cat(Basename, '.P', PFile),
	hdr_ext(HExt), str_cat(Basename, HExt, HFile),
	obj_ext(OExt), str_cat(Basename, OExt, OFile),
	asm_ext(AExt), str_cat(Basename, AExt, AFile),
	decl_ext(DExt), str_cat(Basename, DExt, DFile),
	str_cat(Basename, '.spec', SpecFile),
	str_cat(Basename, '.ti', TIFile),
	str_cat(Basename, '.table', TableFile),
	str_cat(Basename, '.P.opt', OptFile).

initialize :-
	conset('table #', 0),
	conset('syntax errors', 0),
	conset('error occurred', 0),
	conset(ti_all, 0), conset(ti_all_off, 0),
	conset('EDB Dep #', 2),
	prepare.   /* uses globalset here! */

abort_if_syntax_errors(Modname) :-
	conget('syntax errors', N),
	( N =\= 0, Modname \== user -> 
		% Forget about syntax errors when compiling module user
	 	message(('Aborting compilation of module ', 
			 Modname, ' due to ', N, ' syntax error(s).')), 
		abort
	; true
	).

/*======================================================================*/
/* db_preprocess(+PFile, +HFile, +Options, +OptFile, -SourceFile)	*/
/*	Calls the database optimizer of XSB as a preprocessor that	*/
/*	produces the file OptFile out of PFile and HFile.		*/
/*======================================================================*/

db_preprocess(PFile, HFile, Options, OptFile, SourceFile) :-
	( option(db_opt) ->
		db_opt_options(Options, [], DB_Opt_Options),
		db_optimize(PFile, HFile, DB_Opt_Options, OptFile),
		SourceFile = OptFile
	; SourceFile = PFile
	).

:- mode db_opt_options(+,+,-).

db_opt_options(Options, Oin, Oout) :-
	( member1(unfold, Options) -> Omid = [unfold|Oin] ; Omid = Oin ),
	( member1(reorder, Options) -> Oout = [reorder|Omid] ; Oout = Omid ).

/*======================================================================*/
/* table_process(+ModuleIn, -ModuleOut, +SFile)				*/
/*	Performs necessary module-level analyses for tabling.		*/
/*======================================================================*/

table_process(ModuleIn, ModuleOut, SFile) :-
	( option(auto_table) -> perform_auto_table(ModuleIn) ; true ),
	( option(suppl_table) ->
		supplementary_tabling(ModuleIn, ModuleMid)
	; ModuleMid = ModuleIn
	),
	conget('table #', Tables),
	( Tables =:= 0 -> ModuleOut = ModuleMid
	; cp_opt(ModuleMid, ModuleOut), 
          ( option(no_check) -> true ; build_graph(ModuleOut) )
	),
	( option(table_dump) -> dump_module(SFile, ModuleOut) ; true ).

/*======================================================================*/
/* specialise(+ModuleIn, -ModuleOut, +SpecFile)				*/
/*	Performs the specialisation of partially instantiated calls.	*/
/*======================================================================*/

specialise(ModuleIn, ModuleOut, SpecFile) :-
	( option(spec_off) -> ModuleIn = ModuleOut
	; spec(ModuleIn, ModuleOut),
	  ( option(spec_dump) -> dump_module(SpecFile, ModuleOut) ; true )
	).

/*======================================================================*/
/* modeinfer(+ModuleIn)							*/
/*	Infer modes using the mode analyzer.				*/
/*======================================================================*/

modeinfer(ModName, Module, SymTab) :-
	( option(modeinfer) -> modeanalyze(ModName, Module, SymTab)
	; true).

/*======================================================================*/
/*======================================================================*/

compile1(Modname, Module, SymTab, AFile, OFile, TIFile, IsModule) :-
      ( option(compile_off) ->		%  generate *.A file
	  write_asmheader(AFile, Modname, SymTab, IsModule), myclose(AFile)
      ; conget('error occurred', 1) ->
		message(('Aborting compilation of module ', Modname,
			 ' due to errors')), abort
      ; option(asm_dump) -> 
	  write_asmheader(AFile,Modname,SymTab, IsModule), % generate .A header
	  asm_genheader(OFile, Modname, SymTab, IsModule), % generate .O header
	  compile0(Module, 1, AFile, OFile, TIFile, IsModule),
	  myclose(AFile), myclose(OFile)
      ; asm_genheader(OFile, Modname, SymTab, IsModule),   % generate .O header
	compile0(Module, 0, AFile, OFile, TIFile, IsModule),
	myclose(OFile)
      ).

/*======================================================================*/
/* compile0(+Module, +GenAsm, +AFile, +OFile, +IsModule)		*/
/*	Compiles a module in the internal form.				*/
/*======================================================================*/

compile0(module(SymTab,_,ClList,[MainPred]),GenAsm,AFile,OFile,TIFile,M) :-
	member(PredBlk, [MainPred|ClList]),
	compile_predicate(PredBlk, GenAsm, AFile, OFile, TIFile, M, SymTab),
	fail.	/* just reclaim space */
compile0(_, _, _, _, _, _).


/*======================================================================*/
/* compile_predicate(+pred(Sym,Clauses,_), +GenAsm,	 		*/
/*		     +AFile, +OFile, +IsModule, +SymTab)		*/
/*	Compile the clauses of a single predicate into an assembly	*/
/*	(*.A) file and/or an object (*.O) file.				*/
/*======================================================================*/

compile_predicate(PredDef, GenAsm, AFile, OFile, TIFile, IsModule, SymTab) :-
	PredDef = pred(Sym,_,_),
	sym_name(Sym, P, N),
	( option(verbo) -> message(('        ....compiling ', P/N)) ; true ),
	( option(sysmod) -> true
	; standard_symbol(P, N, _) ->
		warning(('Redefining the standard predicate: ', P, '/', N))
	; true
	),
	( sym_prop(im(Mod), Sym) ->
		error(('Cannot redefine ', P, '/', N,
		' (already declared imported from ', Mod, '!)'))
	; true
	),
	preprocess(PredDef, PredBlks, SymTab),
	ti_transform(PredBlks, TIPredBlks, TIFile, SymTab),
	compile_pred_block(TIPredBlks, PilCode-[], 0, NC),
	compile_peephole_opt(PilCode, PilCode1),
	( GenAsm =:= 0 -> true; tell(AFile), write_asm_instructions(PilCode1) ),
	tell(OFile), asm_PIL(Sym, PilCode1, NC, IsModule),
	!.

ti_transform(PredBlks, TIPredBlks, TIFile, SymTab) :-
	ti_pred_block(PredBlks, TIPredBlks, SymTab),
	( option(ti_dump) ->
		telling(F), tell(TIFile),
		write_preds(TIPredBlks), tell(F)
	; true
	).

close_ti_file(TIFile) :-
	( option(ti_dump) ->
		telling(F), tell(TIFile), told, tell(F)
	; true
	).

compile_pred_block([], PilCode-PilCode, NCin, NCin).
compile_pred_block([PredDef|PRest], PilCode-PilCodeR, NCin, NCout) :-
	compile_predicate2(PredDef, PilCode-PilCodeM, NClauses),
	NCmid is NCin + NClauses,
	!,
	compile_pred_block(PRest, PilCodeM-PilCodeR, NCmid, NCout).

/*======================================================================*/
/* compile_predicate2(+pred(Sym,Clauses,Prag), -PilCode-PilCodeR, -NC)	*/
/*	Compiles the clauses of a single predicate after preprocessing.	*/
/*	A single predicate in the source level can be transformed by	*/
/*	preprocess/3 into several predicates.  compile_predicate2/2	*/
/*	does the compilation for one of them.  The result is a list of	*/
/*	PIL code in assembler format.  The predicate also returns the	*/
/*	number of clauses NC (length of the Clauses list).		*/
/*======================================================================*/

compile_predicate2(pred(Sym,Clauses,Prag), PilCode-PilCodeR, NC) :-
	gennum(L),
	PilCode = [label(pred,(Sym,L))|PilCode1],
	find_if_tabled(Sym,Tabled,Tabind),
	makeindex(Sym, Clauses, PilCode1, PilCodeM, Prag, Tabled, Tabind),
	need_neck(Clauses, Neck),
%    ( option(profile) -> cputime(TimeStart) ; TimeStart = TimeStart ),
	compile_clauses(Clauses, Sym, PilCodeM, PilCodeR, Neck, 0, NC).
%    ( option(profile) -> 
%		time_message(TimeStart, 'Compile_clauses finito') 
%    ; true).

find_if_tabled(Sym, 1, tabled(Tabind,Chs,Rhs,Ar)):-
	sym_type(Sym, tabled(Tabind,Chs,Rhs,Ar)),!. 
find_if_tabled(_, 0, _). 

/*======================================================================*/
/* need_neck(+Clauses, -Neck)						*/
/*	A neck instruction (shallow backtracking) is needed when there	*/
/*	are more than one clauses and the option is turned on.		*/
/*======================================================================*/

need_neck([_,_|_], 1) :- option(shallow), !.
need_neck(_, 0).

compile_clauses([], _, PilCode, PilCode, _, Nin, Nin).
compile_clauses([Clause|Clauses], Sym, PilCode, PilCodeR, Neck, Nin, Nout) :-
	Nmid is Nin + 1,  
	compile_clause(Sym, Clause, PilCode, PilCodeM, Neck, Nmid),
	compile_clauses(Clauses, Sym, PilCodeM, PilCodeR, Neck, Nmid, Nout).


/*======================================================================*/
/* hack_self_compile/0							*/
/*	Forces all the modules that are used by the XSB compiler to	*/
/*	be loaded into the system before overwriting the .O file when	*/
/*	self-compiling the module (or the whole system).		*/
/*======================================================================*/

hack_self_compile :-
	force_tprog_loaded,
	force_inprog_loaded,
	force_tp_var_loaded,
	force_flatten_loaded,
	force_varproc_loaded,
	force_tp_eval_loaded,
	force_tp_comp_loaded,
	force_tp_cond_loaded,
	force_tp_goal_loaded,
	force_asm_opt_loaded,
	force_tp_index_loaded,
	force_listutil_loaded,
	force_peephole_loaded,
	force_asm_inst_loaded,
	force_asm_pass2_loaded,
	force_preprocess_loaded,
	force_tp_geninline_loaded,
	force_ti_mod_loaded.


