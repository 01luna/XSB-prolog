/* File:      varproc.P
** Author(s): Jiyang Xu, Terrance Swift, Kostis Sagonas, David S. Warren
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** Copyright (C) ECRC, Germany, 1990
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: varproc.P,v 1.9 2007-06-22 19:51:09 dwarren Exp $
** 
*/

%%%:- import writeq/1,writeln/1,tell/1,telling/1 from standard.


varproc(VarList, VarTab, PvarCount) :-
	get_lastchunk(VarTab, LastChunk),
	closetail(LastChunk), !,
	mark_occurrences(VarTab), !,
	mark_type(VarList, VarTab, LastChunk), !,
	alloc_vars(VarList, VarTab, 0, PvarCount).
% ,
% ( option(asm_dump) -> telling(X), tell(userout),
% 	write('VarList = '), writeln(VarList),
% 	write('VarTab = '), writeln(VarTab),
% 	write('LastChunk = '), writeln(LastChunk),
% 	told, tell(X)
% ; true
% ).


/*======================================================================*/
/* get_lastchunk(+VarTab, -LastChunks)					*/
/*	Get the chunk id(s) of the last chunk(s).			*/
/*		-LastChunks: is an open ended-list.			*/
/*======================================================================*/

get_lastchunk([One|Rest], LastChunk) :-
	( Rest == [] -> get_lastchunk1(One, LastChunk)
	; get_lastchunk(Rest, LastChunk)
	).

get_lastchunk1(goal(CkId,_,_,_), LastChunk) :- memberchk(CkId, LastChunk).
get_lastchunk1(inlinegoal(CkId,_,_,_), LastChunk) :- memberchk(CkId, LastChunk).
get_lastchunk1(head(_VOList), LastChunk) :- memberchk(1, LastChunk).
get_lastchunk1(branch(A,B), LastChunk) :- 
	get_lastchunk(A, LastChunk),
        get_lastchunk(B, LastChunk).
get_lastchunk1(ifthenelse(_,B,C), LastChunk) :- 
        get_lastchunk(B, LastChunk),
        get_lastchunk(C, LastChunk).


/*======================================================================*/
/* mark_occurrences(#VarTab)	[dsw rewrote]	        		*/
/*	Fills in occurrence information (f, s, l, or v).		*/
/*	      #VarTab  has the occurrence attribute of the		*/
/*		       varocc(Vid,vrec()) structures marked		*/
/*		       after the exit from this predicate.		*/
/*======================================================================*/

mark_occurrences(VarTab) :-
	collect_variables(VarTab,[],MarkTab),
	leaflist(MarkTab,MarkList),
	mark_collected_vars(MarkList).

/*======================================================================*/
/* mark_collected_vars(#OccList) runs each variable occurrence		*/
/* structure and binds the occurrence variables to the appropriate one	*/
/* of f (first), s (subsequent), l (last) or v (void).  The occurrence	*/
/* structure is collected so that the variables appear from the end of	*/
/* the clause to the front, so, e.g., the first encountered is marked l	*/
/* (last). (dsw) 							*/
/*======================================================================*/

mark_collected_vars([]).
mark_collected_vars([l(_,OccStr)|MarkList]) :-
	mark_occ_str0(OccStr),
	mark_collected_vars(MarkList).

% Nothing marked, first seen should be l (for last)
mark_occ_str0([]).
mark_occ_str0([One|Rest]) :-
	(var(One)
	 ->	(Rest == []
		 ->	One = v
		 ;	One = l,
			mark_occ_str1(Rest)
		)
	 ;	One = br(OneA,OneB),
		mark_occ_str2(OneA,Rest),
		mark_occ_str2(OneB,Rest),
		mark_occ_str1(Rest)
	).

% last has been marked, so next ones will be s or f
mark_occ_str1([]).
mark_occ_str1([One|Rest]) :-
	(var(One)
	 ->	(Rest == []
		 ->	One = f
		 ;	One = s,
			mark_occ_str1(Rest)
		)
	 ;	One = br(OneA,OneB),
		mark_occ_str1(OneA,Rest),
		mark_occ_str1(OneB,Rest),
		mark_occ_str1(Rest)
	).

% last has been marked, More is [] iff nothing follows
mark_occ_str1([],_More).
mark_occ_str1([One|Rest],More) :-
	(var(One)
	 ->	(Rest == [], More == []
		 ->	One = f
		 ;	One = s,
			mark_occ_str1(Rest,More)
		)
	 ;	One = br(OneA,OneB),
		(Rest == [] -> Rest1 = More ; Rest1 = Rest),
		mark_occ_str1(OneA,Rest1),
		mark_occ_str1(OneB,Rest1),
		mark_occ_str1(Rest,More)
	).

% last still not yet marked, More is [] iff nothing follows
mark_occ_str2([],_More).
mark_occ_str2([One|Rest],More) :-
	(var(One)
	 ->	(Rest == [], More == []
		 ->	One = v
		 ;	One = l,
			mark_occ_str1(Rest,More)
		)
	 ;	One = br(OneA,OneB),
		(Rest == [] -> Rest1 = More ; Rest1 = Rest),
		mark_occ_str2(OneA,Rest1),
		mark_occ_str2(OneB,Rest1),
		mark_occ_str1(Rest,More)
	).
	

/*======================================================================*/
/* collect_variables(+OccList,+InitialTab,-FinalTab) runs the variable	*/
/* occurrence structure and for each variable collects a structure	*/
/* (containing variables) that represents its occurrences in the	*/
/* clause.  The occurrences are put on the front of a list as they are	*/
/* constructed, when we're done, e.g., the first variable in the list	*/
/* is the last occurrence in the clause.  Each variable is the Occ	*/
/* value in the varocc structure.  Conjunctions are represented as	*/
/* lists; disjunctions are represented with br(A,B).  This returns a	*/
/* 2-3 tree of pairs of variable ID and corresponding occurrence	*/
/* structure. (dsw)							*/
/*======================================================================*/
collect_variables([],MarkTab,MarkTab).
collect_variables([Goal|Goals],MarkTab0,MarkTab) :-
	collect_variables_in_seg(Goal,MarkTab0,MarkTab1),
	collect_variables(Goals,MarkTab1,MarkTab).

collect_variables_in_seg(head(VOList),MarkTab0,MarkTab) :-
	collect_variables_in_occ_list(VOList,MarkTab0,MarkTab).
collect_variables_in_seg(goal(_,_,_,VOList),MarkTab0,MarkTab) :-
	collect_variables_in_occ_list(VOList,MarkTab0,MarkTab).
collect_variables_in_seg(inlinegoal(_,_,_,VOList),MarkTab0,MarkTab) :-
	collect_variables_in_occ_list(VOList,MarkTab0,MarkTab).
collect_variables_in_seg(branch(A,B),MarkTab0,MarkTab) :-
	collect_variables(A,[],MarkTabA),
	collect_variables(B,[],MarkTabB),
	leaflist(MarkTabA,TabAList),
	leaflist(MarkTabB,TabBList),
	add_branch_occs(TabAList,TabBList,MarkTab0,MarkTab).
collect_variables_in_seg(ifthenelse(A,B,C),MarkTab0,MarkTab) :-
	collect_variables(A,MarkTab0,MarkTab1),
	(C = [inlinegoal(_,fail,0,_)]
	 ->	collect_variables(B,MarkTab1,MarkTab)
	 ;	collect_variables_in_seg(branch(B,C),MarkTab1,MarkTab)  %% this looks wrong to me.
	).

collect_variables_in_occ_list([],MarkTab,MarkTab).
collect_variables_in_occ_list([varocc(Vid,vrec(_,_,_,Occ,_,_))|VarOccs],MarkTab0,MarkTab) :-
	prependval(MarkTab0,Vid,Occ,MarkTab1),
	collect_variables_in_occ_list(VarOccs,MarkTab1,MarkTab).

add_branch_occs(TabAList,TabBList,MarkTab0,MarkTab) :-
	(TabAList == []
	 ->	(TabBList == []
		 ->	MarkTab = MarkTab0
		 ;	TabBList = [l(Vid,Occs)|TabBList0],
			prependval(MarkTab0,Vid,br([],Occs),MarkTab1),
			add_branch_occs([],TabBList0,MarkTab1,MarkTab)
		)
	 ;	TabAList = [l(AVid,AOccs)|TabAList0],
		(TabBList == []
		 ->	prependval(MarkTab0,AVid,br(AOccs,[]),MarkTab1),
			add_branch_occs(TabAList0,[],MarkTab1,MarkTab)
		 ;	TabBList = [l(BVid,BOccs)|TabBList0],
			(AVid == BVid
			 ->	prependval(MarkTab0,AVid,br(AOccs,BOccs),MarkTab1),
				add_branch_occs(TabAList0,TabBList0,MarkTab1,MarkTab)
			 ; AVid @< BVid
			 ->	prependval(MarkTab0,AVid,br(AOccs,[]),MarkTab1),
				add_branch_occs(TabAList0,TabBList,MarkTab1,MarkTab)
			 ;	prependval(MarkTab0,BVid,br([],BOccs),MarkTab1),
				add_branch_occs(TabAList,TabBList0,MarkTab1,MarkTab)
			)
		)
	).

prependval(Tree0,Key,V,Tree) :-
	(updatevs(Tree0,Key,OV,[V|OV],Tree) % add it if var is already there
	 ->	true
	 ;	addkey(Tree0,Key,[V],Tree)  % initialize if first occurrence
	).


/*======================================================================*/
/* mark_type(#VarList, #VarTab, +LastChunk)				*/
/*	Computes and fills in the type of variables.			*/
/*	      #VarList is a list of variable(Vid,VPrag) structures	*/
/*		       where Vprag is uninstantiated on entry (gets	*/
/*		       instantiated by this predicate.			*/
/*	      #VarTab  has the type attribute of the varocc(Vid,vrec())	*/
/*		       structures marked after the exit from this	*/
/*		       predicate in the way described below.		*/
/*									*/
/*   The types of variables filled in can be:				*/
/*	vh - the void variable in the head top level;			*/
/*	 t - when the both following conditions hold:			*/
/*	    * first occur in head, in structure, or in the last chunk	*/
/*	    * does not occur in more than one chunk			*/
/*		(head is considered part of the first chunk)		*/
/*	    I improved the scheme a little bit, now if for every	*/
/*	    indepedant occurrence blocks, above two condition hold, OK.	*/
/*	 p - otherwise							*/
/*======================================================================*/

mark_type([], _VT, _).
mark_type([variable(Vid,v(Type,_Loc,Use,_NoUse))|Rest], VarTab, LastChunk) :-
	mark_type1(VarTab, Chunks, LastChunk, Safe, OKt, Vid),
	length(Chunks, L),
	(L > 1
	 ->	Type = p
	 ; nonvar(OKt)
	 ->	Type = t
	 ; Type = p
	 ->	true
	 ;	true % Type is vh but already determined
	),
	( Type == p -> ( var(Safe) -> Use = d ; Use = u ) ; true ),
	mark_type(Rest, VarTab, LastChunk).

mark_type1([], _, _, _, _, _).
mark_type1([One|Rest], Chunks, LastChunk, Safe, OKt, Vid) :-
	mark_type2(One,  Chunks, LastChunk, Safe, OKt, Vid),
	!,	% needed to cut unnecessary choice points... (bmd & kostis)
	mark_type1(Rest, Chunks, LastChunk, Safe, OKt, Vid).

mark_type2(head(VOList), Chunks, LastChunk, Safe, OKt, Vid) :-
	mark_seen(VOList, 1, Chunks, LastChunk, Safe, OKt, Vid).
mark_type2(goal(CkId,_,_,VOList), Chunks, LastChunk, Safe, OKt, Vid) :-
	mark_seen(VOList, CkId, Chunks, LastChunk, Safe, OKt, Vid).
mark_type2(inlinegoal(CkId,_,_,VOList), Chunks, LastChunk, Safe, OKt, Vid) :-
	mark_seen(VOList, CkId, Chunks, LastChunk, Safe, OKt, Vid).
mark_type2(branch(A,B), Chunks, LastChunk, Safe, OKt, Vid) :-
	mark_type1(A, Chunks, LastChunk, Safe, OKt, Vid),
	mark_type1(B, Chunks, LastChunk, Safe, OKt, Vid).
mark_type2(ifthenelse(A,B,C), Chunks, LastChunk, Safe, OKt, Vid) :-
	mark_type1(A, Chunks, LastChunk, Safe, OKt, Vid),
	mark_type1(B, Chunks, LastChunk, Safe, OKt, Vid),
	mark_type1(C, Chunks, LastChunk, Safe, OKt, Vid).

mark_seen(VOList, CkId, Chunks, LastChunk, Safe, OKt, Vid) :-
	mark_seen1(VOList, CkId, Seen, LastChunk, Safe, OKt, Vid),
	( var(Seen) -> true ; memberchk(CkId, Chunks) ).

mark_seen1([], _, _, _, _, _, _).
mark_seen1([varocc(Vid0,Prag)|Rest], CkId, Seen, LastChunk, Safe, OKt, Vid) :-
    ( Vid0 == Vid -> 
	Seen = 1,	/* just bind Seen to a constant */
	( member(CkId, LastChunk) -> vprag_lastchunk(Prag, 1)
	; vprag_lastchunk(Prag, 0)
	),
	(vprag_level(Prag,s) -> OKt = 1 ; true), %been seen in structure context
	vprag_occ(Prag, Occ),
	( Occ == f ->
	  % determine if the variable is safe when pval in the last goal
	  ( ( vprag_context(Prag, b) ; vprag_context(Prag, i) ),
	    vprag_level(Prag, t) -> Safe = 0 /* unsafe */
	  ; true
	  ),
	  % determine if the variable must be permanent
	  (vprag_context(Prag, h)
	   ->	  OKt = 1
	   ; member(CkId,LastChunk)
	   ->	  OKt = 1
	   ;	  true
	  )
	; Occ == v	% determine if the variable can be typed "vh"
	 ->	(vprag_context(Prag, h), vprag_level(Prag, t)
		 ->	vprag_type(Prag, vh)
		 ; member(CkId,LastChunk)
		 ->	OKt = 1
		 ;	true
		)
	 ;	true
	)
    ; true
    ),
    mark_seen1(Rest, CkId, Seen, LastChunk, Safe, OKt, Vid).


/*======================================================================*/
/* alloc_vars(#VarList, #VarTab, +PvarCountIn, -PvarCountOut)		*/
/*	Allocates locations for permanent variables, and computes	*/
/*	"use" and "nouse" locations for temporary variables.  The	*/
/*	location attribute of all temporary variables remains		*/
/*	uninstantiated.							*/
/*======================================================================*/

alloc_vars([], _VarTab, PV, PV).
alloc_vars([variable(Vid,v(VT,Loc,Use,NoUse))|VarList], VarTab, PVin, PVout) :-
    (VT == p
     ->	    PVmed is PVin+1, Loc is PVmed+1 /* first pvar has offset 2 */
     ; VT == vh
     ->	    PVmed = PVin, Loc = 0
     ;	    PVmed = PVin,
	    search_tvar(VarTab, OccList, LGArity, Vid),
	    compute_use1(OccList, HUse0, [], BUse0, [], NoUse0, [], OccInChunk, Vid),
	    (var(OccInChunk) -> ChkArg = 0 ; ChkArg = LGArity),
	    /* Conflict set = ChkArg - BUse0 */
	    conflict_avoid(BUse0, HUse0, NoUse0, Use, NoUse, ChkArg)
    ),
    !, % needed to cut unnecessary choice points... (bmd & kostis)
    alloc_vars(VarList, VarTab, PVmed, PVout).


/*======================================================================*/
/*======================================================================*/

search_tvar([One|Rest], OccList, Arity, Vid) :-
	'search tvar'(One, OccList, Arity, Vid, Rest),
	!.
search_tvar([_One|Rest], OccList, Arity, Vid) :-
	search_tvar(Rest, OccList, Arity, Vid).

'search tvar'(goal(_,_,Arity,VOList), OccList, Arity, Vid, _) :-
	search_occ(VOList, Vid), OccList = VOList.
'search tvar'(head(VOList), OccList, Arity, Vid, Rest) :-
	search_occ(VOList, Vid), 
	get_OccList(Rest, VOList, OccList, Arity).
'search tvar'(inlinegoal(_,_,_,VOList), OccList, Arity, Vid, Rest) :-
	search_occ(VOList, Vid), 
	get_OccList(Rest, VOList, OccList, Arity).
'search tvar'(ifthenelse(A,B,C), OccList, Arity, Vid, _) :-
	( search_tvar(A, OccList, Arity, Vid)
	; search_tvar(B, OccList, Arity, Vid)
	; search_tvar(C, OccList, Arity, Vid)
	),
	!.
'search tvar'(branch(A,B), OccList, Arity, Vid, _) :-
	( search_tvar(A, OccList, Arity, Vid)
	; search_tvar(B, OccList, Arity, Vid)
	),
	!.

search_occ([varocc(Vid,_Prag)|_Rest], Vid).
search_occ([_|Rest], Vid) :- search_occ(Rest, Vid).

get_OccList([], VOList, VOList, 0).
get_OccList([One|Rest], VOListIn, VOListOut, Arity) :-
	( One = goal(_,_,Arity,VOList) ->
		append(VOList, VOListIn, VOListOut)
	; One = inlinegoal(_,_,_,VOList) ->
		append(VOList, VOListIn, VOListMed),
		get_OccList(Rest, VOListMed, VOListOut, Arity)
	; One = ifthenelse(Test,ThenGoals,ElseGoals) -> 
		get_OccList(Test, VOListIn, TestVOList, TestArity),
		( TestArity =:= 0 -> % all tests are inlines (or variableless).
		    % In the following the VOLists from the "then" and "else"
		    % parts of the if-then-else should really be union(ed) but
		    % I guess (and hope) that appending them will not do much
		    % harm.
		     get_OccList(ThenGoals, TestVOList, ThenVOList, ThenArity),
		     get_OccList(ElseGoals, ThenVOList, VOListOut, ElseArity),
		     ( ThenArity >= ElseArity -> Arity = ThenArity 
		     ; Arity = ElseArity 
		     )
		; Arity = TestArity, VOListOut = TestVOList
		)
	; VOListOut = VOListIn, Arity = 0
	).


/*======================================================================*/
/* compute_use1(+OccList, -HUse0-HUseR, -BUse0-BUseR,			*/
/*			  -NoUse0-NoUseR, -OccInChunk, +Vid)		*/
/*	Collects information to compute "Use" and "NoUse" for temporary	*/
/*	variables.							*/
/*		-HUse0:  occurs at the top level of head.		*/
/*		-BUse0:  occurs at the top level of body		*/
/*			 (excluding inlines).				*/
/*		-NoUse0: another temporary variable occurring at the	*/
/*			 top level of the body (excluding inlines).	*/
/*======================================================================*/

compute_use1([], HUse0,HUse0, BUse0,BUse0, NoUse0,NoUse0, _, _).
compute_use1([varocc(I,Prag)|Rest],HUse0,HUseR,BUse0,BUseR,NoUse0,NoUseR,OccInChunk,Vid) :-
	(I == Vid
	 ->	NoUse0=NoUseM, vprag_context(Prag, HB),
		( HB == b -> OccInChunk = 1 /* just bind it */ ; true ),
		vprag_level(Prag, Level),
		(Level == t
		 ->	(HB == h
			 ->	vprag_argno(Prag, Arg), HUse0=[Arg|HUseM], BUse0=BUseM
			 ; HB == b
			 ->	vprag_argno(Prag, Arg), BUse0=[Arg|BUseM], HUse0=HUseM
			 ; HB == i
			 ->	HUse0=HUseM, BUse0=BUseM
			)
		 ;	HUse0=HUseM, BUse0=BUseM
		)
	 ;      HUse0=HUseM, BUse0=BUseM,
		(vprag_context(Prag, b), vprag_level(Prag, t), vprag_type(Prag, t)
		 ->	vprag_argno(Prag, Arg), NoUse0=[Arg|NoUseM]
		 ;	NoUse0=NoUseM
		)
	),
	compute_use1(Rest,HUseM,HUseR,BUseM,BUseR,NoUseM,NoUseR,OccInChunk,Vid).


/*======================================================================*/
/* conflict_avoid(+BUse0, +HUse0, +NoUse0, -Use, -NoUse, +ChkArg)	*/
/*	Computes Use and NoUse from the partial information obtained	*/
/*	by compute_use1/9.						*/
/*======================================================================*/

conflict_avoid(BUse0, HUse0, NoUse0, Use, NoUse, ChkArg) :-
	conf_real_use(HUse0, Use, BUse0, ChkArg),
	conf_nouse1(NoUse0, Use, NoUse),
	conf_nouse2(ChkArg, Use, NoUse).

conf_real_use([], Use, Use, _ChkArg).
conf_real_use([One|More], Use, UseR, ChkArg) :-
	(One =< ChkArg
	 ->	Use=UseM		% conflict or already in BUse
	 ; member(One, UseR)
	 ->	Use=UseM		% alread in BUse
	 ;	Use = [One|UseM]	% head par in front
	),
	conf_real_use(More, UseM, UseR, ChkArg).

conf_nouse1([], _, _).
conf_nouse1([One|More], Use, NoUse) :-
	(member(One, Use) ; memberchk(One, NoUse)),
	!,
	conf_nouse1(More, Use, NoUse).

conf_nouse2(N, Use, NoUse) :-
	(N =:= 0
	 ->	closetail(NoUse)
	 ; ( member2(N, Use) ; memberchk(N, NoUse) )
	 ->	  N1 is N - 1,
		conf_nouse2(N1, Use, NoUse)
	).


/*======================================================================*/
/*									*/
/* The format of the VPrag record is as follows:			*/
/*									*/
/* vrec(Context,Level,ArgNo,Occurrence,v(Type,Loc,Use,NoUse),LastChunk)	*/
/*									*/
/*======================================================================*/

/*------------------------------------------------------*/
/* The following information is filled by inprog/2.	*/
/*------------------------------------------------------*/

vprag_context(vrec(C,_,_,_,_,_), C).	% h - Head, i - Inline, b - Body
vprag_level(vrec(_,C,_,_,_,_), C).	% t - top level, s - second level
vprag_argno(vrec(_,_,C,_,_,_), C).

/*--------------------------------------------------------------*/
/* The following information is filled by mark_occurrence/2.	*/
/*--------------------------------------------------------------*/

vprag_occ(vrec(_,_,_,C,_,_), C).
	% f - first occ, s - subsequent occ, l - last occ, v - void
vprag_lastchunk(vrec(_,_,_,_,_,C), C).
vprag_common(vrec(_,_,_,_,C,_), C).
vprag_type(vrec(_,_,_,_,v(C,_,_,_),_), C).
	% t - Temp var, p - Permanent var, vh - void var at head, v - void not head

/*------------------------------------------------------*/
/* The following information is filled by alloc_vars/2.	*/
/*------------------------------------------------------*/

vprag_loc(vrec(_,_,_,_,v(_,C,_,_),_), C).
	% for temp var, the register number; for perm var, numbered from 1
vprag_use(vrec(_,_,_,_,v(_,_,C,_),_), C).
	% for temp var, the "use" list; for perm var, "d", "u" or "p"
vprag_nouse(vrec(_,_,_,_,v(_,_,_,C),_), C).
	% for temp var, the "nouse" list; for perm var, not used.

/*----------------------------------------------------------------------*/
/* The non-first occurrence of a permanent variable in the last chunk	*/
/* must be marked by either "u" or "d".  It is marked as "u" if its	*/
/* first occurrence is in the top level of a body (inline) goal; and	*/
/* is marked as "d" otherwise.						*/
/*----------------------------------------------------------------------*/

vprag_type1(Prag, T) :-
	vprag_type(Prag, T0),
	(T0 = p, vprag_lastchunk(Prag,1), (vprag_occ(Prag,l) ; vprag_occ(Prag,s))
	 ->	vprag_use(Prag,T)
	 ;	T = T0
	).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/* 
This is a set of routines that supports indexed tables. Tables
are sets of key-value_list pairs. With each key is associated a list
of values. It uses 2-3 trees for the index (modified by D.S. Warren
from Ivan Bratko: ``Prolog Programming for Artificial
Intelligence'', Addison Wesley, 1986). Operations are: 

Keys must be ground! (so numbervar them)

addkey(Tree,Key,V,Tree1) adds a new Key with value V, returning 
    new Tree1. Fails if the key is already there.

find(Tree,Key,V) finds the entry with Key and returns associated
    values in V.

updatevs(Tree,Key,OldV,NewV,Tree1) replaces value of entry with key
    Key and value OldV with NewV.

leaflist(Tree,List) returns a list of all l(K,V) in the Tree.

*/


addkey(Tree,X,V,Tree1) :-
	ins2(Tree,X,V,Trees),
	cmb0(Trees,Tree1).
addkey([],X,V,l(X,V)).


/*** unused here
find(l(X,V),Xs,V) :- X == Xs.
find(n2(T1,M,T2),X,V) :-
	M @=< X
	 ->	find(T2,X,V)
	 ;	find(T1,X,V).
find(n3(T1,M2,T2,M3,T3),X,V) :-
	M2 @=< X
	 ->	(M3 @=< X
		 ->	find(T3,X,V)
		 ;	find(T2,X,V)
		)
	 ;	find(T1,X,V).
***/

leaflist(Tree,List) :-
	(Tree == []
	 ->	List = []
	 ;	leaflist(Tree,List,[])
	).

leaflist(Node,List0,List) :-
	(Node @= l(_,_)
	 ->	List0 = [Node|List]
	 ; Node = n2(T1,_,T2)
	 ->	leaflist(T1,List0,List1),
		leaflist(T2,List1,List)
	 ;	Node = n3(T1,_,T2,_,T3),
		leaflist(T1,List0,List1),
		leaflist(T2,List1,List2),
		leaflist(T3,List2,List)
	).

% updatevs(Tab0,X,Ov,Nv,Tab) updates Tab0 to Tab, by replacing
% Ov of entry with key X by Nv.

updatevs(l(X,Ov),Xs,Ov,Nv,l(X,Nv)) :- X == Xs.
updatevs(n2(T1,M,T2),X,Ov,Nv,n2(NT1,M,NT2)) :-
	M @=< X
	 ->	NT1=T1, updatevs(T2,X,Ov,Nv,NT2)
	 ;	NT2=T2, updatevs(T1,X,Ov,Nv,NT1).
updatevs(n3(T1,M2,T2,M3,T3),X,Ov,Nv,n3(NT1,M2,NT2,M3,NT3)) :-
	M2 @=< X
	 ->	(M3 @=< X
		 ->	NT2=T2, NT1=T1, updatevs(T3,X,Ov,Nv,NT3)
		 ;	NT1=T1, NT3=T3, updatevs(T2,X,Ov,Nv,NT2)
		)
	 ;	NT2=T2, NT3=T3, updatevs(T1,X,Ov,Nv,NT1).

ins2(n2(T1,M,T2),X,V,Tree) :- 
	M @=< X
	 ->	ins2(T2,X,V,Tree1),
		cmb2(Tree1,T1,M,Tree)
	 ;	ins2(T1,X,V,Tree1),
		cmb1(Tree1,M,T2,Tree).
ins2(n3(T1,M2,T2,M3,T3),X,V,Tree) :- 
	M2 @=< X
	 ->	(M3 @=< X
		 ->	ins2(T3,X,V,Tree1),
			cmb4(Tree1,T1,M2,T2,M3,Tree)
		 ;	ins2(T2,X,V,Tree1),
			cmb5(Tree1,T1,M2,M3,T3,Tree)
		)
	 ;	ins2(T1,X,V,Tree1),
		cmb3(Tree1,M2,T2,M3,T3,Tree).
ins2(l(A,V),X,Vn,Tree) :-
	A @=< X
	 ->	(X @=< A
		 ->	fail
		 ;	Tree = t(l(A,V),X,l(X,Vn))
		)
	 ;	Tree = t(l(X,Vn),A,l(A,V)).

cmb0(t(Tree),Tree).
cmb0(t(T1,M,T2),n2(T1,M,T2)).

cmb1(t(NT1),M,T2,t(n2(NT1,M,T2))).
cmb1(t(NT1a,Mb,NT1b),M,T2,t(n3(NT1a,Mb,NT1b,M,T2))).

cmb2(t(NT2),T1,M,t(n2(T1,M,NT2))).
cmb2(t(NT2a,Mb,NT2b),T1,M,t(n3(T1,M,NT2a,Mb,NT2b))).

cmb3(t(NT1),M2,T2,M3,T3,t(n3(NT1,M2,T2,M3,T3))).
cmb3(t(NT1a,Mb,NT1b),M2,T2,M3,T3,t(n2(NT1a,Mb,NT1b),M2,n2(T2,M3,T3))).

cmb4(t(NT3),T1,M2,T2,M3,t(n3(T1,M2,T2,M3,NT3))).
cmb4(t(NT3a,Mb,NT3b),T1,M2,T2,M3,t(n2(T1,M2,T2),M3,n2(NT3a,Mb,NT3b))).

cmb5(t(NT2),T1,M2,M3,T3,t(n3(T1,M2,NT2,M3,T3))).
cmb5(t(NT2a,Mb,NT2b),T1,M2,M3,T3,t(n2(T1,M2,NT2a),Mb,n2(NT2b,M3,T3))).

force_varproc_loaded.

