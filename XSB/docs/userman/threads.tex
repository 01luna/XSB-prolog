\chapter{Multi-Threaded Programming in XSB} \label{chap:threads}

Starting with Version 3.0, XSB supports the use of Posix threads to
perform separable computations, and in certain cases to parellelize
them.  Posix threads have a simple and clear API, and are available on
all Unixes as well as on Windows via ???.  This chapter introduces how
to program with threads in XSB through a series of examples.  Later
sections discuss performance aspects of our implementation as well as
describing relevant predicates.  A general knowledge of multi-threaded
programming is assumed, such as can be found in \cite{LewB98,Bute97}.

\section{Getting Started with Multi-Threading}
%
In Version 3.0 the default configuration of XSB does not include
multi-threading.  This is partly because multi-threading is new, and
despite our efforts, the multi-threaded engine may contain bugs not
present in the single-
threaded engine.  In addition, in Version 3.0,
not all packages have yet been made thread-safe so that not all
configurations are supported with multi-threading.  Currently ODBC is
supported with the multi-threaded configuration, but {\tt dbdrivers},
{\tt xpath}, {\tt iodbc}, {\tt interprolog} and {\tt smodels} have not
been. {\sf What about others?}

With this in mind, making the multi-threaded engine is simple:
configure and make XSB as in Chapter~\ref{chap:system}, but include
the command {\tt --enable-mt}.  When you invoke the newly made
configuration of XSB you should see {\tt engine: multi-threading} in
the configuration list below the banner rather than {\tt engine:
  slg-wam}.

\paragraph{Hello World for Beginners}
%
We naturally start with a hello world program.  Within the
multi-threaded engine, import {\tt xsb\_thread\_create/2} from the
module {\tt thread}, and type the command
\begin{center} 
{\tt ?- xsb\_thread\_create(writeln('hello world'),Id)} 
\end{center} 
you should see something like 
\begin{center} 
{\tt Id = 1hello world} 
\end{center} 
%
while the output is a little ugly, the simple ``hello world'' program
does illustrate simple multi-threading at work.  The calling thread
(i.e. the thread controlling the command-line interpreter which we
call $T_{prompt}$) executes the predicate {\tt xsb\_thread\_create/2}
which creates a thread $T_{child}$ and immediately returns with the
{\em XSB thread id} of the created thread.  Meanwhile, $T_{child}$
initializes its stacks and other memory areas and executes the goal
{\tt writeln('hello world')}.  $T_{child}$ and $T_{prompt}$ share most
of their process-level information: in particular they share a common
I/O stream for standard output, leading to the output above.  What is
happening may be seen a little more easily by executing the command
%
\begin{center} 
{\tt ?- xsb\_thread\_create((sleep(1),writeln('hello world')),Id)} 
\end{center} 
%
In this case the interpreter reports that {\tt F} is bound to a thread
id, then about a second later {\tt writeln/1} is executed.  

The simple ``hello world'' program illustrates a couple of points.
First, it is easy to create a thread in XSB and have that thread do
work.  Second, it can be tricky to coordinate actions among threads.
We'll explore these two themes in more detail, but first suppose we
are determined to extend out multi-threaded program so that it
produces good output.  One way to do this is to {\em join}
$T_{prompt}$ and $T_{child}$ as follows 
%
\begin{verbatim}
?- xsb_thread_create(writeln('hello world'),Id),
   xsb_thread_join(Id,ExitCode).
hello world

Id = 1
ExitCode = no_error_ball - 0
\end{verbatim}
%
In this case, as soon as $T_{prompt}$ has issued a command to create
$T_{child}$, it executes {\tt xsb\_thread\_join/2}.  This later
predicate makes a system call to the underlying operating system to
suspend $T_{prompt}$ until $T_{child}$ has exited.  {\tt
  xsb\_thread\_join/2} returns both the error ball (if any) and the
exit code of $T_{child}$.  As usual, a value of {\tt 0} indicates
normal termination, as does the fact that no error ball was found.

\comment{
\paragraph{Multi-threading Concepts}

The previous section introduced some new concepts that were not fully
discussed.  First was the concept of an {\em XSB thread id}: XSB
manages up to {\tt MAXTHREAD} active threads using XSB thread ids.  It
should be noted that the XSB thread id of a thread is different from
the identifier of the underlying pthread.  An XSB thread id is a
Prolog term, and unlike Posix thread ids, XSB thread ids can be
compared for equality using unification.  The actual form of an XSB
thread id, however, is subject to change between versions, so programs
should not make use of the exact form of an XSB thread id.  In the
multi-threaded engine, the XSB thread id of any thread can be queried
using the predicate {\tt xsb\_thread\_self/1}

{\sc talk at some point about exit codes and error terms}
}
\section{Predicates for Multi-Threading}

\begin{description}

\ournewitem{xsb\_thread\_create(+Goal,ThreadId,,+OptionsList)}{thread}
\index{\texttt{xsb\_thread\_create/3}}
%
When called from thread $T$, this predicate creates a new XSB thread
$T_{new}$ to execute {\tt Goal}.  When goal either succeeds, throws an
unhandled error, or fails, $T_{new}$ exits, but {\tt
  xsb\_thread\_create/2} will succeed immediately, binding {\tt
  ThreadId} to the XSB thread id of $T_{new}$.  {\tt Goal} must be
callable, but need not be fully instantiated.  No bindings from {\tt
  Goal} are passed back from $T$ to $T_{new}$, so communication
between $T_{new}$ and $T$ must be through tables, asserted code, or
other side effects.

{\tt OptionList} allows optional parameters in the configuration for
the initial size of XSB stacks and to indicate whether $T_{new}$ is to
be created as detached.  Note that XSB threads allow automatic stack
allocation, so that the size options may be most useful for
applications with very large numbers of threads.  In this case,
setting initial stack sizes to be small may allow more threads to be
created on a given hardware platform.  Also note that only XSB stacks
are affected, the stack size of the underlying pthread remains
unaltered.
%
\bi
\item {\tt glsize(N)}: create thread with global (heap) plus local
  stack size initially set ot {\tt N} kbytes.  If not specified, the
  default size is used (cf. Section~\ref{sec:EmuOptions}).
%
\item {\tt tcsize(N)}: create thread with trail plus choice point 
  stack size initially set ot {\tt N} kbytes.  If not specified, the
  default size is used (cf. Section~\ref{sec:EmuOptions}).
%
\item {\tt complsize(N)}: create thread with completion
  stack size initially set ot {\tt N} kbytes. If not specified, the
  default size is used (cf. Section~\ref{sec:EmuOptions}).
%
\item {\tt pdlsize(N)}: create thread with {\tt N} kbytes of
  unification stack.  If not specified, the
  default size is used (cf. Section~\ref{sec:EmuOptions}).
%
\item {\tt detached}: creates detached thread.  If not specified, the
  thread created will be joinable.
\ei

{\bf Error Cases}
\bi
\item 	{\tt Goal} is not callable.
\bi
\item 	{\tt type\_error(callable\_term,Goal)}
\ei
\item 	{\tt ThreadId} is not a variable
\bi
\item 	{\tt instantiation\_error}
\ei
\item   No more system threads are available (EAGAIN)
\bi
\item {\tt resource\_error('system threads')}
\ei
\item 	{\tt OptionList} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
\item 	{\tt OptionList} contains an option, {\tt Option} not described above
\bi
\item 	{\tt domain\_error(xsb\_thread\_create\_optoin,Option)}
\ei
\ei

\ournewitem{xsb\_thread\_create(+Goal,-ThreadId)}{thread}
\index{\texttt{xsb\_thread\_create/2}}
%
Acts as {\tt xsb\_thread\_create(Goal,ThreadId,[])}.

\ournewitem{xsb\_thread\_join(+ThreadIds,-ExitDesignators)}{thread}
\index{\texttt{xsb\_thread\_join/2}} 
% 
When {\tt xsb\_thread\_join/2} is called by thread $T$, {\tt
  ThreadIds} must be instantiated to either an XSB thread id, or a
list of XSB thread ids; in either case, {\tt ExitDesignators} must be
uninstantiated.  The action of the predicate is to suspend $T$ until
all of the threads denoted by {\tt ThreadIds} have exited.  At this
time, any remaining resources for the threads in {\tt ThreadIds} is
reclaimed, and {\tt ExitCode} is either an element of the form:
\begin{center}
{\tt ExitBall -  ExitCode} 
\end{center}
%
or a list of such elements.  For each XSB thread id $T_1$ in
{ThreadIds}, {\tt ExitBall} is either
\begin{itemize}
%
\item {\tt no\_error\_ball} if $T_1$ exited normally (through success or
  failure), without throwing an error or being cancelled.
%
\item An error ball if $T_1$ threw an error that was not explicitly
  handled by a catch or user error handler.
%
\item A special error ball of the form {\tt
  error(thead\_cancel,$T_1$,Backtrace)} if $T_1$ was cancelled by some
  other thread.  In this case, {\tt Backtrace} is an empty backtrace,
  added for conformability with other error forms.
\end{itemize}
%
ExitCode is either {\tt 0} for normal termination, or the value
specified by an explicit call to {\tt xsb\_thread\_exit/1}.

{\bf Error Cases}
\bi
\item 	{\tt ThreadIds} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt ThreadIds} is not a list of XSB thread ids
\bi
\item 	{\tt domain\_error(listof\_threadids,ThreadIds)}
\ei
%
\item 	{\tt ExitCodes} is not a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item   {\tt ThreadId} does not correspond to a valid thread
\bi
\item   {\tt existence\_error(valid\_thread,ThreadId)}
\ei
\item   {\tt ThreadId} does not correspond to a joinable thread
  (i.e. {\tt ThreadId} is detached).
\bi
\item   {\tt permission\_error(join,non\_joinable\_thread,ThreadId)}
\ei
\ei

\ournewitem{xsb\_thread\_exit(+ExitCode)}{thread}
\index{\texttt{xsb\_thread\_exit/1}} 
%
Exits a thread $T$ with {\tt ExitCode} after releasing any mutexes
held by $T$, freeing any thread-specific memory allocated for $T$ (we
hope).  {\tt ExitCode} will be used if the caller of $T$ joins to $T$,
but will be ignored in other cases.  There is no need to call this
routine on normal termination of a thread as it is called implicitly
on success or (final) failure of a thread's goal.

{\bf Error Cases}
\bi
\item 	{\tt ThreadId} is not an integer
\bi
\item 	{\tt type\_error(integer,ExitCode)}
\ei
\ei

\ournewitem{xsb\_thread\_self(-ThreadId)}{thread}
\index{\texttt{xsb\_thread\_self/1}} 
%
Returns the XSB thread id of the calling thread.

{\bf Error Cases}
\bi
\item 	{\tt ThreadId} is not a variable
\bi
\item 	{\tt instantiation\_error}
\ei
\ei

\ournewitem{xsb\_thread\_detach(+ThreadId)}{thread}
\index{\texttt{xsb\_thread\_detach/1}} 
%
Detaches a joinable thread denoted by {\tt ThreadId} so that all
resources will be reclaimed upon its exit.  The thread denoted by {\tt
  ThreadId} will no longer be joinable, once it is detached.

Note, if it is known at thread creation time that a thread should be
detached, it is better to create the thread as detached via {\tt
  xsb\_thread\_create/3}.

{\bf Error Cases}
\bi
\item 	{\tt ThreadId} is not an integer
\bi
\item 	{\tt type\_error(integer,ExitCode)}
\ei
\item   {\tt ThreadId} does not correspond to a valid thread
\bi
\item   {\tt existence\_error(valid\_thread,ThreadId)}
\ei
\item 	{\tt ThreadId} is active but not joinable
\bi
\item 	{\tt permission\_error(thread\_detach,non\_joinable\_thread,ThreadId)}
\ei
\ei

\ournewitem{xsb\_thread\_cancel(+ThreadId)}{thread}
\index{\texttt{xsb\_thread\_cancel/1}} 
%
Cancels the XSB thread denoted by {\tt ThreadId}.  The cancellation
does not use pthread cancellation mechanisms, rather it uses XSB's
interrupt mechanism to set {\tt ThreadId}'s interrupt vector.  When
this interrupt vector is checked, {\tt ThreadId} will throw a thread
cancellation error, which can be caught within {\tt ThreadId} like any
other error.  Usually, this means that {\tt ThreadId} will abort and
exit.  Note that the high-level upon which thread cancellation is
implemented allows for simplicity and portability of thread
cancellation.  \footnote{While interrupt vector is not checked upon
  every SLG-WAM instructiuon, it is checked on every {\sf call} and
  {\sf execute} instruction, and should should be suitable for almost
  any need for cancellation.}.

The main XSB thread cannot be cancelled; apart from that any thread
can cancel any other thread.

{\bf Error Cases}
\bi
\item 	{\tt ThreadId} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item   {\tt ThreadId} does not correspond to valid thread
\bi
\item   {\tt existence\_error(valid\_thread,ThreadId)}
\ei
\item   {\tt ThreadId} denotes the main thread.
\bi
\item   {\tt permission\_error(cancel,main\_thread,ThreadId)}
\ei
\ei

\ournewitem{xsb\_thread\_yield}{thread}
\index{\texttt{xsb\_thread\_yield/0}} 
% 
Make the calling thread ready to be run {\em after} other threads of
the same priority.  This predicate relies on the real-time extensions
to pthreads specified in Posix 1b, and may not be available on all
platforms.

{\bf Error Cases}
\bi
\item 	The current platform does not support Posix real-time extensions
\bi
\item 	{\tt misc\_error}
\ei
\ei

\comment{
\ournewitem{xsb\_user\_mutex\_lock(MutexId)}{thread}
\index{\texttt{xsb\_user\_mutex\_lock/1}} 
%
Locks a user-mutex, currently numbered 0 through 9, with 0
corresponding to the mutex that controls I/O to the console.  These
mutexes are initalized automatically at process startup, and In
addition each of the mutexes have a {\tt pthread\_mutexattr\_t} type
of {\tt NORMAL}.

{\bf Error Cases}
\bi
\item 	{\tt MutexId} is not an integer
\bi
\item 	{\tt type\_error(integer,MutexId)}
\ei
\item   {\tt MutexId} does is not the index of a user mutex
\bi
\item 	{\tt domain\_error(mutex\_id,MutexId)}
\ei
\item 	Locking {\tt MutexId} would lead to a deadlock
\bi
\item 	{\tt permission\_error('mutex lock','deadlocking mutex',MutexId)}
\ei
\ei

\ournewitem{xsb\_user\_mutex\_trylock(MutexId)}{thread}
\index{\texttt{xsb\_user_mutex_trylock/1}} 
%
If the user-mutex denoted by {\tt MutexId} is not busy, this predicate
locks {\tt MutexId} and succeeds; if {\tt MutexId} is busy the
predicate fails, rather than waiting for the lock as with {\tt
  xsb\_user\_mutex\_trylock/1}

{\bf Error Cases}
\bi
\item 	{\tt MutexId} is not an integer
\bi
\item 	{\tt type\_error(integer,MutexId)}
\ei
\item   {\tt MutexId} does is not the index of a user mutex
\bi
\item 	{\tt domain\_error(mutex\_id,MutexId)}
\ei
\ei

\ournewitem{xsb\_user\_mutex\_unlock/0}{thread}
\index{\texttt{xsb\_user\_mutex\_unlock/1}} 
%
Unlocks a user mutex (user mutexes are described above).

{\bf Error Cases}
\bi
\item 	{\tt MutexId} is not an integer
\bi
\item 	{\tt type\_error(integer,MutexId)}
\ei
\item   {\tt MutexId} does is not the index of a user mutex
\bi
\item 	{\tt domain\_error(mutex\_id,MutexId)}
\ei
\item 	The thread calling {\tt xsb\_user\_mutex\_unlock/1} does not
  own the lock for {\tt MutexId} 
\bi
\item 	{\tt permission\_error('mutex unlock',mutex,MutexId)}
\ei
\ei
}
\end{description}
