\chapter{Multi-Threaded Programming in XSB} \label{chap:threads}

Starting with Version 3.0, XSB supports the use of Posix threads to
perform separable computations, and in certain cases to parallelize
them~\footnote{\version{} of XSB is the first version to include
  multi-threading, and is still under development.  Users who want to
  develop XSB applications using multi-threading should consider
  checking out the latest stable CVS version of XSB for extensions to
  features and bug fixes.}.Posix threads have a simple and clear API,
and are available on all Unixes and, by using open-source libraries,
on Windows as well (see Section~\ref{sec:mt-windows} to configure
under Windows).  This chapter introduces how to program with threads
in XSB through a series of examples.  Later sections discuss
performance aspects of our implementation as well as describing
relevant predicates.  A general knowledge of multi-threaded
programming is assumed, such as can be found in \cite{LewB98,Bute97}.

\section{Getting Started with Multi-Threading}
%
In Version 3.0 the default configuration of XSB does not include
multi-threading.  This is partly because multi-threading is new, and
despite our efforts, the multi-threaded engine may contain bugs not
present in the single- threaded engine.  However the main reason is
because in Version 3.0, not all libraries and packages have yet been
made thread-safe so that not all configurations are supported with
multi-threading.  Both the XSB-calling-C and the C-calling-XSB
interfaces are supported in the multi-threaded engine.  All XSB
libraries have been ported to the multi-threaded engine {\em except}
the profiling library and the {\tt string} library (which is not yet
thread-safe).  The packages {\tt ODBC} and {\tt CHR}, and {\tt
  FLORA-2} are supported by the multi-threaded engine, but the
packages {\tt dbdrivers}, {\tt xpath}, {\tt interprolog}, {\tt
  smodels}, {\tt perlmatch}, {\tt regmatch}, {\tt libwww} and {\tt
  posix} are not.  We note, however that all basic/ISO Prolog
functionality is thread-safe (at least, as far as we know :-).

With this in mind, making the multi-threaded engine is simple:
configure and make XSB as in Chapter~\ref{chap:system}, but include
the command {\tt --enable-mt}.  When you invoke the newly made
configuration of XSB you should see {\tt engine: multi-threading} in
the configuration list below the banner rather than {\tt engine:
  slg-wam} as in the sequential engine.

\paragraph{Hello World for Beginners}
%
We naturally start with a program to print ``hello world''.  Within
the multi-threaded engine, import {\tt thread\_create/2} from the
module {\tt thread}, and type the command
\begin{center} 
{\tt ?- thread\_create(writeln('hello world'),Id)} 
\end{center} 
you should see something like 
\begin{center} 
{\tt Id = 1hello world} 
\end{center} 
%
while the output is a little ugly, the ``hello world'' program does
illustrate simple multi-threading at work.  The calling thread
(i.e. the thread controlling the command-line interpreter which we
call $T_{prompt}$) executes the predicate {\tt thread\_create/2} which
creates a thread $T_{child}$ and immediately returns with the {\em XSB
  thread id} of the created thread.  Meanwhile, $T_{child}$
initializes its stacks and other memory areas and executes the goal
{\tt writeln('hello world')}.  $T_{child}$ and $T_{prompt}$ share most
of their process-level information: in particular they share a common
I/O stream for standard output, leading to the output above.  What is
happening may be seen a little more easily by executing the command
%
\begin{center} 
{\tt ?- thread\_create((sleep(1),writeln('hello world')),Id)} 
\end{center} 
%
In this case the interpreter reports that {\tt F} is bound to a thread
id, then about a second later {\tt writeln/1} is executed.  

The simple ``hello world'' program illustrates a couple of points.
First, it is easy to create a thread in XSB and have that thread do
work.  Second, it can be tricky to coordinate actions among threads.
We'll explore these two themes in more detail, but first suppose we
are determined to extend out multi-threaded program so that it
produces good output.  One way to do this is to {\em join}
$T_{prompt}$ and $T_{child}$ as follows 
%
\begin{verbatim}
?- xsb_thread_create(writeln('hello world'),Id),
   xsb_thread_join(Id,ExitCode).
hello world

Id = 1
ExitCode = no_error_ball - 0
\end{verbatim}
%
In this case, as soon as $T_{prompt}$ has issued a command to create
$T_{child}$, it executes {\tt thread\_join/2}.  This latter predicate
makes a system call to the underlying operating system to suspend
$T_{prompt}$ until $T_{child}$ has exited.  {\tt thread\_join/2}
returns both the error ball (if any) and the exit code of $T_{child}$.
As usual, a value of {\tt 0} indicates normal termination, as does the
fact that no error ball was found.

So far, we've introduced a few concepts that have not been fully
discussed.  First is the concept of an {\em XSB thread id}: XSB
manages up to {\tt MAXTHREAD} active threads using XSB thread
ids~\footnote{This number can be reset via a command line option to
  XSB, see Section~\ref{sec:EmuOptions}}.  It should be noted that the
XSB thread id of a thread is different from the identifier of the
underlying Pthread.  An XSB thread id is a Prolog term, and unlike
Posix thread ids, XSB thread ids can be compared for equality using
unification.  The actual form of an XSB thread id, however, is subject
to change between versions, so programs should not make use of the
exact form of an XSB thread id.  In the multi-threaded engine, the XSB
thread id of any thread can be queried using the predicate {\tt
  thread\_self/1}.

\section{Communication among Threads}

\begin{example}
Consider the program fragment
%
\begin{verbatim}
:- dynamic p/1.

test:- xsb_thread_create(assert(p(1)),_X).
\end{verbatim}
If you type the goal {\tt ?- test} and then the goal {\tt ?- p(X)},
the call {\tt p(X)} will fail.  
\end{example}

\noindent
This illustrates an important point about dynamic and tabled
predicates in the multi-threaded engine: by default clauses for a
dynamic predicate {\tt p/n} are private to the thread that asserts
them; and by default tables created in an evaluation of a goal for
{\tt p/n} are private to the thread that evaluates the goal.  This
behavior contrasts to that of static code which is always shared
between threads.  In the example above, to allow {\tt p(1)} to be
visible to various threads, {\tt p/1} must be declared to be shared
with the following declaration.
%
\begin{verbatim}
:- thread_shared(p(_)).
\end{verbatim}

The ability to share dynamic code between predicates provides an
extremely powerful mechanism for threads to communicate.  So why does
XSB make dynamic predicates thread-private by default?  The main
reason for this is that if dozens or hundreds of threads are running
concurrently, shared dynamic code becomes an expensive synchronization
point.  Code for shared predicates must be more heavily mutexed than
code for private predicates.  In the case of dynamic code, XSB does
not always immediately reclaim the space of retracted clause, to avoid
the possibility of some computation backtracking into a clause that
has been reclaimed.  Rather, (like most Prologs), XSB may garbage
collect the space of the retracted clauses at a later time.  While
clause garbage collection is simple enough to implement for a single
thread, garbage collecting clauses for shared dynamic predicates is
difficult to do when multiple threads are active.  Accordingly, in
\version , space for shared dynamic clauses is not reclaimed until
there is a single active thread.  However for {\em thread-private}
dynamic predicates, there is no problem in reclaiming space when
multiple threads are active: from the engine's perspective garbage
collection is no different than in the sequential case.  Thus one set
of reasons for making dynamic predicates private by default are based
on efficiency~\footnote{Future versions may offer more powerful
  garbage collectors for shared predicates.}.

The second reason for making dynamic predicates thread-private by
default is semantic.  Suppose thread $T_1$ starts a tabled computation
that depends on the dynamic shared predicate {\tt p/1}.  While $T_1$
is computing the table, thread $T_2$ asserts a clause to {\tt p/1}.
$T_1$'s table is likely to be inconsistent, leading to the problem of
{\em read consistency} of any table that depends on thread-shared
dynamic predicates.  In \version , users are responsible for ensuring
read consistency of any tables that depend on shared dynamic data.
Future versions of XSB are intended to allow more sophisticated
mechanisms for read consistency.

Not only can tables depend on thread-shared or thread-private dynamic
data, but 
%in the default multi-threaded configuration of XSB, which
%uses local scheduling for tabled evaluation, 
the tables themselves may be thread-shared or thread-private.  Like
dynamic code, the declaration {\tt thread\_shared/1} allows sharing of
tables for a predicate evaluated with call-variance to be shared among
threads~\footnote{In \version, tabled predicates using
  call-subsumption are always private; an attempt to make such a
  predicate thread-shared throws an exception.}.
%
To some extent, tabling considerations for making a predicate
thread-shared or thread-private are like those of dynamic code.
Thread-private tables require fewer synchonization points overall.
The situation for reclaiming space for abolished tables is analogous
to reclaiming space for retracted dynamic clauses: the garbage
collector treats abolished tables for thread-private predicates as in
the sequential case, while space for shared tables is not reclaimed
until there is a single active thread.  However the precise semantics
of how tabling information is shared depends on whether the
multi-threaded engine is configured with the default local evaluation
or with batched evaluation.  As discussed in
Chapter~\ref{chap:TablingOverview},xs local evaluation is so-named
because computation always takes place in the SCC most recently
created, and no answer is returned outside of an SCC until the SCC has
been completely evaluated.  Within this scheduling strategy it is not
often useful to share answers between tables that have not been
completed -- as local evaluation would allow these answers to be
returned only if the tables were in the same SCC.  This leads to a
concurrency semantics called {\em Shared Completed Tables}.  Shared
Completed Tables can in fact be supported by a relatively simple
algorithm for optimistic concurrency control.  If goals to two
mutually dependent tables $Table_a$ and $Table_b$ are called
concurrently by two different threads, $Thread_a$ and $Thread_b$,
nothing is done until it is detected that $Table_a$ and $Table_b$ are
both incomplete and are contained in the same SCC of the table
dependency grahp.  At that time, one of the threads (e.g. $Thread_a$)
takes over recomputation of all tables in the SCC, and when the SCC is
completed, any remaining answers are returned to other threads that
had invoked goals in the SCC.  While $Thread_a$ is completing this
computation, $Thread_b$ suspends until the SCC is complete.  Thus the
semantics of Shared Completed Tables supports concurrency for the
well-founded semantics, but only supports the most coarse-grained
parallelism.

Batched evaluation, on the other hand, allows answers to be returned
outside of an SCC before that SCC has been completed.  Concurrency
control for batched evaluation is similar to that for local
evaluation, except in the following case.  Assume as before that
$Table_a$, first called by $Thread_a$, and $Table_b$ first called by
$Thread_b$ are determined to be in the same SCC, and that $Thread_a$
takes over computation of subgoals in the SCC.  Now, $Thread_b$,
rather than suspending, may continue work.  In particular, $Thread_b$
can return any answers in $Table_b$ that it finds whenever it finds
them, regardless of whether they have been produced by $Thread_b$
(before $Thread_a$ took over the SCC) or by $Thread_a$ (afterwards).
We call this type of concurrency semantics, {\em Table Parallelism}.
Table Parallelism can be used to program producer-consumer examples,
as well as to implement Or- and And- parallelism.  Table Parallelism
was first introduced in~\cite{FHSW95}, but the mechanism now used for
implementing Table Parallelism differs significantly from what was
described there.  In \version{} of XSB, the implementation of Table
Parallelism is experimental: in particular, it does not yet support
tabled negation.

As mentioned, for either semantics of shared tables, in \version{},
users of thread-shared tables are responsible for ensuring read
consistency.  Note that, in principle, thread-shared tables may depend
on thread-private tables and vice-versa.  Either type of table may
depend on thread-private or thread-shared dynamic code.  In addition,
a predicate may be {\em both} dynamic and tabled, and its clauses and
tables may be either thread-private or thread-shared.

\section{Error Conditions: Joinable and Detached Threads}

So far we have assumed that the goal called in {\tt
  thread\_create/2} terminates normally --- by success or
failure.  But what if a thread throws an error while executing a goal?
How long should error information for a thread persist, and how can it
be checked?

\index{thread!valid}

Our approach relies on the semantics of Pthreads, which can be either
{\em joinable} or {\em detached}.  Within this framework, we consider
a thread to be {\em valid} if it has not yet terminated, or if it is
joinable and has not yet been joined.  After a joinable Pthread
$T_{dead}$ has terminated, status information about $T_{dead}$
persists until some other thread joins it --- at which time the
information is removed.  On the other hand, if $T_{dead}$ is detached,
status information is removed as soon as $T_{dead}$ terminates.
Reclamation of thread status information may be constrasted to that of
thread-specific data structures such as stacks.  Upon normal or
exceptional termination of $T_{dead}$, any memory automatically
allocated in the process of initializing $T_{dead}$'s, or executing
its goal -- including stacks, private dynamic code, private tables is
reclaimed.  In addition, any mutexes held by $T_{dead}$, are released.
On the other hand, XSB-specific {\em status} information about threads
follows the Pthread model: by default, error information is available
when joining a joinable thread, but not otherwise~\footnote{This
  behavior can, of course, be overridden by embedding goals within
  {\tt catch/3} and handling errors separately, or simply by adding a
  default user error handler: see Chapter~\ref{chap:exception} for
  details.}.

\begin{example}
Suppose the goal 
\begin{verbatim}
 ?- xsb_thread_create(functor(X,Y,Z),F).
\end{verbatim}
%
is executed.  By default, this will produce the result
%
\begin{verbatim}
X = _h113
Y = _h127
Z = _h141
F = 1++Error[XSB/Runtime/P]: [Instantiation]  in arg 2 of predicate functor/3
\end{verbatim}
%
In fact, the variable bindings are output to {\tt STDOUT}, while the
error message
%
\begin{verbatim}
++Error[XSB/Runtime/P]: [Instantiation]  in arg 2 of predicate functor/3
\end{verbatim}
%
is output to {\tt STDERR}, and may be redirected.  The call
%
\begin{verbatim}
?- xsb_thread_join(2,Error).
\end{verbatim}
%
returns
%
\begin{verbatim}
Error = error(instantiation_error, in arg 2 of predicate functor/3,
              [[Forward Continuation...,... standard:call/1,... standard:catch/3],
                Backward Continuation...]) - 0
\end{verbatim}
%
In other words, {\tt Error} is instantiated to a {\tt -/2} structure,
the first argument of which is a standard XSB error term (including
backtrace), and the second argument of which is the exit code of the
thread.
\end{example}
%
Error terms in XSB provide much more information than C exit codes,
but C exit codes may conceivably be useful if XSB is called by one of
the interfaces for C calling XSB~\footnote{The C calling XSB
  interfaces are not yet supported in \version.}.  By default when no
call to {\tt thread\_exit/1} has been made, an XSB thread that
terminates normally will have an exit code of {\tt XSB\_SUCCESS} ({\tt
  0}), a cancelled thread will have an exit code of {\tt 1} and a
thread terminated with any other error will have an exit code of~{\tt
  XSB\_ERROR} ({\tt 2}).

As with p!threads, XSB threads are created as joinable by default, but
can be created as detached using an option in {\tt thread\_create/3}.
Alternatively, a thread created as joinable can be made detached by
{\tt thread\_detach/1}.  Both of these predicates are described in
Section~\ref{sec:mt-threading}.

\section{Thread Cancellation}
%
There may be a number of situations in which it is useful to give one
thread the ability to cancel the execution of another thread.  Within
the semantics of Pthreads, this is called {\em thread cancellation}.
At the C level, thread cancellation can be tricky, as mutexes must be
released, allocated memory freed, and so on.  Accordingly, the
predicate {\tt thread\_cancel/1} cancels XSB threads by acting purely
within the SLG-WAM engine.  When thread $T_1$ interrupts thread $T_2$,
$T_1$ writes to the thread-specific XSB interrupt vector in $T_2$.
Later, when $T_2$ checks its interrupt vector, it throws a
cancellation error, which causes it to clean up its mutexes, memory,
private tables and dynamic code, and then exit.

Any thread can cancel any other thread, with the exception that the
{\em main} thread, which controls the console (or interface to C or
interprolog) cannot be cancelled.  The main thread always has XSB
thread id {\tt 0} in both the single-threaded and multi-threaded
systems.

\section{Performance and other Considerations}
%
For running programs that do not use multiple threads, the
multi-threaded engine has a minimal overhead compared to the
single-threaded engine.  Times for single-threaded execution of Prolog
or tabled programs range from about 10-20\% slower to 10-20\% {\em
  faster} for the multi-threaded engine compared to the
single-threaded engine.  Speedups for running multiple threads on
multiple processors depends heavily on the applications run and on the
underlying operating system.

The size of a given thread may be a consideration for multi-threaded
applications.  Each thread has an area of thread-private variables
that are ``global'' to its own virtual machine.  This area, called the
{\em thread context}, which accounts for about 4 Kbytes of space.
Much larger are the various stacks used by the threads for tabled and
Prolog execution.  Almost all of XSB's stacks are fully expandable,
and the initial size of several of these stacks may be set explicitly
as options in {\tt thread\_create/3}.  Explicitly setting a default
thread stack size for an XSB thread to be smaller than the default
process stack size may be useful for applications that have a large
number of concurrently running threads.

Other performance considerations involve the contention by threads for
shared resources.  As discussed above, contention may arise when
creating or abolishing tables, or when asserting or retracting dynamic
code --- however in either case thread-private predicates give rise to
less contention than thread-shared predicates.  In terms of I/O, each
XSB stream up to the maximum number of file descriptors has its own
mutex; as a result threads writing to different streams will not
contend for I/O.  Thus, in multi-threaded applications, it may be more
efficient to open and close streams and access these streams
explicitly, than to redirect standard input or standard output through
{\tt see/1} and {\tt tell/1}.

\section{Configuring the Multi-threaded Engine under Windows} \label{sec:mt-windows}

Libraries for Pthreads are included on most versions of Unix and
Linux.  Windows also supports multi-threading, but with a somewhat
different semantics and API than that of Pthreads.  To run
multi-threaded XSB under Windows, a library must be included to
translate the Pthread library, used by XSB, to the native thread API
of Windows.

Different libraries are available for this purpose.  Internally, the
multi-threaded engine has been tested using the Win32 Pthreads
interface, available via {\tt http://sourceware.org/pthreads-win32},
but other libraries may also work, including Pthread library included
with Cygwin.  To install the sourceware library, let {\tt \$XSBENV} be
the parent directory of {\tt \$XSBDIR} the root directory of XSB --
i.e. {\tt \$XSBENV} is the directory into which XSB is installed.

\begin{itemize}
\item Download a version such as pthreads-2005-01-25.exe or later, and
  extract it into {\tt \$XSBENV}\\pthreads.  Add
  \verb|$XSBENV\pthreads\Pre-built\lib| to your system path

\item To configure with windows enter the commands: 
\begin{verbatim}
sh configure --enable-mt --with-wind \
--site-includes='c:\XSBSYS\XSBENV\pthreads\Pre-built\include \
--site-static-libraries='c:\XSBSYS\XSBENV\pthreads\Pre-built\lib

makexsb_wind
\end{verbatim}
Note that the Unix {\tt sh} shell must be available in order to
reconfigure.

\item To configure with cygwin enter the commands:
\begin{verbatim}
sh configure --enable-mt \
  --site-includes='/cygdrive/c/XSBSYS/XSBENV/pthreads/Pre-built/include' \
  --site-static-libraries='/cygdrive/c/XSBSYS/XSBENV/pthreads/Pre-built/lib'

sh makexsb --config-tag=mt
\end{verbatim}

\end{itemize}

\section{Predicates for Multi-Threading} \label{sec:mt-threading}

\begin{description}

\ournewitem{thread\_create(+Goal,ThreadId,,+OptionsList)}{thread}
\index{\texttt{thread\_create/3}}
%
When called from thread $T$, this predicate creates a new XSB thread
$T_{new}$ to execute {\tt Goal}.  When goal either succeeds, throws an
unhandled error, or fails, $T_{new}$ exits, but {\tt thread\_create/2}
will succeed immediately, binding {\tt ThreadId} to the XSB thread id
of $T_{new}$.  {\tt Goal} must be callable, but need not be fully
instantiated.  No bindings from {\tt Goal} are passed back from $T$ to
$T_{new}$, so communication between $T_{new}$ and $T$ must be through
tables, asserted code, message queues or other side effects.

{\tt OptionList} allows optional parameters in the configuration for
the initial size of XSB stacks, for aliases, and to indicate whether
$T_{new}$ is to be created as detached.  Note that XSB threads allow
automatic stack allocation, so that the size options may be most
useful for (32-bit) applications with very large numbers of threads.
In this case, setting initial stack sizes to be small may allow more
threads to be created on a given hardware platform.  Also note that
only XSB stacks are affected, the stack size of the underlying Pthread
remains unaltered.
%
\bi
\item {\tt glsize(N)}: create thread with global (heap) plus local
  stack size initially set to {\tt N} kbytes.  If not specified, the
  default size is used (cf. Section~\ref{sec:EmuOptions}).
%
\item {\tt tcsize(N)}: create thread with trail plus choice point 
  stack size initially set to {\tt N} kbytes.  If not specified, the
  default size is used (cf. Section~\ref{sec:EmuOptions}).
%
\item {\tt complsize(N)}: create thread with completion
  stack size initially set to {\tt N} kbytes. If not specified, the
  default size is used (cf. Section~\ref{sec:EmuOptions}).
%
\item {\tt pdlsize(N)}: create thread with {\tt N} kbytes of
  unification stack.  If not specified, the
  default size is used (cf. Section~\ref{sec:EmuOptions}).
%
\item {\tt detached(Boolean)}: if {\tt Boolean} is true, creates
  detached thread.  If {\tt Boolean} is false or the option is not
  specified, the thread created will be joinable.  
%
\item {\tt alias(Alias)}: Allow thread {\tt ThreadId} to be referred
  to via {\tt Alias} in all standard thread predicates.  {\tt Alias}
  remains active for {\tt ThreadId} until it is joined.  \ei

{\bf Error Cases}
\bi
\item 	{\tt Goal} is a variable
\bi
\item 	{\tt instantiation\_error}.
\ei
\item 	{\tt Goal} is not callable
\bi
\item 	{\tt type\_error(callable,Goal)}.
\ei
\item 	{\tt ThreadId} is not a variable
\bi
\item 	{\tt type\_error(variable,ThreadId)}
\ei
\item 	{\tt OptionList} is a partial list or contains an option that is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
\item 	{\tt OptionList} is neither a list nor a partial list
\bi
\item 	{\tt type\_error(list,OptionsList)}
\ei
\item 	{\tt OptionList} contains an option, {\tt Option} not described above
\bi
\item 	{\tt domain\_error(thread\_option,Option)}
\ei
\item An element of {\tt OptionsList} is alias(A) and A is already
  associated with an existing thread, queue or stream 
\bi
\item {\tt permission\_error(create,alias, A)}
\ei
\item An element of {\tt OptionsList} is alias(A) and A is not an atom
\bi
\item {\tt type\_error(atom,A)}
\ei
\item   No more system threads are available (EAGAIN)
\bi
\item {\tt resource\_error(system threads)}
\ei
\ei

\ournewitem{thread\_create(+Goal,-ThreadId)}{thread}
\index{\texttt{thread\_create/2}}
%
Acts as {\tt thread\_create(Goal,ThreadId,[])}.

\ournewitem{thread\_join(+ThreadIds,-ExitDesignators)}{thread}
\index{\texttt{thread\_join/2}} 
% 
When {\tt thread\_join/2} is called by thread $T$, {\tt
  ThreadIds} must be instantiated to either an XSB thread id, or a
list of XSB thread ids; in either case, {\tt ExitDesignators} must be
uninstantiated.  The action of the predicate is to suspend $T$ until
all of the threads denoted by {\tt ThreadIds} have exited.  At this
time, any remaining resources for the threads in {\tt ThreadIds} is
reclaimed, and {\tt ExitCode} is either an element of the form:
\begin{center}
{\tt ExitBall -  ExitCode} 
\end{center}
%
or a list of such elements.  For each XSB thread id $T_1$ in
{ThreadIds}, {\tt ExitBall} is either
\begin{itemize}
%
\item {\tt no\_error\_ball} if $T_1$ exited normally (through success or
  failure), without throwing an error or being cancelled.
%
\item An error ball if $T_1$ threw an error that was not explicitly
  handled by a catch or user error handler.
%
\item A special error ball of the form {\tt
  error(thead\_cancel,$T_1$,Backtrace)} if $T_1$ was cancelled by some
  other thread.  In this case, {\tt Backtrace} is an empty backtrace,
  added for conformability with other error forms.
\end{itemize}
%
ExitCode is either {\tt 0} for normal termination, or the value
specified by an explicit call to {\tt thread\_exit/1}.

{\bf Error Cases}
\bi
\item 	{\tt ThreadIds} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt ThreadIds} is not a list of XSB thread ids
\bi
\item 	{\tt domain\_error(listof\_threadids,ThreadIds)}
\ei
%
\item 	{\tt ExitCodes} is not a variable
\bi
\item 	{\tt type\_error(variable,ExitCodes)}
\ei
%
\item   {\tt ThreadId} does not correspond to a valid thread
\bi
\item   {\tt existence\_error(valid\_thread,ThreadId)}
\ei
\item   {\tt ThreadId} does not correspond to a joinable thread
  (i.e. {\tt ThreadId} is detached).
\bi
\item   {\tt permission\_error(join,non\_joinable\_thread,ThreadId)}
\ei
\ei

\comment{
a) Thread is a variable  instantiation_error
}

\ournewitem{thread\_exit(+ExitCode)}{thread}
\index{\texttt{thread\_exit/1}} 
%
Exits a thread $T$ with {\tt ExitCode} after releasing any mutexes
held by $T$, freeing any thread-specific memory allocated for $T$ (we
hope).  {\tt ExitCode} will be used if the caller of $T$ joins to $T$,
but will be ignored in other cases.  There is no need to call this
routine on normal termination of a thread as it is called implicitly
on success or (final) failure of a thread's goal.

{\bf Error Cases}
\bi
\item 	{\tt ExitCode} is not an integer
\bi
\item 	{\tt type\_error(integer,ExitCode)}
\ei
\ei

\ournewitem{thread\_self(-ThreadId)}{thread}
\index{\texttt{thread\_self/1}} 
%
Returns the XSB thread id of the calling thread.

{\bf Error Cases}
\bi
\item 	{\tt ThreadId} is not a variable
\bi
\item 	{\tt type\_error(variable,ThreadId)}
\ei
\ei

\ournewitem{thread\_detach(+ThreadId)}{thread}
\index{\texttt{thread\_detach/1}} 
%
Detaches a joinable thread denoted by {\tt ThreadId} so that all
resources will be reclaimed upon its exit.  The thread denoted by {\tt
  ThreadId} will no longer be joinable, once it is detached.

Note, if it is known at thread creation time that a thread should be
detached, it is better to create the thread as detached via {\tt
  thread\_create/3}.

{\bf Error Cases}
\bi
\item 	{\tt ThreadId} is not an integer
\bi
\item 	{\tt type\_error(integer,ExitCode)}
\ei
\item   {\tt ThreadId} does not correspond to a valid thread
\bi
\item   {\tt existence\_error(valid\_thread,ThreadId)}
\ei
\item 	{\tt ThreadId} is active but not joinable
\bi
\item 	{\tt permission\_error(thread\_detach,non\_joinable\_thread,ThreadId)}
\ei
\ei

\ournewitem{thread\_cancel(+ThreadId)}{thread}
\index{\texttt{thread\_cancel/1}} 
%
Cancels the XSB thread denoted by {\tt ThreadId}.  The cancellation
does not use Pthread cancellation mechanisms, rather it uses XSB's
interrupt mechanism to set {\tt ThreadId}'s interrupt vector.  When
this interrupt vector is checked, {\tt ThreadId} will throw a thread
cancellation error, which can be caught within {\tt ThreadId} like any
other error.  Usually, this means that {\tt ThreadId} will abort and
exit.  Note that the high-level upon which thread cancellation is
implemented allows for simplicity and portability of thread
cancellation.  \footnote{While interrupt vector is not checked upon
  every SLG-WAM instruction, it is checked on every {\sf call} and
  {\sf execute} instruction, and should should be suitable for almost
  any need for cancellation.}.

The main XSB thread cannot be cancelled; apart from that any thread
can cancel any other thread.

{\bf Error Cases}
\bi
\item 	{\tt ThreadId} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item   {\tt ThreadId} does not correspond to valid thread
\bi
\item   {\tt existence\_error(valid\_thread,ThreadId)}
\ei
\item   {\tt ThreadId} denotes the main thread.
\bi
\item   {\tt permission\_error(cancel,main\_thread,ThreadId)}
\ei
\ei

\ournewitem{thread\_yield}{thread}
\index{\texttt{thread\_yield/0}} 
% 
Make the calling thread ready to be run {\em after} other threads of
the same priority.  This predicate relies on the real-time extensions
to Pthreads specified in Posix 1b, and may not be available on all
platforms.

{\bf Error Cases}
\bi
\item 	The current platform does not support Posix real-time extensions
\bi
\item 	{\tt misc\_error}
\ei
\ei
\end{description}

\subsection{Predicates for Thread Synchronization and Communication} 
\label{sec:synchronization}

While the XSB engine itself is thread-safe, thread synchronization may
be needed when calling a package that is not itself thread safe (see
the beginning of this chapter for a list of which packages are and are
not thread-safe).  Synchronization may also be needed to protect data
accessed by foreign function calls, or to coordinate responses to
external events.

\subsubsection{User-defined Mutexes}~\label{sec:mutexes}
%
One of the simplest and most powerful primitives for thread
synchronization are mutexes.  The mutexes provided by the following
primitives are {\em recursive}: if a thread $T$ locks a recursive
mutex $M$, any calls to {\tt mutex\_lock(M)} made by $T$ will
immediately succeed without suspending while $M$ is locked.  Other
threads that attempt to lock $M$ will suspend until $M$ is unlocked.
To unlock $M$ after $n$ calls to {\tt mutex\_lock(M)}, $T$ must make
$n$ calls to {\tt mutex\_unlock(M)}.

When using mutexes in XSB, programmers must not only avoid explicitly
creating deadlocks, but must also ensure that a mutex is unlocked when
leaving a critical area, and destroyed when it is no longer needed.
Making sure that this happens for successful goals, for failed goals
and for goals that raise exceptions can sometimes be complicated.  The
predicate {\tt with\_mutex/2} handles all of these cases.  We
recommend using it if possible, and making use of lower-level calls to
{\tt mutex\_lock/1}, {\tt mutex\_unlock/1} and {\tt mutex\_trylock/1}
only when {\tt with\_mutex/2} is not applicable.

\begin{description}
\ournewitem{with\_mutex(+Mutex,?Goal)}{mutex}
\index{\texttt{with\_mutex/2}} 
%
Locks a current mutex {\tt Mutex}, executes {\tt Goal}
deterministically, then unlocks {\tt Mutex}.  If {\tt Goal} leaves
choice-points, these are destroyed.  {\tt Mutex} is unlocked
regardless of whether {\tt Goal} succeeds, fails or raises an
exception. Any exception thrown by {\tt Goal} is re-thrown after the
mutex has been successfully unlocked.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is not an atom
\bi
\item 	{\tt type\_error(atom,Mutex)}
\ei
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item 	{\tt Mutex} is locked
\bi
\item 	{\tt permission\_error(mutex,destroy,Mutex)}
\ei
\ei

\ournewitem{mutex\_create(?Mutex)}{mutex}
\index{\texttt{mutex\_create/1}} 
%
Creates a user mutex, {\tt Mutex}.  If {\tt Mutex} is instantiated to
an atom upon call, the mutex will have that name; if {\tt Mutex} is
not instantiated at call, a system-generated atom {\tt mutex}$n$
($N>0$) will be returned.  The mutex itself will be recursive.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is not a variable or an atom
\bi
\item 	{\tt domain\_error(variable\_or\_atom,Mutex)}
\ei
\item 	{\tt Mutex} is already associated with a mutex.
\bi
\item 	{\tt permission\_error(create,mutex,Mutex)}
\ei
\ei

\ournewitem{mutex\_destroy(+Mutex)}{mutex}
\index{\texttt{mutex\_destroy/1}} 
%
Destroys a current unlocked mutex {\tt Mutex} along with any memory it
uses.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is not an atom
\bi
\item 	{\tt type\_error(atom,Mutex)}
\ei
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item 	{\tt Mutex} is locked
\bi
\item 	{\tt permission\_error(mutex,destroy,Mutex)}
\ei
\ei

\ournewitem{mutex\_lock(+Mutex)}{mutex}
\index{\texttt{mutex\_lock/1}} 
%
{\tt mutex\_lock(Mutex)} locks a (recursive) mutex. Locking and
unlocking mutexes should be paired carefully in order to avoid
deadlocks. In particular, a programmer needs to ensure that mutexes
are properly unlocked even if the protected code fails or raises an
exception.
%For most common cases, the built-in predicate with mutex/2 (3.4.3)
%provides a safer way for using mutexes.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is not an atom
\bi
\item 	{\tt type\_error(atom,Mutex)}
\ei
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\ei

\ournewitem{mutex\_trylock(+Mutex)}{mutex}
\index{\texttt{mutex\_trylock/1}} 
%
Works as {\tt mutex\_lock/1} but fails immediately if {\tt Mutex} is
held by another thread rather than suspending the calling thread.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is not an atom
\bi
\item 	{\tt type\_error(atom,Mutex)}
\ei
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\ei

\ournewitem{mutex\_unlock(+Mutex)}{mutex}
\index{\texttt{mutex\_unlock/1}} 
%
Unlocks {\tt Mutex} when called by the same thread that locked the mutex.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is not an atom
\bi
\item 	{\tt type\_error(atom,Mutex)}
\ei
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item 	{\tt Mutex} is not held by the calling thread
\bi
\item 	{\tt permission\_error(unlock,mutex,Mutex)}
\ei
\ei

\ournewitem{mutex\_unlock\_all}{mutex}
\index{\texttt{mutex\_unlock\_all/0}} 
%
{\tt mutex\_unlock\_all/0} unlocks all user mutexes owned by the
current thread.  It has no error cases.

\ournewitem{mutex\_property(?Mutex,?Property)}{mutex}
\index{\texttt{mutex\_property/2}} 
%
If {\tt Mutex} is instantiated, unifies {\tt Property} with current
properties of the mutex; if {\tt Mutex} is a variable, backtracks
through all the current mutexes whose properties unify with {\tt
  Property}.  If the mutex is locked, {\tt Property} will be a term of
the form {\tt locked(ThreadId,NumLocks)} where {\tt ThreadId} is a
thread id, and {\tt NumLocks} is the number of times the mutex has
been locked.  If the mutex is unlocked, {\tt Property} will be a term
of the form {\tt unlocked(NumLocks)} where {\tt NumLocks} is the
number of times the mutex has been locked.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is not an atom
\bi
\item 	{\tt type\_error(atom,Mutex)}
\ei
\ei

\end{description}

%--------------------------------------------------------------------
\comment{
mutex_statistics not yet implemented.
}
%--------------------------------------------------------------------

\subsubsection{Prolog Message Queues}~\label{sec:mutexes}
While Prolog predicates can communicate through shared dynamic code
and tables, message queues provide a useful mechanism for one thread
to pass a command to another or to synchronize on the return of data.
A Prolog message queue can be defined to have a speficied or default
$size$ and can have any number of consumerss and any number of
producers.  When a producer writes a $Term$ into a queue, the term is
copied into the queue so that no binding are shared between $Term$ and
the producer's stacks.  $Term$ may include structures or lists and
need not be bound, and any variable bindings within $Term$ are
preserved.  If the queue already contains $size$ elements, the
producer will suspend until one or more elements are removed from the
queue.  When a consumer $T_{cons}$ accesses the queue it provides a
goal $G$ and traverses the queue until it finds a term in the queue
that unifies with $G$.  If $T_{cons}$ finds a term in the queue that
unifies with $G$, it removes it from the queue and continues in its
computation.  If there is no term in the queue that unifies with $G$,
$T_{cons}$ will suspend until at least one other term is added to the
queue.  When it awakens it will retraverse the queue from the
beginning to find a term that unifies with $G$~\footnote{Note that
  this traversal is necessary since the position of $T_{cons}$ may in
  the queue may not be valid due to the addition and deletion of terms
  by other threads.}.  Because of the behavior of message queues, it
is usually good programming practice to ensure that terms written into
the queue will unify with the goals of consumers.  This can usually be
done by abstracting a consumers goal (say to a variable, {\tt X}) or
by splitting one ``multiplexed'' queue into two separate queues.

\begin{description}

\ournewitem{message\_queue\_create(-Queue,+Options)}{mutex}
\index{\texttt{message\_queue\_create/2}} 
%
Creates a new message queue with identifier {\tt Queue}.  If {\tt
  Options} contains the term {\tt size(S)} the queue will have {\tt S}
elements, otherwise it will have a default number of elements.  The
default number of elements can be obtained via the query

{\tt ?- xsb\_configuration(default\_message\_queue\_size,X)}

{\bf Error Cases}
\bi
\item 	Queue is not a variable
\bi
\item 	{\tt type\_error(variable,Queue)}
\ei
\item Options is a partial list or a list with an element that is a
  variable 
\bi
\item  instantiation error
\ei
\item Options is neither a partial list or a list
\bi
\item  type error(list, Options)
\ei
\ei

\ournewitem{thread\_send\_message(+Queue,\#Message)}{mutex}
\index{\texttt{thread\_send\_message/2}} 
%
If there are fewer than elements on {\tt Queue} than its maximum size,
{\tt thread\_send\_message/} puts {\tt Message} onto {\tt Queue}, and
  returns immediately.  Otherwise, it suspends until there are fewer
  elements on {\tt Queue} than its maximum size when it will be
  awakened to put {\tt Message} onto queue.

{\bf Error Cases}
\bi
\item Queue is a variable
\bi
\item instantiation error
\ei
\ei

\ournewitem{thread\_get\_message(+Queue,?Message)}{mutex}
\index{\texttt{thread\_get\_message/2}} 

If there are elements on {\tt Queue} {\tt thread\_get\_message/}
traverses the queue to obtain the first element of {\tt Queue} that
unifies with {\tt Message}.  If it does, it returns with {\tt Message}
bound to the most general unifier.  If there are no elements on {\tt
  Queue} or if no elements unify with {\tt Message}, the thread
suspends until elements are added to {\tt Queue}.  When it awakes, it
will restart, rechecking {\tt Queue} from its beginning for a term that unifies
with {\tt Message}.

{\bf Error Cases}
\bi
\item Queue is a variable
\bi
\item instantiation error
\ei
\ei


\end{description}



