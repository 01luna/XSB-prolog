\chapter{Multi-Threaded Programming in XSB} \label{chap:threads}

Starting with Version 3.0, XSB supports the use of Posix threads to
perform separable computations, and in certain cases to parallelize
them.  Posix threads have a simple and clear API, and are available on
all Unixes and, by using open-source libraries, on Windows as well
(see Section~\ref{sec:mt-windows} to configure under Windows).  This
chapter introduces how to program with threads in XSB through a series
of examples.  Later sections discuss performance aspects of our
implementation as well as describing relevant predicates.  A general
knowledge of multi-threaded programming is assumed, such as can be
found in \cite{LewB98,Bute97}.

\section{Getting Started with Multi-Threading}
%
In \version{} the default configuration of XSB does not include
multi-threading.  This is partly because multi-threading is new, and
despite our efforts, the multi-threaded engine may contain bugs not
present in the single-threaded engine.  However the main reason is
because in \version , not all libraries and packages have yet been
made thread-safe so that not all configurations are supported with
multi-threading.  Both the XSB-calling-C and the C-calling-XSB
interfaces are supported in the multi-threaded engine.  All XSB
libraries have been ported to the multi-threaded engine {\em except}
the profiling library and the {\tt string} library (which is not yet
thread-safe).  The packages {\tt ODBC} and {\tt CHR}, {\tt FLORA-2},
and {\tt regmatch} are supported by the multi-threaded engine, but the
packages {\tt dbdrivers}, {\tt xpath}, {\tt interprolog}, {\tt
  smodels}, {\tt perlmatch}, {\tt libwww} and {\tt posix} are not
(yet).  We note, however that all basic/ISO Prolog functionality is
thread-safe (at least, as far as we know :-).

With this in mind, making the multi-threaded engine is simple:
configure and make XSB as in Chapter~\ref{chap:system}, but include
the command {\tt --enable-mt}.  When you invoke the newly made
configuration of XSB you should see {\tt engine: multi-threading} in
the configuration list below the banner rather than {\tt engine:
  slg-wam} as in the sequential engine.

\paragraph{Hello World for Beginners}
%
We naturally start with a program to print ``hello world''.  Within
the multi-threaded engine, import {\tt thread\_create/2} from the
module {\tt thread}, and type the command
\begin{center} 
{\tt ?- thread\_create(writeln('hello world'),Id)} 
\end{center} 
you should see something like 
\begin{center} 
{\tt Id = 1hello world} 
\end{center} 
%
while the output is a little ugly, the ``hello world'' program does
illustrate simple multi-threading at work.  The calling thread
(i.e. the thread controlling the command-line interpreter which we
call $T_{prompt}$) executes the predicate {\tt thread\_create/2} which
creates a thread $T_{child}$ and immediately returns with the {\em XSB
  thread id} of the created thread.  Meanwhile, $T_{child}$
initializes its stacks and other memory areas and executes the goal
{\tt writeln('hello world')}.  $T_{child}$ and $T_{prompt}$ share most
of their process-level information: in particular they share a common
I/O stream for standard output, leading to the output above.  What is
happening may be seen a little more easily by executing the command
%
\begin{center} 
{\tt ?- thread\_create((sleep(1),writeln('hello world')),Id)} 
\end{center} 
%
In this case the interpreter reports that {\tt F} is bound to a thread
id, then about a second later {\tt writeln/1} is executed.  

The simple ``hello world'' program illustrates a couple of points.
First, it is easy to create a thread in XSB and have that thread do
work.  Second, it can be tricky to coordinate actions among threads.
We'll explore these two themes in more detail, but first suppose we
are determined to extend out multi-threaded program so that it
produces good output.  One way to do this is to {\em join}
$T_{prompt}$ and $T_{child}$ as follows 
%
\begin{verbatim}
?- xsb_thread_create(writeln('hello world'),Id),
   xsb_thread_join(Id,ExitCode).
hello world

Id = 1
ExitCode = true
\end{verbatim}
%
In this case, as soon as $T_{prompt}$ has issued a command to create
$T_{child}$, it executes {\tt thread\_join/2}.  This latter predicate
makes a system call to the underlying operating system to suspend
$T_{prompt}$ until $T_{child}$ has exited.  {\tt thread\_join/2}
returns a status term indicating whether the goal to thread {\tt Id}
succeeded, failed, exited with an error term, or was cancelled (in
this case it succeeded).

So far, we've introduced a few concepts that have not been fully
discussed.  First is the concept of an {\em XSB thread id}: XSB
manages up to $M$ active threads using XSB thread ids.  The default
for $M$ in \version{} is 1024, but $M$ can be reset via a command line
option to XSB (cf. Section~\ref{sec:EmuOptions}), and can be obtained
at run time via the XSB flag {\tt max\_threads}
(cf. Section~\ref{State}).  It should be noted that the XSB thread id
of a thread is different from the identifier of the underlying
Pthread.  An XSB thread id is a Prolog term, and unlike Posix thread
ids, XSB thread ids can be compared for equality using unification.
The actual form of an XSB thread id, however, is subject to change
between versions, so programs should not make use of the exact form of
an XSB thread id.  In the multi-threaded engine, the XSB thread id of
any thread can be queried using the predicate {\tt thread\_self/1}.

\section{Communication among Threads}

\begin{example}
Consider the program fragment
%
\begin{verbatim}
:- dynamic p/1.

test:- xsb_thread_create(assert(p(1)),_X).
\end{verbatim}
If you type the goal {\tt ?- test} and then the goal {\tt ?- p(X)},
the call {\tt p(X)} will fail.  
\end{example}

\noindent
This illustrates an important point about dynamic and tabled
predicates in the multi-threaded engine: by default clauses for a
dynamic predicate {\tt p/n} are private to the thread that asserts
them; and by default tables created in an evaluation of a goal for
{\tt p/n} are private to the thread that evaluates the goal.  This
behavior contrasts to that of static code which is always shared
between threads.  In the example above, to allow {\tt p(1)} to be
visible to various threads, {\tt p/1} must be declared to be shared
with the following declaration.
%
\begin{verbatim}
:- thread_shared(p(_)).
\end{verbatim}

The ability to share dynamic code between predicates provides an
extremely powerful mechanism for threads to communicate.  So why does
XSB make dynamic predicates thread-private by default?  The main
reason for this is that if dozens or hundreds of threads are running
concurrently, shared dynamic code becomes an expensive synchronization
point.  Code for shared predicates must be more heavily mutexed than
code for private predicates.  In the case of dynamic code, XSB does
not always immediately reclaim the space of retracted clause, to avoid
the possibility of some computation backtracking into a clause that
has been reclaimed.  Rather, (like most Prologs), XSB may garbage
collect the space of the retracted clauses at a later time.  While
clause garbage collection is simple enough to implement for a single
thread, garbage collecting clauses for shared dynamic predicates is
difficult to do when multiple threads are active.  Accordingly, in
\version , space for shared dynamic clauses is not reclaimed until
there is a single active thread.  However for {\em thread-private}
dynamic predicates, there is no problem in reclaiming space when
multiple threads are active: from the engine's perspective garbage
collection is no different than in the sequential case.  Thus one set
of reasons for making dynamic predicates private by default are based
on efficiency~\footnote{Future versions may offer more powerful
  garbage collectors for shared predicates.}.

The second reason for making dynamic predicates thread-private by
default is semantic.  Suppose thread $T_1$ starts a tabled computation
that depends on the dynamic shared predicate {\tt p/1}.  While $T_1$
is computing the table, thread $T_2$ asserts a clause to {\tt p/1}.
$T_1$'s table is likely to be inconsistent, leading to the problem of
{\em read consistency} of any table that depends on thread-shared
dynamic predicates.  In \version , users are responsible for ensuring
read consistency of any tables that depend on shared dynamic data.
Future versions of XSB are intended to allow more sophisticated
mechanisms for read consistency.

Not only can tables depend on thread-shared or thread-private dynamic
data, but 
%in the default multi-threaded configuration of XSB, which
%uses local scheduling for tabled evaluation, 
the tables themselves may be thread-shared or thread-private.  Like
dynamic code, the declaration {\tt thread\_shared/1} allows sharing of
tables for a predicate evaluated with call-variance to be shared among
threads~\footnote{In \version, tabled predicates using
  call-subsumption are always private; an attempt to make such a
  predicate thread-shared throws an exception.}.
%
To some extent, tabling considerations for making a predicate
thread-shared or thread-private are like those of dynamic code.
Thread-private tables require fewer synchonization points overall.
The situation for reclaiming space for abolished tables is analogous
to reclaiming space for retracted dynamic clauses: the garbage
collector treats abolished tables for thread-private predicates as in
the sequential case, while space for shared tables is not reclaimed
until there is a single active thread.  However the precise semantics
of how tabling information is shared depends on whether the
multi-threaded engine is configured with the default local evaluation
or with batched evaluation.  As discussed in
Chapter~\ref{chap:TablingOverview},xs local evaluation is so-named
because computation always takes place in the SCC most recently
created, and no answer is returned outside of an SCC until the SCC has
been completely evaluated.  Within this scheduling strategy it is not
often useful to share answers between tables that have not been
completed -- as local evaluation would allow these answers to be
returned only if the tables were in the same SCC.  This leads to a
concurrency semantics called {\em Shared Completed Tables}.  Shared
Completed Tables can in fact be supported by a relatively simple
algorithm for optimistic concurrency control.  If goals to two
mutually dependent tables $Table_a$ and $Table_b$ are called
concurrently by two different threads, $Thread_a$ and $Thread_b$,
nothing is done until it is detected that $Table_a$ and $Table_b$ are
both incomplete and are contained in the same SCC of the table
dependency grahp.  At that time, one of the threads (e.g. $Thread_a$)
takes over recomputation of all tables in the SCC, and when the SCC is
completed, any remaining answers are returned to other threads that
had invoked goals in the SCC.  While $Thread_a$ is completing this
computation, $Thread_b$ suspends until the SCC is complete.  Thus the
semantics of Shared Completed Tables supports concurrency for the
well-founded semantics, but only supports the most coarse-grained
parallelism.

Batched evaluation, on the other hand, allows answers to be returned
outside of an SCC before that SCC has been completed.  Concurrency
control for batched evaluation is similar to that for local
evaluation, except in the following case.  Assume as before that
$Table_a$, first called by $Thread_a$, and $Table_b$ first called by
$Thread_b$ are determined to be in the same SCC, and that $Thread_a$
takes over computation of subgoals in the SCC.  Now, $Thread_b$,
rather than suspending, may continue work.  In particular, $Thread_b$
can return any answers in $Table_b$ that it finds whenever it finds
them, regardless of whether they have been produced by $Thread_b$
(before $Thread_a$ took over the SCC) or by $Thread_a$ (afterwards).
We call this type of concurrency semantics, {\em Table Parallelism}.
Table Parallelism can be used to program producer-consumer examples,
as well as to implement Or- and And- parallelism.  Table Parallelism
was first introduced in~\cite{FHSW95}, but the mechanism now used for
implementing Table Parallelism differs significantly from what was
described there.  In \version{} of XSB, the implementation of Table
Parallelism is experimental: in particular, it does not yet support
tabled negation.

As mentioned, for either semantics of shared tables, in \version{},
users of thread-shared tables are responsible for ensuring read
consistency.  Note that, in principle, thread-shared tables may depend
on thread-private tables and vice-versa.  Either type of table may
depend on thread-private or thread-shared dynamic code.  In addition,
a predicate may be {\em both} dynamic and tabled, and its clauses and
tables may be either thread-private or thread-shared.

\section{Thread Statuses: Joinable and Detached Threads}

So far we have assumed that the goal called in {\tt
  thread\_create/2} terminates normally --- by success or
failure.  But what if a thread throws an error while executing a goal?
How long should error information for a thread persist, and how can it
be checked?

\index{thread!valid}

Our approach relies on the semantics of Pthreads, which can be either
{\em joinable} or {\em detached}.  Within this framework, we consider
a thread to be {\em valid} if it has not yet terminated, or if it is
joinable and has not yet been joined.  After a joinable Pthread
$T_{dead}$ has terminated, status information about $T_{dead}$
persists until some other thread joins it --- at which time the
information is removed.  On the other hand, if $T_{dead}$ is detached,
status information is removed as soon as $T_{dead}$ terminates.
Reclamation of thread status information may be constrasted to that of
thread-specific data structures such as stacks.  Upon normal or
exceptional termination of $T_{dead}$, any memory automatically
allocated in the process of initializing $T_{dead}$'s, or executing
its goal -- including stacks, private dynamic code, private tables is
reclaimed.  In addition, any mutexes held by $T_{dead}$, are released.
On the other hand, XSB-specific {\em status} information about threads
follows the Pthread model: by default, error information is available
when joining a joinable thread, but not otherwise~\footnote{This
  behavior can, of course, be overridden by embedding goals within
  {\tt catch/3} and handling errors separately, or simply by adding a
  default user error handler: see Chapter~\ref{chap:exception} for
  details.}.

\begin{example}
Suppose the goal 
\begin{verbatim}
 ?- xsb_thread_create(functor(X,Y,Z),F).
\end{verbatim}
%
is executed.  By default, this will produce the result
%
\begin{verbatim}
X = _h113
Y = _h127
Z = _h141
F = 1++Error[XSB/Runtime/P]: [Instantiation]  in arg 2 of predicate functor/3
\end{verbatim}
%
In fact, the variable bindings are output to {\tt STDOUT}, while the
error message
%
\begin{verbatim}
++Error[XSB/Runtime/P]: [Instantiation]  in arg 2 of predicate functor/3
\end{verbatim}
%
is output to {\tt STDERR}, and may be redirected.  The call
%
\begin{verbatim}
?- xsb_thread_join(2,Error).
\end{verbatim}
%
returns
%
\begin{verbatim}

Error = exception(error(instantiation_error, in arg 2 of predicate functor/3,
              [[Forward Continuation...,... standard:call/1,... standard:catch/3],
                Backward Continuation...]))
\end{verbatim}
%
In other words, {\tt Error} is instantiated to a {\tt exception/1}
structure, containing a standard XSB error term (including backtrace).
\end{example}
%
The error term in the above example is one example of a {\em thread
  status} term.  In XSB, these thread statuses are as follows.
\index{thread!thread status}
\label{page:thread-status} 
%
\bi
\item {\tt running} The thread is still executing
%
\item {\tt true} The thread has exited and successfully evaluated its goal.
%
\item {\tt false} The thread has exited and failed its goal.
%
\item {\tt exception(Exception)} The thread has been terminated due to
  an uncaught exception, represented by the term {\tt Exception} which
  is a standard XSB error term.
%
\item {\tt cancelled(Exception)} The thread has been terminated due to
  a thread cancellation, represented by the term {\tt Exception} which
  is a standard XSB error term.
%
\item {\tt exited(ExitTerm)} The thread has been terminated using the
  predicate {\tt thread exit/1} with {\tt ExitTerm} as its argument.
\ei 
%
Any of these statuses except {\tt running} may be returned by {\tt
  thread\_join/2}.  In Prolog, the statuses of exited threads `
provide much more information than C exit codes.  

\comment{but C exit codes may conceivably be useful if XSB is called by one
of the interfaces for C calling XSB~\footnote{The C calling XSB
  interfaces are not yet supported in \version.}.  By default when no
call to {\tt thread\_exit/1} has been made, an XSB thread that
terminates normally will have an exit code of {\tt XSB\_SUCCESS} ({\tt
  0}), a cancelled thread will have an exit code of {\tt 1} and a
thread terminated with any other error will have an exit code of~{\tt
  XSB\_ERROR} ({\tt 2}).
}
%
As with pthreads, XSB threads are created as joinable by default, but
can be created as detached using an option in {\tt thread\_create/3}.
Alternatively, a thread created as joinable can be made detached by
{\tt thread\_detach/1}.  All of the predicates mentioned in this
section are fully described in Section~\ref{sec:mt-threading}.

\section{Thread Cancellation}
%
There may be a number of situations in which it is useful to give one
thread the ability to cancel the execution of another thread.  Within
the semantics of Pthreads, this is called {\em thread cancellation}.
At the C level, thread cancellation can be tricky, as mutexes must be
released, allocated memory freed, and so on.  Accordingly, the
predicate {\tt thread\_cancel/1} cancels XSB threads by acting purely
within the SLG-WAM engine.  When thread $T_1$ interrupts thread $T_2$,
$T_1$ writes to the thread-specific XSB interrupt vector in $T_2$.
Later, when $T_2$ checks its interrupt vector, it throws a
cancellation error, which causes it to clean up its mutexes, memory,
private tables and dynamic code, and then exit.

Any thread can cancel any other thread, with the exception that the
{\em main} thread, which controls the console (or interface to C or
interprolog) cannot be cancelled.  The main thread always has XSB
thread id {\tt 0} in both the single-threaded and multi-threaded
systems.

\section{Performance and other Considerations}
%
For running programs that do not use multiple threads, the
multi-threaded engine has a minimal overhead compared to the
single-threaded engine.  Times for single-threaded execution of Prolog
or tabled programs range from about 10-20\% slower to 10-20\% {\em
  faster} for the multi-threaded engine compared to the
single-threaded engine.  Speedups for running multiple threads on
multiple processors depends heavily on the applications run and on the
underlying operating system.

The size of a given thread may be a consideration for multi-threaded
applications.  Each thread has an area of thread-private variables
that are ``global'' to its own virtual machine.  This area, called the
{\em thread context}, which accounts for about 4 Kbytes of space.
Much larger are the various stacks used by the threads for tabled and
Prolog execution.  Almost all of XSB's stacks are fully expandable,
and the initial size of several of these stacks may be set explicitly
as options in {\tt thread\_create/3}.  Explicitly setting a default
thread stack size for an XSB thread to be smaller than the default
process stack size may be useful for applications that have a large
number of concurrently running threads.

Other performance considerations involve the contention by threads for
shared resources.  As discussed above, contention may arise when
creating or abolishing tables, or when asserting or retracting dynamic
code --- however in either case thread-private predicates give rise to
less contention than thread-shared predicates.  In terms of I/O, each
XSB stream up to the maximum number of file descriptors has its own
mutex; as a result threads writing to different streams will not
contend for I/O.  Thus, in multi-threaded applications, it may be more
efficient to open and close streams and access these streams
explicitly, than to redirect standard input or standard output through
{\tt see/1} and {\tt tell/1}.

\section{Configuring the Multi-threaded Engine under Windows} \label{sec:mt-windows}

Libraries for Pthreads are included on most versions of Unix and
Linux.  Windows also supports multi-threading, but with a somewhat
different semantics and API than that of Pthreads.  To run
multi-threaded XSB under Windows, a library must be included to
translate the Pthread library, used by XSB, to the native thread API
of Windows.

Different libraries are available for this purpose.  Internally, the
multi-threaded engine has been tested using the Win32 Pthreads
interface, available via {\tt http://sourceware.org/pthreads-win32},
but other libraries may also work, including Pthread library included
with Cygwin.  To install the sourceware library, let {\tt \$XSBENV} be
the parent directory of {\tt \$XSBDIR} the root directory of XSB --
i.e. {\tt \$XSBENV} is the directory into which XSB is installed.

\begin{itemize}
\item Download a version such as pthreads-2005-01-25.exe or later, and
  extract it into {\tt \$XSBENV}\\pthreads.  Add
  \verb|$XSBENV\pthreads\Pre-built\lib| to your system path

\item To configure with windows enter the commands: 
\begin{verbatim}
sh configure --enable-mt --with-wind \
--site-includes='c:\XSBSYS\XSBENV\pthreads\Pre-built\include \
--site-static-libraries='c:\XSBSYS\XSBENV\pthreads\Pre-built\lib

makexsb_wind
\end{verbatim}
Note that the Unix {\tt sh} shell must be available in order to
reconfigure.

\item To configure with cygwin enter the commands:
\begin{verbatim}
sh configure --enable-mt \
  --site-includes='/cygdrive/c/XSBSYS/XSBENV/pthreads/Pre-built/include' \
  --site-static-libraries='/cygdrive/c/XSBSYS/XSBENV/pthreads/Pre-built/lib'

sh makexsb --config-tag=mt
\end{verbatim}

\end{itemize}

\section{Predicates for Multi-Threading} \label{sec:mt-threading}

The predicates described in this section do not address tabling or
dynamic code.  With only a few minor deviations the provisional
working standard described in \cite{Prolog-MT-ISO} is supported.  As a
result, these predicates are substantially the same as those in SWI,
YAP, and other Prologs.

\begin{description}

\ournewitem{thread\_create(+Goal,ThreadId,,+OptionsList)}{thread}
\index{\texttt{thread\_create/3}}
%
When called from thread $T$, this predicate creates a new XSB thread
$T_{new}$ to execute {\tt Goal}.  When goal either succeeds, throws an
unhandled error, or fails, $T_{new}$ exits, but {\tt thread\_create/2}
will succeed immediately, binding {\tt ThreadId} to the XSB thread id
of $T_{new}$.  {\tt Goal} must be callable, but need not be fully
instantiated.  No bindings from {\tt Goal} are passed back from $T$ to
$T_{new}$, so communication between $T_{new}$ and $T$ must be through
tables, asserted code, message queues or other side effects.

{\tt OptionList} allows optional parameters in the configuration for
the initial size of XSB stacks, for aliases, and to indicate whether
$T_{new}$ is to be created as detached.  Note that XSB threads allow
automatic stack allocation, so that the size options may be most
useful for (32-bit) applications with very large numbers of threads.
In this case, setting initial stack sizes to be small may allow more
threads to be created on a given hardware platform.  Also note that
only XSB stacks are affected, the stack size of the underlying Pthread
remains unaltered.
%
\bi
\item {\tt glsize(N)}: create thread with global (heap) plus local
  stack size initially set to {\tt N} kbytes.  If not specified, the
  default size is used.  The default size can be set at the command
  line (cf. Section~\ref{sec:EmuOptions}), and altered at run time by
  the xsb flag {\tt thread\_glsize} (cf. Section~\ref{State}).
%
\item {\tt tcpsize(N)}: create thread with trail plus choice point
  stack size initially set to {\tt N} kbytes.  If not specified, the
  default size is used (cf. Section~\ref{sec:EmuOptions}).  The
  default size can be set at the command line
  (cf. Section~\ref{sec:EmuOptions}), and altered at run time by the
  xsb flag {\tt thread\_tcpsize} (cf. Section~\ref{State}).
%
\item {\tt complsize(N)}: create thread with completion stack size
  initially set to {\tt N} kbytes. If not specified, the default size
  is used (cf. Section~\ref{sec:EmuOptions}).  The default size can be
  set at the command line (cf. Section~\ref{sec:EmuOptions}), and
  altered at run time by the xsb flag {\tt thread\_complsize}
  (cf. Section~\ref{State}).
%
\item {\tt pdlsize(N)}: create thread with {\tt N} kbytes of
  unification stack.  If not specified, the default size is used
  (cf. Section~\ref{sec:EmuOptions}).  The default size can be set at
  the command line (cf. Section~\ref{sec:EmuOptions}), and altered at
  run time by the xsb flag {\tt thread\_pdlsize}
  (cf. Section~\ref{State}).
%
\item {\tt detached(Boolean)}: if {\tt Boolean} is true, creates
  detached thread.  If {\tt Boolean} is false, the thread created will
  be joinable, while if no option is given the default will be used.
  In \version{} threads are created joinable by default, but this
  default can be altered at run time by the xsb flag {\tt
    thread\_default} (cf. Section~\ref{State}).
%
\item {\tt alias(Alias)}: Allow thread {\tt ThreadId} to be referred
  to via {\tt Alias} in all standard thread predicates.  {\tt Alias}
  remains active for {\tt ThreadId} until it is joined.  
\ei

{\bf Error Cases}
\bi
\item 	{\tt Goal} is a variable
\bi
\item 	{\tt instantiation\_error}.
\ei
\item 	{\tt Goal} is not callable
\bi
\item 	{\tt type\_error(callable,Goal)}.
\ei
\item 	{\tt ThreadId} is not a variable
\bi
\item 	{\tt type\_error(variable,ThreadId)}
\ei
\item 	{\tt OptionList} is a partial list or contains an option that is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
\item 	{\tt OptionList} is neither a list nor a partial list
\bi
\item 	{\tt type\_error(list,OptionsList)}
\ei
\item 	{\tt OptionList} contains an option, {\tt Option} not described above
\bi
\item 	{\tt domain\_error(thread\_option,Option)}
\ei
\item An element of {\tt OptionsList} is alias(A) and A is already
  associated with an existing thread, queue, mutex or stream 
\bi
\item {\tt permission\_error(create,alias, A)}
\ei
\item An element of {\tt OptionsList} is alias(A) and A is not an atom
\bi
\item {\tt type\_error(atom,A)}
\ei
\item   No more system threads are available (EAGAIN)
\bi
\item {\tt resource\_error(system threads)}
\ei
\ei

\ournewitem{thread\_create(+Goal,-ThreadId)}{thread}
\index{\texttt{thread\_create/2}}
%
Acts as {\tt thread\_create(Goal,ThreadId,[])}.

\ournewitem{thread\_join(+Threads\_or\_aliases,-ExitDesignators)}{thread}
\index{\texttt{thread\_join/2}} 
% 
When {\tt thread\_join/2} is called by thread $T$, {\tt
  Threads\_or\_aliases} must be instantiated to either 1) an XSB
thread id or alias; or 2) a list where each element is an XSB thread
id or an alias; {\tt ExitDesignators} must be uninstantiated.  The
action of the predicate is to suspend $T$ until all of the threads
denoted by {\tt Threads\_or\_aliases} have exited.  At this time, any
remaining resources for the threads in {\tt ThreadIds} will have been
reclaimed.  Upon success {\tt ExitDesignators} is either a the thread
status of the associated thread (see page~\pageref{page:thread-status}) 
or a list of such elements.  

{\bf Error Cases}
\bi
\item 	{\tt Thread\_or\_Aliases} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Threads\_or\_aliases} is not a list of XSB thread ids or aliases
\bi
\item 	{\tt domain\_error(listof(thread\_or\_alias),ThreadIds)}
\ei
%
\item 	{\tt ExitDesignators} is not a variable
\bi
\item 	{\tt type\_error(variable,ExitDesignatorst)}
\ei
%
\item   {\tt ThreadId} does not correspond to a valid thread
\bi
\item   {\tt existence\_error(valid\_thread,ThreadId)}
\ei
\item   {\tt ThreadId} does not correspond to a joinable thread
  (i.e. {\tt ThreadId} is detached).
\bi
\item   {\tt permission\_error(join,non\_joinable\_thread,ThreadId)}
\ei
\ei

\comment{
a) Thread is a variable  instantiation_error
}

\ournewitem{thread\_exit(+ExitTerm)}{thread}
\index{\texttt{thread\_exit/1}} 
%
Exits a thread $T$ with {\tt ExitTerm} after releasing any mutexes
held by $T$, freeing any thread-specific memory allocated for $T$ (we
hope).  {\tt ExitTerm} will be used if the caller of $T$ joins to $T$,
but will be ignored in other cases.  There is no need to call this
routine on normal termination of a thread as it is called implicitly
on success or (final) failure of a thread's goal.

{\bf Error Cases}
\bi
\item 	{\tt ExitCode} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
\ei

\ournewitem{thread\_self(?ThreadId\_or\_Alias)}{thread}
\index{\texttt{thread\_self/1}} 
%
If {\tt ThreadId} is an atom, unifies {\tt ThreadId\_or\_Alias} with
an alias of the calling thread.  Otherwise, unifies {\tt
  ThreadId\_or\_Alias} with the XSB thread id of the calling thread.
There are no error conditions.

%-------------------------------------------------------------------

\ournewitem{thread\_detach(+Thread\_or\_Alias)}{thread}
\index{\texttt{thread\_detach/1}} 
%
Detaches a joinable thread denoted by {\tt Thread\_or\_Alais} so that
all resources will be reclaimed upon its exit.  The thread denoted by
{\tt ThreadId} will no longer be joinable, once it is detached.  If
{\tt Thread\_or\_Alias} has already exited, all resources used by {\tt
  Thread\_or\_Alias} are removed from the system.

%Note, if it is known at thread creation time that a thread should be
%detached, it is better practice to create the thread as detached via {\tt
%  thread\_create/3}.

{\bf Error Cases}
\bi
%
\item 	{\tt Thread\_or\_Alias} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Thread\_or\_Alias} is not a thread id or alias
\bi
\item 	{\tt domain\_error(thread\_or\_alias,Thread\_or\_Alias)}
\ei
%
\item   {\tt Thread\_or\_Alias} does not correspond to a valid thread
\bi
\item   {\tt existence\_error(valid\_thread,Thread\_or\_alias)}
\ei
%
\item 	{\tt Thread\_or\_Alias} is active but not joinable
\bi
\item 	{\tt permission\_error(thread\_detach,thread,Thread\_or\_Alias)}
\ei
\ei

\ournewitem{thread\_cancel(+ThreadId)}{thread}
\index{\texttt{thread\_cancel/1}} 
%
Cancels the XSB thread denoted by {\tt ThreadId}.  The cancellation
does not use Pthread cancellation mechanisms, rather it uses XSB's
interrupt mechanism to set {\tt ThreadId}'s interrupt vector.  When
this interrupt vector is checked, {\tt ThreadId} will throw a thread
cancellation error, which can be caught within {\tt ThreadId} like any
other error.  Usually, this means that {\tt ThreadId} will abort and
exit.  Note that the high-level upon which thread cancellation is
implemented allows for simplicity and portability of thread
cancellation.  \footnote{While interrupt vector is not checked upon
  every SLG-WAM instruction, it is checked on every {\sf call} and
  {\sf execute} instruction, and should should be suitable for almost
  any need for cancellation.}.

The main XSB thread cannot be cancelled; apart from that any thread
can cancel any other thread.

{\bf Error Cases}
\bi
\item 	{\tt ThreadId} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item   {\tt ThreadId} does not correspond to valid thread
\bi
\item   {\tt existence\_error(valid\_thread,ThreadId)}
\ei
\item   {\tt ThreadId} denotes the main thread.
\bi
\item   {\tt permission\_error(cancel,main\_thread,ThreadId)}
\ei
\ei

\ournewitem{thread\_yield}{thread}
\index{\texttt{thread\_yield/0}} 
% 
Make the calling thread ready to be run {\em after} other threads of
the same priority.  This predicate relies on the real-time extensions
to Pthreads specified in Posix 1b, and may not be available on all
platforms.

{\bf Error Cases}
\bi
\item 	The current platform does not support Posix real-time extensions
\bi
\item 	{\tt misc\_error}
\ei
\ei

\ournewitem{usleep(+Microseconds)}{thread}
\index{\texttt{usleep/1}} 
%
Causes the calling thread to sleep approximately {\tt Microseconds}
before resuming.

{\bf Error Cases}
\bi
\item 	{\tt Microseconds} is a variable
\bi
\item 	{\tt instantiation\_error}.
\ei
\item 	{\tt Microseconds} is not an integer
\bi
\item 	{\tt type\_error(integer, Microseconds)}.
\ei
\ei



% 

\end{description}

\subsection{Predicates for Thread Synchronization and Communication} 
\label{sec:synchronization}

While the XSB engine itself is thread-safe, thread synchronization may
be needed when calling a package that is not itself thread safe (see
the beginning of this chapter for a list of which packages are and are
not thread-safe).  Synchronization may also be needed to protect data
accessed by foreign function calls, or to coordinate responses to
external events.

\subsubsection{User-defined Mutexes}~\label{sec:mutexes}
%
One of the simplest and most powerful primitives for thread
synchronization are mutexes.  The mutexes provided by the following
primitives are {\em recursive}: if a thread $T$ locks a recursive
mutex $M$, any calls to {\tt mutex\_lock(M)} made by $T$ will
immediately succeed without suspending while $M$ is locked.  Other
threads that attempt to lock $M$ will suspend until $M$ is unlocked.
To unlock $M$ after $n$ calls to {\tt mutex\_lock(M)}, $T$ must make
$n$ calls to {\tt mutex\_unlock(M)}.

When using mutexes in XSB, programmers must not only avoid explicitly
creating deadlocks, but must also ensure that a mutex is unlocked when
leaving a critical area, and destroyed when it is no longer needed.
Making sure that this happens for successful goals, for failed goals
and for goals that raise exceptions can sometimes be complicated.  The
predicate {\tt with\_mutex/2} handles all of these cases.  We
recommend using it if possible, and making use of lower-level calls to
{\tt mutex\_lock/1}, {\tt mutex\_unlock/1} and {\tt mutex\_trylock/1}
only when {\tt with\_mutex/2} is not applicable.

\begin{description}
\ournewitem{with\_mutex(+Mutex,?Goal)}{mutex}
\index{\texttt{with\_mutex/2}} 
%
Locks a current mutex or alias{\tt Mutex}, executes {\tt Goal}
deterministically, then unlocks {\tt Mutex}.  If {\tt Goal} leaves
choice-points, these are destroyed.  {\tt Mutex} is unlocked
regardless of whether {\tt Goal} succeeds, fails or raises an
exception. Any exception thrown by {\tt Goal} is re-thrown after the
mutex has been successfully unlocked.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mutex} is not a mutex id or alias
\bi
\item 	{\tt domain\_error(mutex\_or\_alias,Mutex\_or\_Alias)}
\ei
%
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item Locking {\tt Mutex} would give rise to a deadlock~\footnote{This
  error case handles the {\tt EDEADLK} return code on OS X, and other
  platforms.}
\bi
\item 	{\tt permission\_error(mutex,lock,Mutex)}
\ei
\item {\tt Goal} is a variable
\bi
\item  instantiation error
\ei
%
\item {\tt Goal} is neither a variable nor a callable term
\bi
\item type error(callable, Goal)
\ei
%
\ei

\ournewitem{mutex\_create(?Mutex)}{mutex}
\index{\texttt{mutex\_create/1}} 
%
Creates a new recursive user mutex with identifier {\tt Mutex}.  {\tt
  Options} allows optional parameters to be passed, currently only for
aliases of the mutex.
%
\bi
\item {\tt alias(Mutex)}: Allow queue {\tt Mutex} to be referred to
  via {\tt Mutex} in all standard queue predicates.  {\tt Mutex}
  remains active for {\tt Mutex} until it is destroyed.
\ei

{\bf Error Cases}
\bi
\item 	Mutex is not a variable
\bi
\item 	{\tt type\_error(variable,Mutex)}
\ei
\item Options is a partial list or a list with an element that is a
  variable 
\bi
\item  instantiation error
\ei
\item Options is neither a partial list or a list
\bi
\item  type error(list, Options)
\ei
\item 	{\tt Options} contains an option, {\tt Option} not described above
\bi
\item 	{\tt domain\_error(mutex\_option,Option)}
\ei
%
\item An element of {\tt Options} is {\tt alias(A)} and {\tt A} is
  already associated with an existing thread, queue, mutex or stream 
\bi
\item {\tt permission\_error(create,alias, A)}
\ei
\item An element of {\tt Options} is {\tt alias(A)} and {\tt A} is not an atom
\bi
\item {\tt type\_error(atom,A)}
\ei
\ei

\ournewitem{mutex\_destroy(+Mutex)}{mutex}
\index{\texttt{mutex\_destroy/1}} 
%
Destroys a current unlocked mutex with alias or id {\tt Mutex} along
with any memory it uses.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mutex} is not a mutex id or alias
\bi
\item 	{\tt domain\_error(mutex\_or\_alias,Mutex\_or\_Alias)}
\ei
%
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item 	{\tt Mutex} is locked
\bi
\item 	{\tt permission\_error(mutex,destroy,Mutex)}
\ei
\ei

\ournewitem{mutex\_lock(+Mutex)}{mutex}
\index{\texttt{mutex\_lock/1}} 
%
{\tt mutex\_lock(Mutex)} locks a (recursive) mutex with alias or id
{\tt Mutex}. Locking and unlocking mutexes should be paired carefully
in order to avoid deadlocks. In particular, a programmer needs to
ensure that mutexes are properly unlocked even if the protected code
fails or raises an exception.
%For most common cases, the built-in predicate with mutex/2 (3.4.3)
%provides a safer way for using mutexes.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mutex} is not a mutex id or alias
\bi
\item 	{\tt domain\_error(mutex\_or\_alias,Mutex\_or\_Alias)}
\ei
%
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item Locking {\tt Mutex} would give rise to a deadlock~\footnote{This
  error case handles the {\tt EDEADLK} return code on OS X, and other
  platforms.}
\bi
\item 	{\tt permission\_error(mutex,lock,Mutex)}
\ei
\ei

\ournewitem{mutex\_trylock(+Mutex)}{mutex}
\index{\texttt{mutex\_trylock/1}} 
%
Works as {\tt mutex\_lock/1} but fails immediately if {\tt Mutex} is
held by another thread,  rather than suspending the calling thread.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mutex} is not a mutex id or alias
\bi
\item 	{\tt domain\_error(mutex\_or\_alias,Mutex\_or\_Alias)}
\ei
%
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\ei

\ournewitem{mutex\_unlock(+Mutex)}{mutex}
\index{\texttt{mutex\_unlock/1}} 
%
Unlocks the mutex with alias or id {\tt Mutex} when called by the same
thread that locked {\tt Mutex}.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mutex} is not a mutex id or alias
\bi
\item 	{\tt domain\_error(mutex\_or\_alias,Mutex\_or\_Alias)}
\ei
%
\item 	{\tt Mutex} is not associated with a current mutex.
\bi
\item 	{\tt existence\_error(mutex,Mutex)}
\ei
\item 	{\tt Mutex} is not held by the calling thread
\bi
\item 	{\tt permission\_error(unlock,mutex,Mutex)}
\ei
\ei

\ournewitem{mutex\_unlock\_all}{mutex}
\index{\texttt{mutex\_unlock\_all/0}} 
%
{\tt mutex\_unlock\_all/0} unlocks all user mutexes owned by the
current thread.  It has no error cases.

\ournewitem{mutex\_property(?Mutex,?Property)}{mutex}
\index{\texttt{mutex\_property/2}} 
%
If {\tt Mutex} is instantiated, unifies {\tt Property} with current
properties of the mutex; if {\tt Mutex} is a variable, backtracks
through all the current mutexes whose properties unify with {\tt
  Property}.  If the mutex is locked, {\tt Property} will be a term of
the form {\tt locked(ThreadId,NumLocks)} where {\tt ThreadId} is a
thread id, and {\tt NumLocks} is the number of times the mutex has
been locked.  If the mutex is unlocked, {\tt Property} will be a term
of the form {\tt unlocked(NumLocks)} where {\tt NumLocks} is the
number of times the mutex has been locked.

{\bf Error Cases}
\bi
\item 	{\tt Mutex} is not an atom
\bi
\item 	{\tt type\_error(atom,Mutex)}
\ei
\ei

\end{description}

%--------------------------------------------------------------------
\comment{
mutex_statistics not yet implemented.
}
%--------------------------------------------------------------------

\subsubsection{Prolog Message Queues}~\label{sec:mutexes}
While Prolog predicates can communicate through shared dynamic code
and tables, message queues provide a useful mechanism for one thread
to pass a command to another or to synchronize on the return of data.
A Prolog message queue can be defined to have a speficied or default
$size$ and can have any number of consumerss and any number of
producers.  When a producer writes a $Term$ into a queue, the term is
copied into the queue so that no binding are shared between $Term$ and
the producer's stacks.  $Term$ may include structures or lists and
need not be bound, and any variable bindings within $Term$ are
preserved.  If the queue already contains $size$ elements, the
producer will suspend until one or more elements are removed from the
queue.  When a consumer $T_{cons}$ accesses the queue it provides a
goal $G$ and traverses the queue until it finds a term in the queue
that unifies with $G$.  If $T_{cons}$ finds a term in the queue that
unifies with $G$, it removes it from the queue and continues in its
computation.  If there is no term in the queue that unifies with $G$,
$T_{cons}$ will suspend until at least one other term is added to the
queue.  When it awakens it will retraverse the queue from the
beginning to find a term that unifies with $G$~\footnote{Note that
  this traversal is necessary since the position of $T_{cons}$ may in
  the queue may not be valid due to the addition and deletion of terms
  by other threads.}.  Because of the behavior of message queues, it
is usually good programming practice to ensure that terms written into
the queue will unify with the goals of consumers.  This can usually be
done by abstracting a consumers goal (say to a variable, {\tt X}) or
by splitting one ``multiplexed'' queue into two separate queues.

\begin{description}

\ournewitem{message\_queue\_create(-Queue,+Options)}{mutex}
\index{\texttt{message\_queue\_create/2}} 
%
Creates a new message queue with identifier {\tt Queue}.  {\tt
  Options} allows optional parameters to be passed for the maximum
number of terms in the queue, and for aliases of the queue.
%
\bi
\item {\tt max\_terms(N)}: create queue so that it can contain at most
  {\tt N} terms before writes to the queue block.  If not specified,
  the default size is used.  This default can be queried and altered
  at run time via the xsb flag {\tt queue\_max\_terms}.
  (cf. Section~\ref{State}).
%
\item {\tt alias(Alias)}: Allow queue {\tt Queue} to be referred to
  via {\tt Alias} in all standard queue predicates.  {\tt Alias}
  remains active for {\tt Queue} until it is destroyed.
\ei

{\bf Error Cases}
\bi
\item 	Queue is not a variable
\bi
\item 	{\tt type\_error(variable,Queue)}
\ei
\item Options is a partial list or a list with an element that is a
  variable 
\bi
\item  instantiation error
\ei
\item Options is neither a partial list or a list
\bi
\item  type error(list, Options)
\ei
\item 	{\tt Options} contains an option, {\tt Option} not described above
\bi
\item 	{\tt domain\_error(queue\_option,Option)}
\ei
%
\item An element of {\tt Options} is {\tt alias(A)} and {\tt A} is
  already associated with an existing thread, queue, mutex or stream 
\bi
\item {\tt permission\_error(create,alias, A)}
\ei
\item An element of {\tt Options} is {\tt alias(A)} and {\tt A} is not an atom
\bi
\item {\tt type\_error(atom,A)}
\ei
\ei

\ournewitem{message\_queue\_detroy(+Queue\_or\_Alias,\#Message)}{mutex}
\index{\texttt{message\_queue\_destroy/1}} 
%
Destroys a message queue with alias or id {\tt Queue\_or\_alias}, as
created by {\tt message\_queue\_create/[1,2]}.
%  It is not allowed to
%de- stroy the queue of a thread. 
If any threads are currently waiting on {\tt Queue\_or\_Alias}, an
error will be thrown.
% or may try to wait for later?

{\bf Error Cases}
\bi
\item 	{\tt Queue\_or\_Alias} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Queue\_or\_Alias} is not a queue id or alias
\bi
\item 	{\tt domain\_error(queue\_or\_alias,Queue\_or\_Alias)}
\ei
\ei
%


\ournewitem{thread\_send\_message(+Queue\_or\_Alias,\#Message)}{mutex}
\index{\texttt{thread\_send\_message/2}} 
%
If there are fewer terms on {\tt Queue\_or\_Alias} than the queue's
maximum allowed number {\tt thread\_send\_message/2} puts {\tt
  Message} onto {\tt Queue\_or\_Alias}, and returns immediately.
Otherwise, the calling thread suspends until there are fewer elements
on {\tt Queue\_or\_Alias} than the queue's maximum allowed number,
when the thread will be awakened to put {\tt Message} onto the queue.

{\bf Error Cases}
\bi
\item 	{\tt Queue\_or\_Alias} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Queue\_or\_Alias} is not a queue id or alias
\bi
\item 	{\tt domain\_error(queue\_or\_alias,Queue\_or\_Alias)}
\ei
\ei
%

\ournewitem{thread\_get\_message(+Queue\_or\_Alias,?Message)}{mutex}
\index{\texttt{thread\_get\_message/2}} 

If there are terms on {\tt Queue\_or\_Alias} {\tt
  thread\_get\_message/2} traverses {\tt Queue\_or\_Alias} to obtain
the first term $T$ that unifies with {\tt Message}.  If $T$ exists,
the predicate returns with {\tt Message} bound to the most general
unifier of {\tt Message} and $T$.  If there are no terms on {\tt
  Queue\_or\_Alias} or if no terms unify with {\tt Message}, the
calling thread suspends until at least one term is added to {\tt
  Queue\_or\_Alias}.  When the thread awakes, it will recheck {\tt
  Queue} from its beginning for a term that unifies with {\tt
  Message}.

{\bf Error Cases}
\bi
\item 	{\tt Queue\_or\_Alias} is a variable
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Queue\_or\_Alias} is not a queue id or alias
\bi
\item 	{\tt domain\_error(queue\_or\_alias,Queue\_or\_Alias)}
\ei
\ei
%

\end{description}



