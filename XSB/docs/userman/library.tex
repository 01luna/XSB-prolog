\chapter{Library Utilities} \label{library_utilities}
%====================================================

In this chapter we introduce some useful predicates that are supplied
with the system. These predicates are available only when imported
them from (or explicitly consult) the corresponding modules.


\section{List Processing}
%========================
The XSB library contains various list utilities, some of which 
are listed below.  These predicates should be explicitly imported from
the module specified after the skeletal specification of each predicate.
There are a lot more useful list processing predicates in various modules
of the XSB system, and the interested user can find them by 
looking at the sources.

\begin{description}
\ournewitem{append(?List1, ?List2, ?List3)}{basics}\index{{\tt append/3}}
%\predindex{append/3~(L)}
    Succeeds if list {\tt List3} is the concatenation of lists 
    {\tt List1} and {\tt List2}.

\ournewitem{member(?Element, ?List)}{basics}\index{{\tt member/2}}
%\predindex{member/2~(L)}
    Checks whether {\tt Element} unifies with any element of list 
    {\tt List}, succeeding more than once if there are multiple 
    such elements.

\ournewitem{memberchk(?Element, ?List)}{basics}\index{{\tt memberchk/2}}
%\predindex{memberchk/2~(L)}
    Similar to {\tt member}/2, except that {\tt memberchk}/2 is
    deterministic, i.e.\ does not succeed more than once for any call.

\ournewitem{ith(?Index, ?List, ?Element)}{basics}\index{{\tt ith/3}}
%\predindex{ith/3~(L)}
    Succeeds if the ${\tt Index^{th}}$ element of the list {\tt List} 
    unifies with {\tt Element}.  Fails if {\tt Index} is not a positive
    integer or greater than the length of {\tt List}.
    Either {\tt Index} and {\tt List}, or {\tt List} and {\tt Element}, 
    should be instantiated (but not necessarily ground) at the time of 
    the call.

\ournewitem{length(?List, ?Length)}{basics}\index{{\tt length/2}}
%\predindex{length/2~(L)}
    Succeeds if the length of the list {\tt List} is {\tt Length}.
    This predicate is deterministic if {\tt List} is instantiated 
    to a list of definite length, but is nondeterministic if 
    {\tt List} is a variable or has a variable tail.  If {\tt List}
    is uninstantiated, it is unified with a list of length {\tt Length}
    that contains variables.

\ournewitem{same\_length(?List1, ?List2)}{basics}\index{{\tt same\_length/2}}
%\predindex{same\_length/2~(L)}
    Succeeds if list {\tt List1} and {\tt List2} are both lists of
    the same number of elements.  No relation between the types or
    values of their elements is implied.  This predicate may be used
    to generate either list (containing variables as elements) given
    the other, or to generate two lists of the same length, in which
    case the arguments will be bound to lists of length $0,1,2,\ldots$.

\ournewitem{select(?Element, ?L1, ?L2)}{basics}\index{{\tt select/3}}
%\predindex{select/3~(L)}
    {\tt List2} derives from {\tt List1} by selecting (removing) an 
    {\tt Element} non-deterministically.

\ournewitem{reverse(+List, ?ReversedList)}{basics}\index{{\tt reverse/2}}
%\predindex{reverse/2~(L)}
    Succeeds if {\tt ReversedList} is the reverse of list {\tt List}.
    If {\tt List} is not a proper list, {\tt reverse/2} can succeed
    arbitrarily many times.  It works only one way.

\ournewitem{perm(+List, ?Perm)}{basics}\index{{\tt perm/2}}
%\predindex{perm/2~(L)}
    Succeeds when {\tt List} and {\tt Perm} are permutations of each
    other.  The main use of {\tt perm/2} is to generate permutations
    of a given list.  {\tt List} must be a proper list.
    {\tt Perm} may be partly instantiated.

\ournewitem{subseq(?Sequence, ?SubSequence, ?Complement)}{basics}
\index{{\tt subseq/3}}
%\predindex{subseq/3(L)}
    Succeeds when {\tt SubSequence} and {\tt Complement} are both
    subsequences of the list {\tt Sequence} (the order of corresponding
    elements being preserved) and every element of {\tt Sequence} which
    is not in {\tt SubSequence} is in the {\tt Complement} and vice
    versa.  That is,
    \[ length({\tt Sequence}) =
		length({\tt SubSequence})+length({\tt Complement}) \]
    for example, {\tt subseq([1,2,3,4], [1,3], [2,4]).}
    The main use of {\tt subseq/3} is to generate subsets and their
    complements together, but can also be used to interleave two lists
    in all possible ways.

\ournewitem{merge(+List1, +List2, ?List3)}{listutil}\index{{\tt merge/3}}
%\predindex{merge/3~(L)}
    Succeeds if {\tt List3} is the list resulting from ``merging'' lists 
    {\tt List1} and {\tt List2},
    i.e.\ the elements of {\tt List1} together with any element of 
    {\tt List2} not occurring in {\tt List1}.
    If~{\tt List1} or~{\tt List2} contain duplicates, {\tt List3} may 
    also contain duplicates.

\ournewitem{absmerge(+List1, +List2, ?List3)}{listutil}\index{{\tt absmerge/3}}
%\predindex{absmerge/3~(L)}
    Predicate {\tt absmerge/3} is similar to {\tt merge/3}, except that 
    it uses predicate {\tt absmember/2} described below rather than 
    {\tt member/2}.

\ournewitem{absmember(+Element, +List)}{listutil}\index{{\tt absmember/2}}
%\predindex{absmember/2~(L)}
    Similar to {\tt member}/2, except that it checks for identity
    (through the use of predicate {\tt '=='/2}) rather than unifiability 
    (through {\tt '='/2}) of {\tt Element} with elements of {\tt List}.

\ournewitem{member2(?Element, ?List)}{listutil}\index{{\tt member2/2}}
%\predindex{member2/2~(L)}
    Checks whether {\tt Element} unifies with any of the actual elements 
    of {\tt List}.  The only difference between this predicate and 
    predicate {\tt member/2} is on lists having a variable tail, 
    e.g.\ \verb'[a, b, c | _ ]': while {\tt member/2} would insert 
    {\tt Element} at the end of such a list if it did not find it, 
    Predicate {\tt member2/2} only checks for membership but does not 
    insert the {\tt Element} into the list if it is not there.

\ournewitem{delete\_ith(+Index, +List, ?Element, ?RestList)}{listutil}
\index{{\tt delete\_ith/4}}
%\predindex{delete\_ith/4~(L)}
    Succeeds if the ${\tt Index^{th}}$ element of the list {\tt List}
    unifies with {\tt Element}, and {\tt RestList} is {\tt List} with
    {\tt Element} removed.  Fails if {\tt Index} is not a positive
    integer or greater than the length of {\tt List}.

\ournewitem{closetail(?List)}{listutil}\index{{\tt closetail/1}}
%\predindex{closetail/1~(L)}
    Predicate {\tt closetail/1} closes the tail of an open-ended list.
    It succeeds only once.

\end{description}



\section{Asserting Dynamic Code} \label{LoadDyn}
%===============================================

The module {\tt consult} in directory {\tt lib} provides several handy
library predicates that can assert the contents of a file into
XSB's database.  The use of these predicates may be necessary
when the code needs to be {\tt dynamic} (so that it is retractable),
or when it contains atoms whose length is more than 255 that cannot be
handled by the XSB compiler.

\begin{description}
\ournewitem{load\_dyn(+FileName)}{consult}
\index{{\tt load\_dyn/1}}\label{load_dyn/1}
%\predindex{load\_dyn/1~(L)}
    Asserts the contents of file {\tt FileName} into the database.
    All existing clauses of the predicates in the file that already
    appear in the database, are retracted, unless there is a {\tt
    multifile/1} declaration for them.  Clauses in the file must be
    in a format that {\tt read/1} will process.  So, for example,
    operators are permitted.  As usual, clauses of predicates are not
    retracted if they are compiled instead of dynamically asserted.
    All predicates are loaded into {\tt usermod}.  Module declarations
    such as {\tt :- export} are ignored and a warning is issued.

    Dynamically loaded files can be filtered through the XSB preprocessor.
    To do this, put the following in the source file: 
    %%
    \begin{verbatim}
    :- compiler_options([xpp_on]).      
    \end{verbatim}
    %%
    Of course, the name \verb|compiler_options| might seem like a misnomer
    here (since the file is not being compiled), but it is convenient to
    use the same directive both for compiling and loading, in case the same
    source file is used both ways.

\ournewitem{ensure\_dyn\_loaded(+FileName)}{consult}
\index{{\tt ensure\_dyn\_loaded/1}}
    Is similar to {\tt load\_dyn/1} except that it does nothing if the
    file has previously been loaded and the file has not been changed
    since.  However the file will be reloaded if the index declaration of
    any predicate in that file has changed to require more indexing, or a
    larger hash table.

\ournewitem{load\_dync(+FileName)}{consult}\index{{\tt load\_dync/1}}
%\predindex{load\_dync/1~(L)}
    Asserts the contents of file {\tt FileName} into the database.
    All existing clauses of the predicates in the file that already appear
    in the database, are retracted unless there is a {\tt multifile/1}
    directive for them.  The terms in the file {\tt FileName} must be in
    ``canonical'' format; that is, they must not use any operators (or
    list notation.) This is the format produced by the predicate {\tt
    write\_canonical/1}. (See {\tt cvt\_canonical/2} to convert a file from
    the usual {\tt read/1} format to {\tt read\_canonical} format.)  As
    usual, clauses of predicates are not retracted if they are compiled
    instead of dynamically asserted. All predicates are loaded into {\tt
    usermod}.  {\tt :- export} declarations are ignored and a warning is
    issued.

    Notice that this predicate can be used to load files of Datalog facts
    (since they will be in canonical format).  This predicate is
    significantly faster than {\tt load\_dyn/1} and should be used when
    speed is important.  A file that is to be dynamically loaded often but
    not often modified by hand should be loaded with this predicate.  Use
    predicate {\tt cvt\_canonical/2} (see below) to convert a usual file
    to a format readable by this predicate.

    As with \verb|load_dyn/1|, the source file can be filtered through the C
    preprocessor. However, since all clauses in such a file must be in
    canonical form, the \verb|compiler_options/1| directive should look as
    follows:
    %%
    \begin{verbatim}
     :-(compiler_options('.'(xpp_on,[]))).      
    \end{verbatim}
    %%

\ournewitem{ensure\_dync\_loaded(+FileName)}{consult}
\index{{\tt ensure\_dync\_loaded/1}}
    Is similar to {\tt load\_dync/1} except that it does nothing if the
    file has previously been loaded and the file has not been changed
    since.  However the file will be reloaded if the index declaration of
    any predicate in that file has changed to require more indexing, or a
    larger hash table.

\ournewitem{cvt\_canonical(+FileName1,+FileName2)}{consult}
\index{{\tt cvt\_canonical/2}}
    Converts a file from standard term format to ``canonical'' format.
    The input file name is {\tt FileName1}; the converted file is put in
    {\tt FileName2}.  This predicate can be used to convert a file in
    standard Prolog format to one loadable by {\tt load\_dync/1}.
\end{description}

%----------------------------------------------------------------------


\section{Ground, Numbervars, Subsumption, Variant} \label{NumberVars}
%====================================================================

\begin{description}
\ournewitem{ground(+X)}{basics}\index{{\tt ground/1}}
%\predindex{ground/1~(L)}
    Succeeds if {\tt X} is currently instantiated to a term that is 
    completely bound (has no uninstantiated variables in it); 
    otherwise it fails.  Predicate {\tt ground/1} has no associated 
    error conditions.

\ournewitem{numbervars(+Term, +FirstN, ?LastN)}{num\_vars}
\index{{\tt numbervars/3}}
%\predindex{numbervars/3~(L)}
    This predicate provides a mechanism for grounding a (HiLog) term
    so that it may be analyzed.  Each variable in the (HiLog) term
    {\tt Term} is instantiated to a term of the form \verb|'$VAR'(N)|,
    where {\tt N} is an integer starting from {\tt FirstN}.  
    {\tt FirstN} is used as the value of {\tt N} for the first
    variable in {\tt Term} (starting from the left). The second distinct
    variable in {\tt Term} is given a value of {\tt N} satisfying
    {\tt "N is FirstN + 1"} and so on.  The last variable in {\tt Term}
    has the value {\tt LastN-1}.

\ournewitem{numbervars(+Term)}{num\_vars}\index{{\tt numbervars/1}}
%\predindex{numbervars/1~(L)}
    This predicate is defined as:
    \begin{center}
    {\tt   numbervars(Term, 0, \_)}.
    \end{center}
    It is included solely for convenience.

%\ournewitem{varnumbers(Term, FirstN, Copy)}{num\_vars}
%\index{{\tt varnumbers/3}}
%%\predindex{varnumbers/3~(B)}
%    This predicate is a partial inverse of predicate {\tt numbervars/3}.
%    It unifies {\tt Copy} with a copy of {\tt Term} in which subterms of
%    the form \verb|'$VAR'(N)| where {\tt N} is an integer not less than
%    {\tt FirstN} have been systematically replaced by fresh variables. 
%    Since 0 is the usual second argument of numbervars/3,
%    \begin{center}
%    {\tt   varnumbers(Term, Copy)}
%    \end{center}
%    is also provided.

\ournewitem{subsumes(?Term1, +Term2)}{subsumes}\index{{\tt subsumes/2}}
%\predindex{subsumes/2~(L)}
    Term subsumption is a sort of one-way unification.  Term {\tt Term1}
    and {\tt Term2} unify if they have a common instance, and unification
    in Prolog instantiates both terms to that (most general) common instance.
    {\tt Term1} subsumes {\tt Term2} if {\tt Term2} is already an instance of
    {\tt Term1}.  For our purposes, {\tt Term2} is an instance of {\tt Term1}
    if there is a substitution that leaves {\tt Term2} unchanged and makes
    {\tt Term1} identical to {\tt Term2}.  Predicate {\tt subsumes/2} does
    not work as described if {\tt Term1} and {\tt Term2} share common
    variables.

\ournewitem{subsumes\_chk(+Term1, +Term2)}{subsumes}
\index{{\tt subsumes\_chk/2}}
%\predindex{subsumes\_chk/2~(L)}
    The {\tt subsumes\_chk/2} predicate is true when {\tt Term1} subsumes 
    {\tt Term2}; that is, when {\tt Term2} is already an instance of
    {\tt Term1}.  This predicate simply checks for subsumption and 
    does not bind any variables either in {\tt Term1} or in {\tt Term2}.
    {\tt Term1} and {\tt Term2} should not share any variables.

    Examples:
    {\footnotesize
     \begin{verbatim}
            | ?- subsumes_chk(a(X,f,Y,X),a(U,V,b,S)).

            no
            | ?- subsumes_chk(a(X,Y,X),a(b,b,b)).

            X = _595884
            Y = _595624
     \end{verbatim}}

\ournewitem{variant(?Term1, ?Term2)}{subsumes}\index{{\tt variant/2}}
%\predindex{variant/2~(L)}
    This predicate is true when {\tt Term1} and {\tt Term2} are 
    alphabetic variants.  That is, you could imagine that {\tt variant/2}
    as being defined like:
    \begin{center}
    \begin{minipage}{3.5in}
    \begin{verbatim}
	variant(Term1, Term2) :-
	     subsumes_chk(Term1, Term2),
	     subsumes_chk(Term2, Term1).
    \end{verbatim}
    \end{minipage}
    \end{center}
    but the actual implementation of {\tt variant/2} is considerably more
    efficient.  However, in general, it does not work for terms that share
    variables; an assumption that holds for most (reasonable) uses of
    {\tt variant/2}.
\end{description}


\section{Lower-Level I/O}
%======================

XSB has various low-level routines that support input and output, at both
the term level and the character level.  Unlike the standard Prolog stream
I/O, the low-level routines use \emph{XSB I/O ports} to refer to files. XSB
I/O ports should not be confused with the file descriptors used by the OS
Both are small integers, but they refer to different things. However, the
OS file descriptors are objects returned by the C {\tt open} function; XSB
I/O ports indices into the internal XSB table of open files. The OS does
not know about XSB I/O ports, while XSB (obviously) does know about the OS
file descriptors. Typically XSB opens files for buffered I/O (whether using
the stream I/O predicates or the predicates described here), so XSB I/O
ports internally refer to {\tt FILE} data structures (those returned by the
C {\tt fopen} function).

When it starts, XSB opens a number of standard I/O ports that it uses to
print results, errors, debugging info, etc. The descriptors are described
in the file {\tt prolog\_includes/standard.h}. This file provides the
following symbolic definitions:
%%
\begin{verbatim}
    #define STDIN            0
    #define STDOUT           1
    #define STDERR           2
    #define STDWARN          3    /* output stream for xsb warnings  */
    #define STDMSG           4    /* output for regular xsb messages */
    #define STDDBG           5    /* output for debugging info       */
    #define STDFDBK          6    /* output for XSB feedback
                                     (prompt/yes/no/Aborting/answers) */
    #define OREAD            0    /* open for read        */
    #define OWRITE           1    /* open for write       */
    #define OAPPEND          2    /* open for append      */
    #define OSTRING          3    /* open for as a string */

    #define AF_INET     0     /* XSB-side socket request for Internet domain */
    #define AF_UNIX     1     /* XSB-side socket request for UNIX domain */
\end{verbatim}
%%
These definitions can be used in user programs, if the following is
provided at the top of the source file:
%%
\begin{verbatim}
    compiler_options([xpp_on]).
    #include "standard.h"
\end{verbatim}
%%
(Note: the XSB preprocessor is not invoked on clauses typed into an
interactive XSB session, so the above applies only to programs loaded from
a file using {\tt consult} and such.)

\begin{description}

\ournewitem{current\_input\_port(-IOport)}{curr\_sym} \index{{\tt current\_input\_port/}}
   See {\tt current\_output\_port/1}.
\ournewitem{current\_output\_port(-IOport)}{curr\_sym} \index{{\tt current\_output\_port/}}
   The above two predicates instantiate {\tt IOport} to the XSB I/O port
   for the current user input and output ({\it i.e.}, the things 
   that are manipulated through {\tt see/seen} and {\tt tell/told} predicates).
   Once the I/O port is obtained, it is possible to safely use the
   lower-level I/O predicates described below interchangeably with stream
   I/O. 
    
\ournewitem{file\_open(+FileName,+Mode,-IOport)}{file\_io} \index{{\tt file\_open/3}}
    Opens a file with name {\tt FileName} to be accessed
    in mode {\tt Mode} and returns a file-descriptor in {\tt IOport} that
    can be used to access the file.  If {\tt Mode} is atom ``{\tt r}'', the
    the file is opened for reading; if it is ``{\tt w}'', the file is
    opened for writing; if it is ``{\tt a}'', the file is opened for
    appending.  If {\tt Mode} is ``{\tt s}'', then the string making
    up the atom {\tt FileName} is treated as the contents of the file, and
    a descriptor is returned that allows ``file'' access to that string.
    This is how one can use XSB's term I/O routines to build terms from
    atoms.

    The old-style mode specification, 0 ({\tt OREAD}), 1 ({\tt OWRITE}), 2
    ({\tt OAPPEND}), or 3 ({\tt OSTRING}), is also supported.

\ournewitem{file\_reopen(+FileName,+Mode,+IOport,-RetCode)}{file\_io}\index{{\tt file\_reopen/1}}
    Takes an existing I/O port, closes it, then opens it and
    attaches it to a file. This can be used to redirect I/O from any of the
    standard streams to a file. For instance, 
%%
\begin{verbatim}
    | ?- file_reopen('/dev/null', w, 3, Error).
\end{verbatim}
%%
    redirects all warnings to the Unix black hole. 

    On success, {\tt RetCode} is 0; on error, the return code is negative.

\ournewitem{file\_clone(+SrcIOport,?DestIOport,-RetCode)}{file\_io}\index{{\tt file\_clone/1}}
    This is yet another way to redirect I/O. It is a prolog interface to
    the C {\tt dup} and {\tt dup2} system calls. If {\tt DestIOport} is a
    variable, then this call creates a new XSB I/O port that is a
    clone of {\tt SrcIOport}. This means that I/O sent to either
    descriptor goes to the same place. If {\tt DestIOport} is not a
    variable, then it must be a number corresponding to a valid I/O
    port. In this case, XSB closes {\tt DestIOport} and makes it 
    into a clone on {\tt SrcIOport}. For instance, suppose that 10 is a
    I/O port that is currently open for writing to file {\tt foo.bar}.
    Then
    %%
    \begin{verbatim}
    | ?- file_clone(10,3,_).      
    \end{verbatim}
    %%
    causes all messages sent to XSB standard warnings port to go to file
    {\tt foo.bar}. While this could be also done with {\tt file\_reopen},
    there are things that only {\tt file\_clone} can do:
    %%
    \begin{verbatim}
    | ?- file_clone(1,10,_).      
    \end{verbatim}
    %%
    This means that I/O port 10 now becomes clone of standard
    output. So, all subsequent I/O will now go to standard output instead
    of {\tt foo.bar}. 

    On success, {\tt RetCode} is 0; on error, the return code is negative.

\ournewitem{file\_close(+IOport)}{file\_io}\index{{\tt file\_close/1}}
    Closes the file (or string) for descriptor {\tt IOport}.

\ournewitem{fmt\_read(+Fmt,-Term,-Ret)}{file\_io}\index{{\tt fmt\_read/3}}
%\predindex{fmt\_read/4~(L)}
    This predicate provides a low-level routine for reading data from
    the current input file (which must have been already opened by using
    {\tt see/1}) according to a C format, as used in the C function
    {\tt scanf}. To use it, it must be imported from the module {\tt
    file\_io}.  {\tt Fmt} must be a string of characters (enclosed in "")
    representing the format that 
    will be passed to the C call to {\tt scanf}.  See the C
    documentation for {\tt scanf} for the meaning of this string.
    The usual alphabetical C escape characters ({\it e.g.}, $\backslash n$)
    are recognized, but not the octal or the hexadecimal ones.
    Another difference with C is that, unlike most C compilers, XSB insists
    that a single {\tt \%} in the format string signifies format conversion
    specification. (Some C compilers might output {\tt \%} if it is not
    followed by a valid type conversion spec.) So, to output {\tt \%}
    you must type {\tt \%\%}.
    Format can also be an atom enclosed in single quotes. However, in that
    case, escape sequences are not recognized and are printed as is.

    {\tt Term} is a term ({\it e.g.}, {\tt args(X,Y,Z)})  whose arguments
    will be unified with the field values read in.  (The functor symbol of {\tt
    Term} is ignored.)  Special syntactic sugar is provided for the case
    when the format string contains only one format specifier: If {\tt
    Term} is a variable, {\tt X}, then the predicate behaves as if {\tt
    Term} were {\tt arg(X)}.

  If the number of arguments exceeds the number of format specifiers, a
  warning is produced and the extra arguments remain uninstantiated.
  If the number of format specifiers exceeds the number of arguments, then
  the remainder of the format string (after the last matching specifier) is
  ignored.
  
  Note that floats do not unify with anything.  {\tt Ret} must be a
  variable and it will be assigned a return value by the predicate: a
  negative integer if end-of-file is encountered; otherwise the number of
  fields read (as returned by {\tt scanf}.)

\ournewitem{fmt\_write(+Fmt,+Term)}{file\_io}\index{{\tt fmt\_write/2}}
    This predicate provides a low-level routine for writing data to
    the current output file (which must have been already opened by using
    {\tt tell/1}) according to a C format, as used in the C function
    {\tt printf}.
    To use it, it must be imported from the module {\tt file\_io}.
    {\tt Fmt} must be a string of characters (enclosed in "")
    representing the format that 
    will be passed to the C call to {\tt scanf}.  See the C
    documentation for {\tt scanf} for the meaning of this string.
    The usual alphabetical C escape characters ({\it e.g.}, $\backslash n$)
    are recognized, but not the octal or the hexadecimal ones.

    In addition to the usual C conversion specifiers, {\tt \%S} is also
    allowed. The corresponding argument can be any Prolog term. This
    provides an easy way to print the values of Prolog variables, etc.

    Another difference with C is that, unlike most C compilers, XSB insists
    that a single {\tt \%} in the format string signifies format conversion
    specification. (Some C compilers might output {\tt \%} if it is not
    followed by a valid type conversion spec.) So, to output {\tt \%}
    you must type {\tt \%\%}.
    
    Format can also be an atom, but then escape sequences are not
    recognized.

    {\tt Term} is a term ({\it e.g.}, {\tt args(X,Y,Z)}) whose arguments
    will be output. The functor symbol of {\tt Term} is ignored.
    
    Special syntactic sugar is provided for the following cases: If {\tt
      Term} is a variable, {\tt X}, then it is ignored and only the format
    string is printed. If {\tt Term} is a string, integer or a float, then
    it is assumed that this is the only argument to be printed, {\it i.e.},
    it is equivalent to specifying {\tt arg(Term)}.

    If the number of format specifiers is greater than the number of
    arguments to be printed, an error is issued. If the number of arguments
    is greater, then a warning is issued.

\ournewitem{fmt\_write\_string(-String,+Fmt,+Term)}{file\_io}\index{{\tt fmt\_write\_string/2}}
    This predicate works like the C function {\tt sprintf}. It takes the
    format string and substitutes the values from the arguments of {\tt
      Term} ({\it e.g.}, {\tt args(X,Y,Z)}) for the formatting instructions
    \%s, \%d, etc. Additional syntactic sugar, as in \verb|fmt_write|, is
    recognized. The result is available in {\tt String}. {\tt Fmt} is a
    string or an atom that represents the format, as in
    {\tt fmt\_write}.
    
    If the number of format specifiers is greater than the number of
    arguments to be printed, an error is issued. If the number of arguments
    is greater, then a warning is issued.

\ournewitem{file\_flush(+IOport, -Return)}{file\_io}
\index{{\tt file\_flush/2}}
    Any buffered data gets delivered. If the call is successful, {\tt Return}
    is zero; otherwise {\tt EOF} is returned.

\ournewitem{file\_seek(+IOport, +Offset, +Place, -Return)}{file\_io}
\index{{\tt file\_seek/4}}
    Sets the file position indicator for the next input or output
    operation. The position is {\tt Offset} bytes from {\tt Place}.
    The value of {\tt Place} can be 0, 1, or 2, which correspond to
    the beginning of the file, the current position in the file, or
    the end of the file, respectively. If the call is successful,
    {\tt Return} is set to zero.

\ournewitem{file\_pos(+IOport, -Position)}{file\_io}
\index{{\tt file\_pos/2}}
    Unifies {\tt Position} with the position inside the file indicated by
    {\tt IOport}.

\ournewitem{file\_truncate(+IOport, +Length, -Return)}{file\_io}
\index{{\tt file\_truncate/3}}
    The regular file  referenced by the I/O port {\tt IOport}
    is chopped to have the size of {\tt Length} bytes. Upon successful
    completion {\tt Return} is set to zero.

\ournewitem{file\_write(+IOport,+Term)}{xsb\_writ}
\index{{\tt file\_write/2}}
    Writes the term {\tt Term} to the file (or string) with descriptor {\tt
    IOport}.

\ournewitem{file\_read(+IOport,-Term)}{xsb\_read}
\index{{\tt file\_read/2}}
    Reads a term from the file (or string) with descriptor {\tt
    IOport} into {\tt Term}.  Note that the term must be terminated
    with a period (.) (whether it appears in a file or in a string.)

\ournewitem{file\_read(+IOport,-Term,-Vars)}{xsb\_read}
\index{{\tt file\_read/3}}
    Reads a term from the file (or string) with descriptor {\tt
    IOport} into {\tt Term}, and returns in {\tt Vars} an open-tailed list of
    pairs of names of variables and the variables themselves that
    appear in Term.  For example, reading a term {\tt f(a,X,Y,X)}
    would result in {\tt term} being bound to {\tt
    f(a,\_25,\_26,\_25)} (for some internal variables) and {\tt Vars}
    being bound to {[vv('X',\_25),vv('Y',\_26)|\_83]}.  Note that the
    pairing functor symbol is {\tt vv/2} and it must be imported from
    {\tt xsb\_read} along with this read predicate.  Also note that 
    {\tt Vars} is not a proper list, but has a free variable instead 
    of [] at its end.

\ournewitem{file\_read\_canonical(+IOport,-Term,-Psc)}{machine}
\index{{\tt file\_read\_canonical/3}}
    Reads a term that is in canonical format from the the I/O port
    indicated by {\tt IOport} (as returned by {\tt file\_open/3} or
    by {\tt stat\_flag(10,IOport))}, and returns it in {\tt Term}.
    It also returns (in {\tt Psc}) the psc address of the main functor
    symbol of the term, if it is the same as that of the previously
    read term, and the current term is a ground (non 0-ary) fact.
    (This is used for efficiency in the implementation of {\tt
    load\_dync/1}).  Otherwise {\tt Psc} is set to 0.  To initialize
    its previous psc value to zero, this predicate can be called with
    {\tt IOport} of -1000.

\ournewitem{file\_read\_line(+IOport,-String,-IsFullLine)}{file\_io}
\index{{\tt file\_read\_line/3}}
    This is a low-level predicate that allows XSB to read input files
    efficiently, line by line. It returns the string read from {\tt
      IOport} using the variable {\tt String}. The output variable {\tt
      IsFullLine} is 1, if the line read contains the newline character at
    the end. Otherwise, it is 0. This latter case arises in two situations:
    when the last line in the stream does not have a newline  character or
    when the line is very long, longer than the buffer allocated for that
    purpose. (In such a case {\tt file\_read\_line/3} will read only as
    much as the buffer allows.) 

    This predicate fails on reaching the end of file.
    
    {\bf Important}: This predicate does not intern the string it reads
    from the input, so you cannot unify or compare the value read with
    anything. Moreover, if you use this predicate twice, then the second
    call replaces the value read by the first call. In other words, this
    predicate is very low-level and should be used with great care.
    One simple use of this facility is to copy one file into another.
    See \verb|file_read_line_atom| and \verb|file_read_line_list| for
    alternatives that are easier to use.

\ournewitem{file\_read\_line\_atom(+IOport,-String,-IsFullLine)}{file\_io}
\index{{\tt file\_read\_line\_atom/3}}
    This predicate is like \verb|file_read_line|, but the line read from
    the input is interned. Therefore, {\tt String} is instantiated
    to a normal atom. This predicate fails on reaching the end of file.
    
    {\bf Important}: At present, XSB does not have atom table garbage
    collector. Therefore, each line read from the file using this predicate
    gets stored in the atom table. Thus, large files can cause XSB to run
    out of memory.  This problem will go away when atom table garbage
    collection is implemented.

\ournewitem{file\_read\_line\_atom(-String,-IsFullLine)}{file\_io}
\index{{\tt file\_read\_line\_atom/2}}
   Like \verb|file_read_line_atom/3|, but {\tt IOport} is not required.
   The file being read is the one previously opened with {\tt see/1}.

\ournewitem{file\_read\_line\_list(+IOport,-CharList,-IsFullLine)}{file\_io}
\index{{\tt file\_read\_line\list/3}}
    This predicate is like \verb|file_read_line_atom|, but the line read from
    the input is converted into a list of characters.
    This predicate is \emph{much} more efficient than {{\tt fget\_line/3}}
    (see below), and is recommended when speed is important.
    This predicate fails on reaching the end of file.

\ournewitem{file\_read\_line\_list(-String,-IsFullLine)}{file\_io}
\index{{\tt file\_read\_line\_list/2}}
   Like \verb|file_read_line_list/3|, but {\tt IOport} is not required.
   The file being read is the one previously opened with {\tt see/1}.

\ournewitem{fget\_line(+Str,-Inlist,-Next)}{scrptutl}
\index{{\tt fget\_line/3}}
    {\tt fget\_line/3} reads one line from the input stream {\tt Str} and
    unifies {\tt Inlist} to the list of ASCII integers representing the
    characters in the line, and {\tt Next} to the line terminator, either
    a newline ({\tt 10}) or EOF ({\tt-1}).
    
    This predicate exists for backward compatibility. It is very
    inefficient compared to \verb|file_read_line_list|.

\ournewitem{file\_write\_line(+IOport, +String, +Offset)}{file\_io}
\index{{\tt file\_write\_line/3}}
   Write {\tt String} beginning with character {\tt Offset}  to the output
   file represented by the I/O port {\tt IOport}. {\tt String} can
   be an atom or a list of ASCII characters. This does \emph{not} put the
   newline character at the end of the string (unless {\tt String} already
   had this character). Note that escape sequences, like \verb|\n|, are
   recognized if {\tt String} is a character list, but are output as is if
   {\tt String} is an atom.
   
\ournewitem{file\_write\_line(+String, +Offset)}{file\_io}
\index{{\tt file\_write\_line/2}}
   Like \verb|file_write_line/3|, but output goes to the currently open
   output stream.


\ournewitem{file\_getbuf(+IOport, +BytesRequested, -String, -BytesRead)}{file\_io}
\index{{\tt file\_getbuf/4}}
Read {\tt BytesRequested} bytes from file represented by I/O port {\tt
  IOport} (which must already be open for reading) into variable {\tt
  String}. This is analogous to {\tt fread} in C.  This predicate always
succeeds. It does not distinguish between a file error and end of file.
You can determine if either of these conditions has happened by verifying
that $\tt BytesRead < BytesRequested$.

Note: The string read is {\bf not} interned. Please see explanations to
\verb|file_read_line| on this matter. Because of the difficulties in using
this predicate, the predicates \verb|file_getbuf_atom| and
\verb|file_getbuf_list| are often better alternatives.

\ournewitem{file\_getbuf\_atom(+IOport, +BytesRequested, -String, -BytesRead)}{file\_io}
\index{{\tt file\_getbuf\_atom/4}}
Like \verb|file_getbuf|, but {\tt String} is instantiated to an interned atom.

Note: because XSB does not have an atom table garbage collector yet, this
predicate should not be used to read large files.

\ournewitem{file\_getbuf\_atom(+BytesRequested, -String, -BytesRead)}{file\_io}
\index{{\tt file\_getbuf\_atom/3}}
Like \verb|file_getbuf_atom/4|, but reads from the currently open input stream
(using {\tt see/1}). This predicate always
succeeds. It does not distinguish between a file error and end of file.
You can determine if either of these conditions has happened by verifying
that $\tt BytesRead < BytesRequested$.

\ournewitem{file\_getbuf\_list(+IOport, +BytesRequested, -CharList, -BytesRead)}{file\_io}
\index{{\tt file\_getbuf\_list/4}}
Like \verb|file_getbuf_atom/4|, but {\tt CharList} is instantiated to a list
of characters that represent the string read from the input.

\ournewitem{file\_getbuf\_list(+BytesRequested, -String, -BytesRead)}{file\_io}
\index{{\tt file\_getbuf\_list/3}}
Like \verb|file_getbuf_list/3|, but reads from the currently open input stream
({\it i.e.}, with {\tt see/1}).


\ournewitem{file\_putbuf(+IOport, +BytesRequested, +String, +Offset, -BytesWritten)}{file\_io}
\index{{\tt file\_putbuf/5}}
Write {\tt BytesRequested} bytes into file represented by I/O port {\tt
  IOport} (which must already be open for writing) from variable {\tt
  String} at position {\tt Offset}. This is analogous to C {\tt fwrite}.
The value of {\tt String} can be an atom or a list of ASCII characters.

\ournewitem{file\_putbuf(+BytesRequested, +String, +Offset, -BytesWritten)}{file\_io}
\index{{\tt file\_putbuf/4}}
Like \verb|file_putbuf/3|, but output goes to the currently open output stream.


\end{description}

\section{Script Writing Utilities}
%========================

Prolog, (or XSB) can be useful for writing scripts in a UNIX system.
Prolog's simple syntax and declarative semantics make it especially
suitable for scripts that involve text processing.  The following
library functions are intended to be used on UNIX-based platforms.
Furthermore, they are new to Version 1.7 and should be considered to
be in the Beta test stage.

\begin{description}
\ournewitem{date(?Date)}{scrptutl}
\index{{\tt date/1}}
       Unifies {\tt Date} to the current date, returned as a Prolog
term, suitable for term comparison.

Example:
{\footnotesize
\begin{verbatim}
                > date 
                Thu Feb 20 08:46:08 EST 1997
                > xsb -i
               XSB Version 1.7
               [sequential, single word, optimal mode]
               | ?- [scrptutl].
               [scrptutl loaded]

               yes
               | ?- date(D).
               D = date(1997,1,20,8,47,41)

               yes
\end{verbatim}}

\ournewitem{file\_time(+FileName, -time(Time1,Time2))}{file\_io}
\index{{\tt file\_time/2}}

Returns file's modification time. Because 
XSB steals 5 bits from each word, time must be returned as two words:
Time1, representing the most significant digits, and Time2, representing
the less significant digits.

\ournewitem{file\_size(+FileName, -Size)}{file\_io}
\index{{\tt file\_size/2}}

Returns file size.

\ournewitem{directory(+Path,?Directory)}{directry}
\index{{\tt directory/2}}

	Unifies {\tt Directory} with a list of files in the directory
specified by path.  Information about the files is similar to that
obtained by {\tt ls -l}, but transformed for ease of processing.


\ournewitem{expand\_filename(+FileName,-ExpandedName)}{machine}
\index{{\tt expand\_filename/2}}
Expands the file name passed as the first argument and binds the variable
in the second argument to the expanded name. This includes expanding Unix
tildas, prepending the current directory, etc. In addition, the expanded
file name is ``rectified'' so that multiple repeated slashes are replaced
with a single slash, the intervening ``./'' are removed, and ``../'' are
applied so that the preceding item in the path name is deleted. For
instance, if the current directory is {\tt /home}, then {\tt
  abc//cde/..///ff/./b} will be converted into {\tt /home/abc/ff/b}.

Under NT and Windows, this predicates does rectification (using
backslashes when appropriate), but it does not expand the tildas.

\ournewitem{tilde\_expand\_filename(+FileName,-ExpandedName)}{machine}
\index{{\tt tilde\_expand\_filename/2}}
Like {\tt expand\_filename/2}, but only expands tildas and does
rectification. This does not prepend the current working directory to
relative file names.

\ournewitem{is\_absolute\_filename(+FileName)}{machine} \index{{\tt
is\_absolute\_filename/1}} Succeeds, if file name is absolute; fails
otherwise.  This predicate works also under NT and Windows, {\it
i.e.}, it recognizes drive letters, etc.

\ournewitem{parse\_filename(+FileName,-Dir,-Base,-Extension)}{machine}
\index{{\tt parse\_filename/4}}
This predicate parses file names by separating the directory part, the base
name part, and file extension. If file extension is found, it is removed
from the base name. Also, directory names are rectified and if a directory
name starts with a tilde (in Unix), then it is expanded. Directory names
always end with a slash or a backslash, as appropriate for the OS at hand.

For instance, {\tt $\sim$john///doe/dir1//../foo.bar} will be parsed into:
{\tt /home/john/doe/}, {\tt foo}, and {\tt bar} (where we assume that    
{\tt /home/john} is what {\tt $\sim$john} expands into).  


%% This predicate is superseded by spawn_process/5 and shell/5
%% Do not use it!
%%
%%\ournewitem{sysin(+Command,?Output)}{scrptutl}
%%\index{{\tt sysin/2}}
%%
%%	Unifies {\tt Output} with the stdout of {\tt Command}
%%represented as a list of lists of tokens, where each element in the
%%outer list of {\tt Command} represents a line of stdout.
%%
%%Example:
%%{\footnotesize
%%\begin{verbatim}
%%                > uname -a
%%                Linux swiftlap 1.2.8 #1 Sun May 7 13:10:10 CDT 1995 i486
%%                | ?- sysin('uname -a',Output).
%%
%%                Output = [[Linux,swiftlap,1.2.8,#1,Sun,May,7,13:10:10,CDT,1995,i486]]
%%
%%                yes
%%\end{verbatim}}

\end{description}


\section{Communication with Subprocesses}

In the previous section, we have seen several predicates that allow XSB to
create other processes. However, these predicates offer only a very limited
way to communicate with these processes. The predicate
\verb|spawn_process/5| and friends come to the rescue. It allows to spawn
any process (including multiple copies of XSB) and redirect its standard
input and output to XSB I/O ports. XSB can then write to the process and
read from it. The section of socket I/O describes yet another mode of
interprocess communication. 

In addition, the predicate {\tt pipe\_open/2} described in this section
lets one create any number of pipes (that do not need to be connected to
the standard I/O port) and talk to child processes through these pipes.

All predicates in this section, except {\tt pipe\_open/2} and
{\tt fd2ioport/2}, must be imported from module {\tt shell}.
The predicates {\tt pipe\_open/2} and
{\tt fd2ioport/2} must be imported from {\tt file\_io}.

\begin{description}
\ouritem{spawn\_process(+CmdSpec,-StreamToProc,-StreamFromProc,-ProcStderrStream,-ProcId)}\index{{\tt spawn\_process/5}} 
Spawn a new process specified by {\tt CmdSpec}. {\tt CmdSpec} must be
either a single atom or a \emph{list} of atoms.
If it is an atom, then it must represent a shell command.
If it is a list, the first member of the list must be the name of the
program to run and the 
other elements must be arguments to the program. Program name must be specified
in such a way as to make sure the OS can find it using the contents of the
environment variable {\tt PATH}.
Also note that pipes, I/O redirection and such are not allowed in command
specification. That is, {\tt CmdSpec} must represent a single command.
(But read about process plumbing below and about the related predicate
{\tt shell/5}.)

The next three parameters of \verb|spawn_process| are XSB I/O ports
to the process (leading to the subprocess standard input), from the process
(from its standard output), and a port capturing the
subprocess standard error output. The last parameter is the system process id.
\end{description}
%%

\noindent
Here is a simple example of how it works.

%%
\begin{verbatim}
| ?- import file_flush/2, file_read_line_atom/3 from file_io.
| ?- import file_nl/1 , file_write/2 from xsb_writ.  

| ?- spawn_process([cat, '-'], To, From, Stderr, Pid),
     file_write(To,'Hello cat!'), file_nl(To), file_flush(To,_),
     file_read_line_atom(From,Y,_).

To = 3
From = 4
Stderr = 5
Pid = 14328
Y = Hello cat!

yes
\end{verbatim}
%%

Here we created a new process, which runs the ``{\tt cat}'' program
with argument ``--''. This forces {\tt cat} to read from standard input and
write to standard output. The next line writes a newline-terminated string
to the XSB port {\tt To} the, which is bound to the standard input of the
{\tt cat} process. The process then copies the input to the standard output.
Since standard output of the process is redirected to the XSB port {\tt
  From}, the last line in our program is able to read it and return in the
variable {\tt Y}.

Note that in the second line we used {\tt file\_flush/2}. Flushing the
output is extremely important here, because XSB I/O ports are buffered.
Thus, {\tt cat} might not see its input until the buffer is filled up, so
the above clause might hang. {\tt file\_flush/2} makes sure that the input
is immediately available to the subprocess.

In addition to the above general schema, the user can tell
\verb|spawn_process/5| to not open one of the communication ports or to
use one of the existing communication ports.  This is useful when you do
not expect to write or read to/from the subprocess or when one process
wants to write to another (see the process plumbing example below).

To tell that a certain port is not needed, it suffices to bind that port to
an atom.  For instance,
%%
\begin{verbatim}
| ?- spawn_process([cat, '-'], To, none, none, _),
     file_nl(To), file_write(To,'Hello cat!'), file_nl(To), file_flush(To,_).


To = 3,
Hello cat!
\end{verbatim}
%%
reads from XSB and copies the result to standard output. Likewise,
%%
\begin{verbatim}
| ?- spawn_process('cat test', none, From, none, _),
     file_read_line_atom(From, S, _).

From = 4
S = The first line of file `test'
\end{verbatim}
%%
In each case, only one of the ports is open. (Note that the shell command
is specified as an atom rather than a list.) Finally, if both ports are
suppressed, then \verb|spawn_process| reduces to the usual
{\tt shell/1} call (in fact, this is how {\tt shell/1} is implemented):
%%
\begin{verbatim}
| ?- spawn_process([pwd], none, none).

/usr/local/foo/bar
\end{verbatim}
%%
On the other hand, if any one of the three port variables in
\verb|spawn_process| is bound to an already existing file port, then the
subprocess will use that port (see the process plumbing example below).

One of the uses of XSB subprocesses is to create XSB servers that spawn
subprocesses and control them. A spawned subprocess can be another XSB
process. The following example shows one XSB process spawning another,
sending it a goal to evaluate and obtaining the result:
%%
\begin{verbatim}
| ?- spawn_process([xsb], To, From,Err,_),
     file_write(To,'assert(p(1)).'), file_nl(To), file_flush(To,_),
     file_write(To,'p(X), writeln(X).'), file_nl(To), file_flush(To,_), 
     file_read_line_atom(From,XX,_).  

XX = 1

yes
| ?-
\end{verbatim}
%%
Here the parent XSB process sends ``\verb|assert(p(1)).|'' and then
``\verb|p(X), writeln(X).|'' to the spawned XSB subprocess. The latter
evaluates the goal and prints (via ``\verb|writeln(X)|'')
to its standard output. The main process reads it through the {\tt From}
port and binds the variable {\tt XX} to that output.

Finally, we should note that the port variables in the
\verb|spawn_process| predicate can be used to do process plumbing, {\it
  i.e.}, redirect output of one subprocess into the input of another. Here
is an example:
%%
\begin{verbatim}
| ?- file_open(test,w,IOport),
     spawn_process([cat, 'data'], none, FromCat1, none, _),
     spawn_process([sort], FromCat1, IOport, none, _).  
\end{verbatim}
%%
Here, we first open file {\tt test}. Then \verb|cat data| is spawned.  This
process has the input and standard error ports blocked (as indicated by the
atom {\tt none}), and its output goes into port FromCat1.  Then we spawn
another process, {\tt sort}, which picks the output from the first process
(since it uses the port {\tt FromCat1} as its input) and sends its own
output (the sorted version of {\tt data}) to its output port {\tt IOport}.
However, {\tt IOport} has already been open for output into the file {\tt
  test}. Thus, the overall result of the above clause is tantamount to the
following shell command:
%%
\begin{verbatim}
        cat data | sort > test  
\end{verbatim}
%%

\paragraph{\em Important notes about spawned processes\/}:
\begin{enumerate}
\item Asynchronous processes spawned by XSB do not disappear (at least on
  Unix) when they terminate, \emph{unless} the XSB program executes a
  \emph{wait} on them (see {\tt process\_control} below). Instead, such
  processes become defunct \emph{zombies} (in Unix terminology); they do
  not do anything, but consume resources (such as file descriptors). So,
  when a subprocess is known to terminate, it must be waited on.
  
\item The XSB parent process must know how to terminate the asynchronous
  subprocesses it spawns. The drastic way is to kill it (see {\tt
    process\_control} below). Sometimes a subprocess might terminate by
  itself ({\it e.g.}, having finished reading a file). In other cases, the
  parent and the child programs must agree on a protocol by which the
  parent can tell the child to exit. The programs in the XSB subdirectory
  {\tt examples/subprocess} illustrate this idea. If the child subprocess
  is another XSB process, then it can be terminated by sending the atom
  {\tt end\_of\_file} or {\tt halt} to the standard input of the child.
  (For this to work, the child XSB must waiting at the prompt).
\item It is very important to not forget to close the I/O ports that the
  parent uses to communicate with the child. These are the ports that are
  provided in arguments 2,3,4 of {\tt spawn\_process}. The reason
  is that the child might terminate, but these ports will remain open,
  since they belong to the parent process. As a result, the parent will own
  defunct I/O ports and might eventually run out of file descriptors.
\end{enumerate}

\begin{description}
\ouritem{process\_status(+Pid,-Status)}\index{{\tt process\_status/2}} 
    This predicate always succeeds. Given a process id, it binds the second
    argument (which must be an unbound variable) to one of the following
    atoms: {\tt running}, {\tt stopped}, {\tt exited} (normally), {\tt
      aborted} (abnormally), {\tt invalid}, and {\tt unknown}.
    The {\tt invalid} status is given to processes that never existed or
    that are not children of the parent XSB process. The {\tt unknown}
    status is assigned when none of the other statuses can be assigned.

    Note: process status (other than {\tt running}) is system dependent.
    Windows does not seem to support {\tt stopped} and {\tt aborted}.
    Also, processes killed using the \verb|process_control| predicate
    (described next) are often marked as {\tt invalid} rather than {\tt
    exited}, because Windows seems to lose all information about such
    processes.
\ouritem{process\_control(+Pid,+Operation)}\index{{\tt process\_control/2}} 
    Perform a process control {\tt operation} on the process with the given
    {\tt Pid}. 
    Currently, the only supported operations are {\tt kill} and {\tt wait}
    (both must be atoms).
    The former causes the process to exit unconditionally, and the latter
    waits for process completion.

    This predicate succeeds, if the operation was performed successfully.
    Otherwise, it fails. The {\tt wait} operation fails if the process
    specified in {\tt Pid} does not exist or is not a child of the parent
    XSB process. 
    
    The {\tt kill} operation might fail, if the process to be killed does
    not exist or if the parent XSB process does not have the permission to
    terminate that process. Unix and Windows have different ideas as to
    what these permissions are. See \emph{kill(2)} for Unix and
    \emph{TerminateProcess} for Windows.
    
    \emph{Note}: under Windows, the programmer's manual warns of dire
    consequences if one kills a process that has DLLs attached to it.
\ouritem{get\_process\_table(-ProcessList)}\index{{\tt get\_process\_table/1}} 
    Binds {\tt ProcessList} to the list of terms, each describing one of
    the active XSB subprocesses (created via \verb|spawn_process/5|).
    Each term has the form:
    %%
    \begin{center}
      \verb|process(Pid,ToStream,FromStream,StderrStream,CommandLine)|. 
    \end{center}
    %%
    The first argument in the term is the process id of the corresponding
    process, the next three arguments describe the three standard ports
    of the process, and the lat is an atom that shows the command line used
    to invoke the process.
    This predicate always succeeds.

\ouritem{shell(+CmdSpec,-StreamToProc, -StreamFromProc, -ProcStderr,
  -ErrorCode)}\index{{\tt shell/5}} 
    The arguments of this predicate are similar to those of
    \verb|spawn_process|, except for the following:
    (1) The first argument is an atom or a list of atoms, like in
    \verb|spawn_process|. However, if it is a list of atoms, then the
    resulting shell command is obtained by string concatenation. This is
    different from \verb|spawn_process| where each member of the list must
    represent an argument to the program being invoked (and which must be
    the first member of that list).  (2) The last argument is the error
    code returned by the shell command and not a process id. The code -1
    and 127 mean that the shell command failed.
    
    The {\tt shell/5} predicate is similar to \verb|spawn_process| in that
    it spawns another process and can capture that process' input and
    output ports.
    
    The important difference, however, is that XSB will ways until the
    process spawned by {\tt shell/5} terminates. In contrast, the process
    spawned by \verb|spawn_process| will run concurrently with XSB.  In
    this latter case, XSB must explicitly synchronize with the spawned
    subprocess using the predicate \verb|process_control/2| (using the {\tt
      wait} operation), as described earlier.
    
    The fact that XSB must wait until {\tt shell/5} finishes has a very
    important implication: the amount of data the can be sent to and from
    the shell command is limited (1K is probably safe). This is because the
    shell command communicates with XSB via pipes, which have limited
    capacity.  So, if the pipe is filled, XSB will hang waiting for {\tt
      shell/5} to finish and {\tt shel/5} will wait for XSB to consume data
    from the pipe.  Thus, use \verb|spawn_process/5| for any kind of
    significant data exchange between external processes and XSB.
  
  Another difference between these two forms of spawning subprocesses is
  that {\tt CmdSpec} in {\tt shell/5} can represent \emph{any} shell
  statement, including those that have pipes and I/O redirection. In
  contrast, \verb|spawn_process| only allows command of the form ``program
  args''. For instance,
%%
\begin{verbatim}
| ?- file_open(test,w,IOport),
     shell('cat | sort > data', IOport, none, none, ErrCode)
\end{verbatim}
%%
As seen from this example, the same rules for blocking I/O streams
apply to {\tt shell/5}. Finally, we should note that the already familiar
standard predicates {\tt shell/1} and {\tt shell/2} are implemented using
shell/5.

\paragraph{\em Notes:}
%%
\begin{enumerate}
  \item  With {\tt shell/5}, you do not have to worry about terminating
    child processes: XSB waits until the child exits automatically.
    However, since communication pipes have limited capacity, this method
    can be used only for exchanging small amounts of information between
    parent and child.
  \item The earlier remark about the need to close I/O streams to the child
    \emph{does} apply.
\end{enumerate}
%%

\ouritem{pipe\_open(-ReadPipe, -WritePipe)}\index{{\tt pipe\_open/2}} 
  Open a new pipe and return the read end and the write end of that pipe.
  If the operation fails, both {\tt ReadPipe} and {\tt WritePipe} are bound
  to negative numbers.
  
  The pipes returned by the {\tt pipe\_open/2} predicate are small integers
  that represent file descriptors used by the underlying OS. They are {\bf
    not XSB I/O ports}, and they cannot be used for I/O directly. To
  use them, one must call the {\tt fd2ioport/2} predicate, as described
  next.\footnote{
    %%
    XSB does not convert pipes into I/O ports automatically.
    Because of the way XSB I/O ports are represented, they are not
    inherited by the child process and they do not make sense to the child
    process (especially if the child is not another xsb). Therefore, we
    must pass the child processes an OS file descriptor instead. The child then
    converts these descriptor into XSB I/O ports.
    %%
    }
\ouritem{fd2ioport(+Pipe, -IOport)}\index{{\tt fd2ioport/2}} 
    Take a pipe and convert it to an XSB I/O port that can be used
    for I/O. This predicate is needed because pipes must be associated with
    XSB I/O ports before any I/O can be on them by an XSB program.

    The best way to illustrate how one can create a new pipe to a child
    (even if the child has been created earlier) is to show an example.
    Consider two programs, {\tt parent.P} and {\tt child.P}. The parent
    copy of XSB consults {\tt parent.P}, which does the following: First, it
    creates a pipe and spawns a copy of XSB. Then it tells the
    child copy of XSB to assert the fact {\tt pipe(RP)}, where {\tt RP} is
    a number representing the read part of the pipe. Next, the parent XSB tells
    the child XSB to consult the program {\tt child.P}. Finally, it sends
    the message {\tt Hello!}.

    The {\tt child.P} program gets the pipe from predicate {\tt pipe/1}
    (note that the parent tells the child XSB to first assert {\tt
    pipe(RP)} and only then to consult the {\tt child.P} file).
  After that, the child reads a message from the pipe and prints it to its
    standard output. Both programs are shown below:
    %%
    \begin{verbatim}
%% parent.p      
:- import pipe_open/2, fd2ioport/2, fmt_write/3, file_flush/2 from file_io.
%% Create the pipe and pass it to the child process
?- pipe_open(RP,WP),
   %% WF is now the XSB I/O port bound to the write part of the pipe
   fd2ioport(WP,WF),
   %% We aren't going to read from child, so let's close the pipe coming 
   %% from it -- we don't want to run out of file descriptors!!!
   fd2ioport(RP,RF), file_close(RF),
   %% ProcInput becomes the XSB stream leading directly to the child's stdin
   spawn_process(xsb, ProcInput, block, block, Process),
   %% Tell the child where the reading part of the pipe is
   fmt_write(ProcInput, "assert(pipe(%d)).\n", arg(RP)),
   fmt_write(ProcInput, "[child].\n", _),
   file_flush(ProcInput, _),
   %% Pass a message through the pipe
   fmt_write(WF, "Hello!\n", _),
   file_flush(WF, _),
   fmt_write(ProcInput, "end_of_file.\n",_), % send end_of_file atom to child
   file_flush(ProcInput, _),
   %% wait for child (so as to not leave zombies around; 
   %% zombies quit when the parent finishes, but they consume resources)
   process_control(Process, wait),
   %% Close the ports used to commuicate with the process
   %% Otherwise, the parent might run out of file descriptors 
   %% (if many processes were spawned)
   file_close(ProcInput), file_close(WF).
    \end{verbatim}
    %%
    %%
    \begin{verbatim}
%% child.P
:- import fd2ioport/2 from file_io.
:- import file_read_line_atom/3 from file_io.
:- dynamic pipe/1.
?- pipe(P), fd2ioport(P,F),
   %% Acknowledge receipt of the pipe
   fmt_write("\nPipe %d received\n", arg(P)),
   %% Get a message from the parent and print it to stdout
   file_read_line_atom(F, Line,_), write('Message was: '), writeln(Line).
    \end{verbatim}
    %%
    This produces the following output:
    %%
    \begin{verbatim}
| ?- [parent].                    <- parent XSB consults parent.P
[parent loaded]
yes
| ?- [xsb_configuration loaded]   <- parent.P spawns a child copy of XSB
[sysinitrc loaded]                   Here we see the startup messages of
[packaging loaded]                   the child copy
XSB Version 2.0 (Gouden Carolus) of June 27, 1999
[i686-pc-linux-gnu; mode: optimal; engine: slg-wam; scheduling: batched]
| ?- 
yes
| ?- [Compiling ./child]          <- The child copy of received the pipe from
[child compiled, cpu time used: 0.1300 seconds]     the parent and then the
[child loaded]                                      request to consult child.P
Pipe 15 received                  <- child.P acknowledges receipt of the pipe
Message was: Hello!               <- child.P gets the message and prints it
yes       
    \end{verbatim}
    %%
    
    Observe that the parent process is very careful about making sure that
    the child terminates and also about closing the I/O ports after they
    are no longer needed.
    
    Finally, we should note that this mechanism can be used to communicate
    through pipes with non-XSB processes as well. Indeed, an XSB process
    can create a pipe using {\tt pipe\_open} (\emph{before} spawning a
    child process), pass one end of the pipe to a child process (which can
    be a C program), and use {\tt fd2ioport} to convert the other end of
    the pipe to an XSB file. The C program, of course, does not need {\tt
      fd2ioport}, since it can use the pipe file handle directly. Likewise,
    a C program can spawn off an XSB process and pass it one end of a pipe.
    The XSB child-process can then convert this pipe fd to a file using
    {\tt fd2ioport} and then talk to the paren C program.

\ouritem{sys\_exit(-ExitCode)}\index{{\tt sys\_exit/1}} 
This predicate causes XSB subprocess to exit unconditionally with the exit
code {\tt ExitCode}. Normally {\tt 0} is considered to indicate normal
termination, while other exit codes are used to report various degrees of
abnormality.
\end{description}



\section{Socket I/O}

The XSB socket library defines a number of predicates manipulating
sockets. They are all rather straight-forward interfaces to the
corresponding BSD-type socket functions with the same name. For detailed
information on sockets, the reader is referred to the Unix man pages
(another good source is \emph{Unix Network Programming}, by W. Richard
Stevens).

To load the package, enter the query 
\begin{verbatim}
| ?- [sockets].
\end{verbatim}

Examples can be found in the examples directory in the XSB source tree.

\begin{description}
\ouritem{socket(-Sockfd)}\index{{\tt socket/1}}
    A socket Sockfd in the AF\_INET domain is created (AF\_UNIX is not
implemented). 

\ouritem{socket\_set\_option(+Sockfd,+OptionName,+Value)}\index{{\tt socket\_set\_option/3}}
    Set socket option. At present, only the {\tt linger} option is
    supported. ``Lingering'' is a situation when a socket continues to live
    after it was shut down by the owner. This is used in order to let the
    client program that uses the socket to finish reading or writing
    from/to the socket. {\tt Value} represents the number of seconds to linger.
    The value -1 means do not linger at all.

\ouritem{socket\_close(+Sockfd)}\index{{\tt socket\_close/1}}
    Sockfd is closed. Sockets used in socket\_connect/2 should not be
closed by socket\_close/1 as they will be closed when the corresponding
stream is closed.

\ouritem{socket\_bind(+Sockfd,+Port)}\index{{\tt socket\_bind/2}}
   The socket Sockfd is bound to the address (Port is the port number).

\ouritem{socket\_connect(+Sockfd,+Port,+Hostname,SockIOport)}\index{{\tt socket\_connect/4}}
    The socket Sockfd is connected to the address (Hostname and
Port). SockIOport is an XSB I/O port on which items can be both read and
    written. 

\ouritem{socket\_listen(+Socket, +Length)}\index{{\tt socket\_listen/2}}
    The socket Sockfd is defined to have a maximum backlog queue of
Length pending connections.

\ouritem{socket\_accept(+Sockfd,-SockIOport)}\index{{\tt socket\_accept/2}}
    Block the caller until a connection attempt arrives. If the incoming 
    queue is not empty, the first connection request is accepted, the call
    succeeds and binds SockIOport to an XSB I/O port that can be used for
    this new connection.

\ouritem{socket\_flush(+SockIOport)}\index{{\tt socket\_flush/1}}
    Any buffered data in the XSB I/O port SockIOport gets delivered.

\ouritem{socket\_select} \index{{\tt socket\_select}} \emph{Not implemented.}

\end{description}

All streams above can be both read from and written on. All
I/O-predicates operating on streams can be used, for example
file\_read/2, file\_write/2, etc.


\comment{

TLS --- Im not quite sure that the sockets are ready for prime time.

\section{The Socket Library}

As a convenience, XSB provides access to sockets through the following
routines.  Currently only the domain {\tt AF\_INET} is supported.

\begin{description}
\ournewitem{socket(-Socket\_fd)}{socket}

\ournewitem{socket\_request(+Socket\_fd,+Port,+Hostname,+SockIOport)}{socket}



\ournewitem{socket\_bind(+Socket\_fd,+Port)}{socket}

\ournewitem{socket\_listen(+Socket\_fd,+Length)}{socket}

\ournewitem{socket\_accept(+Socket\_fd,SockIOport)}{socket}

\ournewitem{socket\_connect(+Socket\_fd,Port,Hostname,SockIOport)}{socket}

\ournewitem{socket\_flush(+Socket\_fd)}{socket}

\ournewitem{socket\_close(+Socket\_fd)}{socket}

\end{description}

(dsw - This is stuff Hasan wrote, which ought to be formated, cleaned up and included: )

The following calls can be imported from the ``socket'' library.

socket(-Sockfd) :
Creates a new TCP communication end point of type AF_INET. Succeeds with
binding Sockfd to a small integer called a socket descriptor.

socket\_set\_option(+Sockfd,+OptionName,Value) :
    Set socket option. At present, only the {\tt linger} option is
    supported. ``Lingering'' is a situation when a socket continues to live
    after it was shut down by the owner. This is used in order to let the
    client program that uses the socket to finish reading or writing
    from/to the socket. {\tt Value} represents the number of seconds to linger.
    The value -1 means do not linger at all.


socket_bind(+Sockfd, +Port) :
Used for attaching a specific local (integer) Port for the socket with
descriptor Sockfd.

socket_listen(+Sockfd, +QueueLength) :
Used for announcing willingness to accept connections at the socket identified
with descriptor Sockfd. The (integer) QueueLength sets the length of the queue
for the incoming connections at this socket.

socket_accept(+Sockfd, -NewSockfd) :
Block the caller until a connection attempt arrives. If the incoming queue is
not empty, the first connection request is accepted, the call succeeds and
binds NewSockfd with a socket descriptor that will be used for this new
connection.

socket_connect(+Sockfd, +Port, +Hostname, -SockIOport) :
The caller identifies a server's IP address in Hostname and port in Port.
TCP will attempt to establish a connection with the server using local socket
with descriptor Sockfd. For information about SockIOport argument see the
note below.

socket_close(+Sockfd) :
Terminates and closes a connection identified with the descriptor Sockfd.

socket_recv(+Sockfd, -Data) :
Receives a message from the connection identified with the descriptor Sockfd,
strips off the special end_of_message symbol ```'' and binds it to variable Data.

socket_send(+Sockfd, +Data) :
Appends the end_of_message symbol ```'' to the atom Data and sends Data over
the connection identified with the descriptor Sockfd.

socket_send_eof(+Sockfd) :
Sends the special EOF symbol appended with end_of_message symbol ```'' over
the connection identified with the descriptor Sockfd.

socket_send_asci(+Sockfd, Code) :
Send the ascii character with ASCII code Code appended with end_of_message
symbol ```''  over the connection identified with the descriptor Sockfd.


Note: (UNIX only) file_write_canonical(+SockIOport, +Data)
		  file_read_canonical(+SockIOport, -Data, -Psc) 
		  socket_flush(+SockIOport)

The above calls can be used for sending/flushing and receiving {\tt Data}
over an XSB I/O port
SockIOport associated with a socket. SockIOport can be
either obtained from the socket_accept(+Sockfd, -SockIOport) in server mode
or from socket_connect(+Sockfd, +Port, +Hostname, -SockIOport) in client mode.

socket_get0(+Sockfd, -Char, -ErrorCode):
The equivalent of {\tt get0} for sockets.

socket_put(+Sockfd, -Char):
Similar to put/1, but works on sockets.

}

\section{Arrays}
%===============

The module {\tt array1} in directory {\tt lib} provides a very simple 
backtrackable array implementation.  The predicates through which the 
array objects are manipulated are:

\begin{description}
\ournewitem{array\_new(-Array, +Size)}{array1}\index{{\tt array\_new/2}}
%\predindex{array\_new/2~(L)}
    Creates a one dimensional empty array of size {\tt Size}.  All the 
    elements of this array are variables.
\ournewitem{array\_elt(+Array, +Index, ?Element)}{array1}
\index{{\tt array\_elt/3}}
%\predindex{array\_elt/3~(L)}
    True iff {\tt Element} is the {\tt Index}-th element of array 
    {\tt Array}.
\ournewitem{array\_update(+Array, +Index, +Elem, -NewArray)}{array1}
\index{{\tt array\_update/4}}
%\predindex{array\_update/4~(L)}
    Updates the array {\tt Array} such that the {\tt Index}-th element
    of the new array is {\tt Elem} and returns the new array in 
    {\tt NewArray}.  The implementation is quite efficient in that it 
    avoids the copying of the entire array.
\end{description}

A small example that shows the use of these predicates is the following:
{\footnotesize
 \begin{verbatim}
           | ?- import [array_new/2, array_elt/3, array_update/4] from array1.

           yes
           | ?- array_new(A, 4), array_update(A,1,1,B), array_update(B,2,2,C),
                ( array_update(C,3,3,D), array_elt(D,3,E)
                ; array_update(C,3,6,D), array_elt(D,3,E)
                ; array_update(C,3,7,D), array_elt(D,3,E)
                ).

           A = array(1,2,3,_874600)
           B = array(1,2,3,_874600)
           C = array(1,2,3,_874600)
           D = array(1,2,3,_874600)
           E = 3;

           A = array(1,2,6,_874600)
           B = array(1,2,6,_874600)
           C = array(1,2,6,_874600)
           D = array(1,2,6,_874600)
           E = 6;

           A = array(1,2,7,_874600)
           B = array(1,2,7,_874600)
           C = array(1,2,7,_874600)
           D = array(1,2,7,_874600)
           E = 7;

           no
 \end{verbatim}
}


%\section{The Profiling Library}
%==============================

%These predicates are available by loading the library through
%{\tt [prof\_lib]}.

%\begin{description}
%\ournewitem{measure(+Call)}{prof\_lib}\index{{\tt measure/1}}
%\predindex{measure/1~(L)}\label{p:measure}
%     The same as {\tt once/1} (see the section {\it Meta-Predicates}
%in Volume 1)
%     but it also prints out statistical information about the call,
%     that looks like the information printed out by predicate
%     {\tt statistics/0} (see the section {\it Execution State} in Volume 1).
%\end{description}

%----------------------------------------------------------------------
%\input{tr_assert}
\section{Asserts/Retracts using Tries }

\index{{\tt trie\_assert/1}}
\index{{\tt trie\_retract/1}}
\index{{\tt trie\_retractall/1}}
\index{{\tt trie\_retract\_nr/1}}
\index{{\tt abolish\_trie\_asserted/1}}
\index{{\tt trie\_dynamic/1}}

In \version, trie asserted code has been merged with standard asserted
code.  If the user wishes to use tries for dynamic code, the
recommended programming practice is as outlined in the section {\it
Modification of the Database} in Volume 1.
For compatibility with previous versions, the
predicates {\tt trie\_assert/1}, {\tt trie\_retract/1}, {\tt
trie\_retractall/1}, {\tt trie\_retract\_nr/1}, {\tt
abolish\_trie\_asserted/1} and {\tt trie\_dynamic/1} can be imported
from the module {\sf tables}.  However, if the current index
specification of these predicates is {\tt trie} (again, see the
section {\it Modification of the Database} in Volume 1, the predicates
are defined as {\tt assert/1}, {\tt 
retract/1}, {\tt retractall/1}, {\tt retract\_nr/1}, {\tt abolish/1}
and {\tt dynamic/1} respectively.  If the index specification is other
than {\tt tries}, the predicate will issue a warning message and have
no effect on the database.

\section{Extended Logic Programs}  \label{library_utilities:wfsx}
\index{WFSX}
\index{negation!explicit negation}
As explained in the section {\it Using Tabling in XSB}, XSB can
compute normal logic programs according to the well-founded semantics.
In fact, XSB 
can also compute {\em Extended Logic Programs}, which contain an
operator for explicit negation (written using the symbol {\tt -} in
addition to the negation-by-failure of the well-founded semantics
(\verb|\+| or {\tt not}).  Extended logic programs can be extremely
useful when reasoning about actions, for model-based diagnosis, and
for many other uses \cite{AlPe95}.  The library, {\sf slx} provides a means
to compile programs so that they can be executed by XSB according to
the {\em well-founded semantics with explicit negation} \cite{ADP95}.
Briefly, WFSX is an extension of the well-founded semantics to include
explicit negation and which is based on the {\em coherence principle}
in which an atom is taken to be default false if it is proven to be
explicitly false, intuitively:
\[
-p \Rightarrow not\ p.
\]

This section is not intended to be a primer on extended logic
programming or on WFSX semantics, but we do provide a few sample
programs to indicate the action of WFSX.  Consider the program
{\small 
\begin{verbatim}
s:- not t.

t:- r.
t.

r:- not r.
\end{verbatim}
}
If the clause {\tt -t} were not present, the atoms {\tt r, t, s} would
all be undefined in WFSX just as they would be in the well-founded
semantics.  However, when the clause {\tt t} is included, {\tt t}
becomes true in the well-founded model, while {\tt s} becomes false.
Next, consider the program
{\small 
\begin{verbatim}
s:- not t.

t:- r.
-t.

r:- not r.
\end{verbatim}
}
In this program, the explicitly false truth value for {\tt t} obtained
by the rule {\tt -t} overrides the undefined truth value for {\tt t}
obtained by the rule {\tt t:- r}.  The WFSX model for this program
will assign the truth value of {\tt t} as false, and that of {\tt s}
as true.  If the above program were contained in the file {\tt
test.P}, an XSB session using {\tt test.P} might look like the
following:
{\small
\begin{verbatim}
              > xsb
              
              | ?- [slx].
              [slx loaded]
            
              yes
              | ?- slx_compile('test.P').
              [Compiling ./tmptest]
              [tmptest compiled, cpu time used: 0.1280 seconds]
              [tmptest loaded]
            
              | ?- s.
              
              yes
              | ?- t.

              no
              | ?- naf t.
              
              yes
              | ?- r.

              no
              | ?- naf r.
              
              no
              | ?- und r.
              
              yes
\end{verbatim}
}
In the above program, the query {\tt ?- t.} did not succeed,  because
{\tt t} is false in WFSX: accordingly the query {\tt naf t} did
succeed, because it is true that t is false via negation-as-failure,
in addition to {\tt t} being false via explicit negation.  Note that
after being processed by the SLX preprocessor, {\tt r} is undefined
but does not succeed, although {\tt und r} will succeed.

We note in passing that programs under WFSX can be paraconsistent.
For instance in the program.
{\small
\begin{verbatim}
              p:- q.

              q:- not q.
              -q.
\end{verbatim}
}
both {\tt p} and {\tt q} will be true {\em and} false in the WFSX
model.  Accordingly, under SLX preprocessing, both {\tt p} and {\tt
naf p} will succeed.

\begin{description}
\ournewitem{slx\_compile(+File)}{slx}
Preprocesses and loads the extended logic program named {\tt File}.
Default negation in {\tt File} must be represented using the operator
{\tt not} rather than using {\tt tnot} or \verb|\+|.  If {\tt L} is an
objective literal (e.g. of the form $A$ or $-A$ where $A$ is an atom),
a query {\tt ?- L} will succeed if {\tt L} is true in the WFSX model,
{\tt naf L} will succeed if {\tt L} is false in the WFSX model, and
{\tt und L} will succeed if {\tt L} is undefined in the WFSX model.
\end{description}


\section{Generalized Annotated Programs}  \label{library_utilities:gap}
\index{Generalized Annotated Programs}

Generalized Annotated Programs (GAPs) \cite{KiSu92} offer a powerful
computational framework for handling paraconsistentcy and quantitative
information within logic programs.  The tabling of XSB is well-suited
to implementing GAPs, and the gap library provides a meta-interpreter
that has proven robust and efficient enough for a commercial
application in data mining.  The current meta-interpreter is limited
to range-restricted programs.

A description of GAPs along with full documentation for this
meta-interpreter is provided in \cite{Swif99a} (currently also
available at {\tt http://www.cs.sunysb.edu/~tswift}).  Currently, the
interface to the GAP library is through the following call.

\begin{description}
\ournewitem{meta(?Annotated\_atom)}{gap} 
%
If {\tt Annotated\_atom} is of the form {\tt
Atom:[Lattice\_type,Annotation]} the meta-interpreter computes bindings
for {\tt Atom} and {\tt Annotation} by evaluating the program
according to the definitions provided for {\tt Lattice\_type}.
\end{description}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual2"
%%% End: 
