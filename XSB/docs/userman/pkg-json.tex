\chapter[Importing JSON Structures]
{Importing and Exporting JSON Structures\\
  {\Large by Michael Kifer}}

JSON is a popular notation for representing data. JSON is defined
by the ECMA-404 standard, which can be found at \url{http://www.json.org/}.
This chapter describes the \ERGO facility for importing JSON structures
called \emph{values}; it is based on an open source parser called Parson
\url{https://github.com/kgabis/parson}.

\section{Introduction}

In brief, a JSON structure is a \emph{value}  is an \emph{object}, an
\emph{array}, a \emph{string}, a \emph{number},  \texttt{true}, \texttt{false},
or \texttt{null}. An array is an expression of the form
\texttt{[$value_1$, ..., $value_n$]}; an object has a form
\texttt{\{ $string_1$ : $value_1$,  ..., $string_n$ : $value_n$
  \}}; strings are enclosed in double quotes and are called the \emph{keys}
of the object; numbers have the usual
syntax, and \texttt{true}, \texttt{false}, and \texttt{null} are constants
as written. Here are examples of relatively simple JSON values:
%% 
\begin{verbatim}
{
  "first": "John",
  "last": "Doe",
  "age": 25
}

[1, 2, {"one" : 1.1, "two": 2.22}, null]

123
\end{verbatim}
%% 
and here is a more complex example where values are nested to the depth of
five:
%% 
\begin{verbatim}
{
  "status": "ok",
  "results": [{"recordings": [{"id": "12345"}],
               "score": 0.789,
               "id": "9876"
              }]
}
\end{verbatim}
%% 

Although not part of the standard, it is quite common to see JSON
structures that contains comments like in C, Java, etc. The multiline
comments have the form \texttt{/* ... */} and the here-to-end-of-line
comments start with the \texttt{//}. \ERGO ignores such comments.

The standard recommends, but does not require that the keys in an object
do not have duplicates (at the same level of nesting). Thus, for instance,
%% 
\begin{verbatim}
    {"a":1, "b":2, "b":3}
\end{verbatim}
%% 
is allowed, but discouraged. By default, the \ERGO parser does not allow
duplicate keys and considers such objects as ill-formed. However, it also
provides a way to set an option to allow duplicate keys.


\section{API for Importing JSON  as Terms}

When \ERGO ingests a JSON structure, it represents it as a term as follows:
%% 
\begin{itemize}
\item  Arrays are represented as lists.
\item  Strings are represented as \ERGO symbols (Prolog atoms).
\item  Numbers are represented as such.
\item  \texttt{true}, \texttt{false}, \texttt{null} are represented as the
  Prolog (not HiLog!) terms of the form \texttt{true()},
  \texttt{false()}, and \texttt{'NULL'(?)} (the latter is the internal
  representation of the \FLSYSTEM quasi-constant \texttt{\bs{}@?}). 
\item Finally, an object of the form \texttt{\{
    $str_1$:$val_1$,...,$str_n$:$val_n$\}} is represented as
  \texttt{json([$str_1'$=$val_1'$,...,$str_n'$=$val_n'$])}, where
  $str_i'$ is the atom corresponding to the string $str_i$ and $val_i'$ is
  the \ERGO representation of the JSON value $val_i$.
  Here, as above, \texttt{json} is a unary Prolog, not HiLog, function
  symbol.
\end{itemize}
%% 
For instance, the above examples would be represented as HiLog 
\ERGO terms as follows:
%% 
\begin{verbatim}
json([first = John, last = Doe, age = 25])
[1, 2, json([one = 1.1000, two = 2.2200]), \@?]
123
json([status = ok,
      results = [json([recordings = [json([id = '12345'])],
                       score = 0.7890,
                       id = '9876']
                     )]
     ])
\end{verbatim}
%% 
where we tried to pretty-print the last result so it would be easier to
relate to the original (which was also pretty-printed).

\ERGO provides the following methods for importing JSON:
%% 
\begin{itemize}
\item
  \texttt{\emph{Source}[parse -> ?\emph{Result}]@\bs{}json}\\
  Here \emph{Source} can have one of these forms
  %% 
  \begin{itemize}
  \item   \texttt{string(\emph{Atom})}  
  \item   \texttt{str(\emph{Atom})}
  \item   \texttt{url(\emph{Atom})}
  \item   \texttt{file(\emph{Atom})}
  \item   \emph{Atom}
  \item   a variable
  \end{itemize}
  %% 
  The forms \texttt{string(\emph{Atom})} and \texttt{str(\emph{Atom})}
  must supply an atom whose content is a JSON structure and
  \emph{Result} will then be bound to the \ERGO representation of that
  structure.
  The form \texttt{url(\emph{Atom})} can be used to ask \ERGO to get a JSON
  document from the Web. In that case, \emph{Atom} must be a URL. 
  The forms \texttt{file(\emph{Atom})} and \emph{Atom}
  interpret \emph{Atom} as a file name and will read the JSON structure
  from there. The last form, when the source is a variable, assumes
  that the JSON structure will come from the standard input. The user will
  have to send the end-of-file signal (Ctrl-D in Linux or Mac; Ctrl-Z in
  Windows) in order to tell the when the entire term has been entered.\footnote{
    Sending the end-of-file signal is not possible in the \ERGOAI Studio Listener,
    so this last option is not available through the studio.
  }
  If the input JSON structure contains a syntax error or some other problem
  is encountered (e.g., not enough memory) then the above predicate will
  fail and a warning indicating the reason will be printed to the standard
  output.

  \emph{?Result} can be a variable or any other term. If  \emph{?Result}
  has the form \texttt{pretty}(\emph{?Var})  then \emph{?Var}
  will get bound to a pretty-printed string representation of the input
  JSON structure. If \emph{?Result} has any other form (typically a
  variable) then the input is converted into an \ERGO term as explained
  above.
  For instance, the query 
  \texttt{string('\{"abc":1, "cde":2\}')[parse->?X]@\bs{}json}   
  will bind \texttt{?X} to the \ERGO HiLog term \texttt{json([abc=1,cde=2])}
  while the query  \texttt{string('\{"abc":1,
    "cde":2\}')[parse->pretty(?X)]@\bs{}json}  will bind \texttt{?X} to the atom
  %% 
\begin{verbatim}
'{
    "abc": 1,
    "cde": 2
}'
\end{verbatim}
  %% 
  which is a pretty-printed copy of the input JSON string.
\item
  \texttt{\emph{Source}[parse(\emph{Selector}) -> ?\emph{Result}]@\bs{}json}\\
  The meaning of \emph{Source}  and \emph{Result}  parameters here are the
  same as before.
  The \emph{Selector} parameter must be a path expression of the form
  ``string1.string2.string3'' (with one or more components) that allows
  one to select the \emph{first} sub-object of a bigger JSON object and
  return its
  representation. Note, the first argument \emph{must} supply an object, not an
  array or some other type of value. For instance, if the input is
  %% 
\begin{verbatim}
{ "first":1, "second":{"third":[1,2], "fourth":{"fifth":3}} }  
\end{verbatim}
  %% 
  then the query \texttt{?[parse(first) -> ?X]@\bs{}json} will bind
  \texttt{?X} to 1 while
  \texttt{?[parse('second.fourth') -> ?X]@\bs{}json} will bind it to
  \texttt{json([fifth = 3])}.

  Note that the selector lets one navigate through subobjects and not
  through arrays. If an array is encountered in the middle, the query will
  fail. For instance, if the input is
\begin{verbatim}
{ "first":1, "second":[{"third":[1,2], "fourth":{"fifth":3}}] }  
\end{verbatim}
  then the query \texttt{?[parse('second.fourth') -> ?X]@\bs{}json}
  will fail and \texttt{?X} will not be bound to anything because the
  selector \texttt{"second"} points to an array and the selector
  \texttt{"fourth"} cannot penetrate it. 

  Also note that if the JSON structure has more than one sub-object that
  satisfies the selection and duplicate keys are allowed
  (e.g., in \texttt{\{"a":1, "a":2\}} both 1 and 2 satisfy the selection)
  then only the first sub-object will be returned. (See below to learn about
  duplicate keys in JSON.)

\item \texttt{set\_option(\emph{option}=\emph{value})@\bs{}json}\\
  This sets options for parsing JSON for all the subsequent calls to the
  \texttt{\bs{}json} module. Currently, only the following is supported:
  %% 
\begin{verbatim}
    duplicate_keys=true
    duplicate_keys=false
\end{verbatim}
  %% 
  As explained earlier, the default is that duplicate keys in JSON objects
  are treated as syntax errors. The first of the above options tells the
  parser to allow the duplicates. The second option restores the default.
\end{itemize}
%% 

Here is a more complex example, which uses the JSON parser to
process the result of a search of
Google's Knowledge Graph to see what it knows about Benjamin Grosof.
To make the output a bit more manageable, we are only asking to get the
JSON subobject rooted at the property \texttt{itemListElement}.
The Knowledge Graph itself is queried using XSB's \texttt{curl}
library. 
%% 
\begin{alltt}
?- ?U = '\url{https://kgsearch.googleapis.com/v1/entities:search?query=benjamin_grosof&key=AIzaSyAaMs1AEkgRGAs_hkcULQLJ5NKrEOzyOB0&limit=1}',
   load_page(url(?U),
             [secure(false)], ?, ?_SearchResult, ?)@\bs{}plgall(curl),
   str(?_SearchResult)[parse(itemListElement) -> ?Answer]@\bs{}json.
\end{alltt}
%% 
The answer to this query is
%% 
\begin{alltt}
?Answer = [json(['@type' = EntitySearchResult,
                 result = json(['@id' = 'kg:/m/09pb9y8',
                                name = 'Benjamin Nathan Grosof',
                                '@type' = [Person, Thing],
                                description = Mathematician]),
                 resultScore = 19.3944])]
\end{alltt}
%% 

The same can actually be obtained in a much simpler way using the
\texttt{url} feature for the JSON source, as described above:
%% 
\begin{alltt}
?- ?U = '\url{https://kgsearch.googleapis.com/v1/entities:search?query=benjamin_grosof&key=AIzaSyAaMs1AEkgRGAs_hkcULQLJ5NKrEOzyOB0&limit=1}',
   url(?U)[ parse(itemListElement) -> ?Answer @\bs{}json.
\end{alltt}
%% 
However, at present the \texttt{url(...)} feature works only for documents
that are not protected by passwords or SSL. 




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual2"
%%% End: 
