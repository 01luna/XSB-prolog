\newcommand{\xsbpyversion}{Version 0.2}

\begin{center}
\chapter[XSB and Python]{{\tt xsbpy}: The XSB-Python Inteface} \label{chap:xsbpy}
\end{center}

\vspace*{-.30in} 
\begin{center}
{\Large {\bf  \xsbpyversion}}
\end{center}

\begin{center}
  {\Large {\bf By Muthukumar Suresh, Theresa Swift, Carl Andersen}}
\end{center}

\noindent
{\large {\bf {\em This chapter provides rough draft documentation of
      alpha-level software with rapidly changing features.}}}

%Both XSB and Python are written in C, which makes possible a robust
%and efficient interface.  
%

Although it is under development the {\tt xsbpy} package already
provides an efficient and easy way for XSB to call Python functions.
{\tt xsbpy} leverages the fact that XSB and most Pythons are written
in C, so that both systems are loaded into the same process. The core
infterface routines are also written entirely in C, so the interface
is very efficient and -- it is hoped -- very robust.

This chapter first describes how to configure {\tt xsbpy}, followed by
its current set of functions, its current limitations and overviews
some sample applications and examples.

\section{Configutation and Loading}

{\tt xsbpy} does not yet make use of a proper configuration approach.
Because of this, {\tt xsbpy} has only been configured and tested on
Ubuntu linux using Version 3.7 of Python.  If installing {\tt xsbpy}
on Ubuntu, the first step is to ensure that the proper Python
libraries and header files are present, execute:

{\tt sudo apt-get install libpython3.7-dev}



For {\tt xsbpy} to work properly in Linux:
\begin{itemize}
\item The {\tt xsbpy} code must be compiled and dynamically loaded into XSB.
\item A version of {\tt libpython.so} also needs to be dynamically
  loaded into XSB, and configured with the proper C library paths.
\item The proper paths must be set for the Python Standard Library.
\item Paths to {\tt xsbpy} and to {\tt xsbpy/apps} must be set up to
  access both XSB and Python modules.
\end{itemize}

In Ubuntu Linux, this is all done automatically when the {\tt xsbpy}
is consulted into XSB via a normal consult or {\tt
  ensure\_loaded/[1,2]}.  As part of this process, in {\tt
  init\_xsbpy.P} the main C code for {\tt xsbpy} is compiled using the
following gcc compiler options.  
\begin{verbatim}
-I <path to XSB's emu directory>  
-I/usr/include/python3.7m  -I/usr/include/python3.7  
-lpython3.7m -L/usr/lib/python3.7 
-Wl -rpath=/usr/lib/python3.7 -lpython3.7m -L/usr/lib/python3.7 
-Wl -rpath=/usr/lib/python3.7
\end{verbatim}

\noindent
In the above compilation options, {\tt xsbpy} initialization
configures the path to the XSB {\tt emu} directory but all other paths
are currently hard-coded.
When the {\tt xsbpy} module is
consulted into XSB, the {\tt libpython} shared object file (or DLL) is
loaded dynamically along with the {\tt xsbpy} shared object file.

To test out whether {\tt xsbpy} has been loaded and is working
properly, simply execute {\tt text\_xsbpy.} either from {\tt usermod}.

Remaining onfiguration tasks include

\begin{itemize}
\item {\em In Linux:} automatically finding file Python C development
  libraries and headers.
\item {\em In MacOs:} automatically finding file Python C development
  libraries and headers, as well as ensuring that configuration
  options are properly handled by Clang.
\item {\em In Windows:} ... God only knows...
\end{itemize}

\section{Usage}

\begin{description}

\ourrepeatmoditem{callpy(+Module,+Function,+Kwargs,?Return)}{callpy/4}{xsbpy}
\altourmoditem{callpy(+Module,+Function,?Return)}{callpy/3}{xsbpy}
%
 Ensures that the Python module {\tt Module} is loaded, and calls {\tt
   Module.Function} unifying the return of {\tt Function} with {\tt
   Return}.  A list of keyword arguments may or may not be included.
 For example the goal

\begin{verbatim}
callpy(xsbpy_rdflib,rdflib_write_file(Triples,'new_sample.nt'),
       [format=turtle],Ret).
\end{verbatim}

calls the function {\tt xsbpy\_rdflib,rdflib\_write\_file} to write
{\tt Triples}, a list of triples in Prolog format, to the file {\tt
  new\_sample.nt} using the {\tt nt} (N-triples) format, which is
specified as a keyword argument to {\tt rdflib\_write\_file()} in the
third argument of {\tt callpy/4}.

In general, {\tt Module} must be the name of a Python module
represented as a Prolog atom, and {\tt Function} is the invocation of
a Python function in {\tt Module}, where {\tt Function} is simply a
Prolog structure.  Optional keword arguments are passed in the third
argument as lists of {\em Key = Value} terms; if no such arguments
are needed, {\tt Kwargs} can be an empty list -- or {\tt callpy/3} may
be used.  Finally the return value from {\tt Function} is unified with
{\tt Ret}.

Python modules are searched for in the paths maintained in Python's
{\tt sys.path} list.  As indicated below, these Python paths can be
queried from XSB via {\tt py\_lib\_dir/1} and modified via {\tt
  add\_py\_lib\_dir/1}.
     
{\tt xsbpy} takes advantage of a C-level bi-translation of a large
portion of Prolog terms and Python data structures: i.e., Python
lists, tuples, dictionaries and sets are translated to their Prolog
term forms, and Prolog terms of special syntax are translated to
lists, tuples, dictionaries and sets.  Bi-translation is recursive in
that any of these data structures can be nested in other data
structures.  
     
As terminology, when a Python data structure $D$, say a dictionary, is
translated into a Prolog term $T$, $T$ is sometimes called the {\em
  term form} of $D$.  Due to a syntactic overlap between Prolog terms
and Python data structures, the Prolog term forms are easy to
translate and use -- and sometimes appear syntactically identical.

More specifically, bi-translation between Prolog and Python can be
decribed from the viewpoint of Python types as follows: \footnote{If
  desired, the outer functors {\tt pyDict}, {\tt pySet} and {\tt
    pyObject} can be redefined via the file {\tt xsbpy\_defs.h} in the
  {\tt xsbpy} difectory.}

\begin{itemize}
     \item Any Python object {\tt Obj} of a type that is not
       translated to a specific Prolog term as indicated below is
       translated to the Prolog term {\tt pyObject(Obj)}. \footnote{An
         object's attributes are not automatically translated to
         Prolog in \xsbpyversion{}, but this is an intended future
         change.}
       \item {\em Numeric Types}: Python ints and floats are
         bi-translated to Prolog integers and floats.  Python complex
         numbers are not (yet) translated, and integers are only
         supported if for integers between XSB's minimum and maximum
         integer~\footnote{These integers can be obtained by querying
           {\tt current\_prolog\_flag/2}.}
       \item {\em String Types}: Python string types are bi-translated
         to Prolog atoms.  This translation assumes UTF-8 encoding on
         both sides.

         Note that a Python string can be enclosed in either double
         quotes ('') or single quotes (').  In translating from Python
         to Prolog, the outer enclosure is ignored, so Python {\tt
           "'Hello'"} is translated to the Prolog {\tt
           '\textbackslash{}'Hello\textbackslash{}'{}'}, while the
         Python {\tt '"Goodby"'} is translated to the Prolog {\tt
           '"Goodby"'}.
       \item {\em Sequence Types}:
         \begin{itemize}
           \item Python lists are bi-translated as Prolog lists and
             the two forms are syntactically identical.
           \item Python tuples are bi-translated as compound Prolog
             terms with functor {\tt '{}'/n} (i.e., the functor is the
             empty string, denoted with two apostrophes).
             \item Python ranges are not (yet) translated (i.e., they
               are returned as terms with functor {\tt pyObject/1}).
         \end{itemize}
       \item {\em Mapping Types}: A Python dictionary is translated
         into the term form:

         {\tt pyDict(DictList)}

         where {\tt DictList} is a list of tuples in term form: 

         {\tt ''(Key,Value)}

         where {\tt Key} and {\tt Value} are the translations of any
         Python data structures that are both allowable as a
         dictionary key or value, and supported by {\tt xsbpy}.  For
         instance, {\tt Value} can be (the term form of) a list, a
         set, a tuple or another dictionary.

       \item {\em Set Types}: A Python set {\em S} is translated to
         the term form

         {\tt pySet(SetList)}

         where {\em SetList} is the list containing exactly the
         translated elements of $S$.  Due to Python's implementation
         of sets, there is no guarantee that the order of elements
         will be the same in $S$ and $SetList$.
       \item {\em Boolean Types:} are not yet supported. 
       \item {\em Binary Types:} are not yet supported.  There are no
         current plans to support this type.
     \end{itemize}

 As a futher example, the Prolog goal:

 \begin{verbatim}
callpy('apps/xsbpy_json',
       prolog_loads('{"name": "Bob", "languages": ["English","French","GERMAN"]}'),
       Ret)
\end{verbatim}
 
\noindent 
calls the Python function {\tt xsbpy\_json.prolog\_loads()} on the
above string.  In fact, the {\tt xsbpy\_json} module is a simple
interface to the Python {\tt json} library, in which {\tt
  prolog\_loads()} is a simple wrapper for the Python standard library
function {\tt json.loads()}.  In Python, the action of {\tt
  json.loads()} on the above json string produces a Python dictionary
of the form:
\begin{verbatim}
{
  "name":'Bob',
  "languages":["English", "French","GERMAN"]
}
\end{verbatim}
This dictionary is then translated to the Prolog term:
\begin{verbatim}
pydict([
        ''(name,'Bob'),
        ''(languages,['English','French','GERMAN'])
        ]).
\end{verbatim}

\ourrepeatmoditem{pp\_py(+Stream,+Term)}{pp\_py/2}{xsbpy}
\altourmoditem{pp\_py(Term)}{pp\_py/1}{xsbpy}

Pretty prints the translation of a Python data structure in
Python-like syntax.  For instance, the term

\begin{verbatim}
pydict([''(name,'Bob'),''(languages,['English','French','GERMAN'])]).
\end{verbatim}

\noindent
is printed as 
\begin{verbatim}
{
  name:'Bob',
  languages:[
   'English','
   'French',
   'GERMAN'
  ]
}
\end{verbatim}

Such pretty printing can be useful for develiping applications such as
the {\tt xsbpy} Elasticsearch interface.

\altourmoditem{add\_py\_lib\_dir(+Path)}{add\_py\_lib\_dir/1}{xsbpy}
%
This convenience predicate allows the user to add a path to the Python
library directories in a manner similar to {\tt add\_lib\_dir/1},
which adds Prolog library directories.  

\altourmoditem{py\_lib\_dirs(?Path)}{py\_lib\_dirs/1}{xsbpy}
%
This convenience predicate returns the current Python library
directories as a Prolog list.

\end{description}

\section{Performance}

{\tt callpy/3} is written almost entirely in C, has shown good
performance so far, and continues to be optimized.  Calling a simple
Python function to increment a number and then returning the
incremented value should take slightly over a microsecond on a
reasoably fast machine.  Of course, the overhead for passing large
terms from and to Python will be higher.  Nonetheless, for nearly any
practical application the time to perform useful functionality within
Python will far outweigh the {\tt xsbpy} overhead.

\section{Writing Applications}

A great deal of Python functionality is directly available via {\tt
  callpy/3}.  In other cases, a Python bridge function may need to be
written; fortunately writing such a function is usually quite
simple.  Bridge functions are needed in cases such as the following.

\begin{itemize}
  \item There is a need to use a Python data structure that does not
    correspond to a Prolog data structure.  For instance, the Python
    function {\tt load(Stream)} in the {\tt json} module is based on
    the Python representation of an I/O stream, which does not
    correspond to an XSB stream.  XSB thus cannot call this function
    directly, but must pass a resource name that can be opened on the
    Python side.  In this case the bridge function would have the
    form:

\begin{verbatim}   
def prolog_load(File):
    with open(File) as fileptr:
        return(json.load(fileptr))
\end{verbatim}

\item In its current, early, state of development {\tt xsbpy} call
  only functions, but not applications of a method to an object. In
  this case, a bridge function will be needed.  For instance, when
  using the Python Elasticsearch interface, a named connection is
  opened, to which methods are applied to perform tasks like searching
  an Elasticsearch index.  A bridge function to perform searching in
  Elasticsearch is:

\begin{verbatim}
def search(indexin,bodyin):
    return(conn.search(index=indexin, body=bodyin))
\end{verbatim}

\noindent
See {\tt xsbpy/examples/elastic.py} for similar examples.

\item {\tt xsbpy} does not yet automatically pass back attributes of
  an object.  For instance in {\tt xsbpy/apps/xsbpy\_rdflib} the
  language tags and data types of {\tt rdflib.Literal} objects are
  kept as attributes, and these attributes are critical for RDF I/O
  from Prolog. An example of how to handle this is seen in {\tt
    xsbpy\_rdflib.py}, where slightly more elaborate bridge functions
  are needed to marshal an object's attributes as elements of a tuple.

\end{itemize}

Note that cases like the above do not affect the scope of what {\tt
  xsbpy} can do, but make it {\em slightly} less easy to use.

\subsection{Sample Applications}
When {\tt xsbpy} is loaded, both Prolog and Python paths are added to
the {\tt xsbpy} directory and to its subdirectories, {\tt apps} and
{\tt examples}.  As a result, modules in these subdirectories can be
imported into XSB without changing its library path.

Some of these modules, like {\tt xsbpy\_json} and {\tt xsbpy\_rdflib}
provide useful functionality and can be used as written, or nearly so;
other modules are included to hwlp the user get started in writing
hybrid applications.

Note that several of these applications require the underlying Python
libraries to have been installed via a {\tt pip} or {\tt conda}
install.

\subsubsection{(Rudimentary) Applications}

\paragraph{xsbpy\_json}
This module contains an interface to the Python {\tt json}
module, with predicates to read json from and write json to files and
strings.  The {\tt json} module transforms json objects into and from Python
dictionaries, which the interface maps to and from their term forms.

\paragraph{xsbpy\_rdflib}
This module interfaces to the Python {\tt rdflib} library to read RDF
information from files in Turtle, N-triples and N-quads format, and to
write files in Turtle and N-triples format.  As such it augments XSB's
RDF package (Chapter~\ref{chapter:RDF}) which handles
XML-RDF. \footnote{Testing has been done of this {\tt xsbpy}
  interface, but the testing has not been exhaustive.  As a result,
  please double-check its results if it is used, and report bugs to
  {\tt xsb.sorceforge.net}.}

\subsubsection{Other Examples}

\paragraph{xsbpy\_elastic}
This module contains sample code for using the Python {\tt
  elasticsearch} module.  A step by step description shows how a
connection is opened, and index is created and a document added and
committed to it.  The example then shows how the document can earched
in two ways, and finally deleted.

Much of the information that Elasticsearch reads and writes is in json
format, which the Python interface transforms to dictionaries, and
{\tt xsbpy} transforms these dictionaries to and from their term form.

\paragraph{spacey\_demo}
This flle contains a simple example of how to process a document
through SpaCy, and query the processed document for
information about tokens, named entities and noun chunks.

%\paragraph{mpl}
%This file has a simple example of how to create, display, and save as
%pdf a simple matplotlib document.

\section{Current and Future Work}

\begin{itemize}
\item As mentioned above, current tasks include C-level incorporation
  into {\tt callpy/[3,4]} of method application to objects, as well as
  more powerful interface for object attributes.

\item A callback mechanism is under development.  This mechanism
  allows XSB and Python to recursivly call each other.  Our intention
  is to make our callback mechanism consistent with PyXSB, {\tt
    pypi.org/project/py-xsb}, but currently PyXSB and {\tt xsbpy} are
  independent of each other.

\item Support will be added to better manage Python objects in XSB.
  Such functionality would allow XSB to handle, for instance, multiple
  connections to Elasticsearch databases or more generally, multiple
  Python I/O streams.

\end{itemize}  
