\newcommand{\xsbpyversion}{Version 0.3}

\begin{center}
\chapter[XSB and Python]{{\tt xsbpy}: The XSB-Python Inteface} \label{chap:xsbpy}
\end{center}

\vspace*{-.30in} 
\begin{center}
{\Large {\bf  \xsbpyversion}}
\end{center}

\begin{center}
  {\Large {\bf By Muthukumar Suresh, Theresa Swift, Carl Andersen}}
\end{center}

\noindent
{\large {\bf {\em This chapter provides rough draft documentation of
      alpha-level software with rapidly changing features.}}}

%Both XSB and Python are written in C, which makes possible a robust
%and efficient interface.  
%

Although it is under development the {\tt xsbpy} package already
provides an efficient and easy way for XSB to call Python functions
and methods.  {\tt xsbpy} leverages the fact that XSB and most Pythons
are written in C, so that both systems are loaded into the same
process. The core infterface routines are also written entirely in C,
so the interface is very efficient and -- it is hoped -- very robust.

This chapter first describes how to configure {\tt xsbpy}, followed by
introductory examples.  Next is a more precice decription of its
functions, its current limitations followed by some sample
applications and further examples.

\section{Configutation and Loading}

{\tt xsbpy} does not yet make use of a proper configuration approach.
Because of this, {\tt xsbpy} has only been configured and tested on
Ubuntu linux using Version 3.7 of Python.  If installing {\tt xsbpy}
on Ubuntu, the first step is to ensure that the proper Python
libraries and header files are present, execute:

{\tt sudo apt-get install libpython3.7-dev}



For {\tt xsbpy} to work properly in Linux:
\begin{itemize}
\item The {\tt xsbpy} code must be compiled and dynamically loaded into XSB.
\item A version of {\tt libpython.so} also needs to be dynamically
  loaded into XSB, and configured with the proper C library paths.
\item The proper paths must be set for the Python Standard Library.
\item Paths to {\tt xsbpy} and to {\tt xsbpy/apps} must be set up to
  access both XSB and Python modules.
\end{itemize}

In Ubuntu Linux, this is all done automatically when the {\tt xsbpy}
is consulted into XSB via a normal consult or {\tt
  ensure\_loaded/[1,2]}.  As part of this process, in {\tt
  init\_xsbpy.P} the main C code for {\tt xsbpy} is compiled using the
following gcc compiler options.  
\begin{verbatim}
-I <path to XSB's emu directory>  
-I/usr/include/python3.7m  -I/usr/include/python3.7  
-lpython3.7m -L/usr/lib/python3.7 
-Wl -rpath=/usr/lib/python3.7 -lpython3.7m -L/usr/lib/python3.7 
-Wl -rpath=/usr/lib/python3.7
\end{verbatim}

\noindent
In the above compilation options, {\tt xsbpy} initialization
configures the path to the XSB {\tt emu} directory but all other paths
are currently hard-coded.
When the {\tt xsbpy} module is
consulted into XSB, the {\tt libpython} shared object file (or DLL) is
loaded dynamically along with the {\tt xsbpy} shared object file.

To test out whether {\tt xsbpy} has been loaded and is working
properly, simply execute {\tt text\_xsbpy.} either from {\tt usermod}.

Remaining onfiguration tasks include

\begin{itemize}
\item {\em In Linux:} automatically finding file Python C development
  libraries and headers.
\item {\em In MacOs:} automatically finding file Python C development
  libraries and headers, as well as ensuring that configuration
  options are properly handled by Clang.
\item {\em In Windows:} ... God only knows...
\end{itemize}

\section{Introductory Examples}

We introduce some of the core functionality of {\tt xsbpy} via a
series of simple examples.  As background, when the goal {\tt ?-
  [xsbpy].} is executed, Python is loaded and initialized within the
XSB process, the core Prolog modules of {\tt xsbpy} is loaded into
XSB, and paths to {\tt xsbpy} and its subdirectories are added both to
Prolog and to Python.  Apart from these directories (added by
modifying Python's {\tt sys,path}) XSB calls Python, Python will
search for modules and packages in the same manner as if it were
stand-alone.

{\bf {\em The translation of JSON through xsbpy, although it is
    functional, is mainly presented for pedagogic purposes.  In
    general, we recommend using XSB's native JSON interface described
    in Chapter \ref{chap:json} of this manual.    }}

\begin{example} \rm {\bf Calling a Python Function (I)}
  %
  
\noindent  
Consider the following call:

 \begin{verbatim}
callpy(json,
       loads('{"name": "Bob", "languages": ["English","French","GERMAN"]}'),
       Ret)
\end{verbatim}
 
\noindent 
which loads the Python {\tt json} module if needed, and calls the
Python function

{\tt xsbpy\_json.loads()}

\noindent
on the above string which converts a Json string to a Python
dictionary.  In this case, the dictionary would have the Python form:
\begin{verbatim}
{
  "name":'Bob',
  "languages":["English", "French","GERMAN"]
}
\end{verbatim}
{\tt xsbpy} then translates this dictionary to a Prolog term, that can
be pretty printed as::
\begin{verbatim}
pydict([
        ''(name,'Bob'),
        ''(languages,['English','French','GERMAN'])
        ]).
\end{verbatim}
We call a term that maps to a Python dictionary either {\em a Python
  dictionary in term form} or just {\em a Prolog dictionary} although
the latter slightly abuses terminology.
\end{example}

Note that the above example did not require writing {\em any} special
Prolog or Python code.  This is in part because Python's basic data
structures -- dictionaries, lists, tuples, sets and so on -- are
mapped to Prolog terms (cf. Section~\ref{sec:bi-translation}).  As a
result, calling Python is often a simple matter of setting up input
terms for a Python function, and processing the terms that Python
returns to Prolog.

\begin{example} \rm {\bf Calling a Python Function (II): Glue Code} \label{xsbpy-examp:glue}

\noindent
  A slightly more complex call to Python is:
 \begin{verbatim}
callpy(xsbpy_json,prolog_load('test.json'),Ret)
\end{verbatim}

\noindent
which loads a {\tt json} string from the file {\tt test.json} into a
Prolog term.  However, the Python function {\tt json.load()} calls
requires a Python file pointer as its input, and Python file poiners
do not correspond to XSB I/O streams.  As we shall see in
Example~\ref{xsbpy-examp:method}, a reference to a Python file pointer
could be passed back to XSB, but in most cases it is probably easiest
to write some simple Python glue code such as:

\begin{verbatim}   
def prolog_load(File):
    with open(File) as fileptr:
        return(json.load(fileptr))
\end{verbatim}
\noindent
As in the previous example, the above Prolog goal produces a Prolog
dictionary corresponding to the {\tt json}.
\end{example}

\begin{example} \rm {\bf Calling a Python Function (III): Keyword Arguments}
  
\noindent
Python functions often make heavy use of keyword arguments.  These can
be easily handled by {\tt callpy/4}:
\begin{verbatim}
callpy(xsbpy_json,prolog_dump(Dict,'new.json'),[indent=2],Ret)
\end{verbatim}

\noindent
in which the third argument is a list of {\tt =/2} terms.  This list
is turned into a Prolog dictionary and then translated into Python.
Because {\tt json.dump()} needs a file pointer in the same way {\tt
  json.load()}, glue code will also needed, but the glue code passes
keyword arguments in the usual manner of Python:
\begin{verbatim}
def prolog_dump(Dict,File,**Features):
    with open(File,"w") as fileptr:
        ret = json.dump(Dict,fileptr,**Features)
        return(ret)
\end{verbatim}
\end{example}

The previous examples have sketched an approach that can efficiently
call virtually any Python function or method, \footnote{{\tt xsbpy}
  does not currently support Python's binary types.}  although it
might require a small amunt of glue code.  However, Python methods can
also be called directly.

\begin{example} \rm {\bf Calling a Python Method} \label{xsbpy-examp:method}

\noindent
Consider the folllowing simple Python class:

\begin{verbatim}
class Person:
  def __init__(self, name, age, ice_cream=None):
    self.name = name
    self.age = age
    if favorite_ice_cream is None:
      favorite_ice_cream = 'chocolate'
    self.favorite_ice_cream = favorite_ice_cream

  def hello(self,mytype):
    return("Hello my name is " + self.name + " and I'm a " + mytype)
\end{verbatim}

\noindent
The call

\begin{verbatim}
    callpy('Person','Person'(john,35),Obj),
\end{verbatim}
\noindent
creates a new instance of the {\tt Person} class, and returns a
reference to this instance which has a form such as {\tt
  pyObj(p0x7fb1947b0210)}.  XSB can later use this reference to call a
method:
\begin{verbatim}
    callpy_meth('Person',pyObj(p0x7fb1947b0210),hello(programmer),Ret2).
\end{verbatim}

\noindent
which returns the Prolog atom:

{\tt 'Hello my name is john and I'm a programmer'}

\noindent
Although Python methods, like Python functions, can include keyword
arguments, {\tt xsbpy} does not support keyword arguments in {\tt
  call\_meth/4} because Version 3.9.4 of the Python C API does not
permit this.
\end{example}

\begin{example} \rm {\bf Examining a Python Object} \label{xsbpy-examp:exam-object}

\noindent
Example \ref{xsbpy-examp:method} showed how to create a Python object,
pass it back to Prolog and apply a method to it.  Suppose we create
another {\tt Person} instance:

\begin{verbatim}
    callpy('Person','Person'(bob,34),Obj),
\end{verbatim}
\noindent
and later want to find out all attributes of {\tt bob} both explicitly
assicned and default.  This is easily done by {\tt
  xsbpy\_utils:obj\_dict/2}.  Assuming that {\tt
  pyObj(p0x7f386e1e9650)} is the object reference for {\tt bob} in
Prolog, the call
\begin{verbatim}
obj_dict(pyObj(p0x7f386e1e9650) ,F ) .
\end{verbatim}
returns
\begin{verbatim}
pyDict([(name,bob),(age,34),(favorite_ice_cream,chocolate)])
\end{verbatim}
\end{example}

To summarize, a great deal of Python functionality is directly
available via {\tt callpy/[3,4]} and {\tt callpy\_meth/4}.  In our
experience so far, many Python libraries can be called directly and
``just work'' immediately.  Cases where glue code is needed include
the following.

\begin{itemize}
\item In a case like Example \ref{xsbpy-examp:glue} where a Python
  method or function like {\tt json.load()} requres a Python resource
  as input, a small amount of code might be useful to, say, open a
  file and perform an operation.  However as an alternative, the file
  might be opened, the file pointer passed back to XSB, and the
  function called directly from XSB using the file pointer.

  \item As mentioned, {\tt call\_method/4} does not support keyword
    arguments, due to restsictions in the Python C API.

  \item Suppose a class with several attributes is defined as a
    subclass of, say a string type.  Currently {\tt xsbpy} will simply
    pass back such objects as strings, rather than as object
    references.  An example of this occurs in the sample interface
    {\tt xsbpy/apps/xsbpy\_rdflib}.  In the {\tt rdflib} package {\tt
      rdflib.Literal} objects are in fact subclasses of a string type.
    These literal objects have as attributes language tags and data
    types, and these attributes are critical for RDF I/O from Prolog.
    An example of how to handle this is seen in {\tt
      xsbpy\_rdflib.py}, where slightly more elaborate bridge
    functions are needed to marshal an object's attributes as elements
    of a tuple along with the object.\footnote{This behavior may
      change in future versions.}
\end{itemize}

With those disclaimers in mind, all glue code that we have needed to
write so far has been simple and straightforward.

\section{Bi-translation between Prolog Terms and Python Data Structures} \label{sec:bi-translation}

{\tt xsbpy} takes advantage of a C-level bi-translation of a large
portion of Prolog terms and Python data structures: i.e., Python
lists, tuples, dictionaries, sets and other objects are translated to
their Prolog term forms, and Prolog terms of special syntax are
translated to lists, tuples, dictionaries, sets and so on.
Bi-translation is recursive in that any of these data structures can
be nested in other data structures.
     
As mentioned above, when a Python data structure $D$, say a
dictionary, is translated into a Prolog term $T$, $T$ is sometimes
called the {\em term form} of $D$.  Due to a syntactic overlap between
Prolog terms and Python data structures, the Prolog term forms are
easy to translate and use -- and sometimes appear syntactically
identical.

More specifically, bi-translation between Prolog and Python can be
decribed from the viewpoint of Python types as follows: 

\begin{itemize}
       \item {\em Numeric Types}: Python ints and floats are
         bi-translated to Prolog integers and floats.  Python complex
         numbers are not (yet) translated, and integers are only
         supported if for integers between XSB's minimum and maximum
         integer~\footnote{These integers can be obtained by querying
           {\tt current\_prolog\_flag/2}.}
         \begin{itemize}
           \item {\em Boolean Types} which are numeric types are
             translated to their integer value: {\tt True} as {\tt 1}
             and {\tt False} as {\tt 0}.
         \end{itemize}
       \item {\em String Types}: Python string types are bi-translated
         to Prolog atoms.  This translation assumes UTF-8 encoding on
         both sides.

         Note that a Python string can be enclosed in either double
         quotes (\verb|''|) or single quotes (\verb|'|).  In
         translating from Python to Prolog, the outer enclosure is
         ignored, so Python {\tt "'Hello'"} is translated to the
         Prolog {\tt '\textbackslash{}'Hello\textbackslash{}'{}'},
         while the Python {\tt '"Goodby"'} is translated to the Prolog
         {\tt '"Goodby"'}.
       \item {\em Sequence Types}:
         \begin{itemize}
           \item Python lists are bi-translated as Prolog lists and
             the two forms are syntactically identical.
           \item A Python tuple of arity {\tt N} is bi-translated with
             a compound Prolog term \verb|''/N| (i.e., the functor is
             the empty string, denoted by two apostrophes).
             \item Python ranges are not (yet) translated (i.e., they
               are returned as terms with functor {\tt pyObj/1}).
         \end{itemize}
       \item {\em Mapping Types}: A Python dictionary is translated
         into the term form:

         {\tt pyDict(DictList)}

         where {\tt DictList} is a list of tuples in term form: 

         {\tt ''(Key,Value)}

         {\tt Key} and {\tt Value} are the translations of any Python
         data structures that are both allowable as a dictionary key
         or value, and supported by {\tt xsbpy}.  For instance, {\tt
           Value} can be (the term form of) a list, a set, a tuple or
         another dictionary.

       \item {\em Set Types}: A Python set {\em S} is translated to
         the term form

         {\tt pySet(SetList)}

         where {\em SetList} is the list containing exactly the
         translated elements of $S$.  Due to Python's implementation
         of sets, there is no guarantee that the order of elements
         will be the same in $S$ and $SetList$.
       \item {\em None Types.} The Python keyword {\tt None} is
         translated to the Prolog atom {\tt 'None'}. 
       \item {\em Binary Types:} are not yet supported.  There are no
         current plans to support this type.
     \item Any Python object {\tt Obj} of a type that is not
       translated to a specific Prolog term as indicated above is
       translated to the Prolog term {\tt pyObj(Obj)}. 
\end{itemize}

Additionally, a user with a minimal knowledge of C can change parts of
the syntax used in Prolog term forms.  The outer functors {\tt
  pyDict}, {\tt pySet} and {\tt pyObj} and the constant {\tt None} can
all be redefined my modifying xbthe file {\tt xsbpy\_defs.h} in the {\tt
  xsbpy} difectory.

\section{Usage}

\begin{description}

\ourrepeatmoditem{callpy(+Module,+Function,+Kwargs,?Return)}{callpy/4}{xsbpy}
\altourmoditem{callpy(+Module,+Function,?Return)}{callpy/3}{xsbpy}
%
 Ensures that the Python module {\tt Module} is loaded, and calls {\tt
   Module.Function} unifying the return of {\tt Function} with {\tt
   Return}.  A list of keyword arguments may or may not be included.
 For example the goal

\begin{verbatim}
callpy(xsbpy_rdflib,rdflib_write_file(Triples,'new_sample.ttl'),
       [format=turtle],Ret).
\end{verbatim}

calls the function {\tt xsbpy\_rdflib,rdflib\_write\_file} to write
{\tt Triples}, a list of triples in Prolog format, to the file {\tt
  new\_sample.ttl} using the {\tt turtle} format.  This format is
specified as a keyword argument to {\tt rdflib\_write\_file()} in the
third argument of {\tt callpy/4}.

In general, {\tt Module} must be the name of a Python module or path
represented as a Prolog atom, and {\tt Function} is the invocation of
a Python function in {\tt Module}, where {\tt Function} is simply a
Prolog structure.  Optional keword arguments are passed in the third
argument as lists of {\tt Key = Value} terms; if no such arguments are
needed, {\tt Kwargs} can be an empty list -- or {\tt callpy/3} may be
used.  Finally the return value from {\tt Function} is unified with
{\tt Return}.

Python modules are searched for in the paths maintained in Python's
{\tt sys.path} list.  As indicated below, these Python paths can be
queried from XSB via {\tt py\_lib\_dir/1} and modified via {\tt
  add\_py\_lib\_dir/1}.
     
\altourmoditem{callpy\_meth(+Module,+ObjRef,+Method,?Return)}{callpy\_meth/4}{xsbpy}
%
Acts in a manner similar to {\tt callpy/[3,4]}.  {\tt Module} is a
Python module or path, {\tt ObjRef} a Python object reference in term
form, and {\tt Method} a compound term corresponding to a Python
method.  The predicate calls {\tt Objref.Method} and unifies its
return with {\tt Return}.

Due to limitations in the Python C API version 3.9.4, keyword
arguments cannot be used when calling Python method as they can for
Python functions.

\ourrepeatmoditem{pp\_py(+Stream,+Term)}{pp\_py/2}{xsbpy}
\altourmoditem{pp\_py(Term)}{pp\_py/1}{xsbpy}
%
Pretty prints the Prolog translation of a Python data structure in
Python-like syntax.  For instance, the term

\begin{verbatim}
pydict([''(name,'Bob'),''(languages,['English','French','GERMAN'])]).
\end{verbatim}

\noindent
is printed as 
\begin{verbatim}
{
  name:'Bob',
  languages:[
   'English','
   'French',
   'GERMAN'
  ]
} 
\end{verbatim}

Such pretty printing can be useful for develiping applications such as
the {\tt xsbpy} Elasticsearch interface.

\altourmoditem{add\_py\_lib\_dir(+Path)}{add\_py\_lib\_dir/1}{xsbpy}
%
This convenience predicate allows the user to add a path to the Python
library directories in a manner similar to {\tt add\_lib\_dir/1},
which adds Prolog library directories.

\altourmoditem{py\_lib\_dirs(?Path)}{py\_lib\_dirs/1}{xsbpy}
%
This convenience predicate returns the current Python library
directories as a Prolog list.

\altourmoditem{values(+Dict,+Path,?Val)}{values/3}{xsbpy\_utils}
%
  Convenience predicate to obtain a value from a (possibly nested)
  Prolog dictionary.  The goal

  {\tt values(D,key1,V)}

\noindent
  is equivalent to the
  Python expression {\tt D[key1]} while

  {\tt values(D,[key1,key2,key3],V)}

\noindent
is equivalent to the Python expression

{\tt D[key1][key2][key3]}.

\ourrepeatmoditem{keys(+Dict,?Keys)}{keys/2}{xsbpy\_utils}
\altourmoditem{items(+Dict,?Items)}{items/2}{xsbpy\_utils}
%
Convenience predicates to obtain a list of keys or items from a Prolog
dictionary.  For the inveterate Python programmer.

\altourmoditem{obj\_dict(+ObjRef,-Dict)}{obj\_dict/2}{xsbpy\_utils}
%
Given a reference to a Python object as {\tt ObjRef}, this predicate
returns the dictionary of attribtues of {\tt ObjRef} in {\tt Dict}.
(The equivalent of calling {\tt Obj.\_\_dict\_\_} in Python.)

\end{description}

\section{Allowing Python to Reclaim Space}
%
TBD: Disucss space issues for Python how they are now addressed and
how they will be addressed in the future.

\section{Performance}

The core {\tt xsbpy} routines -- {\tt callpy/[3,4]} and {\tt
  call\_meth/4} -- are written almost entirely in C, have shown good
performance so far, and continue to be optimized.  Calling a simple
Python function to increment a number from XSB and then returning the
incremented value to XSB should take about a microsecond on a
reasoably fast machine.  Of course, the overhead for passing large
terms from and to Python will be somewhat higher.  Nonetheless, for
nearly any practical application the time to perform useful
functionality within Python will far outweigh any {\tt xsbpy}
overhead.

\section{Sample Applications}
When {\tt xsbpy} is loaded, both the {\tt xsbpy} directory and its
subdirectories, {\tt apps} and {\tt examples}, are added to the Prolog
and Python paths.  As a result, modules in these subdirectories can be
loadedinto XSB and Python without changing their library paths.

Some of these modules, like {\tt xsbpy\_json} and {\tt xsbpy\_rdflib}
provide useful functionality and can be used as written, or nearly so;
other modules are included to help the user get started in writing
hybrid applications.

Note that several of these applications require the underlying Python
libraries to have been installed via a {\tt pip} or {\tt conda}
install.

\subsubsection{(Rudimentary) Applications}

\paragraph{xsbpy\_json}
This module contains an interface to the Python {\tt json}
module, with predicates to read json from and write json to files and
strings.  The {\tt json} module transforms json objects into and from Python
dictionaries, which the interface maps to and from their term forms.

\paragraph{xsbpy\_rdflib}
This module interfaces to the Python {\tt rdflib} library to read RDF
information from files in Turtle, N-triples and N-quads format, and to
write files in Turtle and N-triples format.  As such it augments XSB's
RDF package (Chapter~\ref{chapter:RDF}) which handles
XML-RDF. \footnote{Testing has been done of this {\tt xsbpy}
  interface, but the testing has not been exhaustive.  As a result,
  please double-check its results if it is used, and report bugs to
  {\tt xsb.sorceforge.net}.}

\subsubsection{Other Examples}

\paragraph{xsbpy\_elastic}
This module contains sample code for using the Python {\tt
  elasticsearch} module.  A step by step description shows how a
connection is opened, and index is created and a document added and
committed.  The example then shows how the document can earched in two
ways, and finally deleted.

Much of the information that Elasticsearch reads and writes is in json
format, which the Python interface transforms to dictionaries, and
{\tt xsbpy} transforms these dictionaries to and from their term form.
Thus although this example is short, the ideas in it can easily be
extended to a full interface.~\footnote{This has already been done by
  one company that uses XSB.}

\paragraph{spacey\_demo}
This flle contains a simple example of how to process a document
through SpaCy, and query the processed document for
information about tokens, named entities and noun chunks.

%\paragraph{mpl}
%This file has a simple example of how to create, display, and save as
%pdf a simple matplotlib document.

\section{Current and Future Work}

\begin{itemize}
\item A callback mechanism is under development.  This mechanism
  allows XSB and Python to recursivly call each other.  Our intention
  is to make our callback mechanism consistent with PyXSB, {\tt
    pypi.org/project/py-xsb}, but currently PyXSB and {\tt xsbpy} are
  independent of each other.

\item A possible future version may include a hook in XSB's atom
  garbage collection to list Python objects that may be garbage
  collected, and to send this information back to Python.  
\end{itemize}  
