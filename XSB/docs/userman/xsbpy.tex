
\chapter[XSB and Python]{{\tt xsbpy}: The XSB-Python Inteface}

\begin{center}
  {\Large {\bf By Muthukumar Suresh, Theresa Swift, Carl Andersen}}
\end{center}

\noindent
{\large {\bf {\em This chapter provides rough draft documentation of
      alpha-level software with rapidly changing features.}}}

%Both XSB and Python are written in C, which makes possible a robust
%and efficient interface.  
%

Although it is under development the {\tt xsbpy} package already
provides an efficient and easy way for XSB to call Python functions.
{\tt xsbpy} leverages the fact that XSB and most Pythons are written
in C, so that both systems are linked into the same process. The core
infterface routines are also written in C, so the interface is very
efficient and -- it is hoped -- very robust.

This chapter first describes how to configure {\tt xsbpy}, followed by
its current set of functions, its current limitations and overviews
some sample applications and examples.

\section{Configutation and Loading}

{\tt xsbpy} does not yet make use of a proper configuration approach.
Because of this, {\tt xsbpy} has only been configured and tested on
Ubuntu linux using Version 3.7 of Python.  If installing {\tt xsbpy}
on Ubuntu, the first step is to ensure that the proper Python
libraries and header files are present, execute:

{\tt sudo apt-get install libpython3.7-dev}



For {\tt xsbpy} to work properly in Linux:
\begin{itemize}
\item The {\tt xsbpy} code must be compiled and dynamically loaded into XSB.
\item A version of {\tt libpython.so} also needs to be dynamically
  loaded into XSB, and configured with the proper C library paths.
\item The proper paths must be set for the Python Standard Library.
\item Paths to {\tt xsbpy} and to {\tt xsbpy/apps} must be set up to
  access both XSB and Python modules.
\end{itemize}

In Ubuntu Linux, this is all done automatically when the {\tt xsbpy}
is consulted into XSB via a normal consult or {\tt
  ensure\_loaded/[1,2]}.  As part of this process, in {\tt
  init\_xsbpy.P} the main C code for {\tt xsbpy} is compiled using the
following gcc compiler options.  
\begin{verbatim}
-I <path to XSB's emu directory>  
-I/usr/include/python3.7m  -I/usr/include/python3.7  
-lpython3.7m -L/usr/lib/python3.7 
-Wl -rpath=/usr/lib/python3.7 -lpython3.7m -L/usr/lib/python3.7 
-Wl -rpath=/usr/lib/python3.7
\end{verbatim}

\noindent
In the above compilation options, {\tt xsbpy} initialization
configures the path to the XSB {\tt emu} directory but all other paths
are currently hard-coded.
When the {\tt xsbpy} module is
consulted into XSB, the {\tt libpython} shared object file (or DLL) is
loaded dynamically along with the {\tt xsbpy} shared object file.

To test out whether {\tt xsbpy} has been loaded and is working
properly, simply execute {\tt text\_xsbpy.} either from {\tt usermod}.

Remaining onfiguration tasks include

\begin{itemize}
\item {\em In Linux:} automatically finding file Python C development
  libraries and headers.
\item {\em In MacOs:} automatically finding file Python C development
  libraries and headers, as well as ensuring that configuration
  options are properly handled by Clang.
\item {\em In Windows:} ... God only knows...
\end{itemize}

\section{Usage}

\begin{description}

\altourmoditem{callpy(+Module,+Function,?Return)}{callpy/3}{xsbpy}
%
 Ensures that the Python module {\tt Module} is loaded, and calls {\tt
   Module.Function} unifying the return of {\tt Function} with {\tt
   Return}. 

 \begin{itemize}
   \item Python modules are searched for in the paths maintained in
     Python's {\tt sys.path} list.
   \item {\tt Goal} is simply a Prolog term, and a large portion of
     Prolog terms and Python data structures are recursively
     bi-translated, making this interface easy to use.  In fact, due
     to the syntactic similarity of Prolog and Python, {\tt Goal}
     often needs no processing to use.  When a Python data structure
     $D$, say a dictionary, is translated into a Prolog term $T$, $T$
     is sometimes called the {\em term form} of $D$.

     Bi-translation between Prolog and Python can be decribed from the
     viewpoint of Python types as follows:
     \begin{itemize}
       \item {\em Numeric Types}: Python ints and floats are
         bi-translated to Prolog inteers and floats.  Python complex
         types are not (yet) handled, and integers are only supported
         if for integers between XSB's minimum and maximum
         integer~\footnote{These integers can be obtained by querying
           {\tt current\_prolog\_flag/2}.}
       \item {\em String Types}: Python string types are bi-translated
         to Prolog atoms.  This translation assumes UTF-8 encoding on
         both sides.

         Note that a Python string is enclosed in either double quotes
         ('') or single quotes (').  In translating from Python to
         Prolog, the outer enclosure is ignored, so Python {\tt
           "'Hello'"} is translated to the Prolog {\tt '''Hello'''},
         while the Python {\tt '"Goodby"'} is  translated to the Prolog
         {\tt '"Goodby"'}.
       \item {\em Sequence Types}:
         \begin{itemize}
           \item Python lists are bi-translated as Prolog lists and
             the two forms are syntactically identical.
           \item Python tuples are bi-translated as compound Prolog
             terms with functor {\tt ''/n} (i.e., the functor is the
             empty string, denoted with two apostrophes).
             \item Python ranges are not (yet) translated.
         \end{itemize}
       \item {\em Mapping Types}: A Python dictionary is translated
         into the term form:

         {\tt '\_\$pydict'(DictList)}

         where {\tt DictList} is a list of tuples in term form: 

         {\tt ''(Key,Value)}

         where {\tt Key} and {\tt Value} are the translations of any
         Python data structures that are both allowable as a
         dictionary key or value, and supported by {\tt xsbpy}.  For
         instance, {\tt Value} can be (the term form of) a list, a
         set, a tuple or another dictionary.

       \item {\em Set Types}: A Python set {\em S} is translated to
         the term form

         {\tt '\_\$pyset'(SetList)}

         where {\em SetList} is the list containing exactly the
         translated elements of $S$.  Due to Python's implementation
         of sets, there is no guarantee that the order of $S$ and
         $SetList$ will be the same.
       \item {\em Boolean Types:} are not yet supported. 
       \item {\em Binary Types:} are not yet supported.  There are no
         current plans to support this type.
     \end{itemize}
   \item {\tt Return} is a Prolog term.  When the Python function
     returns, the return value is translated into its term form
     $T_{ret}$, and then an attempt is made to unify $T_{ret}$ with
     the {\tt Return} term.
 \end{itemize}

 As an example, the Prolog goal:

 \begin{verbatim}
callpy('apps/xsbpy_json',
       prolog_loads('{"name": "Bob", "languages": ["English","Fench","GERMAN"]}'),
       Ret)
\end{verbatim}
 
\noindent 
calls the Python function {\tt xsbpy\_json.prolog\_loads()} on the
above string.  In fact, the {\tt xsbpy\_json} module is a simple
interface to the Python {\tt json} library, in which {\tt
  prolog\_loads()} is a simple wrapper for the Python standard library
function {\tt json.loads()}.  In Python, the action of {\tt
  json.loads()} on the above json string produces a Python dictionary
of the form:
\begin{verbatim}
{
  "name":'Bob',
  "languages":["English", "Fench","GERMAN"]
}
\end{verbatim}
This dictionary is then translated to a Prolog term, displayed via
{\tt writeq/1} and pretty printing as:
\begin{verbatim}
'_pydict'([
           ''(name,'Bob'),
           ''(languages,['English','Fench','GERMAN'])
          ]).
\end{verbatim}

\ourrepeatmoditem{pp\_py(+Stream,+Term)}{pp\_py/2}{xsbpy}
\altourmoditem{pp\_py(Term)}{pp\_py/1}{xsbpy}

Pretty prints the translation of a Python data structure in
Python-like syntax.  For instance, the term

\begin{verbatim}
'_pydict'([''(name,'Bob'),''(languages,['English','Fench','GERMAN'])]).
\end{verbatim}

\noindent
is printed as 
\begin{verbatim}
{
  name:Bob,
  languages:[
   'English','
   'Fench',
   'GERMAN'
  ]
}
\end{verbatim}

Such pretty printing can be useful for develiping applications such as
the {\tt xsbpy} Elasticsearch interface.

\altourmoditem{add\_py\_lib\_dir(+Path)}{add\_py\_lib\_dir/1}{xsbpy}
%
This convenience predicate allows the user to add a path to the Python
library directories in a manner similar to {\tt add\_lib\_dir/1},
which adds Prolog library directories.  

\altourmoditem{py\_lib\_dirs(?Path)}{py\_lib\_dirs/1}{xsbpy}
%
This convenience predicate returns the current Python library
directories as a Prolog list.

\end{description}

\section{Performance}

{\tt callpy/3} is written entirely in C, has shown good performance so
far, and continues to be optimized.  Calling a simple Python function
to increment a number and then zbyreturning the incremented value should
take slightly over a microsecond on a reasoably fast machine.  Of
course, the overhead for passing large terms from and to Python will
be higher.

\section{Writing Applications}

A great deal of Python functionality is directly available via {\tt
  callpy/3}.  In other cases, a Python bridge function may need to be
written; fortunately writing such a function is usually quite
simple.  Bridge functions are needed in cases such as the following.

\begin{itemize}
  \item There is a need to use a Python data structure that does not
    correspond to a Prolog data structure.  For instance, the Python
    function {\tt load(Stream)} in the {\tt json} module is based on
    the Python representation of an I/O stream, which does not
    correspond to an XSB stream.  XSB thus cannot call this function
    directly, but must use a resource name that can be opened on the
    Python side.  In this case the bridge function would have the
    form:

\begin{verbatim}   
def prolog_load(File):
    with open(File) as fileptr:
        return(json.load(fileptr))
\end{verbatim}

\item In its current, early, state of development {\tt xsbpy} call
  only functions, but not applications of a method to an object.  In
  addition, {\tt xsbpy} does not yet support Python functions with a
  variable number of arguments, or with keyword arguments.  In any of
  these cases, a bridge function will be needed.  For instance, when
  using the Python Elasticsearch interface, a named connection is
  opened, to which methods are applied to perform tasks like searching
  an index.  In addition, tehse methods make heavy use of keyword
  arguments.  A bridge function to perform searching in Elasticsearch
  is:

\begin{verbatim}
def search(indexin,bodyin):
    return(conn.search(index=indexin, body=bodyin))
\end{verbatim}
\end{itemize}

Note that cases like the above do not affect the scope of what {\tt
  xsbpy} can do, but make it {\em slightly} less easy to use.

\subsection{Sample Applications}

When {\tt xsbpy} is loaded, both Prolog and Python paths are added to
the {\tt xsbpy} directory and to its subdirectories, {\tt apps} and
{\tt examples}.  As a result, modules in these subdirectories can be
imported into XSB without changing its library path.

Some of these modules, like {\tt xsbpy\_json} provide useful
functionality and can be used as written, while others are included to
hwlp the user get started in writing hybrid applications.

Note that several of these applications require the underlying Python
libraries to have been installed via a {\tt pip} or {\tt conda}
install.

\paragraph{xsbpy\_json}
This module contains a rudimentary interface to the Python {\tt json}
module, with predicates to read json from and write json to files and
strings.  The {\tt json} module transforms json objects into and from Python
dictionaries, which the interface maps to and from their term forms.

\paragraph{xsbpy\_elastic}
This module contains sample code for using the Python {\tt
  elasticsearch} module.  A step by step description shows how a
connection is opened, and index is created and a document added and
committed to it.  The example then shows how the document can earched
in two ways, and finally deleted.

Much of the information that Elasticsearch reads and writes is in json
format, which the Python interface transforms to dictionaries, and
{\tt xsbpy} transforms these dictionaries to and from their term form.

\paragraph{spacey\_demo}
This flle contains simple code for processing a document through
SpaCy, and then querying the processed document for information about
tokens, named entities and noun chunks.

\paragraph{mpl}
This file has a simple example of how to create, display, and save as
pdf a simple matplotlib document.

\section{Current and Future Work}

\begin{itemize}
\item As mentioned above, current tasks include C-level incorporation
  into {\tt callpy/3} of function keyword arguments and object
  methids.

\item A callback mechanism is under development.  This mechanism
  allows XSB and Python to recursivly call each other.  Our intention
  is to make our callback mechanism consistent with PyXSB, {\tt
    pypi.org/project/py-xsb}, but currently PyXSB and {\tt xsbpy} are
  independent of each other.

\item A facility will be added to pass Python object referecnes to and
  from XSB.  This would allow XSB to handle, for instance, multiple
  connections to Elasticsearch databases, or multiple Python I/O
  streams in general.

\end{itemize}  
