\chapter{{\tt clpr}: The CPL(R) package}
%===========================

\begin{center}
{\Large {\bf By Leslie De Koninck based on code by Christian
    Holzbaur}}~\footnote{The CLP(R) package is based on the clpqr
  package included in SWI Prolog version 5.6.49, and was ported to XSB
  by Terrance Swift.}
\end{center}

The CLP(R) library supports solutions of linear equations and
inequalities over the real numbers and the lazy treatment of nonlinear
equations.  In displaying sets of equations and disequations, the
library removes redundancies, performs projections, and provides for
linear optimization.  The goal of the XSB port is to provide the same
CLP(R) functionality as in other platforms, but also to allow
constraints to be used by tabled predicates.  This section provides a
general introduction to the CLP(R) functionality available in XSB, for
further information on the API described in Section~\ref{sec:clpr-api}
see {\tt http://www.ai.univie.ac.at/clpqr}, or the Sicstus Prolog
manual (the CLP(R) library should behave similarly on XSB and
Sicstus at the level of this API).

The {\tt clpr} package may be loaded by the command {\tt [clpr]}.
Loading the package imports exported predicates from the various files
in the {\tt clpr} package into {\tt usermod} (see Volume 1, Section
3.3) so that they may be used in the interpreter.  Modules that use
the exported predicates need to explicitly import them from the files
in which they are defined (e.g. {\tt bv}, as shown below).

XSB's tabling engine supports the use of attributed variables
(Section~\ref{sec:attributed-variables}), which in turn have been used
to port real constraints to XSB under the CLP(R) library of Christian
Holzbauer \cite{Holz95}.  Constraint equations are represented using
the Prolog syntax for evaluable functions (Volume 1, Section 6.2.1).
Formally:

{\it
\begin{tabbing}
12 \= 12345678901234567890 \= 12345678901234567890 \=	\kill
\> ConstraintSet --$>$   \>  C $|$ C {\tt ,} C   \\
\\
\> C --$>$ \> Expr {\tt =:=} Expr \> {\rm equation} \\
\>    \> $|$ Expr {\tt =} Expr \> {\rm equation} \\
\>    \> $|$ Expr {\tt $<$} Expr \> {\rm strict inequation} \\
\>    \> $|$ Expr {\tt $>$} Expr \> {\rm strict inequation} \\
\>    \> $|$ Expr {\tt =$<$} Expr \> {\rm nonstrict inequation} \\
\>    \> $|$ Expr {\tt $>$=} Expr \> {\rm nonstrict inequation} \\
\>    \> $|$ Expr {\tt =/=} Expr \> {\rm disequation} \\
\\
\> Expr --$>$  \> variable \> {\rm Prolog variable} \\
\> \> $|$ number \> {\rm floating point number} \\
\> \> $|$ {\tt +} Expr \\
\> \> $|$ {\tt -} Expr \\
\> \> $|$ Expr {\tt +}  Expr \\
\> \> $|$ Expr {\tt -} Expr \\
\> \> $|$ Expr {\tt *} Expr \\
\> \> $|$ Expr {\tt /} Expr \\
\> \> $|$ {\tt abs($Expr$)} \\
`\> \> $|$ {\tt sin($Expr$)} \\
\> \> $|$ {\tt cos($Expr$)} \\
\> \> $|$ {\tt tan($Expr$)} \\
\> \> $|$ {\tt pow($Expr$,$Expr$)} \> {\rm raise to the power} \\
\> \> $|$ {\tt exp($Expr$,$Expr$)} \> {\rm raise to the power} \\
\> \> $|$ {\tt min($Expr$,$Expr$)} \> {\rm minimum of two expressions} \\
\> \> $|$ {\tt max($Expr$,$Expr$)} \> {\rm maximum of two expressions} \\
\> \> $|$ \verb|#|(Expr) \> {\rm symbolic numerical constants} 
\end{tabbing}
}

\section{The CLP(R) API} \label{sec:clpr-api}
%
From the command line, it is usually easiest to load the {\tt clpr}
package and call the predicates below directly from {\tt usermod} (the
module implicitly used by the command line).  However, when calling
any of these predicates from compiled code, they must be explicitly
imported from their modules (e.g. {\tt \{\}} must be explicitly
imported from {\tt clpr}).  Figure~\ref{fig:clpr} shows an example of
how this is done.
%
\begin{figure} \label{fig:clpr}
{\small 
\begin{verbatim}
   :- import {}/1 from clpr.

   root(N, R) :-
   root(N, 1, R).
   root(0, S, R) :- !, S=R.
   root(N, S, R) :-
	N1 is N-1,
	{ S1 = S/2 + 1/S },
	root(N1, S1, R).
\end{verbatim}
}
\caption{Example of a file with a CLP(R) predicate}
\end{figure}
%
`
\begin{description}
\ournewitem{\{+Constraints\}} {clpr} \index{{\tt \{\}/1}}
%
When the CLP(R) package is loaded, inclusion of equations in braces
({\tt \{\}}) adds {\tt Constraints} to the constraint store where they
are checked for satisfiability. 

{\bf Example:}
{\small
\begin{verbatim}
     | ?- [clpr].
     [clpr loaded]
     [itf loaded]
     [dump loaded]
     [bv_r loaded]
     [nf_r loaded]

     yes

     | ?- {X = Y+1, Y = 3*X}.

     X = -0.5000
     Y = -1.5000;

     yes
\end{verbatim}
}
{\bf Error Cases}
\bi
\item 	{\tt Constraints} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Constraints} is not an equation, an inequation or a disequation
\bi
\item 	{\tt domain\_error('constraint relation',Rel)}
\ei
\item {\tt Constraints} contains an expression {\tt Expr} that is not
  a numeric expression 
\bi
\item 	{\tt domain\_error('numeric expression',Expr)}
\ei
\ei

\ournewitem{entailed(+Constraint)} {clpr} \index{{\tt entailed/1}}
%
Succeeds if {\tt Constraint} is logically implied by the current
constraint store.  {\tt entailed/1} does not change the constraint
store.
%

{\bf Example:}
{\small
\begin{verbatim}
| ?- {A =< 4},entailed(A =\= 5).
 { A =< 4.0000 }

yes   
\end{verbatim}
}
{\bf Error Cases}
\bi
\item 	{\tt Constraints} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Constraints} is not an equation, an inequation or a disequation
\bi
\item 	{\tt domain\_error('constraint relation',Rel)}
\ei
\ei

\ourrepeatnewitem{inf(+Expr,-Val)} {clpr} \index{{\tt inf/2}}

\ourrepeatnewitem{sup(+Expr,-Val)} {clpr} \index{{\tt sup/2}}

\ourrepeatnewitem{minimize(Expr)} {clpr} \index{{\tt minimize/1}}

\ournewitem{maximize(Expr)} {clpr} \index{{\tt maximize/1}}
%
These four related predicates provide various mechanisms to compute
the maximum and minimum of expressions over variables in a constraint
store.  In the case where the expression is not bounded from above
over the reals {\tt sup/2} and {\tt maximize/1} will fail; similarly
if the expression is not bounded from below {\tt inf/2} and {\tt
minimize/1} will fail.

{\bf Examples:}
{\small
\begin{verbatim}
| ?- {X = 2*Y,Y >= 7},inf(X,F).
 { X >= 14.0000 }
 { Y = 0.5000 * X }

X = _h8841
Y = _h9506
F = 14.0000

| ?- {X = 2*Y,Y >= 7},minimize(X).
X = 14.0000
Y = 7.0000

| ?- {X = 2*Y,Y =< 7},maximize(X-2).

X = 14.0000
Y = 7.0000

| ?- {X = 2*Y,Y =< 7},sup(X-2,Z).
 { X =< 14.0000 }
 { Y = 0.5000 * X }

X = _h8975
Y = _h9640
Z = 12.0000

yes
| ?- {X = 2*Y,Y =< 7},maximize(X-2).

X = 14.0000
Y = 7.0000

yes
\end{verbatim}
}

\ourrepeatnewitem{inf(+Expr,-Val, +Vector, -Vertex)} {clpr} \index{{\tt inf/4}}

\ournewitem{sup(+Expr,-Val, +Vector, -Vertex)} {clpr} \index{{\tt sup/4}}
%
These predicates work like {\tt inf/2} and {\tt sup/2} with the
following addition.  {\tt Vector} is a list of Variables, and for each
variable $V$ in {\tt Vector}, the value of $V$ at the extremal point
{\tt Val} is returned in corresponding position in the list {\tt
  Vertex}.

{\bf Example:}
{\small 
\begin{verbatim}
| ?= { 2*X+Y =< 16, X+2*Y =< 11,X+3*Y =< 15, Z = 30*X+50*Y},
     sup(Z, Sup, [X,Y], Vertex).
 { X + 3.0000 * Y =< 15.0000 }
 { X + 0.5000 * Y =< 8.0000 }
 { X + 2.0000 * Y =< 11.0000 }
 { Z = 30.0000 * X + 50.0000 * Y }

X = _h816
Y = _h869
Z = _h2588
Sup = 310.0000
Vertex = [7.0000,2.0000]
\end{verbatim}
}

\ournewitem{bb\_inf(+IntegerList,+Expr,-Inf,-Vertex, +Eps)}  {clpr}
\index{{\tt bb\_inf/4}}
%
Works like {\tt inf/2} in {\tt Expr} but assumes that all the
variables in {\tt IntegerList} have integral values.  {\tt Eps} is a
positive number between $0$ and $0.5$ that specifies how close an
element of {\tt IntegerList} must be to an integer to be considered
integral -- i.e. for such an {\tt X}, {\tt abs(round(X) - X) < Eps}.
Upon success, {\tt Vertex} is instantiated to the integral values of
all variables in {\tt IntegerList}.  {\tt bb\_inf/5} works properly for
non-strict inequalities only.

{\bf Example:}
{\small
\begin{verbatim}
| ?- {X > Y + Z,Y > 1, Z > 1},bb_inf([Y,Z],X,Inf,Vertex,0).
 { Z > 1.0000 }
 { Y > 1.0000 }
 { X - Y - Z > 0.0000 }

X = _h14286
Y = _h10914
Z = _h13553
Inf = 4.0000
Vertex = [2.0000,2.0000]

yes
\end{verbatim}
}
%
{\bf Error Cases}
\bi
\item 	{\tt IntegerList} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
\ei

\ournewitem{bb\_inf(+IntegerList,+Expr,-Inf)}  {clpr}
\index{{\tt bb\_inf/3}}
%
Works like {\tt bb\_inf/5}, but with the neighborhood, {\tt Eps}, set
to {\tt 0.001}.

{\bf Example}
{\small
\begin{verbatim}
|?- {X >= Y+Z, Y > 1, Z > 1}, bb_inf([Y,Z],X,Inf)
 { Z > 1.0000 }
 { Y > 1.0000 }
 { X - Y - Z >= 0.0000 }

X = _h14289
Y = _h10913
Z = _h13556
Inf = 4.

yes
\end{verbatim}
}

\ournewitem{dump(+Variables,+NewVars,-CodedVars} {dump} 
\index{{\tt dump/3}}
%
For a list of variables {\tt Variables} and a list of variable names
{\tt NewVars}, returns in {\tt CodedVars} the constraints on the
variables, without affecting the constraint store.

{\bf Example:}
{\small
\begin{verbatim}
| ?- {X > Y+1, Y > 2},
     dump([X,Y], [x,y], CS).
 { Y > 2.0000 }
 { X - Y > 1.0000 }

X = _h17748
Y = _h17139
CS = [y > 2.0000,x - y > 1.0000];
\end{verbatim}
}
%
{\bf Error Cases}
\bi
\item 	{\tt Variables} is not instantiated to a list of variables
\bi
\item 	{\tt instantiation\_error}
\ei
\ei

\ournewitem{projecting\_assert(+Clause)}{dump}
\index{projecting\_assert/1}
\index{constraints!asserting dynamic code with}
%
In XSB, when a subgoal is tabled, the tabling system automatically
determines the relevant projected constraints for an answer and copies
them into and out of a table.  However, when a clause with constrained
variables is asserted, this predicate must be used rather than {\tt
  assert/1} in order to project the relevant constraints.  This
predicate works with either standard or trie-indexed dynamic code.

{\bf Example:}
{\small
\begin{verbatim}
| ?- {X > 3},projecting_assert(q(X)).
 { X > 3.0000 }

X = _h396

yes
| ?- listing(q/1).
q(A) :-
    clpr : {A > 3.0000}.

yes
| ?- q(X),entailed(X > 2).
 { X > 3.0000 }

X = _h358

yes
| ?- q(X),entailed(X > 4).

no
\end{verbatim}
}
\end{description}
