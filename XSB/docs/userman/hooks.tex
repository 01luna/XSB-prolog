\chapter{Hooks} \label{hooks}

Sometimes it is useful to let the user application catch certain
events that occur during XSB execution. For instance, when the user
asserts or retracts a clause, when an evaluation encounters an
undefined predicate, etc.  XSB has a general mechanism by which the
user program can register \emph{hooks} to handle certain supported
events. All the predicates described below must be imported from {\tt
xsb\_hook}.

An example of the use of hooks is to have XSB fail quietly when it
encounters an undefined predicate.  This can be achieved by the
the example code, which is explained in the following sections.

\begin{verbatim}
:- import add_xsb_hook/1,xsb_undefined_predicate_hook/1 from xsb_hook.

:- add_xsb_hook(xsb_undefined_predicate_hook(undef_fail(_))).

undef_fail(_).
\end{verbatim}


\section{Adding and Removing Hooks}

A hook in XSB can be either a 0-ary predicate or a unary predicate.
A 0-ary hook is called without parameters and unary hooks are called with
one parameter. The nature of the parameter depends on the type of the hook,
as described in the next subsection.


\begin{description}
\ouritem{add\_xsb\_hook(+HookSpec)} \index{{\tt add\_xsb\_hook/1}} 

This predicate registers a hook; it must be imported from {\tt xsb\_hook}.
{\tt HookSpec} has the following format:
%%
\begin{quote}
 {\tt
   hook-type(your-hook-predicate(\_))
   }
\end{quote}
%%
or, if it is a 0-ary hook:
%%
\begin{quote}
  {\tt
   hook-type(your-hook-predicate)
   }  
\end{quote}
%%
For instance, 
%%
\begin{verbatim}
    :- add_xsb_hook(xsb_undefined_predicate_hook(foobar(_))).
\end{verbatim}
%%
registers the hook {\tt foobar()} as a hook that should be called when XSB
encounters an undefined predicate. Of course, your program must include
clauses that define {\tt foobar/1}, or else an error will result.

The predicate that defines the hook type must be imported from {\tt
  xsb\_hook}:
%%
\begin{verbatim}
    :- import xsb_undefined_predicate_hook/1 from xsb_hook.  
\end{verbatim}
%%
or {\tt add\_xsb\_hook/1} will issue an error.

\ouritem{remove\_xsb\_hook(+HookSpec)} \index{{\tt remove\_xsb\_hook/1}}

Unregisters the specified XSB hook; imported from {\tt xsb\_hook}. For
instance,
%%
\begin{verbatim}
    :- remove_xsb_hook(xsb_undefined_predicate_hook(foobar(_))).
\end{verbatim}
%%
As before, the predicate that defines the hook type must be imported from
{\tt xsb\_hook}.
\end{description}


\section{Hooks Supported by XSB}

The following predicates define the hook types supported by XSB. They must
be imported from {\tt xsb\_hook}.

\begin{description}
\ouritem{xsb\_exit\_hook(\_)} \index{{\tt xsb\_exit\_hook/1}}

These hooks are called just before XSB exits. You can register as many
hooks as you want and all of them will be called on exit (but the order of
the calls is not guaranteed). Exit hooks are all 0-ary and must be registered
as such:
%%
\begin{verbatim}
    :- add_xsb_hook(xsb_exit_hook(my_own_exit_hook)).
\end{verbatim}
%%

\ouritem{xsb\_undefined\_predicate\_hook(\_)}
\index{{\tt xsb\_undefined\_predicate\_hook/1}}

These hooks are called when an undefined predicate is encountered.
Each such hook must be unary and registered appropriately:
%%
\begin{verbatim}
    :- add_xsb_hook(xsb_undefined_predicate_hook(my_undef_pred_handler(_))).
\end{verbatim}
%%
\index{PSC record}
%%
An undefined predicate hook receives one argument, a list of the form
%%
\begin{quote}
  {\tt [PSC, ContinuationInstruction]} 
\end{quote}
%%
The first element in the list, {\tt PSC}, is bound to a number that
represents the internal data structure (the \emph{PSC record})
corresponding to the undefined predicate. To extract the information about
the predicate, one can use the following predicates defined in the module
{\tt machine}:
%%
\begin{itemize}
  \index{{\tt psc\_name/2}}
  \index{{\tt psc\_arity/2}}
  \index{{\tt psc\_prop/2}}
  \item  {\tt psc\_name(+PSC, -PredName)} -- returns the predicate name.
  \item  {\tt psc\_arity(+PSC, -PredArity)} -- returns the predicate arity.
  \item  {\tt psc\_prop(+PSC, -ModulePSC)} -- if the predicate is defined in
    a module other than {\tt usermod}, {\tt ModulePSC} will be bound to a
    non-zero number that represents the PSC record of the predicate's
    module. Thus, the module name of the predicate can be obtained as follows:
    %%
    \begin{verbatim}
        psc_prop(PSC,ModulePSC),
        ( ModulePSC =\= 0 -> psc_name(ModulePSC, ModuleName)
        ; ModuleName = usermod
        )
    \end{verbatim}
    %%
\end{itemize}
%%
The last element of the list, {\tt ContinuationInstruction}, is unbound and
it is supposed to be instantiated by the handler as described below.

When an undefined predicate is encountered, XSB would call the hooks
registered to handle this condition until it finds one that succeeds (or
aborts). The order in which the hooks are called is not guaranteed so one
should not rely on a specific order.

A hook for undefined predicates must follow the following protocol: A hook
should examine the information about the predicate and decide whether it
wants to handle this particular undefined predicate.

If the hook decides \emph{not} to handle the given
predicate, then it should \emph{fail} and XSB will then look at other hooks
registered to handle undefined predicates. If none of the hooks succeeds,
XSB aborts the current program clause.

If the hook decides that it wants to handle the undefined predicate, it
should perform whatever actions are necessary for handling the event and
then it must either \emph{abort} or \emph{succeed}.  If it aborts, then the
current program clause (that called the undefined predicate) will also
\emph{abort}.  If it succeeds, then the handler has a choice regarding the
disposition of the original call to the undefined predicate. Namely, it can
tell XSB to fail the call or it can tell it to \emph{repeat} the call. Of
course, the latter makes sense only if the handler somehow caused the
predicate to become defined ({\it e.g.}, by consulting an appropriate
file).

To force XSB to reissue the original call, the handler must bind the fourth
argument, {\tt ContinuationInstruction}, to {\tt true}. If XSB detects that
the predicate is still undefined, then it will fail the original call.  If
{\tt ContinuationInstruction} is bound to anything else (or remains
unbound), then XSB fails the original call.

Here is an example:
%%
\begin{verbatim}
    :- import psc_name/2, psc_arity/2, psc_prop/2 from machine.
    my_undef_pred_handler([PSC,Continuation]) :-
            psc_name(PSC,Name), % obtain the name of the undefined predicate
            (str_sub('foo',Name)
             -> [foo_file], Continuation=true
             ;  fail)
\end{verbatim}
%%
This hook handles only the undefined predicates that contain {\tt foo} in
their name.  If this hook is called and the undefined predicate happens to
have {\tt foo} in its name, a file called {\tt foo\_file} is consulted and
XSB is told to try the call again. If consulting {\tt foo\_file} still
fails to define the predicate, then XSB will fail the call to the undefined
predicate.


\ouritem{xsb\_assert\_hook(\_)} \index{{\tt xsb\_assert\_hook/1}}

These hooks are called whenever the program asserts a clause. An assert
hook must be a unary predicate, which expects the clause
being asserted as a parameter. For instance,
%%
\begin{verbatim}
    :- add_xsb_hook(xsb_assert_hook(my_assert_hook(_))).
\end{verbatim}
%%
registers {\tt my\_assert\_hook/1} as an assert hook. One can register
several assert hooks and all of them will be called (but the order is not
guaranteed).

\ouritem{xsb\_retract\_hook(\_)} \index{{\tt xsb\_retract\_hook/1}}

These hooks are called whenever the program retracts a clause. A retract
hook must be a unary predicate, which expects as a parameter a list of the
form {\tt [Head,Body]}, which represent the head and the body parts of the
clause being retracted. As with assert hooks, any number of retract hooks
can be registered and all of them will be called in some order.

\end{description}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual1"
%%% End: 
