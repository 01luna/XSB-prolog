\chapter{XSB-ODBC Interface} \label{odbc_interface}
%====================================================

\begin{center}
{\Large {\bf By Baoqiu Cui, Lily Dong, and David S. Warren }}
\end{center}

\section{Introduction}
%=====================

The XSB-ODBC interface is subsystem that allows XSB users to access
databases through ODBC connections.  This is mostly of interest to
Microsoft Windows users.  The interface allows XSB users to access
data in any ODBC compliant database management system (DBMS). Using
this uniform interface, information in different DBMS's can be
accessed as though it existed as Prolog facts. The XSB-ODBC interface
provides users with three levels of interaction: an {\it SQL level}, a
{\it relation level} and a {\it view level}.  The {\it SQL level}
allows users to write explicit SQL statements to be passed to the
interface to retrieve data from a connected database.  The {\it
relation level} allows users to declare XSB predicates that connect to
individual tables in a connected database, and which when executed
support tuple-at-a-time retrieval from the base table.  The {\it view
level} allows users to use a complex XSB query, including conjuction,
negation and aggregates, to specify a database query.  A listing of
the features that the XSB-ODBC interface provides is as follows:
\begin{itemize} 
\item Concurrent access from multiple XSB processes to a single DBMS
\item Access from a single XSB process to multiple ODBC DBMS's
\item Full data access and cursor transparency including support for
        \begin{itemize}
        \item Full data recursion through XSB's tabling mechanism 
        (depending on the capabilities of the underlying ODBC driver.
        \item Runtime type checking
        \item Automatic handling of NULL values for insertion, 
                deletion and querying
        \end{itemize}
\item Full access to data source including
        \begin{itemize}
        \item Transaction support
        \item Cursor reuse for cached SQL statements 
                with bind variables (thereby avoiding re-parsing and 
                re-optimizing).
        \item Caching compiler generated SQL statements with bind variables 
                and efficient cursor management for cached statements
        \end{itemize}
\item A powerful Prolog / SQL compiler based on \cite{Drax92}.
\item Full source code availability
\item Independence from database schema by the {\it relation level} interface
\item Performance as SQL by employing a {\it view level} 
\item No mode specification is required for optimized view compilation
\end{itemize}

We use the {\tt Hospital} database as our example to illustrate 
the usage of XSB-ODBC interface in this manual. We assume the basic 
knowledge of Microsoft ODBC interface and its ODBC administrator 
throughout the text.  Please refer to ``Inside Windows$^{TM}$ 95''
(or more recent documentation) for information on this topic.

\section{Using the Interface}
%========================================

The XSB-ODBC module is a module and as such exports the predicates it
supports.  In order to use any predicate defined below, {\bf it must be
imported} from {\tt odbc\_call}.  For example, before you can use the
predicate to open a data source, you must include:

\begin{verbatim}
:- import odbc_open/3 from odbc_call.
\end{verbatim}

\subsection{Connecting to and Disconnecting from Data Sources}
%=================================================

Assuming that the data source to be connected to is available, i.e. it has an 
entry in {\tt ODBC.INI} file which can be checked by running Microsoft 
ODBC Administrator, it can be connected to in the following way: 

\begin{verbatim}
| ?- odbc_open(data_source_name, username, passwd).
\end{verbatim}

If the connection is successfully made, the predicate invocation will
succeed.  This step is necessary before anything can be done with the
data sources since it gives XSB the opportunity to initialize system
resources for the session.

This is an executable predicate, but you may want to put it as a query
in a file that declares a database interface and will be loaded.

To close the current session use:
\begin{verbatim}
| ?- odbc_close.
\end{verbatim}

and XSB will give all the resources it allocated for this session back
to the system.

If you are connecting to only one data source at a time, the
predicates above are sufficient.  However, if you want to connect to
multiple data sources at the same time, you must use extended versions
of the predicates above.  When connecting to multiple sources, you
must give an atomic name to each source you want to connect to, and
use that name whenever referring to that source.  The names may be
chosen arbitrarily but must be used consistently.  The extended
versions are:

\begin{verbatim}
| ?- odbc_open(data_source_name, username, passwd, connectionName).
\end{verbatim}

and

\begin{verbatim}
| ?- odbc_close(connectionName).
\end{verbatim}

A list of existing Data Source Names and descriptions can be obtained
by backtracking through \texttt{odbc\_data\_sources/2}. For example:

\begin{verbatim}
| ?- odbc_data_sources(DSN,DSNDescr).
 
DSN = myoms
DSNDescr = MySQL driver;
 
DSN = mywinoms
DSNDescr = TDS driver (Sybase/MS SQL);
\end{verbatim}

\subsection{Accessing Tables in Data Sources Using SQL}
%=======================================

There are several ways that can be used to extract information from or
modify a table in a data source.  The most basic way is to use
predicates that pass an SQL statement directly to the ODBC driver.
The basic call is:

\begin{verbatim}
| ?- odbc_sql(BindVals,SQLStmt,ResultRow).
\end{verbatim}
\noindent
where {\tt BindVals} is a list of (ground) values that correspond to
the parameter indicators in the SQL statement (the '?'s); {\tt
SQLStmt} is an atom containing an SQL statement; and {\tt ResultRow}
is a returned list of values constituting a row from the result set
returned by the SQL query.  Thus for a select SQL statement, this call
is nondeterministic, returning each retrieved row in turn.

The {\tt BindVals} list should have a length corresponding to the
number of parameters in the query, in particular being the empty list
([]) if {\tt SQLStmt} contains no '?'s.  If {\tt SQLStmt} is not a
select statement returning a result set, then ResultRow will be the
empty list, and the call is deterministic.  Thus this predicate can be
used to do updates, DDL statements, indeed any SQL statement.

{\tt SQLStmt} need not be an atom, but can be a (nested) list of atoms
which flattens (or concatenates) to form an SQL statement.

When connecting to multiple data sources, you should use the form:

\begin{verbatim}
| ?- odbc_sql(ConnectionName,BindVals,SQLStmt,ResultRow).
\end{verbatim}

For example, we can define a predicate, {\tt get\_test\_name\_price},
which given a test ID, retrieves the name and price of that test from
the test table in the hospital database:

\begin{verbatim}
get_test_name_price(Id,Nam,Pri) :-
        odbc_sql([Id],'SELECT TName,Price FROM Test WHERE TId = ?', [Nam,Pri]).
\end{verbatim}

The interface uses a cursor to retrieve this result and caches the
cursor, so that if the same query is needed in the future, it does not
need to be re-parsed, and re-optimized.  Thus, if this predicate were
to be called several times, the above form is more efficient than the
following form, which must be parsed and optimized for each and every
call:

\begin{verbatim}
get_test_name_price(Id,Nam,Pri) :-
      odbc_sql([],['SELECT TName,Price FROM Test WHERE TId = ''',Id,''''], [Nam,Pri]).
\end{verbatim}

Note that to include a quote (') in an atom, it must be represented
by using two quotes.

\subsection{Accessing Tables in Data Sources through the Relation Level}

While all access to a database is possible using SQL as described
above, the XSB-ODBC interface supports higher-level interaction for
which the user need not know or write SQL statements; that is done as
necessary by the interface.  With the relation level interface, users
can simply declare a predicate to access a table and the system
generates the necessary underlying code, generating specialized code
for each mode in which the predicate is called.

To declare a predicate to access a database table, a user must use the
{\tt odbc\_import/2} interface predicate.

The syntax of  {\tt odbc\_import/2} is as follows:

\begin{verbatim}
| ?- odbc_import('TableName'('FIELD1', 'FIELD2', ..., 'FIELDn'), 'PredicateName').
\end{verbatim}
\noindent
where {\tt 'TableName'} is the name of the database table to be
accessed and {\tt 'PredicateName'} is the name of the XSB predicate
through which access will be made. {\tt 'FIELD1'}, {\tt 'FIELD2'},
... , {\tt 'FIELDn'} are the exact attribute names$($case sensitive$)$
as defined in the database table schema.  The chosen columns define
the view and the order of arguments for the database predicate {\tt
'PredicateName'}.
 
For example, to create a link to the {\tt Test} table through the {\tt
'test'} predicate:
\begin{verbatim}
| ?- odbc_import('Test'('TId','TName','Length','Price'),test).

yes
\end{verbatim}

When connecting to multiple data sources, you should use the form:
\begin{verbatim}
| ?- odbc_import(ConnectionName,
                 'TableName'('FIELD1', 'FIELD2', ..., 'FIELDn'),
                 'PredicateName').
\end{verbatim}


\subsection{Using the Relation Level Interface}
%===========================================

Once the links between tables and predicates have been successfully established, 
information can then be extracted from these tables using the corresponding 
predicates.   Continuing from the above example, now rows from the table 
{\tt Test} can be obtained:
\begin{verbatim}

| ?- test(TId, TName, L, P).

TId = t001
TName = X-Ray
L = 5
P = 100 
\end{verbatim}

Backtracking can then be used to retrieve the next row of the table {\tt Test}.

Records with particular field values may be selected in the same way
as in Prolog; no mode specification for database predicates is
required. For example:
\begin{verbatim}

| ?- test(TId, 'X-Ray', L, P).
\end{verbatim}
will automatically generate the query:
\begin{verbatim}
SELECT rel1.TId, rel1.TName, rel1.Length, rel1.Price
FROM Test rel1
WHERE rel1.TName = ?
\end{verbatim}
and 
\begin{verbatim}
| ?- test('NULL'(_), 'X-Ray',  L, P).
\end{verbatim}
generates: (See Section \ref{NULL-values})
\begin{verbatim}
SELECT NULL , rel1.TName, rel1.Length, rel1.Price
FROM Test rel1
WHERE rel1.TId IS NULL AND rel1.TName = ?
\end{verbatim}

During the execution of this query the bind variable {\tt ?} will be bound
to the value {\tt 'X-Ray'}.\newline

Also as a courtesy to Quintus Prolog users we have provided
compatibility support for some PRODBI predicates which access tables
at a relational level.

\begin{verbatim}
| ?- odbc_attach(PredicateName, table(TableName)).
\end{verbatim}

eg. invoke 
\begin{verbatim}
| ?- odbc_attach(test2, table('Test')).
\end{verbatim}
and then execute 
\begin{verbatim}
| ?- test2(TId, TName, L, P).
\end{verbatim}
to retrieve the rows.

\subsection{The View Level Interface}
%===========================================

The view level interface can be used to define XSB queries which
include only imported database predicates (by using the relation level
interface) described above and aggregate predicates (defined below).
When these queries are invoked, they are translated into complex
database queries, which are then executed taking advantage of the
query processing ability of the DBMS.

One can use the view level interface through the predicate {\tt odbc\_query/2}:  
\begin{verbatim}
| ?- odbc_query('QueryName'(ARG1, ..., ARGn), DatabaseGoal).
\end{verbatim}
All arguments are standard XSB terms.  {\tt ARG1}, {\tt ARG2}, ...,
{\tt ARGn} define the attributes to be retrieved from the database,
while {\tt DatabaseGoal} is an XSB goal (i.e. a possible body of a
rule) that defines the selection restrictions and join conditions.

The compiler is a simple extension of \cite{Drax92} which generates SQL
queries with bind variables and handles NULL values as described in
Section \ref{NULL-values}.  It allows negation, the expression
of arithmetic functions, and higher-order constructs such as grouping,
sorting, and aggregate functions.

Database goals are translated according to the following rules
from \cite{Drax92}:
\begin{itemize}
\item Disjunctive goals translate to distinct SQL queries
        connected through the UNION operator.
\item Goal conjunctions translate to joins.
\item Negated goals translate to negated EXISTS subqueries.
\item Variables with single occurrences in the body are not
          translated.
\item Free variables translate to grouping attributes.
\item Shared variables in goals translate to equi-join conditions.
\item Constants translate to equality comparisons of an attribute and
          the constant value.
\item Nulls are translated to {\tt IS NULL} conditions.
\end{itemize}
For more examples and implementation details see \cite{Drax92}.
 
In the following, we show the definition of a simple join view between the 
two database predicates {\it Room} and {\it Floor}.

Assuming the declarations:
\begin{verbatim}

| ?- odbc_import('Room'('RoomNo','CostPerDay','Capacity','FId'),room).

| ?- odbc_import('Floor'('FId','','FName'),floor).
\end{verbatim}

use

\begin{verbatim}

| ?- odbc_query(query1(RoomNo,FName),
                  (room(RoomNo,_,_,FId),floor(FId,_,FName))).
yes

| ?- query1(RoomNo,FloorName).
\end{verbatim}

Prolog/SQL compiler generates the SQL statement:
\begin{verbatim}
SELECT rel1.RoomNo , rel2.FName FROM Room rel1 , Floor rel2 
WHERE rel2.FId = rel1.FId;
\end{verbatim}

Backtracking can then be used to retrieve the next row of the view.
\begin{verbatim}
| ?- query1('101','NULL'(_)).
\end{verbatim}

generates the SQL statement:
\begin{verbatim}

SELECT rel1.RoomNo, NULL
FROM Room rel1 , Floor rel2
WHERE rel1.RoomId = ? AND rel2.FId = rel1.FId AND rel2.FName IS NULL;
\end{verbatim}

The view interface also supports aggregate functions such as sum, avg,
count, min and max.  For example
\begin{verbatim}

| ?- odbc_import('Doctor'('DId', 'FId', 'DName','PhoneNo','ChargePerMin'),doctor).

yes
| ?- odbc_query(avgchargepermin(X),
                (X is avg(ChargePerMin, A1 ^ A2 ^ A3 ^ A4 ^ 
                          doctor(A1,A2, A3,A4,ChargePerMin)))).

yes
| ?- avgchargepermin(X).

SELECT AVG(rel1.ChargePerMin)
FROM doctor rel1;

X = 1.64

yes
\end{verbatim}

A more complicated example is the following:
\begin{verbatim}

| ?- odbc_query(nonsense(A,B,C,D,E),
                (doctor(A, B, C, D, E), 
                 not floor('First Floor', B), 
                 not (A = 'd001'), 
                 E > avg(ChargePerMin, A1 ^ A2 ^ A3 ^ A4 ^
                         (doctor(A1, A2, A3, A4, ChargePerMin))))).

| ?- nonsense(A,'4',C,D,E).

SELECT rel1.DId , rel1.FId , rel1.DName , rel1.PhoneNo , rel1.ChargePerMin
FROM doctor rel1
WHERE rel1.FId = ? AND NOT EXISTS
(SELECT *
FROM Floor rel2
WHERE rel2.FName = 'First Floor' and rel2.FId = rel1.FId
) AND rel1.Did <> 'd001' AND rel1.ChargePerMin >
(SELECT AVG(rel3.ChargePerMin)
FROM Doctor rel3
);


A = d004
C = Tom Wilson
D = 516-252-100
E = 2.5
\end{verbatim}

All database queries defined by odbc\_query can be queried with any mode.

Note that at each call to a database relation or rule, the
communication takes place through bind variables.  The corresponding
restrictive SQL query is generated, and if this is the first call with
that adornment, it is cached.  A second call with same adornment would
try to use the same database cursor if still available, without
reparsing the respective SQL statement.  Otherwise, it would find an
unused cursor and retrieve the results.  In this way efficient access
methods for relations and database rules can be maintained throughout
the session.

If connecting to multiple data sources, use the form:
\begin{verbatim}
 :- odbc_query(connectionName,'QueryName'(ARG1, ..., ARGn), DatabaseGoal).
\end{verbatim}


\subsection{Insertions and Deletions of Rows through the Relational Level}
%=========================================

Insertion and deletion operations can also be performed on an imported
table.  The two predicates to accomplish these operations are 
{\tt odbc\_insert/2} and {\tt odbc\_delete/2}.  The syntax of 
{\tt odbc\_insert/2} is as follows: the first argument is the declared 
database predicate for insertions and the second argument
is some imported data source relation.  The second argument can be 
declared with some of its arguments bound to constants.  For example 
after {\tt Room} is imported through {\tt odbc\_import}:
\begin{verbatim}

|?- odbc_import('Room'('RoomNo','CostPerDay','Capacity','FId'), room).
yes 
\end{verbatim}

Now we can do

\begin{verbatim}
| ?- odbc_insert(room_ins(A1,A2,A3),(room(A1,A2,A3,'3'))).

yes
| ?- room_ins('306','NULL'(_),2).

yes
\end{verbatim}
This will insert the row: ('306',NULL, 2,'3') into the table {\tt Room}. Note that 
any call to {\tt room\_ins/7} should have all its arguments bound.

See Section \ref{NULL-values}) for information about NULL value
handling.

The first argument of {\tt odbc\_delete/2} predicate is the declared delete
predicate and the second argument is the imported data source relation
with the condition for requested deletes, if any.  The condition is
limited to simple comparisons.  For example assuming
{\tt Room/3} has been imported as above:
\begin{verbatim}

| ?- odbc_delete(room_del(A), (room('306',A,B,C), A > 2)). 

yes
\end{verbatim}

After this declaration you can use:
\begin{verbatim}

| ?- room_del(3).
\end{verbatim}

to generate the SQL statement:
\begin{verbatim}

DELETE From Room rel1 
WHERE rel1.RoomNo = '306' AND rel1.CostPerDay = ? AND ? > 2
;
\end{verbatim}

Note that you have to commit your inserts or deletes to tables to make
them permanent.  (See section \ref{TransactionManagement}).

These predicates also have the form in which an additional first
argument indicates a connection, for use with multiple datasources.

Also, some ODBC drivers have been found that do not accept the form of
SQL generated for deletes.  In these cases, you must use the
lower-level interface: {\tt odbc\_sql}.

\subsection{Access to Data Dictionaries}
%======================================

The following utility predicates provide users the tools to access data 
dictionaries.  Users of Quintus Prolog may note that these predicates are all 
PRODBI compatible.  A brief description of these predicates is as follows:
\begin{description}

\item[odbc\_show\_schema(accessible(Owner))]
        Shows the names of all accessible tables that are owned by Owner. (This list can be long!) If Owner is a variable, all tables will be shown, grouped by owner.

\item[odbc\_show\_schema(user)]
        Shows just those tables that belongs to user.

\item[odbc\_show\_schema(tuples('Table'))]
        Shows the contents of the base table named {\tt 'Table'}.

\item[odbc\_show\_schema(arity('Table'))]
        The number of fields in the table {\tt 'Table'}.

\item[odbc\_show\_schema(columns('Table'))]
        The field names of a table.
\end{description}

For retrieving above information use:
\begin{itemize}

\item odbc\_get\_schema(accessible(Owner),List)
\item odbc\_get\_schema(user,List)
\item odbc\_get\_schema(arity('Table'),List)
\item odbc\_get\_schema(columns('Table'),List)
\end{itemize}

The results of above are returned in List as a list.

\subsection{Other Database Operations}

\begin{description}

\item[odbc\_create\_table('TableName','FIELDs')]
        {\tt FIELDS} is the field specification as in SQL.
\begin{verbatim}

eg. odbc_create_table('MyTable', 'Col1 NUMBER,
                             Col2 TEXT(50),
                             Col3 TEXT(13)').
\end{verbatim}


\item[odbc\_create\_index('TableName','IndexName', index(\_,Fields))]
        {\tt Fields} is the list of columns for which an index
        is requested.  For example:
\begin{verbatim}

odbc_create_index('Doctor', 'DocKey', index(_,'DId')).
\end{verbatim}

\item[odbc\_delete\_table('TableName')] To delete a table named {\tt 'TableName'}

\item[odbc\_delete\_view('ViewName')] To delete a view named {\tt 'ViewName'}

\item[odbc\_delete\_index('IndexName')] To delete an index named {\tt 'IndexName'}
\end{description}

\subsection{Transaction Management}\label{TransactionManagement}
%===================================================

Depending on how the transaction options are set in ODBC.INI for data
sources, changes to the data source tables may not be
committed (i.e., the changes become permanent) until the user expicitly
issues a commit statement.  Some ODBC drivers support autocommit,
which, if on, means that every update operation is immediately
committed upon execution.  If autocommit is off, then an explicit
commit (or rollback) must be done by the program to ensure the updates 
become permanent (or are ignored.).

The predicate {\tt odbc\_transaction/1} supports these operations.

\begin{description}
\item[odbc\_transaction(autocommit(on))]
        Turns on autocommit, so that all update operations will be
        immediately committed on completion.
\item[odbc\_transaction(autocommit(off))]
        Turns off autocommit, so that all update operations will not
        be committed until explicitly done so by the program (using
        one of the following operations.)
\item[odbc\_transaction(commit)]
        Commits all transactions up to this point.  (Only has an
        effect if autocommit is off).
\item[odbc\_transaction(rollback)]
        Rolls back all update operations done since the last commit
        point.  (Only has an effect if autocommit is off).
\end{description}

\subsection{Handling NULL Values}
%=======================================
Null value is handled in the same way as that of XSB Oracle interface.
Please refer to Section \ref{NULL-values}) for details.

\subsection{Interface Flags}
%====================================

Users are given the option to monitor the SQL queries generated 
by the interface and their execution status by using the 
predicate {\tt odbc\_flag/3}.  The first parameter indicates the function  to be
changed.  The second argument is the old value, and the third argument specifies
the new value.  For example:
\begin{verbatim}

| ?- odbc_flag(show_query, Old, on).

     Old = off
\end{verbatim}

SQL statements will now be displayed for all SQL queries $($the default$)$.
To turn it off use {\tt odbc\_flag(show\_query,on, off)}.  The default value 
for {\tt show\_query} is on.

To control the error behavior of either the interface or
data sources use {\tt odbc\_flag/3} with fail\_on\_error as first argument.
For example:

\begin{description}

\item[\tt | ?- odbc\_flag(fail\_on\_error, on, off)] Gives all the error control 
to users, hence all requests to data sources return true.  It's the users' 
responsibility to check each of their actions and do error handling.

\item[\tt | ?- odbc\_flag(fail\_on\_error, off, on)] Interface fails whenever 
error occurs.
\end{description}

The default value of fail\_on\_error is on.


\subsection{Datalog}
%===================
Users can write recursive Datalog queries with exactly the same
semantics as in XSB using imported database predicates or database
rules.  For example assuming {\tt odbc\_parent/2} is an imported database
predicate, the following recursive query computes its transitive closure.

\begin{verbatim}

:- table(ancestor/2).
ancestor(X,Y) :- odbc_parent(X,Y).
ancestor(X,Z) :- ancestor(X,Y), odbc_parent(Y,Z).
\end{verbatim}

This works with drivers that support multiple open cursors to the same
connection at the same time.  (Sadly, some don't.)  In the case of
drivers that don't support multiple open cursors, one can often
replace each odbc\_import-ed predicate call
\begin{verbatim}
    ...,predForTable(A,B,C),...
\end{verbatim}
by
\begin{verbatim}
    ...,findall([A,B,C],predForTable(A,B,C),PredList),
        member([A,B,C],PredList)...
\end{verbatim}
and get the desired effect.

\section{Limitation and Guidelines for Application Developers} \label{Guide}
%=======================================================
Since XSB-ODBC interface is a simulation of XSB-ORACLE interface on UNIX 
platform, it inherits all limitations of the XSB-ORACLE interface, i.e. limited 
number of usable cursors, cursor leaking when using cuts and etc.  Hence 
the guidelines for XSB-ORACLE interface application 
developers are also for XSB-ODBC interface application developers.  
Please refer to Sections \ref{oracle:use} and \ref{oracle:limitations}
for datails. 

\section{Error messages}
%============================
\begin{description}
\item[ERR - DB: Connection failed] For some reason the attempt to connect
        to data source failed.
        \begin{itemize}
        \item   Diagnosis: Try to see if the data source has been registered 
                                  with Microsoft ODBC Administrator, the username and 
                                  password are correct and MAXCURSORNUM is not set 
                                  to a very large number.
        \end{itemize}

\item[ERR - DB: Parse error] The SQL statement generated by the
                          Interface or the first argument to {\tt odbc\_sql/1} or 
                       {\tt odbc\_sql\_select/2} can not be parsed by the data 
                              source driver.
        \begin{itemize}
        \item   Diagnosis: Check the SQL statement.  If our interface
                generated the erroneous statement please contact us at
                {\tt xsb-contact@cs.sunysb.edu}.
        \end{itemize}

\item[ERR - DB: No more cursors left] Interface run out of non-active
cursors either because of a leak (See Section \ref{oracle:use}) or no
more free cursors left. 
\begin{itemize}

\item Diagnosis: System fails always with this error.  odbc\_transaction(rollback) or
           odbc\_transaction(commit) should resolve this by freeing all cursors.
\end{itemize}

\item[ERR - DB: FETCH failed] Normally this error should not occur if the 
interface running properly.
\begin{itemize}

\item Diagnosis: Please contact us at xsb-contact@cs.sunysb.edu
\end{itemize}

\section{Notes on specific ODBC drivers}
%============================

\begin{description}
\item[MyODBC] The ODBC driver for MySQL is called MyODBC, and it
  presents some particularities that should be noted. 

  First, MySQL, as
  of version 3.23.55, does not support strings of length greater than
  255 characters. XSB's ODBC interface has been updated to allow the
  use of the BLOB datatype to encode larger strings. 
  
  More importantly, MyODBC implements SQLDescribeCol such that, by
  default, it returns actual lengths of columns in the result table,
  instead of the formal lengths in the tables. For example, suppose
  you have, in table A, a field $f$ declared as ``VARCHAR
  (200)''. Now, you create a query of the form ``SELECT $f$ FROM A
  WHERE ...'' If, in the result set, the largest size of $f$ is 52,
  that's the length that SQLDescribeCol will return. This breaks XSB's
  caching of query-related datastructures. In order to prevent this
  behavior, you should configure your DSN setup so that you pass
  ``Option=1'' to MyODBC.

\end{description}


\end{description}

