
\newcommand{\pxversion}{Version 0.1}

\begin{center}
\chapter[Python and XSB]{{\tt px}: The Python 3-XSB Interface} \label{chap:px}
\end{center}

\vspace*{-.30in} 
\begin{center}
{\Large {\bf  \pxversion}}
\end{center}

\begin{center}
  {\Large {\bf By Theresa Swift}}
\end{center}

\noindent
{\large {\bf {\em This chapter documents rapidly-developing software
      that is alpha-level at best.  See Section~\ref{sec:px-limits}
      for a list of currently unsupported features and known bugs.}}}

The {\tt px} module allows XSB to be used as an embedded subprocess
within a Python process.  {\tt px} currently works independently of
{\tt xsbpy}, although they both use much of the same code and in
particular bi-translate Prolog terms and Python data structures in the
same manner.\footnote{Combinind the two systems is a high priority
  for development.}

{\tt px} is only slightly slower than {\tt xsbpy}.  Nearly a million
calls to, and returns from a simple XSB predicate can be made per
second.  Data is transferred very quickly: for instance list elements
can be transferred at a few tens of nanoseconds per list element.

\section{Configuration, Loading and Start-up}

{\sc Working draft -- not complete.
  \bi
  \item Not mentioning LD\_LIBRARY or XSB\_ROOT issues.
  \item  only describing Linux.
  \item Once the above kinks are out, I need to integrate this
    documentation it with the xsbpy configuration.
    \ei
    }

The configuration of {\tt px} works via the Python {\tt distutils}
package. \footnote{At some point, this confuration will probably be
  changed to use Python's {\tt setuptools}}.  The configuration
process compiles the C files needed for the {\tt px} module, and in a
manner similar to {\tt pip}, installs them in a packages directory for
the desired Python.  To properly execute these steps the proper Python
system packages must have been installed.  Also, because {\tt px} is
installed as a site package for a given version of Python, we strongly
recommend using a Python virtual envonment, just as a virtual Python
environment is usually necessary for installation via {\tt pip}.
Fortunately, once the appropriate Python packages are present and a
user has set up a virtual Python environment, {\tt px} is easy to set
up.

On Linux, setting up a Python virtual environment requires the {\tt
  python-dev} and {\tt python-venv} packages to be installed, along
with other Linux packages like {\tt build-essential} on which these
packages depend.  In addition, since {\tt px} requires {\tt
  distutils}, the {\tt python-distutils} package also needs to have
been installed.  On Ubuntu Linux installation of the above packages
requires {\tt sudo}; for for a given version of Python {\tt \$PYTHON}
the command to install these Python packages would be:

{\tt sudo apt-get install \$\{PYTHON\}-dev \$\{PYTHON\}-distutils
\$\{PYTHON\}-venv}

\noindent
On other Linuxes, an {\tt rpm} or equivalent commend must be
used.\footnote{{\tt px} has been tested on Python versions 3.7, 3.8
  and 3.9, although it should work on other recent Python versions as
  well.}

Once the appropriate packages are present, a virtual environment can
be set up, usually in a user's home directory via a command like:

{\tt \$\{PYTHON\} -m venv {\tt \$VENV\_DIR}}

Next, the virtual environment needs to be activated in a command
shell,  In {\tt bash} this is done as:

{\tt source \$VENV\_DIR/bin/activate  }

In the same shell the {\tt px} configuration will be run.  If XSB has
not already been configured and made, you'll need to do so as
discussed in Volume 1 of this manual, which will configure {\tt px}
(and {\tt xsbpy}).  Otherwise, {\tt cd} to the {\tt xsbpy}
subdirectory and run the command

{\tt ./configure}

If all of the above steps have been done properly, {\tt px} will be
reqdy to run.  In fact, it can be used just as any other package
installed in {\tt \$\{PYTHON\}}

\begin{verbatim}
$PYTHON
>>> from px import *
[xsb_configuration loaded]
[sysinitrc loaded]
[xsbbrat loaded]
[xsbrc loaded]
\end{verbatim}

\noindent
Note that XSB is initialized in the Python process when the {\tt px}
module is loaded.


%\subsection{Configuring on Linux Systems}

%Currently {\tt setup.py} requires include and
%library directories as shown below.  The paths to these directories
%must be changed to include the proper {\tt \$XSB\_ROOT} and, in the
%case of the library directory the path of the XSB binary appropriate
%to your system.  An example is:

%\begin{footnotesize}
%  \begin{verbatim}
%module1 = Extension('xsbext',
%                    include_dirs = ['/usr/include/python3.8',
%                                    '/home/tswift/xsb-code/XSB/emu',
%                                    '/home/tswift/xsb-code/XSB/packages/xsbpy',
%                                    '/home/tswift/xsb-code/XSB/config/x86_64-unknown-linux-gnu'],
%                    libraries = ['xsb'],
%                    library_dirs = ['/home/tswift/xsb-code/XSB/config/x86_64-unknown-linux-gnu/bin'],
%                    sources = ['xsbext.c','xsbpy_common.c'])
%  \end{verbatim}
%\end{footnotesize}
%
%Once {\tt setup.py} is properly configured, the user need only enter a
%python comaand to build and install the module ({\tt sudo} privilege
%may be needed for this).  For the above file the command is:
%
%\begin{verbatim}
%%python3.8 setup.py install
%end{verbatim}
%\noindent
%This command compiles the px sources, builds a Python egg, and
%installs the egg in the Python libary for distributed packages
%(e.g. {\tt dist-packages})

\subsection{Python Functions in {\tt px}}

The intention of {\tt px} is to make essentially all of XSB's
functionality directly callable by Python.  As noted, many of these
featues are still under development.

Although Python and Prolog have similiarities at the data structure
level, they differ substanially in their execution.  The design of
{\tt px} is to restrict the form of Prolog goals so that they fit well
with Python's function execution.  Fortunately, this can be done
without sacrificing XSB's expressivity.  {\tt px} functions are
variadic and pass to XSB a module, a predicate name and zero or more
input arguments.  At a general level, XSB then constructs a call from
these pieces and passes the return back to Python, though how this is
done differs for the various {\tt px} functions.  It should be noted
that {\tt px} does not provide a way to represent logical variables in
Python so that if an argument is passed to XSB it will be fully
ground.

XSB goals may succeed with truth value {\tt true} or {\tt undefined}
and fail with truth value {\tt false}.  Truth values are returned to
Python with {\tt true} as {\tt 1}, {\tt undefined} as {\tt 2} and {\tt
  false} as {\tt 0}.

If an exception occurs when XSB is executing a goal, the error is
caught by XSB, translated to a Python exception of the vanilla {\tt
  Exception} class\footnote{A future implementation will use more
  precise mapping of XSB error types to Python error types.}, and can
be caught as any other Python exception of that type.  Precise
information on the XSB exception is available to Python through the
{\tt px} function {\tt px\_get\_error\_message()},

\subsubsection{The {\tt px} API}

\begin{description}

  \pymoditem{px\_cmd(module,pred,*args)}{px\_cmd()}{px}
%
  Allows Python to execute a Prolog goal {\tt Goal} containing no
  variables.  Each argument in {\tt Goal} corresponds to an element of
  in {\tt args}, i.e., the input is translated to
  $module.pred(\vec{args})$, where $\vec{args}$ is an argument vector.
  For instance the Python call

  {\tt px\_cmd('consult','ensure\_loaded','px\_test')}

  calls {\tt consult:ensure\_loaded(px\_test)}.  Calls to XSB
  predicates that are not in a module may be made with {\tt module}
  set to {\tt usermod}.

  {\tt px\_cmd()} returns the truth value of the goal as explained
  above, or {\tt None} if an error occured.
  
  \pymoditem{px\_qdet(module,pred,*args)}{px\_qdet()}{px}
%
  Allows Python to execute a Prolog query, the last argument of which
  is a variable.  If the number of {\tt args} is {\tt n}, a call will
  be made to {\tt pred/(n+1)} in which the first {\tt n} arguments
  correspond to the arguments in {\tt args} and the binding of the
  final argument is returned to Python as a Python object along with
  its truth value, i.e. a call $module.pred(\vec{args},Ret)$ is
  created, where the binding of $Ret$ forms part of the return.  For
  example: the call

  {\tt px\_qdet('basics','reverse',[1,2,3,{'a':{'b':'c'}}]))}

  \noindent
  executes the prolog goal {\tt
    basics.reverse([1,2,3,{'a':{'b':'c'}}],Ret} and passes back the tuple

  {\tt ( [{'a':{'b':'c'}},3,2,1], 1)}

  \noindent
  to Python, where the second argument of the {\em retrun tuple} is
  the truth value of the answer.  More precisely the Prolog goal {\tt
    Goal} returns as follows.

  \bi
  \item If {\tt truthValue} is {\tt 1} (true) or {\tt 2} (undefined),
    {\tt Goal} succeeded.  The return of {\tt px\_qdet()} is a tuple
    {\tt (dataStructure,truthValue)} in which {\tt dataStructure}
    corresponds to the binding of the last argument of {\tt Goal}, and
    {\tt truthValue} is the truth value of the answer;
   \item If {\tt truthValue} is {\tt 0} (false), {\tt Goal} failed,
     and the return of {\tt px\_qdet()} is a tuple {\tt (None,0)};
   \item If the execution of {\tt Goal} caused a Prolog error the
     Python {\tt None} object is returned.
     \ei

     If {\tt Goal} is non-deterministic, only the first answer will be
     produced; multiple answers for a goal can be returned by {\tt
       px\_list} and {\tt px\_set}.

     Note that {\tt px\_cmd()} and {\tt px\_query()} will always call
     different Prolog goals.  For instance {\tt
       px\_cmd(mod,pred,arg1,arg2)} will call the Prolog goal {\tt
       mod:pred(arg1,arg2)} while {\tt px\_query(mod,pred,arg1,arg2)}
     will call {\tt mod:pred(arg1,arg2,Ret)}.
     
     Calls to XSB predicates that are not in a module may be made with
     {\tt module} set to {\tt usermod}.

  \pymoditem{px\_comp(module,pred,*args,**kwargs)}{px\_com()}{px}
%
  
  Allows Python to call XSB to perform the equivalent of list or set
  comprehension.  {\tt px\_comp()} allows zero or more input arguments
  each containing a Python term ($\overrightarrow{input}$) and zero or
  more output arguments ($\overrightarrow{output}$) to call an XSB goal

\[module:pred(\overrightarrow{inputs},\overrightarrow{outputs}) \]

It then returns to Python a list or set of tuples representing all
bindings (or all unique bindings) to $\overrightarrow{outputs}$ for
which the above goal is true.

{\sc TES add example here.}

The actual behavior of {\tt px\_comp()}
depends on the keyword arguments passed to it.

{\tt kwargs} can take the following values:
\begin{itemize}
  \item {\tt vars=N} where {\tt N} is a non-negative integer,
    determines the number {\tt N} of output variables for the call.
    For instance
    
\begin{tabular}{lll}
    {\tt px\_comp(mod,pred)}            & calls the goal & {\tt mod:pred(X1)} \\
    {\tt px\_comp(mod,pred),vars=2}     & calls the goal & {\tt mod:pred(X1,X2)} \\
    {\tt px\_comp(mod,pred,a,vars=0)}   & calls the goal & {\tt mod:pred(a)}. \\
    {\tt px\_comp(mod,pred,a)}          & calls the goal & {\tt mod:pred(a,X1)} \\
    {\tt px\_comp(mod,pred,a,vars=1)}   & calls the goal & {\tt mod:pred(a,X1)} \\
    {\tt px\_comp(mod,pred,a,vars=2)}   & calls the goal & {\tt mod:pred(a,X1,X2)} \\
    {\tt px\_comp(mod,pred,a,b,vars=2)} & calls the goal & {\tt mod:pred(a,b,X1,X2)} \\
\end{tabular}    
    
    \noindent
    The default is {\tt 1}.
    
    \item {\tt set\_collect=True/False} determines the type of
      collection in which the bindings are returned: if the keyword
      argument is {\tt True}, the answers are collected as a set, and
      if {\tt False} the answers are collected as a list.  Default is
      {\tt False}. \footnote{The reason for making lists the default
        collection type is that Python sets can only contain
        non-mutable objects, and so cannot contain lists or
        dictionaries.}
      
    \item {\tt truth\_vals} determines whether how each answer in the
      collection is associated with its truth value.  Values can be:
      
      \bi

      \item {\tt PLAIN\_TRUTHVALS} which associates each answer with its
      truth value 1 or 2 (False answers are never included in the
      collection.)  In this case, each element of the collection is a
      2-ary tuple consisting of an answer and its truth value.
      
      \item {\tt DELAY\_LISTS} which associates each answer with its
        SLG delay list \cite{}. (False answers are never included in
        the collection.)  In this case, each element of the collection
        is a 2-ary tuple consisting of an answer and its delay list.

      \item {\tt NO\_TRUTHVALS} does not associate an answer with any
        truth value.  This should only be used in situations where it
        is know that no answers will be undefined.

        \ei

  \end{itemize}

  As an example consider the XSB predicate: ..... {\sc TES: add example}
\begin{verbatim}
\end{verbatim}
  
  \pymoditem{px\_get\_error\_message()}{px\_get\_error\_message()}{px}
%
  If an XSB exception was raised by the previous call to XSB, {\tt
    px\_get\_error\_message()} returns the XSB exception message as a
  Python Unicode string.
  
  \repeatpymoditem{pp\_px\_cmd(Module,Pred,*args)}{pp\_px\_cmd()}{px}
  \repeatpymoditem{pp\_px\_qdet(Module,Pred,*args)}{pp\_px\_qdet()}{px}
  \pymoditem{pp\_px\_comp(Module,Pred,*args,**kwargs)}{pp\_px\_comp()}{px}
  
  \repeatpymoditem{consult(File)}{consult()}{px}
  \pymoditem{ensure\_loaded(File)}{ensure\_loaded()}{px}
%
  Convenience functions for loading and/or compiling Prolog files.
  They are defined as {\tt px\_cmd('consult','consult',File)} and {\tt
    px\_cmd('consult','ensure\_loaded',File)}.\footnote{On-demand
    loading, available in XSB, is not yet available within {\tt px}.}

  Note that a given XSB file can be compiled and/or loaded into the
  running Python-XSB session (via {\tt consult()} or {\tt
    ensure\_loaded()}), edited and then repeatedly recompiled and
    reloaded without problems.

  \pymoditem{prolog\_paths()}{prolog\_paths()}{px}
%  
  Convenience function to return a list of all current XSB library
  paths (XSB's equivalent of Python's {\tt sys.path}).

  \pymoditem{add\_prolog\_path(Paths)}{add\_prolog\_path()}{px}
%  
    Convenience function to add one or more XSB library paths, (XSB's
    equivalent of Python's {\tt sys.path}) and is defined as: {\tt
      px\_cmd('consult','add\_lib\_dir',Paths)}.
  
\end{description}

\subsection{Current Issues and Limitations} \label{sec:px-limits}

{\tt px} is under active development and its issues and limitations
change on a weekly or even daily basis.

\bi
\item {\tt px} has not been tested on any platform other than Ubuntu
  Linux.
\item {\tt px} does not yet work with {\tt xsbpy}, i.e., callbacks are
  not currently implemented.
\item Heap garbage collection is currently disabled when XSB is called
  from Python, although expansion is allowed for all stacks. 
\item Python sometimes core dumps on exit (via {\tt quit()} or {\tt
  ctrl-D} after using {\tt px}.
  
\ei  
