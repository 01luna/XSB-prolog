\chapter{Standard Predicates and Predicates of General Use} \label{standard}
%=============================================

This chapter describes standard predicates, which are always available
to the Prolog interpreter, and do not need to be imported or loaded
explicitly as do other Prolog predicates.  By default, it is a
compiler error to redefine standard predicates.  

\comment{This behavior can be overridden by allowing explicit
  redefinition of standard predicates (see Section~\ref{}); or
  alternatively the set of standard predicates can be easily
  reconfigured (Section~\ref{}).}

In the description below, certain standard predicates depend on HiLog
semantics; the description of such predicates have the token {\sf
HiLog} at the right of the page.  Similarly predicates that depend on
SLG evaluation are marked as {\sf Tabling}, and predicates whose
semantics is defined by the ISO standard (or whose implementation is
reasonably close to that definition) are marked as {\tt ISO}.
Occasionally, however, we include in this section predicates that are
not standard.  In such cases we denote their module in {\tt text} font
towards the middle of the page.

\comment{
\paragraph*{A Note on Types} \label{sec:types}

Numerous proposals have been made concerning typing systems for Prolog
for the purposes of program analysis, correctness checking, etc.
Analysis-based typing systems are typically lattice-based, following
from their need to compare types to understand whether one type
includes another, or from the need to determine the most specific type
that is more general than two types.  In addition the ISO standard
specifies various types of allowable input or output arguments for
various predicates.

\version{} of XSB has the following approach to program typing.
Typing in an XSB program is done through a {\em type lattice},
generated by {\em primitive type elements}.  How a primitive type is
defined is somewhat separate from how it is used by a type lattice.
For our purposes we assume that each 1-ary type element is defined by
a predicate of arity 1 that is written in a pure enough style so that
its success or failure does not depend on the state of XSB or of any
external state.  Whether these types are recursive or not has no
bearing on the type lattice.  For instance, {\tt integer} or {\tt
listOfAtoms} are primitive type elements.  Similarly, {\tt variable},
{\tt ground} are also type elements.  We say that a given term {\tt
Term} satisfies a primitive type element {\tt t} if {\tt t(Term)}
succeeds.  Given primitive type elements, complex type elements can be
formed using the boolean operations, {\tt and}, {\tt or} and {\tt
not}.  As an example, {\tt integer or not(listOfAtoms)} is a
non-primitive type element.  There is also a product operation ({\tt
,}) on type elements, so that {\tt variable, integer or
not(listOfAtoms)} is a product of the above two types.  
Satisfiability is extended to complex type elements in the obvious
manner, and an n-ary typle of terms satisfies a n-ary product type if
each argument in the tuple satisfies the corresponding argument of the
product type.

The above description is not yet suitable for a type system as it
could not determine, for instance, that {\tt integer} is a subtype of
{\tt number}.  To determine this, an explicit {\em inclusion
statement} can be made indicating that one type is included in
another.  Thus given two elements in a type lattice with inclusion
statements, determining whether one element is more specific than
another can be done using techniques for propositional satisfiability
or stable model generation.

From an implementational level, types can be defined using the Cold
Dead Fish (CDF) package and inclusion can be detected using the CDF
theorem prover or XSB's Smodels interface.  However, for the
purposes in this section we use type elements to define inputs and
outputs of predicates, via {\tt usage statements}.  A usage statement
for an n-ary predicate {\tt p/n} consists of an n-ary product of
primitive types that should be satisfied on a call to {\tt p/n} along
with a n-ary product of primitive types that should hold on success of
{\tt p/n} given the types that hold at call.  If both the the product
types hold, the usage statement is satisfied.  Each successful call to
{\tt p/n} should satisfy one of the usage statements.

As defined, usage statements are very general: they can check not only
traditional Prolog types ({\tt atom}, {\tt integer}, etc), but also
non-Prolog types, such as the fact that the input to a given argument
should be a positive integer, and even instantiation patterns.  For
the various predicates defined in this section, we use the following
conventions for usages and error reporting.  {\bf domain}, {\bf type}
and {\bf instantiation} errors arise from the failure of an argument
of a predicate to satisfy the corresponding type element in the input
term of the usage statements.  All of these could be called type
errors given the system described above.  However to (partially)
conform to the ISO standard, we reserve the {\bf instantiation error}
to mean failure that occurs when an argument does not satisfy a type
in a boolean lattice generated by {\tt var} and {\tt ground}.  A {\bf
  type error} occurs when an argument does not satisfy a type in a
boolean lattice generated by other ISO types, such as {\tt integer},
{\tt atom}, etc.  A {\bf domain error} arises from other such errors.
We note that in certain cases, our designation of an error type may
differ from the ISO standard.
}

%--------------------------------------------------------------------------------------------------
\section{Input and Output}
\index{streams}

XSB's I/O is based on ISO-style streams, although it also supports
older DEC-10 style file handling.  The use of streams provides a
unified interface to a number of different classes of sources and
sinks.  Currently these classes include textual and binary files,
console input and output, pipes, and atoms; in the future sockets and
urls may be handled under the stream interface.  When streams are
opened, certain actions may occur depending on the class of the source
or sink and on the wishes of the user.  For instance when a file {\tt
F} is opened for output mode, an existing file {\tt F} may be
truncated (in write mode) or not (in append mode).  In addition,
various operations may or may not be valid depending on the class of
stream.  For instance, repositioning is valid for an atom or file but
not a pipe or console.

XSB provides several default I/O streams, which make it easier for a
user to embed XSB in other applications.  These streams include the
default input and output streams.  They also include the standard
error stream, to which XSB writes all error messages.  By default the
standard error stream is the same as the standard output stream, but
it can be redirected either by UNIX shell-style I/O redirection or by
the predicates {\tt file\_reopen/4} and {\tt file\_clone/3}.
Similarly there is the standard warning stream (to which all system
warnings are written), the standard message stream, the standard
debugging stream (to which debugging information is written), and the
standard feedback stream (for interpreter prompts, yes/no answers,
etc).  All of these streams are aliased by default to standard output,
and can be redirected by the predicates the predicates {\tt
  file\_reopen/4} and {\tt file\_clone/3}.

\index{aliases!streams}
Streams may also be aliased: the default input and output streams can
be denoted by {\tt user\_input} and {\tt user\_output} and they refer
to the standard input and standard output streams of the
process \footnote{For backwards compatibility, the default input
  stream can also be aliased by {\tt user} or {\tt userin}, and the
  default output stream by {\tt user} or {\tt userout}.}.  Similarly,
XSB's error, warning and message streams user the aliases {\tt
  user\_error}, {\tt user\_warning} and {\tt user\_message}
respectively (cf. Section~\ref{}).

Streams are distinguished by their {\tt class} -- whether they are
file or atom, etc.; as well as by various properties.  These
properties include whether a stream is positionable or not and whether
a (file) stream is textual or binary.

\bi
\item {\tt Console} The default streams mentioned above are
console streams, which are textual and not repositionable.
%
\item {\tt File}  A file stream corresponds to an operating system
file and is repositionable.  On Windows, binary files and textual
files differ, while on UNIX they are the same.  
%
\item {\tt Atom} XSB can read from an atom, just as it can from a file.
Atoms are considered to be textual and repositionable.  Writing to
atoms via streams is not currently available in XSB, although 
the predicate {\tt term\_to\_atom/[2,3]} contains much of the
functionality that such streams would provide.

\item {\tt Pipe} XSB can also open pipes either directly, or as part
of its ability to spawn processes.  When made into streams, pipes are
textual and not repositionable.
\ei

%------------------------------------------------------------------------------------------------
\subsection{I/O Stream Implementation} \label{sec:IO-streams}

A user may note that XSB's I/O streams are small integers, but they
should not be confused with the file descriptors used by the OS.  The
OS file descriptors are objects returned by the C {\tt open} function;
XSB I/O streams indices into the internal XSB table of open files and
associated information. The OS does not know about XSB I/O streams,
while XSB (obviously) does know about the OS file descriptors. An OS
file descriptor may be returned by certain predicates (e.g.  {\tt
pipe\_open/2} or user-defined I/O).  In the former case, a file
descriptor can be promoted to XSB stream by {\tt open/\{3,4\}} and in
the latter by using the predicate {\tt fd2iostream/2}.

When it starts, XSB opens a number of standard I/O streams that it
uses to print results, errors, debugging info, etc. The descriptors
are described in the file {\tt prolog\_includes/standard.h}. This file
provides the following symbolic definitions:
%%
\begin{verbatim}
    #define STDIN            0
    #define STDOUT           1
    #define STDERR           2
    #define STDWARN          3    /* output stream for xsb warnings  */
    #define STDMSG           4    /* output for regular xsb messages */
    #define STDDBG           5    /* output for debugging info       */
    #define STDFDBK          6    /* output for XSB feedback
                                     (prompt/yes/no/Aborting/answers) */

    #define AF_INET     0     /* XSB-side socket request for Internet domain */
    #define AF_UNIX     1     /* XSB-side socket request for UNIX domain */
\end{verbatim}
%%
%------------------------------------------------------------------------------------------
\comment{
In addition, the file \verb|emu/file_modes_xsb.h| provides the definitions
for the file opening modes:
%%
\begin{verbatim}
    #define OREAD          0    /* open for read           */
    #define OWRITE         1    /* open for write          */
    #define OAPPEND        2    /* open for append         */
    #define OSTRINGR       3    /* open string for reading */
    #define OSTRINGW       4    /* open string for writing (not implemented) */
\end{verbatim}
%%
}
%------------------------------------------------------------------------------------------
These definitions can be used in user programs, if the following is
provided at the top of the source file:
%%
\begin{verbatim}
    compiler_options([xpp_on]).
    #include "standard.h"
\end{verbatim}
%%
If this header is used, the various streams can be used as any other output stream -- e.g. 
{\tt ?- write(STDWARN,'watch it!')}.
%
(Note: the XSB preprocessor is not invoked on clauses typed into an
interactive XSB session, so the above applies only to programs loaded from
a file using {\tt consult} and such.)

\subsection{ISO Streams}

\begin{description}

\isoitem{open(+SourceSink,+Mode,-Stream)}{open/3}
%
{\tt open/1} creates a stream for the source or sink designated in
{\tt SourceSink}, and binds {\tt Stream} to a structure representing
that stream.  
%
\bi
\item If {\tt SourceSink} is an atom, or the term {\tt file(File)}
where {\tt File} is an atom, the stream is a file stream.  In this
case {\tt Mode} can be 
\bi
\item {\tt read} to create an input stream.  In Windows, whether the
file is textual or binary is determined by the file's properties.
%
\item {\tt write} to create an output stream.  Any previous file with
a similar path is removed and a (textual) file is created which becomes
a record of the output stream.  
%
\item {\tt write\_binary} to create an output stream.  Any previous file with
a similar path is removed and a file is created which becomes
a record of the output stream.  The file created is binary in Windows,
while in UNIX {\tt write\_binary} has the same effect as {\tt write}.
%
\item {\tt append} to create an output stream.  In this case the
output stream is appended to the contents of the file, if it exists,
and otherwise a new file is created for (textual) output
%
\item {\tt append\_binary} to create an output stream.  In this case the
output stream is appended to the contents of the file, if it exists,
and otherwise a new file is created for (binary) output
\ei
\item If {\tt SourceSink} is the term {\tt atom(Atom)} where {\tt
Atom} is an atom, the stream is an atom stream.  In this case {\tt
Mode} currently can only be {\tt read}.  This stream class, which
reads from interned atoms, is analogous to C's {\tt sscanf()}
function.
%
\item If {\tt SourceSink} is the term {\tt pipe(FIleDescriptor)}
where {\tt FileDescriptor} is an integer, then a pipe stream is opened
in the mode for {\tt FileDescriptor}.
\ei

\compatability This predicate extends the ISO definition of {\tt
open/3} to include strings and pipes as well as the file modes {\tt
write\_binary} and {\tt append\_binary}.

{\bf Error Cases}
\bi
\item 	{\tt SourceSink} or {\tt Mode} is not instantiated
\bi
\item 	{\tt instantiation\_error}
\ei
%
\item 	{\tt Mode} is not a valid I/O mode
\bi
\item 	{\tt domain\_error(io\_mode,Mode)}
\ei
%
\item 	{\tt SourceSink} is a file and cannot be opened, or opened in
the desired mode 
\bi
\item 	{\tt permission\_error(open,file,SourceSink)}
\ei
\ei

\isoitem{open(+File,+Mode,-Stream,+Options)}{open/4}
%
{\tt open/4} behaves as does {\tt open/3}, but allows a list of
options to be given.  The current options are a subset of ISO options
and are:
\bi
\item {\tt alias(A)} allows the stream to be aliased to an atom {\tt
  A}.
%
\item {\tt type(T)} has no effect on file streams in UNIX, which are
  always textual, but in Windows if {\tt T} is {\tt binary} a binary
  file is opened.
\ei
%
{\bf Error Cases}  Error cases are the same as {\tt open/3} but with
the addition: 
\bi
\item {\tt Option\_list} contains an option {\tt O} that is not a
  (currently implemented) stream option.  
\bi
\item {\tt domain\_error(stream\_option,O)}
\ei
\item An element of {\tt OptionsList} is alias(A) and A is already
  associated with an existing thread, queue, mutex or stream 
\bi
\item {\tt permission\_error(create,alias, A)}
\ei
\item An element of {\tt OptionsList} is alias(A) and A is not an atom
\bi
\item {\tt type\_error(atom,A)}
\ei
\ei
%
\compatability 
%
The ISO option {\tt reposition(Boolean)} currently has no effect on
streams, because whether or not the stream is repositionable or not
depends on the stream class.  The ISO option {\tt eof\_action(Action)}
currently has no effect on file streams.  If these options are
encountered in {\tt Options}, a warning is issued to {\tt STDWARN}.

\isoitem{close(+Stream\_or\_alias,+OptionsList)}{close/2}
%
{\tt close/2} closes the stream or alias {\tt Stream\_or\_alias}.
{\tt OptionsList} allows the user to declare whether a permission
error will be raised in XSB upon a resource or system error from the
closing function (e.g. {\tt fclose()} or other system function).  If
{\tt OptionsList} is non-empty and contains only terms unifying with
{\tt force(true)} then such an error will be ignored (possibly leading
to unacknowledged loss of data).  Otherwise, a permission error is
thrown if {\tt fclose()} or other system function returns an error
condition.  If the stream class of {\tt Stream\_or\_alias} is an atom,
then the only action taken is to close the stream itself -- the
interned atom itself is not affected.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a stream term
  nor an alias.  
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item {\tt OptionList} contains an option {\tt O} that is not a closing
option.
\bi
\item {\tt domain\_error(close\_option,O)}
\ei
\item {\tt OptionList} contains conflicting options
\bi
\item {\tt domain\_error(close\_option,OptionList)}
\ei
\item 	Closing the stream produces an error (and {\tt OptionsList} is
	a non-empty list containing terms of the form {\tt force(true)}).
\bi
\item 	{\tt permission\_error(close,file,Stream\_or\_alias)}
\ei
\ei

\isoitem{close(+Stream\_or\_alias)}{close/1}
%
{\tt close/1} closes the stream or alias {\tt Stream\_or\_alias}.\\
Behaves as {\tt close(Stream\_or\_alias,[force(false)])}.

\isoitem{set\_input(+Stream\_or\_alias)}{set\_input/1}
    Makes file {\tt Stream\_or\_alias} the current input stream. 

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\isoitem{set\_output(+Stream\_or\_alias)}{set\_output/1}
    Makes file {\tt Stream\_or\_alias} the current output stream. 

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\isoitem{stream\_property(?Stream,?Property)}{stream\_property/2}
%
This predicate backtracks through the various stream properties that
unify with {\tt Property} for the stream {\tt Stream}.  Currently,
the following properties are defined.

\bi
\item {\tt stream\_class(C)} gives the stream class for a file:
i.e. {\tt file}, {\tt atom}, {\tt console} or {\tt pipe}.

\item {\tt file\_name(F)} is a property of {\tt Stream}, if
{\tt Stream} is a file stream and {\tt F} is the file name
associate with {\tt Stream}.  The full operating system
path is used.
%
\item {\tt type(T)} is a property of {\tt Stream}, if
{\tt Stream} is a file stream and {\tt T} is the file type
of {\tt Stream}: {\tt text} or {\tt binary}.
%
\item {\tt mode(M)} is a property of {\tt Stream}, if {\tt
M} represents the I/O mode with which {\tt Stream} was
opened: i.e. {\tt read}, {\tt write}, {\tt append}, {\tt
write\_binary}, etc., as appropriate for the class of {\tt
Stream}.
%
\item {\tt alias(A)}  is a property of {\tt Stream}, if
{\tt Stream} was opened with alias {\tt A}.
%
\item {\tt input}  is a property of {\tt Stream}, if {\tt
Stream} was opened in the I/O mode: {\tt read}.
% 
\item {\tt output}  is a property of {\tt Stream}, if {\tt
Stream} was opened in the I/O mode: {\tt write}, {\tt
append}, {\tt write\_binary}, or {\tt append\_binary}.
%
\item {\tt reposition(Bool)} is true, if {\tt Stream} is
repositionable, and false otherwise. 
%
\item {\tt end\_of\_stream(E)} returns {\tt at} if the end of stream
condition for {\tt Stream} is true, and {\tt not} otherwise.
%
\item {\tt position(Pos)} returns the current position of the stream
as determined by {\tt fseek{}} or the byte-offset of the current
stream within an atom.  In either case, if an end-of-stream condition
occurs, the token {\tt end\_of\_file} is returned.
%

%
\item {\tt eof\_action(Action)} is {\tt reposition} if the stream class
is {\tt console}, {\tt eof\_code} if the stream class is {\tt file},
and {\tt error} is the stream class is {\tt pipe} or {\tt atom}.
\end{itemize}

\isoitem{flush\_output(+Stream\_or\_alias)}{flush\_output/1}
%
Any buffered data in {\tt Stream\_or\_alias}  gets flushed.  If
{\tt Stream} is not buffered (i.e. if it is of class {\tt
atom}), no action is taken.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(Stream\_or\_alias,Stream)}
\ei
\item 	{\tt Stream} is not associated with an open output stream 
\bi
\item 	{\tt existence\_error(Stream\_or\_alias,Stream)}
\ei
\item 	Flushing (i.e. {\tt fflush()}) returns an error.
\bi
\item 	{\tt permission\_error(flush,stream,Stream)}
\ei
\ei

\isoitem{flush\_output}{flush\_output/0}
%
Any buffered data in the current output stream gets flushed.

\isoitem{set\_stream\_position(+Stream\_or\_alias,+Position)}{set\_stream\_position/2}
%
If the stream associated with {\tt Stream\_or\_alias} is
repositionable (i.e. is a file or atom), sets the stream position
indicator for the next input or output operation. Position is a
positive integer, taken to be the number of bytes the stream is to be
placed from the origin.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Position} is not instantiated to a positive integer.
\bi
\item 	{\tt domain\_error(stream\_position,Position)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not repositionable, or
	repositioning returns an error. 
\bi
\item 	{\tt permission\_error(resposition,stream,Stream\_or\_alias)}
\ei
\ei

\isoitem{at\_end\_of\_stream(+Stream\_or\_alias)}{at\_end\_of\_stream/1}
%
Succeeds if {\tt Stream\_or\_alias} has position at or past the end of
stream.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei
%

\isoitem{at\_end\_of\_stream}{at\_end\_of\_stream/0}
%
Acts as {\tt at\_end\_of\_stream/1} but using the current input
stream.

\end{description}

\subsubsection{Other Predicates using ISO Streams}

\begin{description}

\standarditem{file\_reopen(+FileName,+Mode,+Stream,-RetCode)}{file\_reopen/3}
%
    Takes an existing I/O stream, closes it, then opens it and
    attaches it to a file. This can be used to redirect I/O from any of the
    standard streams to a file. For instance, 
%%
\begin{verbatim}
    | ?- file_reopen('/dev/null', w, 3, Error).
\end{verbatim}
%%
    redirects all warnings to the Unix black hole. 

    On success, {\tt RetCode} is 0; on error, the return code is negative.

%-----------------------------------------------------------------------------

\standarditem{file\_clone(+SrcStream,?DestStream,-RetCode)}{file\_clone/3}
%
This is yet another way to redirect I/O. It is a Prolog interface to
the C {\tt dup} and {\tt dup2} system calls. If {\tt DestStream} is a
variable, then this call creates a new XSB I/O stream that is a clone
of {\tt SrcStream}. This means that I/O sent to either stream goes
to the same place. If {\tt DestStream} is not a variable, then it must
be a number corresponding to a valid I/O stream. In this case, XSB
closes {\tt DestStream} and makes it into a clone of {\tt
SrcStream}. 

For instance, suppose that 10 is a I/O Stream that is currently open
for writing to file {\tt foo.bar}.  Then 
%%
\begin{verbatim} 
| ?- file_clone(10,3,_).  
\end{verbatim} 
%% 
causes all messages sent to XSB standard warnings stream to go to file
{\tt foo.bar}. While this could be also done with {\tt file\_reopen},
there are things that only {\tt file\_clone} can do: 
%%
\begin{verbatim} 
| ?- file_clone(1,10,_). 
\end{verbatim} 
%% 
This means that I/O stream 10 now becomes clone of standard
output. So, all subsequent I/O will now go to standard output instead
of {\tt foo.bar}.

On success, {\tt RetCode} is 0; on error, the return code is negative.

%-----------------------------------------------------------------------------

\ourmoditem{file\_truncate(+Stream, +Length, -Return)}{file\_truncate/3}{file\_io}
    The regular file  referenced by the Stream{\tt Stream}
    is chopped to have the size of {\tt Length} bytes. Upon successful
    completion {\tt Return} is set to zero.

\portability Under Windows (including Cygwin) {\tt file\_truncate/2}
is implemented using {\tt \_chsize()}, while on Unix {\tt ftruncate()}
is used.  There are minor semantic differences between these two
system calls, which are reflected by the behavior of {\tt
file\_truncate/2} on different platforms.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Stream\_or\_alias} is neither a variable, nor a a stream
  term nor an alias.  
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item {\tt Length} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt Length} is neither a variable nor an integer
\bi
\item 	{\tt type\_error(integer,Length)}
\ei
\ei
\comment{Not checking for uninstantiated Return or for negative Length}

\standarditem{tmpfile\_open(-Stream)}{tmpfile\_open/1}
    Opens a temporary file with a unique filename. The file is deleted
    when it is closed or when the program terminates.

\end{description}

\subsection{DEC-IO Style File Handling}

\begin{description}
\standarditem{see(+File\_or\_stream)}{see/1}
%
Makes {\tt File\_or\_stream} the current input stream. 
%
\begin{itemize}
\item If there is an open input stream associated with the file that
  has {\tt File\_or\_stream} as its file name, and that stream was
  opened previously, then it is made the current input stream.
%
\item Otherwise, the specified file is opened for input and made the
  current input stream. If the file does not exist, {\tt see/1} throws
  a permission error.
\end{itemize}
%
Note that {\tt see/1} is incompatable with ISO aliases -- calling {\tt
  see(Alias)} with an ISO alias will try to open a file named {\tt
  Alias} rather than using the alias.  Also note that different file
names (that is, names which do not unify) represent different input
streams (even if these different file names correspond to the same
file).

{\bf Error Cases}
\bi
\item  {\tt File\_or\_stream} is  a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt File\_or\_stream} is neither a variable nor an atomic file identifier nor
  a stream identifier.
\bi
\item {\tt domain\_error(stream\_or\_path,F)}
\ei
\item File {\tt File\_or\_stream} is directory or file is not readable. 
\bi
\item {\tt permission\_error(open,file,F)}
\ei
\item File {\tt File\_or\_stream} does not exist. 
\bi
\item {\tt existence\_error(stream\_or\_path,F)}
\ei
\ei

\standarditem{seeing(?F)}{seeing/1}
    {\tt F} is unified with the name of the current input stream.
    This is exactly the same with predicate {\tt current\_input/1}
    described in Section~\ref{State}, and it is only provided for
    upwards compatibility reasons.

\standarditem{seen}{seen/0}
    Closes the current input stream. 
    Current input reverts to {\tt ``userin''} (the standard input stream).

\standarditem{tell(+F)}{tell/1}
    Makes file {\tt F} the current output stream. 
    \begin{itemize}
    \item If there is an open output stream associated with {\em F}  
          and that was opened previously 
          by {\tt tell/1}, then that stream is made the current output 
	  stream. 
    \item Otherwise, the specified file is opened for output and made the
          current output stream. If the file does not exist, it is created.
    \end{itemize}

    Also note that different file names (that is, names which do not unify) 
    represent different output streams (even if these different file names 
    correspond to the same file).

    The implementation of the ISO predicate {\tt set\_output/1}, is
    essentially that of {\tt tell/1}.

{\bf Error Cases}
\bi
\item  {\tt File\_or\_stream} is  a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt File\_or\_stream} is neither a variable nor an atomic file identifier nor
  a stream identifier.
\bi
\item {\tt domain\_error(stream\_or\_path,F)}
\ei
\item File {\tt File\_or\_stream} is directory or file is not readable. 
\bi
\item {\tt permission\_error(open,file,F)}
\ei
\item File {\tt File\_or\_stream} does not exist. 
\bi
\item {\tt existence\_error(stream\_or\_path,F)}
\ei
\ei

\standarditem{telling(?F)}{telling/1}
    {\tt F} is unified with the name of the current output stream.
    This predicate is exactly the same with predicate {\tt current\_output/1}
    described in Section~\ref{State}, and it is only provided for
    upwards compatibility reasons.

\standarditem{told}{told/0}
    Closes the current output stream. 
    Current output stream reverts to ``userout'' (the standard output stream).

\standarditem{file\_exists(+F)}{file\_exists/1}
    Succeeds if file {\tt F} exists. {\tt F} must be instantiated to
    an atom at the time of the call, or an error message is displayed on
    the standard error stream and the predicate aborts.

{\bf Error Cases}
    \begin {description}
    \item[{\tt instantiation\_error}]
	{\tt F} is uninstantiated.
    \end{description}

\end{description}


\subsection{Character I/O}
\begin{description}

\isoitem{nl}{nl/0}
A new line character is sent to the current output stream.

\isoitem{nl(+Stream\_or\_alias)}{nl/1}
A new line character is sent to the designated output stream.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

%-----------------------------
% Gets

\isoitem{get\_char(+Stream\_or\_alias,?Char)}{get\_char/2}
   Unifies {\tt Char} with the next ASCII character from {\tt
   Stream\_or\_alias}, advancing the position of the stream.  {\tt
   Char} is unified with -1 if an end of file condition is detected.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_or\_variable,Char)}
\ei
\ei

\isoitem{get\_char(?Char)}{get\_char/1}
%
Behaves as {\tt get\_char/2}, but reads from the current input stream.

{\bf Error Cases}
\bi
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_or\_variable,Char)}
\ei
\ei

\isoitem{get\_code(+Stream\_or\_alias,?Code)}{get\_code/2}
%
   {\tt Code} unifies with the ASCII code of the next character from
   {\tt Stream\_or\_alias}.  The position of the stream is advanced.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Code} is not a variable or character code
\bi
\item 	{\tt domain\_error(character\_code\_or\_variable,Code)}
\ei
\ei

\isoitem{get\_code(?Code)}{get\_code/1}
%
Behaves as {\tt get\_code/2}, but reads from the current input stream.

{\bf Error Cases}
\bi
\item 	{\tt Code} is not a variable or character code
\bi
\item 	{\tt domain\_error(character\_code\_or\_variable,Code)}
\ei
\ei

\standarditem{get0(?N)}{get0/1}
%
{\tt N} is the ASCII code of the next character read from the current
input stream (regarded as a text stream). If the current input stream
reaches its end of file, a {\tt -1} is returned.  This predicate does
not check for errors, so that it is faster (and potentially less safe)
than, e.g. {\tt get\_code/1}.

\standarditem{get(?N)}{get/1}
    {\tt N} is the ASCII code of the next non-blank printable
    character from the current input stream (regarded as a text
    stream).  If the current input stream reaches its end of file, a
    {\tt -1} is returned.

%------------------------------------
% Peeks

\isoitem{peek\_char(+Stream\_or\_alias,?Char)}{peek\_char/2}
%
{\tt Char} is the next ASCII character from {\tt Stream\_or\_alias}.
The position in {\tt Stream\_or\_alias} is unchanged.  {\tt Char} is
unified with -1 if an end of file condition is detected.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_or\_variable,Char)}
\ei
\ei

\isoitem{peek\_char(?Char)}{peek\_char/1}
%
{\tt Char} is the next ASCII character from the current input stream.
The position in the current input stream is unchanged.  {\tt Char} is
unified with -1 if an end of file condition is detected.

{\bf Error Cases}
\bi
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_or\_variable,Char)}
\ei
\ei

\isoitem{peek\_code(+Stream\_or\_alias,?Code)}{peek\_code/2}
%
{\tt Code} is the next ASCII coder from {\tt Stream\_or\_alias}.
The position in {\tt Stream\_or\_alias} is unchanged.  {\tt Code} is
unified with -1 if an end of file condition is detected.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Code} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_code\_or\_variable,Code)}
\ei
\ei

\isoitem{peek\_code(?Code)}{peek\_code/1}
%
Behaves as {\tt peek\_code/1}, but the current input stream is used.

{\bf Error Cases}
\bi
\item 	{\tt Char} is not a variable or character.
\bi
\item 	{\tt domain\_error(character\_code\_or\_variable,Code)}
\ei
\ei

%----------------------------------------------
% Puts
%----------------------------------------------

\isoitem{put\_char(+Stream,+Char)}{put\_char/2}
%
Puts the ASCII character {\tt Char} to {\tt Stream\_or\_alias}.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Char} is a not a character
\bi
\item 	{\tt type\_error(character,Char)}
\ei
\ei

\isoitem{put\_char(+Char)}{put\_char/1}
%
Puts the ASCII code of the character {\tt Char} to the current output
stream.

{\bf Error Cases}
\bi
\item 	{\tt Code} is a not a character.
\bi
\item 	{\tt type\_error(character,Char)}
\ei
\ei

\isoitem{put\_code(+Stream,+Code)}{put\_code/2}
%
Puts the ASCII code of the character {\tt Char} to {\tt
Stream\_or\_alias}.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item 	{\tt Code} is a not a character code
\bi
\item 	{\tt type\_error(character\_code,Code)}
\ei
\ei


\isoitem{put\_code(+Code)}{put\_code/1}
%
Puts the ASCII code {\tt Code} to the current output stream.
{\bf Error Cases}
\bi
\item 	{\tt Code} is a not a character code.
\bi
\item 	{\tt type\_error(character\_code,Code)}
\ei
\ei

\standarditem{put(+Code)}{put/1}
    Puts the ASCII character code {\tt N} to the current output stream.

{\bf Error Cases}
\bi
\item 	{\tt Code} is a not a character code.
\bi
\item 	{\tt type\_error(character\_code,Code)}
\ei
\ei

\standarditem{tab(+N)}{tab/1}
    Puts {\tt N} spaces to the current output stream. 

{\bf Error Cases}
\bi
\item 	{\tt Code} is a not a positiveInteger
\bi
\item 	{\tt domain\_error(positiveInteger,Code)}
\ei
\ei

\isorepeatitem{get\_byte/1}{get\_byte/1}
\isorepeatitem{get\_byte/2}{get\_byte/2}
\isorepeatitem{put\_byte/1}{peek\_byte/1}
\isorepeatitem{put\_byte/2}{peek\_byte/2}
\isorepeatitem{put\_byte/1}{put\_byte/1}
\isoitem{put\_byte/2}{put\_byte/2}
%
In XSB, these predicates are simply aliases for the associated {\tt
  xxx\_code} predicates and behave accordingly.  This is safe to do
since the reader for \version{} of XSB supports only ASCII character
codes, which are themselves single bytes.  
%
\end{description}

%---------------------------------------------------------------------------------------------------------
\subsection{Term I/O}
\begin{description}
\isoitem{read(?Term)}{read/1}
    A HiLog term is read from the current or designated input stream,
    and unified with {\tt Term} according to the operator declarations
    in force.  (See Section~\ref{TermSyntax} for the definition and
    syntax of HiLog terms). The term must be delimited by a full stop
    (i.e. a ``.'' followed by a carriage-return, space or tab).
    Predicate {\tt read/1} does not return until a valid HiLog term is
    successfully read; that is, in the presence of syntax errors {\tt
    read/1} does not fail but continues reading terms until a term
    with no syntax errors is encountered.  If a call to {\tt
    read(Term)} causes the end of the current input stream to be
    reached, variable {\tt Term} is unified with the term {\tt
    end\_of\_file}.  In that case, further calls to {\tt read/1} for
    the same input stream will cause an error failure.

%TLS: This doesn't actually seem to be the behavior.  Exceptions:
% \begin{description} 
% \item[{\tt existence\_error}] {\tt end\_of\_file}
%  is reached before the current term is read.  
%\end{description} 
%
In \version, {\tt read/[1,2]} are non ISO-compliant in how they
handle syntax errors or their behavior when encountering an end of
file indicator.

%--------

\isoitem{read(+Stream\_or\_alias, ?Term)}{read/2}
	{\tt read/2} has the same behavior as {\tt read/1} but the
	input stream is explicitly designated by {\tt
	Stream\_or\_alias}.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

%--------
\standarditem{read\_canonical(-Term)}{read\_canonical/1}
Reads a term that is in canonical format from the current input stream
and returns it in {\tt Term}. On end-of-file, it returns the atom {\tt
end\_of\_file}.  If it encounters an error, it prints an error message
on stderr and returns the atom {\tt read\_canonical\_error}. This is
significantly faster than {\tt read/1}, but requires the input to be
in canonical form.

%In \version, {\tt read\_canonical/[1,2]} are non ISO-compliant in how they
%handle syntax errors or their behavior when encountering an end of
%file indicator.

\standarditem{read\_canonical(+Stream\_or\_alias),-Term)}{read\_canonical/2}
Behaves as {\tt read\_canonical/1}, but reads from {\tt Stream\_or\_alias}.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

%--------
\isoitem{read\_term(?Term,?OptionsList)}{read\_term/2}
%
A term is read from the current input stream as in {\tt read/1}; but
{\tt OptionsList} is a (possibly empty) list of {\em read options}
that specifies additional behavior.  The read options include
\begin{itemize}
\item {\tt variables(Vars)}: once a term has been read, {\tt Vars} is a
list of the variables in the term, in left-to-right order. 
\item {\tt variable\_names(VN\_List)}: once a term has been read {\tt
VN\_List} is a list of non-anonymous variables in the term.  The
elements of the list have the form {\tt A = V} where {\tt V} is a
non-anonymous variable of the term, and {\tt A} is the string used to
denote the variable in the input stream.
\item {\tt singletons(VS\_List)}: once a term has been read {\tt
VN\_List} is a list of the non-anonymous {\tt singleton} variables in
the term.  The elements of the list have the form {\tt A = V} where
{\tt V} is a non-anonymous variable of the term, and {\tt A} is the
string used to denote the variable in the input stream.
\end{itemize}

{\bf Error Cases}
\bi
\item 	{\tt OptionsList} is a variable, or is a list containing a
	variable element. 
\bi 
\item instantiation\_error
\ei
\item     {\tt OptionsList} contains a non-variable element {\tt O} that is not
	a read option.
\bi
\item 	{\tt domain\_error(read\_option,O)}
\ei
\ei

%--------

\isoitem{read\_term(+Stream\_or\_alias, ?Term,?OptionsList)}{read\_term/3}
%
{\tt read\_term/3} has the same behavior as {\tt read\_term/2} but
the input stream is explicitly designated using the first argument.

{\bf Error Cases} are the same as {\tt read\_term/2}, but with the
additional errors that may arise in stream checking.
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\isoitem{write\_term(?Term,+Options)}{write\_term/2}
%
Outputs {\tt +Term} to the current output stream.
{\tt Stream} ({\tt write\_term/3}) according to the list of write
options, {\tt Options}.  The current set of write options which form a
superset of the ISO-standard write options, are as follows:
%
\begin{itemize}
%
\item {\tt quoted(+Bool)}.  If {\tt Bool = true}, then atoms and
    functors that can't be read back by {\tt read/1} are quoted, if
    {\tt Bool = false}, each atom and functor is written as its
    unquoted name. Default value is {\tt false}.
%
\item {\tt ignore\_ops(+Bool)}. If {\tt Bool = true} each compound term
is output in functional notation; curly brackets and list braces are
ignored, as are all explicitly defined operators.  If {\tt Bool =
false}, curly bracketed notation and list notation is enabled when
outputting compound terms, and all other operator notation is
enabled.  Default value is {\tt false}.
%
 \item {\tt numbervars(+Bool)}.  If {\tt Bool = true}, a term of the
form {\tt '\$VAR'(N)} where {\tt N} is an integer, is output as a
variable name consisting of a capital letter possibly followed by an
integer.  A term of the form {\tt '\$VAR'(Atom)} where {\tt Atom} is an
atom, is output as itself (without quotes).  Finally, a term of the
form {\tt '\$VAR'(String)} where {\tt String} is a character string, is
output as the atom corresponding to this character string.  If
{\tt bool} is {\tt false} this cases are not treated in any special
way.  Default value is {\tt false}.
%
% TLS: need predicate portray attribute, if we dont have it.
%
\comment{
\item {\tt portrayed(+Bool)}. If {\tt Bool = true}, then a call is made
to the predicate @pred{portray/1}, to
provide the user handlers for pretty printing some terms.  {\tt
portray_attribute/1} is called whenever an attributed variable is to
be printed, {\tt portray/1} is called whenever a non-variable term is
to be printed.  If either call succeeds, then it is assumed that the
term has been output, else it is printed as usual.  If {\tt bool} is
{\tt false}, these predicates are not called. Default value is {\tt
false}.  This option is set by the top-level when writing the final
values of variables, and by the debugging package when writing the
goals in the tracing messages.  Thus you can vary the forms of these
messages if you wish.
}
\item {\tt max\_depth(+Depth)}. {\tt Depth} is a positive integer or
zero. If positive, it denotes the depth limit on printing compound
terms. If {\tt Depth} is zero, there is no limit. Default value is
{\tt 0} (no limit).
%
\item {\tt priority(+Prio)} {\tt Prio} is an integer between 1 and
1200.  If the term to be printed has higher priority than {\tt Prio},
it will be printed parenthesized.  Default value is 1200 (no term
parenthesized).
\end{itemize}

From the following examples it can be seen that {\tt
write\_term/[2,3]} can duplicate the behavior of a number of other
I/O predicates such as {\tt write/[1,2]}, {\tt writeq/[1,2]}, {\tt
write\_canonical/[1,2]}, etc.
{\small
\begin{verbatim}

| ?- write_term(f(1+2,'A',"string",'$VAR'(3),'$VAR'('Temp'),(multifile foo)),[]).
f(1 + 2,A,"string",$VAR(3),$VAR(Temp),(multifile foo))
yes

| ?- write_term(f(1+2,'A',"string",'$VAR'(3),'$VAR'('Temp'),(multifile foo)),
                [quoted(true)]).
f(1 + 2,'A',"string",'$VAR'(3),'$VAR'('Temp'),(multifile foo))
yes

| ?- write_term(f(1+2,'A',"string",'$VAR'(3),'$VAR'('Temp'),(multifile foo)),
                [quoted(true),ignore_ops(true),numbervars(true)]).
f(+(1,2),'A','.'(115,'.'(116,'.'(114,'.'(105,'.'(110,'.'(103,[])))))),D,Temp,(multifile foo))
yes

| ?- write_term(f(1+2,'A',"string",'$VAR'(3),'$VAR'('Temp'),(multifile foo)),
                [quoted(true),ignore_ops(true),numbervars(true),priority(1000)]).
f(+(1,2),'A','.'(115,'.'(116,'.'(114,'.'(105,'.'(110,'.'(103,[])))))),D,Temp,multifile(foo))
yes
\end{verbatim}
}

{\bf Error Cases} 
\bi
\item 	{\tt Options} is a variable
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Options} neither a variable nor a list
\bi
\item    {\tt type\_error(list,Options)}
\ei
\item 	{\tt Options} contains a variable element, {\tt O}
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Options} contains an element {\tt O} that is neither a variable
nor a write option.
\bi
\item    {\tt domain\_error(write\_option,O)}
\ei
\ei

\compatability In \version{}, {\tt write\_term/[2,3]} do not properly
handle operators.

\isoitem{write\_term(+Stream\_or\_alias,?Term,+Options)}{write\_term/3}
% 
Behaves as {\tt write\_term/2}, but writes to {\tt Stream\_or\_alias}.

{\bf Error Cases} are the same as {\tt write\_term/2} but with these
additions.
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\isoitem{write(?Term)}{write/1}
% 
Semantically, {\tt write/1} behaves as if {\tt write\_term/1} were
invoked using {\tt quoted(false)}, {\tt ignore\_ops(false)}, and {\tt
  numbervars(false)}.

The HiLog term {\tt Term} is written to the current output stream,
according to the operator declarations in force.  Any uninstantiated
subterm of term {\tt Term} is written as an anonymous variable (an
underscore followed by a token).  

All {\em proper HiLog terms} (HiLog terms which are not also Prolog
terms) are not written in their internal Prolog representation.  {\tt
  write/1} always succeeds without producing an error.

HiLog (or Prolog) terms that are output by {\tt write/1} cannot in
general be read back using {\tt read/1}.  This happens for two
reasons:
    \begin{itemize}
    \item The atoms appearing in term {\tt Term} are not quoted. In that case 
          the user must use {\tt writeq/1} or 
          {\tt write\_canonical/1} described below, which quote around atoms 
          whenever necessary.
    \item The output of {\tt write/1} is not terminated by a full-stop;
          therefore, if the user wants the term to be accepted as input to
          {\tt read/1}, the terminating full-stop must be explicitly sent 
          to the current output stream. 
    \end{itemize}

{\tt write/1} treats terms of the form \verb|'$VAR'(N)|, which may be
generated by {\tt numbervars/[1,3]} specially: it writes {\tt 'A'} if
{\tt N}=0, {\tt 'B'} if {\tt N}=1, $\ldots$, {\tt 'Z'} if {\tt N}=25,
{\tt 'A1'} if {\tt N}=26, etc.  \verb|'$VAR'(-1)| is written as the
anonymous variable \verb|'_'|.

\isoitem{write(+Stream\_or\_alias, ?Term)}{write/2}
	{\tt write/2} has the same behavior as {\tt write/1} but the
	output stream is explicitly designated using the first argument.

{\bf Error Cases} are the same as {\tt read\_term/2}, but with the
additional errors that may arise in stream checking.
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\isoitem{writeq(?Term)}{writeq/1}
%
Acts as {\tt write\_term/1} when defined with the options {\tt
  quoted(true)}, {\tt numbervers(true)}, and {\tt ignore\_ops(false)}.
In other words, atoms and functors are quoted whenever necessary to
make the result acceptable as input to {\tt read/1} {\tt writeq/1}
also treats terms of the form \verb|'\VAR'(N)| specially, writing {\tt
  A} if {\tt N}= 0, etc., and output is in accordance with current
operator definitions.  {\tt writeq/1} always succeeds without
producing an error.

\isoitem{writeq(+Stream\_or\_alias, ?Term)}{writeq/2}
%
	{\tt writeq/2} has the same behavior as {\tt writeq/1} but the
	output stream is explicitly designated using the first argument.

{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\index{canonical format}
\isoitem{write\_canonical(?Term)}{write\_canonical/1}
%
This predicate is provided so that the HiLog term {\tt Term}, if
written to a file, can be read back using {\tt read\_canonical/[1,2]}
or {\tt read/[1,2]} regardless of special characters appearing in {\tt
  Term} or prevailing operator declarations. Like {\tt
  write\_prolog/1}, {\tt write\_canonical/1} writes all proper HiLog
terms to the current output stream using the standard Prolog syntax
(see Section~\ref{TermSyntax} on the standard syntax of HiLog
terms). {\tt write\_canonical/1} also quotes atoms and functors as
{\tt writeq/1} does, to make them acceptable as input of {\tt
  read/1}\@.  Except for list-notation ({\tt []}) and infix comma-list
notation, operator declarations are not taken into consideration, so
that apart from these exceptions compound terms are written in the
form:
%
		\[ \langle predicate\ name \rangle
			(\langle arg_1 \rangle, \ldots,
			 \langle arg_n \rangle) \]
%
Unlike {\tt writeq/1}, {\tt write\_canonical/1} does not treat terms
of the form \verb|'$VAR'(N)| specially. It writes square bracket lists
using {\tt '.'/2} and {\tt []} (that is, {\tt [foo, bar]} is written
as \verb|'.'(foo,'.'(bar,[]))|).

\compatability
%
In XSB, list notation and infix comma-list notation are considered
canonical both for reading and writing.  We find that this improves
readability, and that these operators are so standard that there is
little likelihood that they will not be in effect by any Prolog
reader.  We therefore deviate from the ISO standard definition of
canonical in these cases.

\isoitem{write\_canonical(+Stream\_or\_alias, ?Term)}{write\_canonical/2}
%
{\tt write\_canonical/2} has the same behavior as {\tt
write\_canonical/1} but the output stream is explicitly designated
using the first argument.

{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\standarditem{writeln(?Term)}{writeln/1}
    {\tt writeln(Term)} can be defined as {\tt write(Term), nl}.

\standarditem{writeln(+Stream,?Term)}{writeln/2}
    {\tt writeln(Term)} can be defined as {\tt write(Stream,Term),
    nl(Stream)}.

\standarditem{display(?Term)}{display/1}
    The HiLog term {\tt Term} is displayed on the terminal (standard output 
    stream), according to the operator declarations in force. In other words,
    {\tt display/1} is similar to {\tt write/1} but the result is always
    written on {\tt ``userout''}\@.  Like {\tt write/1}, {\tt display/1} 
    always succeeds without producing an error. After returning from a call 
    to this predicate, the current output stream remains unchanged.

\ourrepeatstandarditem{write\_prolog(?Term)}{write\_prolog/1}{HiLog}
\ourstandarditem{write\_prolog(+Stream\_or\_alias,?Term)}{write\_prolog/1}{HiLog}
%
   {\tt write\_prolog/1} acts as {\tt write/1} except that any proper
   HiLog term {\tt Term} is written using Prolog syntax -- i.e. as a
   term whose outer functor is apply.  {\tt write\_prolog/1} outputs
   {\tt Term} according to the operator declarations in force.
   Because of this, it differs from {\tt write\_canonical/1} described
   above, despite the fact that both predicates write HiLog terms as
   Prolog terms.

   {\tt write\_prolog/2} has the same behavior as {\tt
     write\_prolog/1} but the output stream is explicitly designated
   using the first argument.  Error Cases for {\tt write\_prolog/2}
   are the same as for {\tt write/2}.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- write_prolog(X(a,1+2)).
                apply(_h120,a,1 + 2)

                yes
                | ?- write(X(a,1+2)).
                _h120(a,1 + 2)

                yes
                | ?- write_canonical(X(a,1+2)).
                apply(_h120,a,+(1,2))

                yes
     \end{verbatim}}


\ourmoditem{numbervars(+Term, +FirstN, ?LastN)}{numbervars/3}{num\_vars}
%\predindex{numbervars/3~(L)}
    This predicate provides a mechanism for grounding a (HiLog) term
    so that it may be analyzed.  Each variable in the (HiLog) term
    {\tt Term} is instantiated to a term of the form \verb|'$VAR'(N)|,
    where {\tt N} is an integer starting from {\tt FirstN}.  
    {\tt FirstN} is used as the value of {\tt N} for the first
    variable in {\tt Term} (starting from the left). The second distinct
    variable in {\tt Term} is given a value of {\tt N} satisfying
    {\tt "N is FirstN + 1"} and so on.  The last variable in {\tt Term}
    has the value {\tt LastN-1}.
% $ for prettyprinter....

\ourmoditem{numbervars(+Term)}{numbervars/1}{num\_vars}
%\predindex{numbervars/1~(L)}
    This predicate is defined as:
    \begin{center}
    {\tt   numbervars(Term, 0, \_)}.
    \end{center}
    It is included solely for convenience.

\ourmoditem{unnumbervars(+Term, +FirstN, ?Copy)}{unnumbervars/3}{num\_vars}
%\predindex{unnumbervars/3~(B)}
    This predicate is a partial inverse of predicate {\tt
    numbervars/3}.  It creates a copy of Term in which all subterms of
    the form \verb|'$VAR'(<int>)| where \verb|<int>| is not less than
    {\tt FirstN} are uniformly replaced by variables.  \verb|'$VAR''|
    subterms with the same integer are replaced by the same variable.
    Also a version {\tt unnumbervars/2} is provided which calls {\tt
    unnumbervars/3} with the second parameter set to 0.

\end{description}

\subsubsection{Term Writing to Designated I/O Streams}
%
While XSB has standard I/O streams for errors, warnings, messages, and
feedback (cf. Section~\ref{sec:IO-streams}), the predicates above
write to {\tt STDOUT} which is the standard output for the process.
Most of the time there is no issue with this as these streams are
aliased to {\tt STDOUT}.  However in a number of circumstances, {\tt
  STDOUT} may be redirected: a user may have invoked {\tt tell/1}, XSB
may be invoked through C or interprolog, etc.  In such cases, it may
be useful to ensure that output goes to one of the other I/O streams.  

\begin{description}

\ourrepeatmoditem{error\_write(?Message)}{error\_write/1}{standard}
\ourmoditem{error\_writeln(?Message)}{error\_writeln/1}{standard}
%
These predicates output {\tt Message} to XSB's {\tt STDERR} stream,
rather than to XSB's {\tt STDOUT} stream, as does {\tt write/1} and
{\tt writeln/1}.  In addition, if {\tt Message} is a list or comma
list, the elements in the comma list are output as if they were
concatenated together.  Each of these predicates must be imported from
the module {\tt standard}.

\ourrepeatmoditem{console\_write(?Message)}{console\_write/1}{standard}
\ourmoditem{console\_writeln(?Message)}{console\_writeln/1}{standard}
%
As above, but writes to {\tt STDFDBK}, the console feedback stream.

\ourmoditem{warning(?Message)}{warning/1}{standard}
%\ourmoditem{warningln(?Message)}{warningln/1}{standard}
%
By default, this predicate outputs {\tt Message} to XSB's {\tt
  STDWARN} stream, rather than to XSB's {\tt STDOUT} stream, as does
{\tt write/1} and {\tt writeln/1}.  In addition, if {\tt Message} is a
list or comma list, the elements in the comma list are output as if
they were concatenated together.  Each of these predicates must be
imported from the module {\tt standard}.

The default behavior for warnings can be altered by setting the value
of the XSB flag {\tt warning\_action} to either {\tt silent\_warning}
which performs no action when {\tt warning/1} is called. or {\tt
  error\_warning} which throws a miscellaneous exception when {\tt
  warning/1} is called (WARNING: this includes compiler warnings).
The default behavior can be restored by setting {\tt warning\_action}
to {\tt print\_warning}.

\ourrepeatmoditem{message(?Message)}{message/1}{standard}
\ourmoditem{messageln(?Message)}{messageln/1}{standard}
%
As above, but writes to {\tt STDMSG} the standard stream for messages.

\end{description}

\subsection{Special I/O}

\begin{description}
\standarditem{fmt\_read(+Fmt,-Term,-Ret)}{fmt\_read/3}
\vspace{-7mm}
\standarditem{fmt\_read(+Stream,+Fmt,-Term,-Ret)}{fmt\_read/4}
%
    These predicates provides a routine for reading data from the
    current input file (which must have been already opened by using
    {\tt see/1}) according to a C format, as used in the C function
    {\tt scanf}. {\tt Fmt} must be a string of characters (enclosed in
    ") representing the format that will be passed to the C call to
    {\tt scanf}.  See the C documentation for {\tt scanf} for the
    meaning of this string.  The usual alphabetical C escape
    characters ({\it e.g.}, $\backslash n$) are recognized, but not
    the octal or the hexadecimal ones.  Another difference with C is
    that, unlike most C compilers, XSB insists that a single {\tt \%}
    in the format string signifies format conversion
    specification. (Some C compilers might output {\tt \%} if it is
    not followed by a valid type conversion spec.) So, to output {\tt
    \%} you must type {\tt \%\%}.  Format can also be an atom enclosed
    in single quotes. However, in that case, escape sequences are not
    recognized and are printed as is.

    {\tt Term} is a term ({\it e.g.}, {\tt args(X,Y,Z)})  whose arguments
    will be unified with the field values read in.  (The functor symbol of {\tt
    Term} is ignored.)  Special syntactic sugar is provided for the case
    when the format string contains only one format specifier: If {\tt
    Term} is a variable, {\tt X}, then the predicate behaves as if {\tt
    Term} were {\tt arg(X)}.

  If the number of arguments exceeds the number of format specifiers, a
  warning is produced and the extra arguments remain uninstantiated.
  If the number of format specifiers exceeds the number of arguments, then
  the remainder of the format string (after the last matching specifier) is
  ignored.
  
  Note that floats do not unify with anything.  {\tt Ret} must be a
  variable and it will be assigned a return value by the predicate: a
  negative integer if end-of-file is encountered; otherwise the number of
  fields read (as returned by {\tt scanf}.)
  
  {\tt fmt\_read} cannot read strings (that correspond to the {\tt \%s}
  format specifier) that are longer than 16K. Attempting to read longer
  strings will cause buffer overflow. It is therefore recommended that one
  should use size modifiers in format strings ({\it e.g.}, {\tt \%2000s}),
  if such long strings might occur in the input.

% Maybe some other error cases, who knows?
{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

If the number of arguments in {\tt Term} is greater than the number of
conversion specifiers in {\tt Fmt} no error is thrown, but a warning
is issued.

\standarditem{fmt\_write(+Fmt,+Term)}{fmt\_write/2}
\vspace{-7mm}
\standarditem{fmt\_write(+Stream\_or\_alias,+Fmt,+Term)}{fmt\_write/3} 
%
These predicates provide routines for writing formatted data to a
given output stream ({\tt fmt\_write/3}) or the current output stream
({\tt fmt\_write/2}).

{\tt Fmt} should be a Prolog character list (string) or atom.  A
Prolog character list is preferred, as space can be more easily
reclaimed for character lists than for atoms.  {\tt Term} is a Prolog
term ({\it e.g.}, {\tt args(X,Y,Z)}) whose arguments will be
output. The number of arguments in {\tt Term} should equal the number
of conversion specifiers in {\tt Fmt}.  The functor symbol of {\tt
  Term} is ignored~\footnote{In the case where {\tt Fmt} contains only
  a single conversion specifier, {\tt Term} may be a string, integer
  or a float, and is considered to be equivalent to specifying {\tt
    arg(Term)}.}.
    
Allowable syntaxes for {\tt Fmt} reflect the syntax of the C function
{\tt printf()} on a given platform, with the following exceptions
%
\bi
\item The usual alphabetical C escape characters ({\it e.g.},
  $\backslash n$) are recognized, but not the octal or the hexadecimal
  ones.
\item {\tt \%S} is supported, in addition to the usual C conversion
  specifiers.  The corresponding argument can be any Prolog term. This
  provides an easy way to print the values of Prolog variables, etc.
\item {\tt \%!} is supported and indicates that the corresponding
  argument is to be ignored and will generate nothing in the output.
\item A single {\tt \%} in the format string must be followed by a
  conversion operator (e.g. {\tt d}, {\tt s}, etc.). (Some C compilers
  output {\tt \%} if the percentage character is not followed by a
  valid type conversion spec.)  However, to output {\tt \%}, {\tt
    fmt\_write} must contain {\tt \%\%}.
\ei    
%
{\bf Example}
{\small
\begin{verbatim}
| ?- fmt_write("%d %f %s %S \n",args(1,3.14159,ready,hello(world))).
1 3.141590 ready hello(world)

yes
\end{verbatim}
}
%
XSB also offers an alternate version of formatted output in the {\tt
  format} library described in volume 2.  While not as efficient as
{\tt fmt\_write/[2,3]}, the {\tt format} library is more compatable
with the formatted output found in other Prologs.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open output stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item {\tt Fmt} is uninstantiated or not a character string or atom
\bi
\item   {\tt type\_error('character string or atom',Fmt)}
\ei
\item A format specifier in {\tt Fmt} and its corresponding argument
  in {\tt Term} are of incompatable types.
\bi
\item   {\tt misc\_error}
\ei
\item {\tt Term} contains fewer arguments than {\tt Fmt} has format
  specifiers or {\tt Term} is uninstantiated
\bi
\item   {\tt misc\_error}
\ei
\ei

If the number of arguments in {\tt Term} is greater than the number of
conversion specifiers in {\tt Fmt} no error is thrown, but a warning
is issued.

{\bf Caution for 64-bit Platforms}
%
As discussed, {\tt fmt\_write/[2,3]} calls {\tt printf()} and inherits
the flexibility of that function, but also its ``features''.  One of
these features is that in most 64-bit platforms, large integers that
behave perfectly well otherwise are not printed out properly by {\tt
  printf()} with the {\tt \%d} format -- rather another format string
needs to be used (such as {\tt \%ld} on Linux).  {\tt
  fmt\_write/[1,2]} recognizes the {\tt \%ld} option and passes it
onto {\tt fprintf()}, but the proper format string for 64-bit integers
may be different on other platforms.

\standarditem{fmt\_write\_string(-String,+Fmt,+Term)}{fmt\_write\_string/3}
    This predicate works like the C function {\tt sprintf}. It takes the
    format string and substitutes the values from the arguments of {\tt
      Term} ({\it e.g.}, {\tt args(X,Y,Z)}) for the formatting instructions
    \%s, \%d, etc. Additional syntactic sugar, as in \verb|fmt_write|, is
    recognized. The result is available in {\tt String}. {\tt Fmt} is a
    string or an atom that represents the format, as in
    {\tt fmt\_write}.
    
    If the number of format specifiers is greater than the number of
    arguments to be printed, an error is issued. If the number of arguments
    is greater, then a warning is issued.

    {\tt fmt\_write\_string} requires that the printed size of each
    argument ({\it e.g.}, X,Y,and Z above) must be less than 16K. Longer
    arguments are cut to that size, so some loss of information is possible.
    However, there is no limit on the total size of the output (apart from
    the maximum atom size imposed by XSB).

\standarditem{file\_read\_line\_list(-String)}{file\_read\_line\_list/1}
A line read from the current input stream is converted into a list of
character codes.  This predicate 
%is \emph{much} more efficient than
%{{\tt fget\_line/3}} (see below), and 
avoids interning an atom as does {\tt file\_read\_line\_atom/3}, and so is
recommended when speed is important.  This predicate fails on reaching
the end of file.

\standarditem{file\_read\_line\_list(Stream\_or\_alias,-CharList)}{file\_read\_line\_list/2}
Acts as does {\tt file\_read\_line\_list}, but uses {\tt Stream\_or\_atom}.

{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\standarditem{file\_read\_line\_atom(-Atom)}{file\_read\_line\_atom/1}
%
Reads a line from the current (textual) input stream, returning it as
{\tt Atom}.  This predicate fails on reaching the end of file.

\standarditem{file\_read\_line\_atom(+Stream\_or\_alias,-Atom)}{file\_read\_line\_atom/2}
Like {\tt file\_read\_line\_atom/1} but reads from {\tt Stream\_or\_alias}.
%
{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\ourrepeatmoditem{file\_write\_line(+String, +Offset)}{file\_write\_line/2}{file\_io}
\ourmoditem{file\_write\_line(+Stream\_or\_alias, +String, +Offset)}{file\_write\_line/3}{file\_io}
%
These predicates write {\tt String} beginning with character {\tt
  Offset} to the current output stream. {\tt String} can be an atom or
a list of ASCII character codes. This does \emph{not} put the newline
character at the end of the string (unless {\tt String} already had
this character). Note that escape sequences, like \verb|\n|, are
recognized if {\tt String} is a character list, but are output as is
if {\tt String} is an atom.

{\bf Error Cases}
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\item {\tt String} is neither a Prolog character list not an atom
\bi
\item {\tt misc\_error}
\ei
\ei

%----------------------------------------------------------------------------------------------

\ourmoditem{file\_getbuf\_list(+Stream\_or\_alias, +BytesRequested, -CharList, -BytesRead)}{file\_getbuf\_list/4}{file\_io} 
Read {\tt BytesRequested} bytes from file represented by {\tt
Stream\_or\_alias} (which must already be open for reading) into
variable {\tt String} as a list of character codes. This is analogous
to {\tt fread} in C.  This predicate always succeeds. It does not
distinguish between a file error and end of file.  You can determine
if either of these conditions has happened by verifying that $\tt
BytesRead < BytesRequested$.

\ourmoditem{file\_getbuf\_list(+BytesRequested, -String, -BytesRead)}{file\_getbuf\_list/3}{file\_io}
%
Like \verb|file_getbuf_list/3|, but reads from the currently open input stream
({\it i.e.}, with {\tt see/1}).


\ourmoditem{file\_getbuf\_atom(+Stream\_or\_alias, +BytesRequested, -String, -BytesRead)}{file\_file\_getbuf\_atom/4}{file\_io}

Read {\tt BytesRequested} bytes from file represented by {\tt
Stream\_or\_alias} (which must already be open for reading) into
variable {\tt String}. This is analogous to {\tt fread} in C.  This
predicate always succeeds. It does not distinguish between a file
error and end of file.  You can determine if either of these
conditions has happened by verifying that $\tt BytesRead <
BytesRequested$.

Note: because XSB does not have an atom table garbage collector yet,
this predicate should not be used to read large files.  Use {\tt
read\_getbuf\_list} or another predicate in this case.

{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\ourmoditem{file\_getbuf\_atom(+BytesRequested, -String, -BytesRead)}{file\_getbuf\_atom/3}{file\_io}
%
Like \verb|file_getbuf_atom/4|, but reads from the currently open input stream.

\ourmoditem{file\_putbuf(+Stream\_or\_alias, +BytesRequested, +String, +Offset, -BytesWritten)}{file\_putbuf/5}{file\_io}

Write {\tt BytesRequested} bytes into file represented by I/O port
{\tt Stream\_or\_alias} (which must already be open for writing) from
variable {\tt String} at position {\tt Offset}. This is analogous to C
{\tt fwrite}.  The value of {\tt String} can be an atom or a list of
ASCII characters.

{\bf Error Cases} 
\bi
\item 	{\tt Stream\_or\_alias} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item 	{\tt Stream\_or\_alias} is neither a variable nor a stream term nor an alias.
\bi
\item 	{\tt domain\_error(stream\_or\_alias,Stream\_or\_alias)}
\ei
\item 	{\tt Stream\_or\_alias} is not associated with an open input stream
\bi
\item 	{\tt existence\_error(stream,Stream\_or\_alias)}
\ei
\ei

\ourmoditem{file\_putbuf(+BytesRequested, +String, +Offset, -BytesWritten)}{file\_putbuf/4}{file\_io}
%
Like \verb|file_putbuf/3|, but output goes to the currently open output stream.


\end{description}

%-------------------------------------------------------------------
\comment{
\standarditem{fmt\_read(+Format, types(+T1,+T2,...), args(-A1,-A2,...), -RetCode)}\index{\texttt{fmt\_read/4}} 
 This predicate implements C-style formatted input. It reads the current
 input according to the {\tt Format} string.  {\tt Format} has the
 same syntax as the input format in C. The term {\tt types(...)} lists the
 types of the arguments; they must match the types specified in {\tt
 Format}. Here, 1 means string, 2 means integer, and 3 means float.
 The term {\tt args()} specifies the variables for the input. {\tt RetCode}
 specifies the return code: 0 -- ok; -1 -- end of file.

\standarditem{read\_line(-Line, -Status)}\index{\texttt{read\_line/2}} 
 Reads the next line from the current input and puts it in {\tt Line}.
 If the line is larger than the available buffer, then {\tt Status} is 0.
 If the line was read in full, up to and including the newline character,
 then {\tt Status} is 1. 

\standarditem{fmt\_write(+Format, args(-A1,-A2,...))}\index{\texttt{fmt\_write/2}} 
 Similar to formatted write in C. The semantics of the arguments is the
 same as for {\tt fmt\_read/4}.

\standarditem{fmt\_write\_string(-String, +Format, args(-A1,-A2,...))}\index{\texttt{fmt\_write/2}} 
 Like {\tt fmt\_write/2}, but the output string is placed in {\tt String}.
}

%--------------------------------------------------------------------------------------------------

\section{Interactions with the Operating System}

XSB provides a number of facilities for interacting with the UNIX and
Windows operating systems.  This section describes basic facilities
for invoking shell commands and file manipulation.  Chapter 1 of
Volume 2 discusses more advanced commands for process spawning and
control, along with interprocess communication.

\begin{description}

\standarditem{shell(+SystemCall)}{shell/1} 
%
Calls the operating system with the atom {\tt SystemCall} as argument,
using the {\tt libc} function {\tt system()}.  The predicate succeeds
if {\tt SystemCall} is executed successfully, otherwise it fails.  As
a notational convenience, the user can also supply {\tt SystemCall}
either as a list.  In this case, elements of the list will be
concatenated together to form the system call.

    For example, the call:

    \demo{{\tt $|$ ?- shell('echo \$HOME').}}

    \noindent
    will output in the current output stream of XSB the name of the
    user's home directory; while the call:

    \demo{{\tt $|$ ?- File = 'test.c', shell(['cc -c ', File]).}}

    \noindent
    will call the C compiler to compile the file {\tt test.c}.

    Note that in UNIX systems, since {\tt system()} (and {\tt
      shell/1}) executes by forking off a shell process.  Thus it
    cannot be used, for example, to change the working directory of
    the program.  For that reason the standard predicate {\tt cd/1}
    described below should be used.

{\bf Error Cases}
\bi
\item  {\tt SystemCall} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt SystemCall} is neither an atom nor a list
\bi
\item {\tt type\_error(atom\_or\_list,SystemCall)}
\ei
\item {\tt SystemCall} is longer than the maximum command legth
  allowed by {\tt shell/1}
\bi
\item {\tt resource\_error(memory)}
\ei
\ei

\standarditem{shell(+SystemCall, -Result)}{shell/2}
%
Calls the operating system with the atom {\tt SystemCall} as argument,
using the {\tt libc} function {\tt system()}.  As a notational
convenience, the user can also supply {\tt SystemCall} as a list.  In
in this case, elements of the list will be concatenated together to
form the system call.  {\tt shell/2} always succeeds instantiating
{\tt Result} to the exit code of {\tt system()}.  Thus {\tt Result}
will be 0 if {\t SystemCall} executed properly, and non-0 otherwise:
the specific return values of {\tt system()} may be platform-dependent.

{\bf Error Cases}
\bi
\item  {\tt SystemCall} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt SystemCall} is neither an atom nor a list
\bi
\item {\tt type\_error(atom\_or\_list,SystemCall)}
\ei
\item {\tt Result} is not a variable
\bi
\item {\tt type\_error(variable,Result)}
\ei
\item {\tt SystemCall} is longer than the maximum command legth
  allowed by {\tt shell/2}
\bi
\item {\tt resource\_error(memory)}
\ei
\ei


\repeatstandarditem{shell\_to\_list(+SystemCall,-StdOut,-ErrOut,-Result)}{shell\_to\_list/4}
\standarditem{shell\_to\_list(+SystemCall,-StdOut,-Result)}{shell\_to\_list/3}
%
Behaves as {\tt shell/2} in its 1st and 4th arguments, and like {\tt
  shell/2} always suceeds.  Both {\tt StdOut} and {\tt ErrOut} are
lists of lists: each element of the outer list corresponds to a line
of output from {\tt SystemCall}, while each element of an inner list
corresponds to a token in that line.  {\tt shell\_to\_list/3} is thus
a sort of Prolog analog of the shell command \verb|`SystemCall`|.

Examples:
\begin{verbatim}
  ?- shell_to_list(sw_vers,Stdout,Ret).

  Stdout = [[ProductName:,Mac,OS,X],[ProductVersion:,10.4.9],[BuildVersion:,8P2137]]
  Ret = 0

  ?- shell_to_lists('gcc -c nofile.c',StdOut,StdErr,Ret).

  Stdout = []
  StdErr = [[i686-apple-darwin8-gcc-4.0.1:,nofile.c:,No,such,file,or,directory]]
  Ret = 256
\end{verbatim}

Error cases are as with {\tt shell/2}

\ourmoditem{datime(?Date)}{datime/1}{standard}
%
Unifies {\tt Date} to the current date, returned as a Prolog term,
suitable for term comparison.  Note that {\tt datime/1} must be
explicitly imported from the module {\tt standard}.

Example:
{\footnotesize
\begin{verbatim}
                > date
                Mon Aug  9 16:19:44 EDT 2004
                > nxsb1
                XSB Version 2.6 (Duff) of June 24, 2003
                [i686-pc-cygwin; mode: optimal; engine: slg-wam; gc: indirection; scheduling: local]

                | ?- import datime/1 from standard

                yes
                | ?- datime(F).
                F = datime(2004,8,9,20,20,23)

                yes
\end{verbatim}}

\end{description}

\subsection{The {\tt path\_sysop/2} interface}
%
In addition, XSB provides the following unified interface to the
operations on files. All these calls succeed iff the corresponding
system call succeeds.  These calls work on both Windows and Unixes
unless otherwise noted.
%%
\begin{description}
  \standarditem{path\_sysop(isplain, +Path)}{path\_sysop/2}
  Succeeds, if {\tt Path} is a plain file.
  \standarditem{path\_sysop(isdir, +Path)}{path\_sysop/2}
  Succeeds, if {\tt Path} is a directory.
  \standarditem{path\_sysop(rename, +OldPath, +NewPath)}{path\_sysop/3}
  Renames {\tt OldPath} into {\tt NewPath}.
  \standarditem{path\_sysop(copy, +FromPath, +ToPath)}{path\_sysop/3}
  Copies {\tt FromPath} into {\tt ToPath}.
  \standarditem{path\_sysop(rm, +Path)}{path\_sysop/2}  Removes the plain file {\tt Path}.
  \standarditem{path\_sysop(rmdir, +Path)}{path\_sysop/2}  Deletes the directory {\tt Path}, succeeding only if the directory is empty.
  \standarditem{path\_sysop(rmdir\_rec, +Path)}{path\_sysop/3}
  Deletes the directory {\tt Path} along with any of its contents.
%  \standarditem{path\_sysop(unlink, +Path)}
%  Same as {\tt rm}.
  \standarditem{path\_sysop(link, +SrsPath, +DestPath)}{path\_sysop/3}
  Creates a hard link from {\tt SrsPath} to {\tt DestPath}. UNIX only.
  \standarditem{path\_sysop(cwd, -Path)}{path\_sysop/2}
  Binds {\tt Path} to the current working directory.
  \standarditem{path\_sysop(chdir, +Path)}{path\_sysop/2}
  Changes the current working directory to {\tt Path}.
  \standarditem{path\_sysop(mkdir, +Path)}{path\_sysop/2}
  Creates a new directory, {\tt Path}.
  \standarditem{path\_sysop(exists, +Path)}{path\_sysop/2}
  Succeeds if the file {\tt Path} exists.
  \standarditem{path\_sysop(readable, +Path)}{path\_sysop/2}
  Succeeds if {\tt Path} is a readable file.
  \standarditem{path\_sysop(writable, +Path)}{path\_sysop/2}
  Succeeds if {\tt Path} is a writable file.
  \standarditem{path\_sysop(executable, +Path)}{path\_sysop/2}
  Succeeds if {\tt Path} is an executable file.
  \standarditem{path\_sysop(modtime, +Path, -Time)}{path\_sysop/3}
  Returns a list that represents the last modification time of the file.
  Succeeds if file exists. In this case, {\tt Time} is bound to a list
  {\tt [high,low]} where {\tt low} is the least significant 24 bits of the
  modification time and {\tt high} is the most significant bits (25th) and up.
  {\tt Time} represents the last modification time of the file.
  The actual value is thus $\tt high*2^{24} + low$, which represents the
  number of seconds elapsed since 00:00:00 on
       January 1, 1970, Coordinated Universal Time (UTC).
  \standarditem{path\_sysop(newerthan, +Path1, +Path2)}{path\_sysop/3}
  Succeeds is the last modification time of {\tt Path1} is higher than that
  of {\tt Path2}. Also succeeds if {\tt Path1} exists but {\tt Path2} does
  not.
  \standarditem{path\_sysop(size, +Path, -Size)}{path\_sysop/3}
  Returns a list that represents the byte size of {\tt Path}.
  Succeeds if the file exists. In this case {\tt Size} is bound to the list
  of the form {\tt [high,low]} where {\tt low} is the least significant 24
  bits of the byte-size and {\tt high} is the most significant bits (25th)
  and up. The actual value is thus $\tt high*2^{24} + low$.
  \standarditem{path\_sysop(tmpfilename, -Name)}{path\_sysop/2}
  Returns the name of a new temporary file. This is useful when the
  application needs to open a completely new temporary file.
  \standarditem{path\_sysop(extension, +Name, -Ext)}{path\_sysop/3}
  Returns file name extension.
  \standarditem{path\_sysop(basename, +Name, -Base)}{path\_sysop/3}
  Returns the base name of the file name ({\it i.e.}, the name sans the
  directory and the extension).
  \standarditem{path\_sysop(dirname, +Name, -Dir)}{path\_sysop/3}
  Returns the directory portion of the filename. The directory is slash or
  backslash terminated.
  \standarditem{path\_sysop(isabsolute, +Name)}{path\_sysop/2}
  Succeeds if {\tt Name} is an absolute path name. File does not need to exist.
  \standarditem{path\_sysop(expand, +Name, -ExpandedName)}{path\_sysop/3}
  Binds {\tt ExpandedName} to the expanded absolute path name of {\tt Name}.
  The file does not need to exist. Duplicate slashes, references to the
  current and parent directories are factored out.
\end{description}
%%

%-----------------------------------------------------------------
\section{Evaluating Arithmetic Expressions through {\tt is/2}}
\label{Arithmetic} 

\comment{
As do most Prologs, XSB supports evaluation of arithmetic expressions
in two ways.  First, ground arithmetic expressions can be evaluated
through the {\tt is/2} operator.  Solving non-ground arithmetic
expressions is provided through XSB's port of the CLPQR constraint
handling interface.  In this section we describe how arithmetic
expressions can be evaluated through {\tt is/2}, while the CLPQR
interface is described in Volume 2 of this manual.
}

Before describing {\tt is/2} and the expressions that it can evaluate,
we note that in \version{} of XSB, integers in XSB are represented
using a single word of 32 or 64 bits, depending on the machine
architecture. Floating point values are, by default, stored as
word-sized references to double precision values, regardless of the
target machine. Direct (non-referenced, tagged) single precision
floats can be activated for speed purposes by passing the option
--enable-fast-floats to the configure script at configuration time.
This option is not recommended when any sort of precision is desired,
as there may be as little as 28 bits available to represent a given
number value under a tagged architecture.  

All of the evaluable functors described below throw an instantiation
error if one of their evaluated inputs is a variable, and an {\tt
  evaluation(undefined)} error if one of their evaluated inputs is
instantiated but non-numeric.  With this in mind, we describe below
only their behavior on correctly typed input.

\compatability
In addition, evaluation of arithmetic expressions through {\tt is/2}
does not check for overflow or underflow.  As a result, XSB's floating
point operations do not conform to IEEE floating point standards, and
deviates in this regard from the ISO Prolog standard (see
\cite{ISO-Prolog} Section 9)~ We hope to fix these problems in a
future release \footnote{We also note that the ISO Prolog evaluable
  functors{\tt float\_integer\_part/1} (which can be obtained via {\tt
    truncate/1}), {\tt float\_fractional\_part/1} (which can be
  obtained via {\tt X - truncate(X)}), and bitwise complement (which
  is implementation dependent in the ISO standard) are not implemented
  in \version .}.

\begin{description}
\isoitem{is(?Result,+Expression)}{is/2}
{\tt is(Result,Expression)} is true iff the result of evaluating {\tt
Expression} as a sequence of evaluable functors unifies with {\tt
Result}.  As mentioned in Section~\ref{inline_predicates}, {\tt is/2}
is an inline predicate, so calls to {\tt is/2} within compiled code
will not be visible during a trace of program execution.
\end{description}

\subsection{Evaluable Functors for Arithmetic Expressions} \label{sec:arith-eval}

\begin{description}
\ourstandarditem{+(+Expr1,+Expr2)}{+/2}{Evaluable Functor (ISO)}
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns {\tt Number1 + Number2}, performing any
necessary type conversions.

\ourstandarditem{-(+Expr1,+Expr2)}{-/2}{Evaluable Functor (ISO)}
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns {\tt Number1 - Number2}, performing any
necessary type conversions.

\ourstandarditem{*(+Expr1,+Expr2)}{*/2}{Evaluable Functor (ISO)}
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns {\tt Number1 * Number2} (i.e. multiplies
them), performing any necessary type conversions.

\ourstandarditem{/(+Expr1,Expr2)}{'/'/2}{Evaluable Functor (ISO)}
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns {\tt Number1 / Number2} (i.e. divides
them), performing any necessary type conversions.

\ourstandarditem{//(+Expr1,Expr2)}{'//'/2}{Evaluable Functor (ISO)}
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns {\tt Number1 // Number2} (i.e. integer
division), performing any necessary type conversions, and rounding to
0 if necessary.  

    Example:
    {\footnotesize
     \begin{verbatim}
                | ?- X is 3/2.

                X = 1.5000

                yes
                | ?- X is 3 // 2.

                X = 1

                yes
                | ?- X is -3 // 2.

                X = -1

                yes
  \end{verbatim}}

\ourstandarditem{-(+Expr1)}{-/1}{Evaluable Functor (ISO)}
%
 If {\tt +Expr} evaluates to {\tt Number}, returns {\tt -Number1},
 performing any necessary type conversions.

\ourstandarditem{'$\wedge$'(+Expr1,+Expr2)}{'$\wedge$'/2}{Evaluable Functor (ISO)}
%
 If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2}
evaluates to {\tt Number2}, returns the bitwise conjunction of {\tt
Number1} and {\tt Number2}.

\ourstandarditem{'$\vee$'(+Expr1,+Expr2)}{'$\vee$'/2}{Evaluable Functor (ISO)}

%
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns the bitwise disjunction {\tt Number1} and
{\tt Number2}.

\ourstandarditem{'>>'(+Expr1,+Expr2)}{'>>'/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2} evaluates
to {\tt Number2}, returns the logical shift right of {\tt Number1},
{\tt Number2} places.

\ourstandarditem{'<<'(+Expr1,+Expr2)}{'<<'/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2}
evaluates to {\tt Number2}, returns the logical shift left of 
{\tt Number1}, {\tt Number2} places.

\ourstandarditem{'><'(+Expr1,+Expr2)}{'><'/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1}, and {\tt Expr2}
evaluates to {\tt Number2}, returns the bitwise exclusive or of 
{\tt Number1} and {\tt Number2}.

\ourstandarditem{min(+Expr1,+Expr2)}{min/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1}, and
{\tt Expr2} evaluates to {\tt Number2}, returns the minimum of the
two.

\ourstandarditem{max(+Expr1,+Expr2)}{max/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1}, and
{\tt Expr2} evaluates to {\tt Number2}, returns the maximum of the
two.

\ourstandarditem{ceiling(+Expr)}{ceiling/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt ceiling(Number)}
returns the integer ceiling of {\tt Number} if {\tt Number} is a
float, and {\tt Number} itself if {\tt Number} is an integer.

\ourstandarditem{float(+Expr)}{float/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt float(Number)} converts
{\tt Number} to a float if {\tt Number} is an integer, and returns
{\tt Number} itself if {\tt Number} is a float.

\ourstandarditem{floor(+Expr)}{floor/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt floor(Number)} returns
the integer floor of {\tt Number} if {\tt Number} is a float, and {\tt
  Number} itself if {\tt Number} is an integer.

\ourstandarditem{mod(+Expr1,+Expr2)}{mod/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1} and {\tt Expr2} evaluates
to {\tt Number2} where {\tt Number2} is not 0, {\tt
mod(Number1,Number2)} returns
\[
	Number1 - (\lfloor (Number1 / Number2) \rfloor) \times Number2)
\]

\ourstandarditem{rem(+Expr1,+Expr2)}{rem/2}{Evaluable Functor (ISO)}
%
If {\tt +Expr1} evaluates to {\tt Number1} and {\tt Expr2} evaluates
to {\tt Number2} where {\tt Number2} is not 0, {\tt
rem(Number1,Number2)} returns
\[
	Number1 - ({Number1} // {Number2}) \times Number2)
\]

    Example:
    {\footnotesize
     \begin{verbatim}
                | ?- X is 5 mod 2.

                X = 1

                yes
                | ?- X is 5 rem 2.

                X = 1

                yes
                | ?- X is 5 mod -2.

                X = -1

                yes
                | ?- X is 5 rem -2.

                X = 1

                yes
  \end{verbatim}}

\ourstandarditem{round(+Expr)}{round/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt round(Number)} returns
the nearest integer to {\tt Number} if {\tt Number} is a float, and
{\tt Number} itself if {\tt Number} is an integer.

\ourstandarditem{'**'(+Expr1,+Expr2)}{**/2}{Evaluable Functor (ISO)}
%
If {\tt Expr1} and {\tt Expr2} both evaluate to numbers, the infix
function {\tt **/2} raises {\tt Expr1} to the {\tt Expr2} power.  If
{\tt Expr1} and {\tt Expr2} both evaluate to integers, an integer is
returned; otherwise a float is returned.

\ourstandarditem{sqrt(+Expr)}{sqrt/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt sqrt(Number)}
returns the square root of {\tt Number}.

\ourstandarditem{truncate(+Expr)}{truncate/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt truncate(Number)}
truncates {\tt Number} if {\tt Number} is a float, and returns {\tt
  Number} itself if {\tt Number} is an integer.

\ourstandarditem{sign(+Expr)}{sign/1}{Evaluable Functor (ISO)}
%
If {\tt +Expr} evaluates to {\tt Number}, {\tt sign(Number)} returns
{\tt 1} if {\tt Number} is greater than 0, {\tt 0} if {\tt Number} is
equal to 0, and {\tt -1} if {\tt Number} is less than 0.

\ourstandarditem{pi}{pi/0}{Evaluable Functor (ISO)}
% 
Evaluates to $\pi$ within an arithemetic expression.

\ourstandarditem{e}{e/0}{Evaluable Functor (ISO)}
% 
Evaluates to $e$, the base of the natural logarithm, within an
arithemetic expression.

\end{description}

\subsubsection{Mathematical Functions from {\tt math.h}}
\stdrefindex{cos/1} \stdrefindex{sin/1} \stdrefindex{tan/1}
\stdrefindex{acos/1} \stdrefindex{asin/1} \stdrefindex{atan/1}
\stdrefindex{log/1} \stdrefindex{log10/1}

XSB also allows as evaluable functors, many of the functions from the
C library {\tt math.h}.  Functions included in XSB \version{} are {\tt
  cos/1}, {\tt sin/1}, {\tt tan/1}, {\tt acos/1}, {\tt asin/1}, {\tt
  atan/1}, {\tt log/1} (natural logarithm), and {\tt log10/1}.  For
  their semantics, see documentation to {\tt math.h}.

\section{Convenience} \label{Convenience}
These predicates are standard and often self-explanatory, so they are 
described only briefly.
\begin{description}

\isoitem{true}{true/0}
    Always succeeds.

\standarditem{otherwise}{otherwise/0}
%\predindex{otherwise/0~(B)}
    Same as {\tt true/0}.

\isoitem{fail}{fail/0}
%\predindex{fail/0~(I)}
    Always fails.

\end{description}

%-----------------------------------------------------------------------------------------
\section{Negation and Control}\label{sec:control}
\index{control}

\begin{description}
\isoitem{\cut}{"!/0}  \index{cut} 
    Cut (discard) all choice points made since the parent goal
    started execution.
    Cuts across tabled predicates are not valid.  The compiler checks for
    such cuts, although whether the scope of a cut includes a tabled 
    predicate is undecidable in the presence of meta-predicates like
    {\tt call/1}.
    Further discussion of conditions allowing cuts and of their actions 
    can be found in Section~\ref{tabling_env}.

%\isoitem{$\backslash$+ +P}{\verb|\+/2|}
\ournewitem{$\backslash$+ +P}{ISO}\index{$\backslash$\texttt{+/1}}\index[pred]{$\backslash$\texttt{+/1}} 
%
If the goal {\tt P} has a solution, fails, otherwise it succeeds.
Equivalently, it is true iff {\tt call(P)} (see
Section~\ref{meta_predicates}) is false. Argument {\tt P} must be
ground for sound negation as failure, although no runtime checks are
made.

{\bf Error Cases}
    \begin{description}
    \item[{\tt instantiation\_error}]
	{\tt P} is not instantiated.
    \item[{\tt type\_error(callable,P)}]
	{\tt P} is not callable.
    \end{description}

\repeatstandarditem{fail\_if(+P)}{fail\_if/1}
\standarditem{not +P}{not/1}
%
Like {\tt $\backslash$+/1} and provided for compatibility with legacy
code.  Compilation of {\tt $\backslash$+/1} and {\tt fail\_if/1} is
optimized by XSB's compiler, while that of {\tt not/1} is not --
therefore the first two syntactical forms are preferred in terms of
efficiency, while {\tt $\backslash$+/1} is preferred in terms of
portability.

All error cases are the same as {\tt call/1} (see
Section~\ref{meta_predicates}).

\ourstandarditem{tnot(+P)}{tnot/1}{Tabling} \label{tnot/1}
    The semantics of {\tt tnot/1} allows for correct execution of
    programs with according to the well-founded semantics.  {\tt P}
    must be a tabled predicate, 
% tls: need to provide an example.
%and the actions of {\tt tnot/1} are
%presented in Figure~\ref{fig:tnot}. 
%
%\input{tnot} 
%
    For a detailed description of the actions of tabled negation for
    in XSB \version\ see~\cite{SaSw98, SaSW96}.
    Chapter~\ref{chap:TablingOverview} contains further discussion of the
    functionality of {\tt tnot/1}.

{\bf Error Cases}
\begin{itemize}
\item	{\tt P} is not ground (floundering occurs)
\bi
    \item {\tt instantiation\_error}
\ei
\item	{\tt P} is not callable
\bi
     \item {\tt type\_error(callable,P)}
\ei
\item {\tt P} is not a call to a tabled predicate
\bi
     \item{\tt table\_error}
\ei
\end{itemize}

\ourstandarditem{sk\_not(+P)}{sk\_not/1}{Tabling} 
%% 
If {\tt +P} is a tabled predicate, {\tt sk\_not/1} acts as {\tt
  tnot/1} but permits variables in its subgoal argument~\footnote{{\tt
    sk\_not/1} replaces the {\tt 't not'/1} predicate of earlier XSB
  versions whose implementation and semantics were dubious.}. The
semantics in the case of unbound variables is as follows:
%% 
\begin{quote} 
\tt ... :- ...,~sk\_not(p(X)),~...  \end{quote} 
%% 
is equivalent to 
%%
\begin{quote}
 \tt ... :- ..., tnot(pp),~...\\ pp :- p(X).
\end{quote} 
%% 
where {\tt pp} is a new proposition. Thus, the unbound variable $X$ is
treated as $\tt tnot(\exists X (p(X)))$.

If {\tt +P} is a non-tabled predicate {\tt sk\_not/1} ensures that
{\tt +P} is ground and called via a tabled predicate so that {\tt
  sk\_not/1} can be used with non-tabled predicates as well,
regardless of whether {\tt +P} is ground or not.

{\bf Error Cases}
\begin{itemize}
\item	{\tt P} is not instantiated
\bi
    \item {\tt instantiation\_error}
\ei
\item	{\tt P} is not callable
\bi
     \item {\tt type\_error(callable,P)}
\ei
\end{itemize}

\ournewitem{P -> Q ; R}{ISO}\index{\texttt{->/2}} 
    Analogous to if {\tt P} then {\tt Q} else {\tt R}, i.e.\ defined as 
    if by
	\begin{center}
	\begin{minipage}{2.10in}
	\begin{verbatim}
	(P -> Q ; R) :- P, !, Q.
	(P -> Q ; R) :- R.
	\end{verbatim}
	\end{minipage}
	\end{center}

\ournewitem{P -> Q}{ISO} \index{\texttt{->/2}}
    When occurring other than as one of the alternatives of a disjunction,
    is equivalent to:
	\begin{center}
	{\tt P -> Q ; fail.}
	\end{center}

\standarditem{repeat}{repeat/0}
    Generates an infinite sequence of choice points (in other words it 
    provides a very convenient way of executing a loop). It is defined 
    by the clauses:
    \begin{center}
    \begin{minipage}{1.5in}
    \begin{verbatim}
	repeat.
	repeat :- repeat.
    \end{verbatim}
    \end{minipage}
    \end{center}

\ourmoditem{between(+L,+U,B)}{between/3}{basics}
%
For {\tt L} and {\tt U} integers, with {\tt L} less than or equal to
{\tt U}, successive calls to {\tt between/3} unify {\tt B} with all
integers between {\tt L} and {\tt U} inclusively.  If {\tt L} is less
than {\tt U} the predicate fails.

{\bf Error Cases:}
\bi
\item 	{\tt L} (or {\tt U}) is a not a character
\bi
\item 	{\tt type\_error(integer,L)}
\ei
\ei
\end{description}

%-------------------------------------------------------------------------
% Comparison and unification of terms.
\input{comparison}

%------------------------------------------------------------------------------------------------
\section{Meta-Logical}\label{MetaLogical}

To facilitate manipulation of terms as objects in themselves,
XSB provides a number meta-logical predicates.  These
predicates include the standard meta-logical predicates of Prolog,
along with their usual semantics.  In addition are provided predicates
which provide special operations on HiLog terms.  For a full
discussion of Prolog and HiLog terms see Section~\ref{TermSyntax}.

\begin{description}
\isoitem{var(?X)}{var/1}
    Succeeds if {\tt X} is currently uninstantiated (i.e.\ is still a 
    variable); otherwise it fails.  

    Term {\tt X} is uninstantiated if it has not been bound to anything, 
    except possibly another uninstantiated variable. Note in particular,
    that the HiLog term X(Y,Z) is considered to be instantiated.  There 
    is no distinction between a Prolog and a HiLog variable.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- var(X).
                yes
                | ?- var([X]).
                no
                | ?- var(X(Y,Z)).
                no
                | ?- var((X)).
                yes
                | ?- var((X)(Y)).
                no
     \end{verbatim}}


\isoitem{nonvar(?X)}{nonvar/1}
    Succeeds if {\tt X} is currently instantiated to a non-variable term;
    otherwise it fails. This has exactly the opposite behaviour of 
    {\tt var/1}\@.

\isoitem{atom(?X)}{atom/1}
    Succeeds only if the {\tt X} is currently instantiated to an atom, that
    is to a Prolog or HiLog non-numeric constant.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- atom(HiLog).
                no
                | ?- atom(10).
                no
                | ?- atom('HiLog').
                yes
                | ?- atom(X(a,b)).
                no
                | ?- atom(h).
                yes
                | ?- atom(+).
                yes
                | ?- atom([]).
                yes
     \end{verbatim}}

\isoitem{integer(?X)}{integer/1}
    Succeeds if {\tt X} is currently instantiated to an integer; 
    otherwise it fails. 

\isoitem{float(?X)}{ISO}{float/1}
    Same as {\tt real/1}. Succeeds if {\tt X} is currently instantiated 
    to a floating point number; otherwise it fails.  
	
\standarditem{real(?X)}{real/1}
%
Succeeds if {\tt X} is currently instantiated to a floating point
number; otherwise it fails. This predicate is included for
compatibility with earlier versions of XSB.

\isoitem{number(?X)}{number/1}
    Succeeds if {\tt X} is currently instantiated to either an integer or 
    a floating point number (real); otherwise it fails.

\isoitem{atomic(?X)}{atomic/1}
    Succeeds if {\tt X} is currently instantiated to an atom or a number;
    otherwise it fails.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- atomic(10).
                yes
                | ?- atomic(p).
                yes
                | ?- atomic(h).
                yes
                | ?- atomic(h(X)).
                no
                | ?- atomic("foo").
                no
                | ?- atomic('foo').
                yes
                | ?- atomic(X).
                no
                | ?- atomic(X((Y))).
                no
     \end{verbatim}}

\isoitem{compound(?X)}{compound/1}
    Succeeds if {\tt X} is currently instantiated to a compound term (with 
    arity greater that zero), i.e.\ to a non-variable term that is not atomic;
    otherwise it fails.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- compound(1).
                no
                | ?- compound(foo(1,2,3)).
                yes
                | ?- compound([foo, bar]).
                yes
                | ?- compound("foo").
                yes
                | ?- compound('foo').
                no
                | ?- compound(X(a,b)).
                yes
                | ?- compound((a,b)).
                yes	
     \end{verbatim}}

\standarditem{structure(?X)}{structure/1}
    Same as {\tt compound/1}\@. Its existence is only for compatibility 
    with previous versions.

\standarditem{is\_list(?X)}{is\_list/1}
    Succeeds if {\tt X} is a {\em proper list}. In other words if it is 
    either the atom {\tt []} or {\tt [H|T]} where H is any Prolog or HiLog
    term and T is a proper list; otherwise it fails.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- is_list([p(a,b,c), h(a,b)]).
                yes
                | ?- is_list([_,_]).
                yes
                | ?- is_list([a,b|X]).
                no
                | ?- is_list([a|b]).
                no
     \end{verbatim}}

\standarditem{is\_charlist(+X)}{is\_charlist/1}
    Succeeds if {\tt X} is a Prolog string, {\it i.e.}, a list of
    characters.
    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- is_charlist("abc").
                yes
                | ?- is_charlist(abc).
                no
     \end{verbatim}}

\standarditem{is\_charlist(+X,-Size)}{is\_charlist/2}
    Works as above, but also returns the length of that string in the second
    argument, which must be a variable.

\standarditem{is\_attv(+Term)}{is\_attv/1}
    Succeeds is {\tt Term} is an attributed variable, and fails otherwise.

\standarditem{is\_most\_general\_term(?X)}{is\_most\_general\_term/1}
    Succeeds if {\tt X} is compound term with all distinct variables
as arguments, or if {\tt X} is an atom. (It fails if X is a cons node.)
    {\footnotesize
     \begin{verbatim}
                | ?- is_most_general_term(f(_,_,_,_)).
                yes
                | ?- is_most_general_term(abc).
                yes
                | ?- is_most_general_term(f(X,Y,Z,X)).
                no
                | ?- is_most_general_term(f(X,Y,Z,a)).
                no
                | ?- is_most_general_term([_|_]).
                no
     \end{verbatim}}

\standarditem{callable(?X)}{callable/1}
    Succeeds if {\tt X} is currently instantiated to a term that standard
    predicate {\tt call/1} could take as an argument and not give an 
    instantiation or type error.  Note that it only checks for errors of
    predicate {\tt call/1}.  In other words it succeeds if {\tt X}
    is an atom or a compound term; otherwise it fails.  Predicate
    {\tt callable/1} has no associated error conditions.

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- callable(p).
                yes
                | ?- callable(p(1,2,3)).
                yes
                | ?- callable([_,_]).
                yes
                | ?- callable(_(a)).
                yes
                | ?- callable(3.14).
                no
     \end{verbatim}}

\ourstandarditem{proper\_hilog(?X)}{proper\_hilog/1}{HiLog}
%
   Succeeds if {\tt X} is a proper HiLog term -- i.e. a HiLog term
   that is not a Prolog term; otherwise the predicate fails.

    Examples:
    (In this example and the rest of the examples of this section we assume
     that {\tt h} is the only parameter symbol that has been declared a HiLog
     symbol).

    {\footnotesize
     \begin{verbatim}
                | ?- proper_hilog(X).
                no
                | ?- proper_hilog(foo(a,f(b),[A])).
                no
                | ?- proper_hilog(X(a,b,c)).
                yes
                | ?- proper_hilog(3.6(2,4)).
                yes
                | ?- proper_hilog(h).
                no
                | ?- proper_hilog([a, [d, e, X(a)], c]).
                yes
                | ?- proper_hilog(a(a(X(a)))).
                yes
     \end{verbatim}}

\isoitem{functor(?Term, ?Functor, ?Arity)}{functor/3}
    Succeeds if the {\em functor} of the Prolog term {\tt Term} is 
    {\tt Functor} and the {\em arity} (number of arguments) of {\tt Term} is
    {\tt Arity}\@.  {\tt Functor} can be used in either the following two 
    ways:
    \begin{enumerate}
    \item If {\tt Term} is initially instantiated, then
          \begin{itemize}
          \item If {\tt Term} is a compound term, {\tt Functor} and 
                {\tt Arity} are unified with the name and arity of 
                its principal functor, respectively. 
          \item If {\tt Term} is an atom or a number, {\tt Functor} is 
                unified with {\tt Term}, and {\tt Arity} is unified with 0.
          \end{itemize}
    \item If {\tt Term} is initially uninstantiated, then either both 
          {\tt Functor} and {\tt Arity} must be instantiated, or {\tt Functor}
          is instantiated to a number, and
          \begin{itemize}
          \item If {\tt Arity} is an integer in the range 1..255, then
                {\tt Term} becomes instantiated to {\em the most general 
                Prolog term} having the specified {\tt Functor} and 
                {\tt Arity} as principal functor and number of arguments,
                respectively. The variables appearing as arguments of 
                {\tt Term} are all distinct.
          \item If {\tt Arity} is 0, then {\tt Functor} must be either an 
                atom or a number and it is unified with {\tt Term}. 
          \item If {\tt Arity} is anything else, then {\tt functor/3} aborts.
          \end{itemize}
    \end{enumerate}

{\bf Error Cases}
    \begin{description}
    \item[{\tt atom\_or\_variable}]
	{\tt Functor} is not an atom or variable.
    \item[{\tt instantiation\_error}]
	Both {\tt Term}, and either {\tt Functor}, or {\tt Arity} are 
	uninstantiated.
    \end{description}

    Examples:
    {\footnotesize
     \begin{verbatim}
                | ?- functor(p(f(a),b,t), F, A).
                F = p
                A = 3

                | ?- functor(T, foo, 3).
                T = foo(_595708,_595712,_595716)

                | ?- functor(T, 1.3, A).
                T = 1.3
                A = 0

                | ?- functor(foo, F, 0).
                F = foo

                | ?- functor("foo", F, A).
                F = .
                A = 2

                | ?- functor([], [], A).
                A = 0

                | ?- functor([2,3,4], F, A).
                F = .
                A = 2

                | ?- functor(a+b, F, A).
                F = +
                A = 2

                | ?- functor(f(a,b,c), F, A).
                F = f
                A = 3

                | ?- functor(X(a,b,c), F, A).
                F = apply
                A = 4

                | ?- functor(map(P)(a,b), F, A).
                F = apply
                A = 3

                | ?- functor(T, foo(a), 1).
                ++Error: Wrong type in argument 2 of functor/3
                Aborting...

                | ?- functor(T, F, 3).
                ++Error: Uninstantiated argument 2 of functor/3
                Aborting...

                | ?- functor(T, foo, A).
                ++Error: Uninstantiated argument 3 of functor/3
                Aborting...
     \end{verbatim}}

\ourstandarditem{hilog\_functor(?Term, ?F, ?Arity)}{hilog\_functor/3}{HiLog}
%
    The XSB standard predicate {\tt hilog\_functor/3} succeeds 
    \begin{itemize}
    \item when {\tt Term} is a Prolog term and the principal function 
          symbol ({\em functor}) of {\tt Term} is {\tt F} and the
          {\em arity} (number of arguments) of {\tt Term} is 
          {\tt Arity}, or
    \item when {\tt Term} is a HiLog term, having {\em name} {\tt F} 
          and the number of arguments {\tt F} is applied to, in the 
          HiLog term, is {\tt Arity}.
    \end{itemize}
    The first of these cases corresponds to the ``usual'' behaviour of
    Prolog's {\tt functor/3}, while the second is the extension of
    {\tt functor/3} to handle HiLog terms. Like the Prolog's {\tt
    functor/3} predicate, {\tt hilog\_functor/3} can be used in either
    of the following two ways:
    \begin{enumerate}
    \item If {\tt Term} is initially instantiated, then
          \begin{itemize}
          \item If {\tt Term} is a Prolog compound term, {\tt F} and 
                {\tt Arity} are unified with the name and arity of 
                its principal functor, respectively.
          \item If {\tt Term} is an atom or a number, {\tt F} is unified 
                with {\tt Term}, and {\tt Arity} is unified with 0.
          \item If {\tt Term} is any other HiLog term, {\tt F} and {\tt Arity} 
                are unified with the name and the number of arguments 
                that {\tt F} is applied to. Note that in this case {\tt F}
                may still be uninstantiated.
          \end{itemize}
    \item If {\tt Term} is initially uninstantiated, then at least
          {\tt Arity} must be instantiated, and
          \begin{itemize}
          \item If {\tt Arity} is an integer in the range 1..255, then
                {\tt Term} becomes instantiated to {\em the most general 
                Prolog or HiLog term} having the specified {\tt F} and 
                {\tt Arity} as name and number of arguments {\tt F} is 
                applied to, respectively. The variables appearing as 
                arguments are all unique.
          \item If {\tt Arity} is 0, then {\tt F} must be a Prolog or
                HiLog constant, and it is unified with {\tt Term}\@. Note
                that in this case {\tt F} cannot be a compound term.
          \item If {\tt Arity} is anything else, then {\tt hilog\_functor/3}
                aborts.
          \end{itemize}
    \end{enumerate}
    In other words, the standard predicate {\tt hilog\_functor/3} either
    decomposes a given HiLog term into its {\em name} and {\em arity}, or
    given an arity ---and possibly a name--- constructs the corresponding 
    HiLog term creating new uninstantiated variables for its arguments. 
    As happens with {\tt functor/3} all constants can be their own 
    principal function symbols.

    Examples:
    {\footnotesize
     \begin{verbatim}
               | ?- hilog_functor(f(a,b,c), F, A).
               F = f
               A = 3

               | ?- hilog_functor(X(a,b,c), F, A).
               X = _595836
               F = _595836
               A = 3

               | ?- hilog_functor(map(P)(a,b), F, A).
               P = _595828
               F = map(_595828)
               A = 2

               | ?- hilog_functor(T, p, 2).
               T = p(_595708,_595712)

               | ?- hilog_functor(T, h, 2).
               T = apply(h,_595712,_595716)

               | ?- hilog_functor(T, X, 3).
               T = apply(_595592,_595736,_595740,_595744)
               X = _595592

               | ?- hilog_functor(T, p(f(a)), 2).
               T = apply(p(f(a)),_595792,_595796)

               | ?- hilog_functor(T, h(p(a))(L1,L2), 1).
               T = apply(apply(apply(h,p(a)),_595984,_595776),_596128)
               L1 = _595984
               L2 = _595776

               | ?- hilog_functor(T, a+b, 3).
               T = apply(a+b,_595820,_595824,_595828)
     \end{verbatim}}

\isoitem{arg(+Index, +Term, ?Argument)}{arg/3} 
%
  Unifies {\tt Argument} with the ${\tt Index}^{th}$ argument of {\tt
    Term}\@, where the index is taken to start at $1$.  In accordance
  with ISO semantics, {\tt Index} must be instantiated to a
  non-negative integer, and {\tt Term} to a compound term, otherwise
  an error is thrown as described below.  If {\tt Index} is {\tt 0} or
  a number greater than the arity of {\tt Term}, the predicate quietly
  fails.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- arg(2, p(a,b), A).
                   A = b

                   | ?- arg(2, h(a,b), A).
                   A = a

                   | ?- arg(0, foo, A).
                   no

                   | ?- arg(2, [a,b,c], A).
                   A = [b,c]

                   | ?- arg(2, "HiLog", A).
                   A = [105,108,111,103]

                   | ?- arg(2, a+b+c, A).
                   A = c

                   | ?- arg(3, X(a,b,c), A).
                   X = _595820 
                   A = b 

                   | ?- arg(2, map(f)(a,b), A).
                   A = a

                   | ?- arg(1, map(f)(a,b), A). 
                   A = map(f)

                   | ?- arg(1, (a+b)(foo,bar), A).
                   A = a+b
     \end{verbatim}}

{\bf Error Cases} 
\bi
\item 	{\tt Index} is a variable
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Index} neither a variable nor an integer
\bi
\item    {\tt type\_error(integer,Index)}
\ei
\item 	{\tt Index} is less than 0
\bi
\item    {\tt domain\_error(not\_less\_than\_zero,Index)}
\ei
\item 	{\tt Term} is a variable
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Term} neither a variable nor a compound term
\bi
\item    {\tt type\_error(integer,Index)}
\ei
\ei

\standarditem{arg0(+Index, +Term, ?Argument)}{arg0/3}
    Unifies {\tt Argument} with the ${\tt Index}^{th}$ argument of {\tt Term}
    if {\tt Index} $>$ 0, or with the functor of {\tt Term} if {\tt Index} = 0.

\ourstandarditem{hilog\_arg(+Index, +Term, ?Argument)}{hilog\_arg/3}{HiLog}
    If {\tt Term} is a Prolog term, it has the same behaviour as {\tt arg/3},
    but if {\tt Term} is a proper HiLog term, {\tt hilog\_arg/3} unifies 
    {\tt Argument} with the 
    $({\tt Index}+1)^{th}$ argument of the Prolog representation of 
    {\tt Term}\@.  Semantically, {\tt Argument} is the ${\tt Index}^{th}$ 
    argument to which the {\em HiLog functor} of {\tt Term} is applied.
    The arguments of the {\tt Term} are numbered from~1 upwards. An atomic term 
    is taken to have $0$ arguments.  
    
    Initially, {\tt Index} must be instantiated to a positive integer and 
    {\tt Term} to any non-variable Prolog or HiLog term.
    If the initial conditions are not satisfied or~$I$ is 
    out of range, the call quietly fails. Note that like {\tt arg/3}
    this predicate does not succeed for {\tt Index}=0.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- hilog_arg(2, p(a,b), A).
                   A = b

                   | ?- hilog_arg(2, h(a,b), A).
                   A = b

                   | ?- hilog_arg(3, X(a,b,c), A).
                   X = _595820
                   A = c

                   | ?- hilog_arg(1, map(f)(a,b), A).
                   A = a

                   | ?- hilog_arg(2, map(f)(a,b), A).
                   A = b

                   | ?- hilog_arg(1, (a+b)(foo,bar), A).
                   A = foo

                   | ?- hilog_arg(1, apply(foo), A). 
                   A = foo

                   | ?- hilog_arg(1, apply(foo,bar), A).
                   A = bar
     \end{verbatim}}

    Note the difference between the last two examples. The difference is 
    due to the fact that {\tt apply/1} is a Prolog term, while 
    {\tt apply/2} is a proper HiLog term.

\isoitem{?Term =.. ?List}{=../2}
%
Given proper instantition of the arguments, {\tt =../2} (pronounced
{\em univ}) succeeds when (1) {\tt Term} unifies with a compound
Prolog or HiLog term and {\tt List} unifies with a list whose head is
the functor of {\tt Term} and whose tail is a list of the arguments of
{\tt Term}; or (2) when {\tt Term} unifies with an atomic term and
{\tt List} unifies with a list whose only element is {\tt Term}.  More
precisely,
    \begin{itemize}
    \item If initially {\tt Term} is uninstantiated, then {\tt List}
      must be instantiated either to a {\em proper list} (list of
      determinate length) whose head is an atom, or to a list of
      length 1 whose head is a number.
    \item If the arguments of {\tt =../2} are both uninstantiated, or
      if either of them is not what is expected, {\tt =../2} throws
      the appropriate error message.
    \end{itemize}

    Examples:
    {\footnotesize
     \begin{verbatim}
           | ?- X - 1 =.. L.
           X = _h112
           L = [-,_h112,1]

           | ?- p(a,b,c) =.. L.
           L = [p,a,b,c]

           | ?- h(a,b,c) =.. L.
           L = [apply,h,a,b,c]

           | ?- map(p)(a,b) =.. L.
           L = [apply,map(p),a,b]

           | ?- T =.. [foo].
           T = foo

           | ?- T =.. [apply,X,a,b].
           T = apply(X,a,b)

           | ?- T =.. [1,2].
           ++Error[XSB/Runtime/P]: [Type (1 in place of atomic)] in arg 2 of predicate =../2

           | ?- T =.. [a+b,2].
           ++Error[XSB/Runtime/P]: [Type (a + b in place of atomic)] in arg 2 of predicate =../2

           | ?- X =.. [foo|Y].
           ++Error[XSB/Runtime/P]: [Instantiation]  in arg 2 of predicate =../2
     \end{verbatim}}

% Not ISO compliant in that X =.. [] should give domain error -- not
% a big deal 
{\bf Error Cases}
\begin{itemize}
\item {\tt Term} is a variable and {\tt List} is a variable, a partial list,
  or a list whose head is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt List} is neither a variable nor a non-empty list
\bi
\item {\tt type\_error(list, H)}
\ei
\item {\tt List} is a list whose head {\tt H} is neither an atom nor a
  variable, and whose tail is not the empty list 
\bi
\item {\tt type\_error(atomic, H)}
\ei
\item {\tt Term} is a variable and the tail of {\tt List} has a length
  greater than XSB's maximum arity for terms (256) 
\bi
\item {\tt representation\_error(max\_arity)}
\ei
\ei

%in the following line I used a very ``dirty'' LaTeX hack! -- Kostis.

\standarditem{?Term \^{ }=.. [?F |?ArgList]}{\^{ }=../2}{HiLog}
    When {\tt Term} is a Prolog term, this predicate behaves exactly like
    the Prolog {\tt =../2}. However when {\tt Term} is a proper HiLog term, 
    {\tt \verb|^|=../2} 
    succeeds unifying {\tt F} to its HiLog functor and {\tt ArgList} to the 
    list of the arguments to which this HiLog functor is applied. Like 
    {\tt =../2}, the use of {\tt \verb|^|=../2} can nearly always be avoided
    by using the more efficient predicates {\tt hilog\_functor/3} and 
    {\tt hilog\_arg/3}. The behaviour of {\tt \verb|^|=../2}, on HiLog terms 
    is as follows:
    \begin{itemize}
    \item If initially {\tt Term} is uninstantiated, then the list in the 
          second argument of {\tt \verb|^|=../2} must be instantiated to 
          a {\em proper list} (list of determinate length) whose head can 
          be any Prolog or HiLog term.
    \item If the arguments of {\tt \verb|^|=../2} are both uninstantiated, 
          or if the second of them is not what is expected, 
          {\tt \verb|^|=../2} aborts, producing an appropriate error message.
    \end{itemize}
    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- p(a,b,c) ^=.. L.
                   L = [p,a,b,c]

                   | ?- h(a,b,c) ^=.. L.
                   L = [h,a,b,c]

                   | ?- map(p)(a,b) ^=.. L.
                   L = [map(p),a,b]

                   | ?- T ^=.. [X,a,b].
                   T = apply(X,a,b)

                   | ?- T ^=.. [2,2].
                   T = apply(2,2)

                   | ?- T ^=.. [a+b,2].
                   T = apply(a+b,2)

                   | ?- T ^=.. [3|X].
                   ++Error: Argument 2 of ^=../2 is not a proper list
                   Aborting...
     \end{verbatim}}

{\bf Error Cases}
     \begin{description}
     \item[{\tt instantiation\_error}]
	Argument 2 of {\tt \verb|^|=../2} is not a proper list.
     \end{description}

\isoitem{copy\_term(+Term, -Copy)}{copy\_term/2}
    Makes a {\tt Copy} of {\tt Term} in which all variables have been
    replaced by brand new variables which occur nowhere else. It can
    be very handy when writing (meta-)interpreters for logic-based
    languages.  The version of {\tt copy\_term/2} provided is {\em space
    efficient} in the sense that it never copies ground terms. 
    Predicate {\tt copy\_term/2} has no associated errors or exceptions.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- copy_term(X, Y).

                   X = _598948
                   Y = _598904

                   | ?- copy_term(f(a,X), Y).

                   X = _598892
                   Y = f(a,_599112)
     \end{verbatim}}

\end{description}

%-----------------------------------------------------------------------------------------------
\section{Manipulation of Atomic Terms}

\begin{description}

\isoitem{atom\_codes(?Atom, ?CharCodeList)}{atom\_codes/2}
    The standard predicate {\tt atom\_codes/2} performs the conversion 
    between an atom and its character list representation. 
    If {\tt Atom} is supplied (and is an atom), {\tt CharList} 
    is unified with a list of ASCII codes representing the {\em ``name''} 
    of that atom.  In that case, {\tt CharList} is exactly the list of 
    ASCII character codes that appear in the printed representation of 
    {\tt Atom}.  If on the other hand {\tt Atom} is a variable, 
    then {\tt CharList} must be a proper list of ASCII character codes. 
    In that case, {\tt Atom} is instantiated to an atom containing
    exactly those characters, even if the characters look like the
    printed representation of a number.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- atom_codes('Foo', L).
                   L = [70,111,111]

                   | ?- atom_codes([], L).
                   L = [91,93]

                   | ?- atom_codes(X, [102,111,111]).
                   X = foo
 
                   | ?- atom_codes(X, []).
                   X = ''

                   | ?- atom_codes(X, "Foo").
                   X = 'Foo'

                   | ?- atom_codes(X, [52,51,49]).
                   X = '431'

                   | ?- atom_codes(X, [52,51,49]), integer(X).
                   no

                   | ?- atom_codes(X, [52,Y,49]).
                   ++Error[XSB/Runtime/P]: [Instantiation]  in arg 2 of predicate atom_codes/2
                   Forward Continuation...

                   | ?- atom_codes(431, L).
                   ++Error[XSB/Runtime/P]: [Type (431 in place of atom)] in arg 1 of predicate 
                   atom_codes/2
                   Forward Continuation...

                   | ?- atom_codes(X, [52,300,49]).
                   [Representation (300 is not character code)] in arg 2 of predicate 
                   atom_codes/2
                   Forward Continuation...
     \end{verbatim}}

{\bf Error Cases}
\begin{itemize}
\item {\tt Atom} is a variable and {\tt CharCodeList} is a partial
  list or a list with an element which is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Atom} is neither a variable nor an atom 
\bi
\item {\tt type\_error(atom, Atom)}
\ei
\item {\tt Atom} is a variable and {\tt CharCodeList} is neither a
  list nor a partial list 
\bi
\item {\tt type\_error(list, CharCodeList)}
\ei
\item {\tt Atom} is a variable and an element {\tt E} of {\tt CharCodeList} is neither a
variable nor a character code
\bi
\item {\tt representation\_error(character\_code, E)}
\ei
\end{itemize}

\isoitem{number\_codes(?Number, ?CharCodeList)}{number\_codes/2}
%
    The standard predicate {\tt number\_codes/2} performs the conversion 
    between a number and its character list representation. 
    If {\tt Number} is supplied (and is a number), {\tt CharList} is
    unified with a list of ASCII codes comprising the printed representation
    of that {\tt Number}.  If on the other hand {\tt Number} is a variable, 
    then {\tt CharList} must be a proper list of ASCII character codes that
    corresponds to the correct syntax of a number (either integer or float)
    In that case, {\tt Number} is instantiated to that number, otherwise
    {\tt number\_codes/2} will simply fail.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- number_codes(123, L).
                   L = [49,50,51];

                   | ?- number_codes(N, [49,50,51]), integer(N).
                   N = 123

                   | ?- number_codes(31.4e+10, L).
                   L = [51,46,49,51,57,57,57,55,69,43,49,48]

                   | ?- number_codes(N, "314e+8").
                   N = 3.14e+10

                   | ?- number_codes(foo, L).
                   ++Error[XSB/Runtime/P]: [Type (foo in place of
                     number)] in arg 1 of predicate 
                   number_codes
                   Forward Continuation...
     \end{verbatim}}

{\bf Error Cases}
\begin{itemize}
\item {\tt Number} is a variable and {\tt CharCodeList} is a partial
  list or a list with an element which is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Number} is neither a variable nor a number
\bi
\item {\tt type\_error(number, Number)}
\ei
\item {\tt Number} is a variable and {\tt CharCodeList} is neither a
  list nor a partial list 
\bi
\item {\tt type\_error(list, CharCodeList)}
\ei
\item {\tt Number} is a variable and an element {\tt E} of {\tt CharCodeList} is neither a
variable nor a character code
\bi
\item {\tt representation\_error(character\_code, E)}
\ei
\end{itemize}

\standarditem{name(?Constant, ?CharList)}{name/2}
%
The standard predicate {\tt name/2} performs the conversion between a
constant and its character list representation.  If {\tt Constant} is
supplied (and is any atom or number), {\tt CharList} is unified with a
list of ASCII codes representing the {\em ``name''} of the constant.
In that case, {\tt CharList} is exactly the list of ASCII character
codes that appear in the printed representation of {\tt Constant}\@.
If on the other hand {\tt Constant} is a variable, then {\tt CharList}
must be a proper list of ASCII character codes.  In that case, {\tt
  name/2} will convert a list of ASCII characters that can represent a
number to a number rather than to a character string.  As a
consequence of this, there are some atoms (for example \verb|'18'|)
which cannot be constructed by using {\tt name/2}\@.  If conversion to
an atom is preferred in these cases, the standard predicate {\tt
  atom\_codes/2} should be used instead. The syntax for numbers that
is accepted by {\tt name/2} is exactly the one which {\tt read/1}
accepts.  

%Predicate {\tt name/2} is provided for backwards
%compatibility.  It is advisable that new programs use the predicates
%{\tt atom\_codes/2} and {\tt number\_codes/2} described below.
%In \version\ predicate {\tt name/2} is not yet implemented for
%converting from a real number to its character list representation,
%%and if the representation of a real is provided as {\tt CharList}, it
%will be converted to an atom.  If both of the arguments of {\tt
%  name/2} are uninstantiated or {\tt CharList} is not a proper list of
%ASCII characters, {\tt name/2} will abort and an error message will be
%sent to the standard error stream.

    Examples:
    {\footnotesize
     \begin{verbatim}
                   | ?- name('Foo', L).
                   L = [70,111,111]

                   | ?- name([], L).
                   L = [91,93]

                   | ?- name(431, L).
                   L = [52,51,49]

                   | ?- name(X, [102,111,111]).
                   X = foo
 
                   | ?- name(X, []).
                   X = ''

                   | ?- name(X, "Foo").
                   X = 'Foo'

                   | ?- name(X, [52,51,49]).
                   X = 431

                   | ?- name(X, [45,48,50,49,51]), integer(X).
                   X = -213

                   | ?- name(3.14, L).
                   ++Error[XSB/Runtime/P]: [Miscellaneous] Predicate name/2 for reals is not implemented yet
                   Aborting...
     \end{verbatim}}

\begin{itemize}
\item {\tt Constant} is a variable and {\tt CharCodeList} is a partial
  list or a list with an element which is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Constant} is neither a variable nor atomic
\bi
\item {\tt type\_error(atomic, Constant)}
\ei
\item {\tt Constant} is a variable and {\tt CharCodeList} is neither a
  list nor a partial list 
\bi
\item {\tt type\_error(list, CharCodeList)}
\ei
\item {\tt Constant} is a variable and an element {\tt E} of {\tt
  CharCodeList} is neither a variable nor a character code 
\bi
\item {\tt representation\_error(character\_code, E)}
\ei
\end{itemize}

\isoitem{atom\_chars(?Number, ?CharList)}{atom\_chars/2}
    Like \verb|atom_codes/2|, but the list returned (or input) is a list of
    characters \emph{as atoms} rather than ASCII codes. For instance, 
    \verb|atom_chars(abc,X)| binds {\tt X} to the list {\tt [a,b,c]}
    Instead of {\tt [97,98,99]}.

{\bf Error Cases}
\begin{itemize}
\item {\tt Atom} is a variable and {\tt CharList} is a partial
  list or a list with an element which is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Atom} is neither a variable nor an atom 
\bi
\item {\tt type\_error(atom, Atom)}
\ei
\item {\tt Atom} is a variable and {\tt CharList} is neither a
  list nor a partial list 
\bi
\item {\tt type\_error(list, CharList)}
\ei
\item An element {\tt E} of {\tt CharList} is not a single-character
atom
\bi
\item {\tt type\_error(character, E)}
\ei
\item {\tt Atom} is a variable and an element {\tt E} of {\tt
  CharCodeList} is not a single-character atom
\bi
\item {\tt representation\_error(character, E)}
\ei
\end{itemize}

\isoitem{number\_chars(?Number, ?CharList)}{number\_chars/2}
%
    Like \verb|number_codes/2|, but the list returned (or input) is a list of
    characters \emph{as atoms} rather than ASCII codes. For instance, 
    \verb|number_chars(123,X)| binds {\tt X} to the list {\tt ['1','2','3']}
    instead of {\tt [49,50,51]}.

{\bf Error Cases}
\begin{itemize}
\item {\tt Number} is a variable and {\tt CharList} is a partial
  list or a list with an element which is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Number} is neither a variable nor a number
\bi
\item {\tt type\_error(number, Number)}
\ei
\item {\tt Number} is a variable and {\tt CharList} is neither a
  list nor a partial list 
\bi
\item {\tt type\_error(list, CharList)}
\ei
\item An element {\tt E} of {\tt CharList} is not a single-character
atom
\bi
\item {\tt type\_error(character, E)}
\ei
\item {\tt CharList} is a list of single-character atoms but is not
  parsable as a number (by XSB)
\bi
\item {\tt syntax\_error(CharList)}
\ei
\end{itemize}

\standarditem{number\_digits(?Number, ?DigitList)}{number\_digits/2}
    Like \verb|number_codes/2|, but the list returned (or input) is a list of
    digits \emph{as numbers} rather than ASCII codes (for floats, the atom
    '.', '+' or '-', and 'e' will also be present in the list). For instance, 
    \verb|number_digits(123,X)| binds {\tt X} to the list {\tt [1,2,3]}
    instead of {\tt ['1','2','3']}, and \verb|number_digits(123.45,X)|
    binds {\tt X} to {\tt [1,.,2,3,4,5,0,0,e,+,0,2]}.

Error cases are the same as {\tt number\_chars/2}.

\isoitem{char\_code(?Character, ?Code)}{char\_code/2}
%
The standard predicate {\tt char\_code/2} is true if {\tt Code} is the
current code for {\tt Character}.  In XSB it is defined as {\tt
  atom\_codes(Character,[Code])}.

\isoitem{atom\_length(+Atom1,?Length)}{atom\_length/2}
%
This standard predicate succeeds if {\tt Length} unifies with the
length of (the name of) {\tt Atom}.

{\bf Example}
{\small
\begin{verbatim}
|?- atom_length(trilobyte,L).

L = 9
\end{verbatim}
}

{\bf Error Cases}
\begin{itemize}
  \item {\tt Atom} is a variable
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Atom} is neither a variable nor an atom
\begin{itemize}      
\item   {\tt type\_error(atom,Atom)}
\end{itemize}
\item {\tt Length} is neither a variable nor an integer
\begin{itemize}      
\item   {\tt type\_error(integer,Length)}
\end{itemize}
\end{itemize}

\ourisousageitem{atom\_concat(Atom1,Atom2,Atom3)}{atom\_concat/3}
\ourusage{atom\_concat(?Atom,?Atom,+Atom)}
\ourusage{atom\_concat(+Atom,+Atom,-Atom)}
%
Suceeds if {\tt Atom12} is the concatenation of {\tt Atom1} and {\tt Atom2}.

{\bf Examples}
{\small
\begin{verbatim}
| ?- atom_concat(hello,world,F).

F = hello world

| ?- atom_concat(X,Y,'hello world').

X =
Y = hello world;

X = h
Y = ello world 
\end{verbatim}
}
The last query will resucceed for all combinations of atoms that
produce {\tt hello world}.

{\bf Error Cases}
\begin{itemize}
  \item {\tt Atom1} and {\tt Atom3} are both variables
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
  \item {\tt Atom2} and {\tt Atom3} are both variables
\begin{itemize}
\item {\tt instantiation\_error}
\end{itemize}
\item {\tt Atom1} is neither a variable nor an atom
\begin{itemize}      
\item   {\tt type\_error(atom,Atom1)}
\end{itemize}
\item {\tt Atom2} is neither a variable nor an atom
\begin{itemize}      
\item   {\tt type\_error(atom,Atom2)}
\end{itemize}
\item {\tt Atom3} is neither a variable nor an atom
\begin{itemize}      
\item   {\tt type\_error(atom,Atom3)}
\end{itemize}
\end{itemize}

\isoitem{sub\_atom(+Atom,?LeftLength,?CenterLength,?RightLength,?CenterAtom}{sub\_atom/5 }
%
Succeeds if {\tt Atom} can be broken into three pieces: A left atom of
length {\tt LeftLength}, a center atom {\tt CenterAtom} of length {\tt
  CenterLength} and a right atom of length {\tt RightLength}.  If
sufficient arguments are uninstantiated to produce {\tt CenterAtom} in
non-deterministic starting positions, the predicate will backtrack
through all center atoms for which the left atom length is the
smallest , up to those whose left atom length is greatest (see
examples below).

{\bf Examples}
{\small
\begin{verbatim}
| ?- sub_atom(trilobyte,5,4,RL,CA).

RL = 0
CA = byte
| ?- sub_atom(trilobyte,1,CL,2,CA).

CL = 6
CA = riloby
| ?- sub_atom(trilobyte,LL,6,RL,riloby).

LL = 1
RL = 2
| ?- sub_atom(trilobyte,RL,4,LL,CA).

RL = 0
LL = 5
CA = tril;

RL = 1
LL = 4
CA = rilo;

RL = 2
CL = 3
CA = ilob
| ?- sub_atom(trilobyte,LL,CL,RL,CA).

LL = 0
CL = 0
RL = 9
CA = ;

LL = 0
CL = 1
RL = 8
CA = t;

LL = 0
CL = 2
RL = 7
CA = tr;

: /* after more backtracking */

LL = 0
CL = 9
RL = 0
CA = trilobyte;

LL = 1
CL = 0
RL = 8
CA = ;

Ll = 1
CL = 1
RL = 7
CA = r;
\end{verbatim}
}

{\bf Error Cases}
\bi
\item  {\tt Atom} is a variable
\bi
\item {\tt instantiation\_error}
\ei
\item  {\tt Atom} is neither a variable nor an atom
\bi
\item {\tt type\_error(atom, Atom)}
\ei
\item  {\tt CenterAtom} is neither a variable nor an atom
\bi
\item {\tt type\_error(atom, CenterAtom)}
\ei
\item  {\tt LeftLength} is neither a variable nor an integer
\bi
\item  {\tt  type\_error(integer, LeftLength)}
\ei
\item  {\tt CenterLength} is neither a variable nor an integer
\bi
\item  {\tt  type\_error(integer, CenterLength)}
\ei
\item  {\tt RightLength} is neither a variable nor an integer
\bi
\item  {\tt type\_error(integer, RightLength)}
\ei
\item  {\tt LeftLength} is an integer that is less than zero
\bi
\item  {\tt  domain\_error(not\_less\_than\_zero, LeftLength)}
\ei
\item  {\tt CenterLength} is an integer that is less than zero
\bi
\item  {\tt  domain\_error(not\_less\_than\_zero, CenterLength)}
\ei
\item  {\tt RightLength} is an integer that is less than zero
\bi
\item  {\tt  domain\_error(not\_less\_than\_zero, RightLength)}
\ei
\ei

\ourmoditem{term\_to\_atom(+Term,-Atom,+Options)}{term\_to\_atom/3}{string}
%
Converts {\tt +Term} to an atomic form according to a list of write
options, {\tt Options}, that are similar to those used by {\tt
write\_term/[2,3]}.  The various options of {\tt
term\_to\_atom/[2,3]} are especially useful for the interface from C
to XSB (see {\em Calling XSB from C} in Volume 2 of this manual).
%
\begin{itemize}
%
\item {\tt quoted(+Bool)}.  If {\tt Bool = true}, then atoms and
    functors that can't be read back by {\tt read/1} are quoted, if
    {\tt Bool = false}, each atom and functor is written as its
    unquoted name. Default value is {\tt false}.
%
\item {\tt ignore\_ops(+Bool)}. If {\tt Bool = true} each compound term
is output in functional notation; list braces are ignored, as are all
explicitly defined operators.  If {\tt Bool = canonical}, bracked list
notation is used.  Default value is {\tt canonical}.  The
corresponding value of {\tt false}, that would enable operator
precedence, is not yet implemented.
%
 \item {\tt numbervars(+Bool)}.  If {\tt Bool = true}, a term of the
form {\tt '\$VAR'(N)} where {\tt N} is an integer, is output as a
variable name consisting of a capital letter possibly followed by an
integer.  A term of the form {\tt '\$VAR'(Atom)} where {\tt Atom} is an
atom, is output as itself (without quotes).  Finally, a term of the
form {\tt '\$VAR'(String)} where {\tt String} is a character string, is
output as the atom corresponding to this character string.  If
{\tt bool} is {\tt false} this cases are not treated in any special
way.  Default value is {\tt false}.
%
\end{itemize}

{\bf Error Cases} 
\bi
\item 	{\tt Options} is a variable
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Options} neither a variable nor a list
\bi
\item    {\tt type\_error(list,Options)}
\ei
\item 	{\tt Options} contains a variable element, {\tt O}
\bi
\item    {\tt instantiation\_error}
\ei
\item 	{\tt Options} contains an element {\tt O} that is neither a variable
nor a write option.
\bi
\item    {\tt domain\_error(write\_option,O)}
\ei
\ei

Examples:
{\footnotesize
\begin{verbatim}
| ?- term_to_atom(f(a,1,X,['3cpio',d(3),'$VAR'("Foo")]),F,[]).

X = _h131
F = f(a,1,_h0,[3cpio,d(3),$VAR([70,111,111])])

yes
| ?- term_to_atom(f(a,1,X,['3cpio',d(3),'$VAR'("Foo")]),F,[numbervars(true)]).

X = _h131
F = f(a,1,_h0,[3cpio,d(3),Foo])

yes
| ?- term_to_atom(f(a,1,X,['3cpio',d(3),'$VAR'("Foo")]),F,[numbervars(true),quoted(true)]).

X = _h131
F = f(a,1,_h0,['3cpio',d(3),Foo])

yes
| ?- term_to_atom(f(a,1,X,['3cpio',d(3),'$VAR'("Foo")]),F,[numbervars(true),quoted(true),ignore_ops(true)]).

X = _h131
F = f(a,1,_h0,'.'('3cpio','.'(d(3),'.'(Foo,[]))))

yes
\end{verbatim}}

\ourmoditem{term\_to\_atom(+Term,-Atom)}{term\_to\_atom/2}{string}
%
This predicate converts an arbitrary Prolog term {\tt Term} into an
atom, putting the result in {\tt Atom}.  It is defined using the
default options for {\tt term\_to\_atom/3}, e.g. {\tt
ignore\_ops(canonical)}, {\tt quoted(false)}, and {\tt
numbervars(false)}.

\ourmoditem{term\_to\_codes(+Term,-CodeList,+OptionList)}{term\_to\_codes/3 }{string}
%
This predicate is used in the definition of {\tt term\_to\_atom/3} but
only converts a term into a list of ASCII codes, and does not intern
the list as an atom.  Allowed values for {\tt OptionList} and error
cases are the same as in {\tt term\_to\_atm/3}.

\ourmoditem{term\_to\_codes(+Term,-CodeList)}{term\_to\_codes/2}{string}
%
This predicate converts a term to a list of ASCII codes.  It is
defined using the default options for {\tt term\_to\_atom/3},
e.g. {\tt ignore\_ops(canonical)}, {\tt quoted(false)}, and {\tt
numbervars(false)}.

\standarditem{gc\_atoms}{gc\_atoms/0}
\index{garbage collection!atoms}
%
Explicitly invokes the garbage collector for atoms that are created,
but no longer needed.  By default, {\tt gc\_atoms/1} is called
automatically, unless the {\tt xsb\_flag} {\tt
  atom\_garbage\_collection} is set to {\tt false}, or if more than
one thread is active.  However there are reasons why a user may need
to invoke atom table garbage collection.  First, in \version{}, if
atom table garbage collection is invoked automatically, it occurs
periodically on heap garbage collection, or if numerous asserts and
retracts have taken place.  These heuristics overlook certain cases
where numerous atoms may be created without invoking the garbage
collector -- e.g. through repeated uses of {\tt
  format\_write\_string/3}.  In addition if user-defined C code
contains pointers to XSB's atom table, atom table garbage collection
will be unsafe, as \version{} of XSB does not detect such pointers in
external code.  In such cases, atom table garbage collection should be
turned off via the {\tt xsb\_flag} {\tt atom\_garbage\_collection},
and reinvoked at a point where the external pointers are no longer
used.

\end{description}


\section{All Solutions and Aggregate Predicates}
\index{sets, bags} \index{aggregate predicates!prolog}
%-----------------------------------------------------
Often there are many solutions to a problem and it is necessary
somehow to compare these solutions with one another.  The most general
way of doing this is to collect all the solutions into a list, which
may then be processed in any way desired.  So XSB provides
ISO-standard predicates such as {\tt setof/3}, {\tt bagof/3}, and {\tt
findall/3} to collect solutions into lists.  Sometimes however, one
wants simply to perform some aggregate operation over the set of
solutions, for example to find the maximum or minimum of the set of
solutions.  XSB uses tabling and HiLog to provide a general and
powerful aggregation facility as discussed in Section
\ref{tabling_aggregate_predicates}.

\begin{description}
\isoitem{setof(?Template, +Goal, ?Set)}{setof/3}
    This predicate may be read as ``{\tt Set} is the set of all instances 
    of {\tt Template} such that {\tt Goal} is provable''.
    If~{\tt Goal} is not provable, {\tt setof/3} fails.
    The term {\tt Goal} specifies a goal or goals as in {\tt call(Goal)}.
    {\tt Set} is a set of terms represented as a list of those terms,
    without duplicates, in the standard order for terms 
    (see Section~\ref{Comparison}).
    If there are uninstantiated variables in {\tt Goal} which do not also 
    appear in {\tt Template}, then a call to this evaluable predicate may backtrack,
    generating alternative values for~{\tt Set} corresponding to different
    instantiations of the free variables of~{\tt Goal}.
    Variables occurring in {\tt Goal} will not be treated as free if they 
    are explicitly bound within~{\tt Goal} by an existential quantifier.
    An existential quantification can be specified as:
    \begin{center}
    {\tt Y \^\ G}\index{\^}
    \end{center}
    meaning there exists a {\tt Y} such that {\tt G} is true,
    where {\tt Y} is some Prolog term (usually, a variable).
  
    Error cases are the same as predicate {\tt call/1} (see
    Section~\ref{meta_predicates}).

Example: Consider the following predicate: 
%
\begin{verbatim}
    p(red,high,1).
    p(green,low,2).
    p(blue,high,3).
    p(black,low,4).
    p(black,high,5).
\end{verbatim}
%
The goal \verb|?- setof(Color,Height^Val^p(Color,Height,Val),List)|
returns a single solution:
\begin{verbatim}
    Color = _h73
    Height = _h87
    Val = _h101
    L = [black,blue,green,red]
\end{verbatim}

If {\tt Height} is removed from the sequence of existential variables, so
that the goal becomes:\\
\verb|?- setof(Color,Val^p(Color,Height,Val),List)}|, the first solution is:
\begin{verbatim}
    Color = _h73
    Val = _h87
    Height = high
    L = [black,blue,red];
\end{verbatim}
%
upon backtracking, a second solution is produced: 
%
\begin{verbatim}
    Color = _h73
    Val = _h87
    Height = low
    L = [black,green]
\end{verbatim}

\isoitem{bagof(?Template, +Goal, ?Bag)}{bagof/3}
%
This predicate has the same semantics as {\tt setof/3} except that the
third argument returns an unsorted list that may contain duplicates.

Error Cases are the same as predicate {\tt call/1} (see
Section~\ref{meta_predicates}).

Example: 
%
For the predicate {\tt p/3} in the example for {\tt setof/3}, the
goal\\ 
\verb|?- bagof(Color,Height^Val^p(Color,Height,Val),L)| returns
the single solution:
\begin{verbatim}
    Color = _h73
    Height = _h87
    Val = _h101
    L = [red,green,blue,black,black];
\end{verbatim}
If {\tt Height} is removed from the sequence of existential variables, so
that the goal becomes: 
\verb|?- bagof(Color,Val^p(Color,Height,Val),List)|, the first solution is:
\begin{verbatim}
    Color = _h73
    Val = _h87
    Height = high
    L = [red,blue,black];
\end{verbatim}
%
upon backtracking, a second solution is produced: 
%
\begin{verbatim}
    Color = _h73
    Val = _h87
    Height = low
    L = [green,black];
\end{verbatim}


\isoitem{findall(?Template, +Goal, ?List)}{findall/3}
Similar to predicate {\tt bagof/3}, except that variables in {\tt
  Goal} that do not occur in {\tt Template} are treated as
existential, and alternative lists are not returned for different
bindings of such variables.  Note that this means that {\tt Goal}
should not contain existential variables.  This makes {\tt findall/3}
deterministic (non-backtrackable).  Unlike {\tt setof/3} and {\tt
  bagof/3}, if {\tt Goal} is unsatisfiable, {\tt findall/3} succeeds
binding {\tt List} to the empty list.

Error cases are the same as {\tt call/1} (see
Section~\ref{meta_predicates}).

Example: 
%
For the predicate {\tt p/3} in the example for {\tt setof/3}, the goal \\
{\tt findall(Color,p(Color,Height,Val),L)} returns a single solution: 
%
\begin{verbatim}
    Color = _h73
    Height = _h107
    Val = _h121
    F = [red,green,blue,black,black]
\end{verbatim}

\ourstandarditem{tfindall(?Template, +Goal, ?List)}{tfindall/3}{Tabling}
%
\label{tfindall/3}

    {\em Note: {\tt tfindall/3} may be deprecated in current versions.
    Please use the predicates described in
    Section~\ref{tabling_aggregate_predicates} if possible}.

    Like {\tt findall/3}, {\tt tfindall/3} treats all variables in
    {\tt Goal} that do not occur in {\tt Template} as existential.  However,
    in {\tt tfindall/3}, the {\tt Goal} must be a call to a single
    tabled predicate.
	
    {\tt tfindall/3} allows the user to build programs that use
    stratified aggregation.  If the table to {\tt Goal} is incomplete,
    {\tt tfindall/3} suspends until the table has been completed, and
    only then computes {\tt List}.  See Chapter~\ref{chap:TablingOverview}
    for further discussion of {\tt tfindall/3}.  Like {\tt findall/3},
    if {\tt Goal} is unsatisfiable, {\tt tfindall/3} succeeds binding
    {\tt List} to the empty list.

    Some of the differences between predicates {\tt findall/3} and
    {\tt tfindall/3} can be seen from the following example:

    {\footnotesize
    \begin{verbatim}
            | ?- [user].
            [Compiling user]
            :- table p/1.
            p(a).
            p(b).
            [user compiled, cpu time used: 0.639 seconds]
            [user loaded]

            yes
            | ?- p(X), findall(Y, p(Y), L).

            X = a
            Y = _922928
            L = [a];

            X = b
            Y = _922820
            L = [a,b];

            no
            | ?- abolish_all_tables.

            yes
            | ?- p(X), tfindall(Y, p(Y), L).

            X = b
            Y = _922820
            L = [b,a];

            X = a
            Y = _922820
            L = [b,a];

            no
    \end{verbatim}
    }

    Error cases are the same as predicate {\tt findall/3} (see above).
    Also:
    \begin{description}
    \item[{\tt table\_error}]
	Upon execution {\tt Goal} is not a subgoal of a tabled predicate.
    \end{description}

\ourrepeatstandarditem{tsetof(?X, +Goal, ?List)}{tsetof/3}{Tabling}
\ourstandarditem{tbagof(?X, +Goal, ?List)}{tbagof/3}{Tabling}

    {\em Note: {\tt tbagof/3} and {\tt tsetof/3} may be deprecated in
    current versions.  Please use the predicates described in
    Section~\ref{tabling_aggregate_predicates} if possible.}

The standard predicates {\tt tbagof/3} and {\tt tsetof/3} provide
tabled versions of {\tt bagof/3} and {\tt setof/3} in a similar manner
to the way in which {\tt tfindall/3} provides a tabled version of {\tt
findall/3}.

\isoitem{X \^\ Goal}{\^\ /2}
%
Within {\tt setof/3}, {\tt bagof/3} and the like, the {\tt \^\ /2}
operator means there exists an {\tt X} such that {\tt Goal} is true.

\end{description}

\subsection{Tabling Aggregate Predicates}\label{tabling_aggregate_predicates}
%-------------------------------------------------------------------------
\index{aggregate predicates!tabling} \index{tabling!aggregate predicates}
%-------------------------------------------------------------------------

HiLog provides an elegant way to introduce aggregate operations into
XSB.  HiLog allows a user to define named (and parameterized) sets (or
bags).  For example, say we have a simple database-like predicate,
\verb|employee(Name,Dept,Sal)|, which contains a tuple for each
employee in our concern and contains the employee's name, department,
and salary.  From this predicate we can construct a set, or bag
really, that contains all the salaries of employees in the relation:
\begin{verbatim}
    :- hilog salaries.
    salaries(Sal) :- employee(_Name,_Dept,Sal).
\end{verbatim}
So \verb|salaries| is the name of a unary predicate that is true of
all salaries, or rather is the name of a {\em bag} of all salaries.
It is a bag since it may contain the same salary multiple times.
XSB provides a predicate \verb|bagSum| which can be used to
sum up the elements in a named bag.  So given the definition of the
HiLog predicate \verb|salaries/1| above, we can get the sum of all the
salaries with:
\begin{verbatim}
    :- bagSum(salaries,TotalSals).
\end{verbatim}
The first argument to \verb|bagSum| is the name of a bag, and the
second is bound to the sum of the elements in the bag.

We can also do a ``group by'' to get total salaries within departments
as follows.  We define a parameterized predicate, \verb|sals(Dept)|,
to be the bag of salaries of employees in department \verb|Dept|, as
follows:
\begin{verbatim}
    sals(Dept)(Sal) :- employee(_Name,Dept,Sal).
\end{verbatim}
This rule says that \verb|Sal| is in the bag named \verb|sals(Dept)|
if there is an employee with some name who works in department
\verb|Dept| and has salary \verb|Sal|.

Now with this definition, we can define a predicate,
\verb|deptPayroll/2|, that associates with each department the sum of
all the salaries of employees in that department:
\begin{verbatim}
    deptPayroll(Dept,Payroll) :- bagSum(sals(Dept),Payroll).
\end{verbatim}

XSB provides analogous aggregate operators, described below, to
compute the minimum, maximum, count, and average, of a bag,
respectively.  These predicates are all defined using a more basic
predicate \verb|bagReduce/4|.

\begin{description}

\ourrepeatstandarditem{bagReduce(?SetPred,?Arg,+Op,+Id)}{bagReduce/4}{HiLog,Tabling}
\ourstandarditem{filterReduce(?SetPred,?Arg,+Op,+Id)}{filterReduce/4}{Tabling}
%
{\tt SetPred} must be a HiLog set specification, i.e., a unary HiLog
predicate.  {\tt Op} must be a Hilog operation, i.e., a 3-ary HiLog
predicate that defines an associative operator.  The predicate must
define a binary function in which the first two arguments determine
the third.  {\tt Id} must be the identity of the operator.  {\tt
bagReduce} returns with {\tt Arg} bound to the ``reduce'' of the
elements of the bag determined by {\tt SetPred} under the operation
{\tt Op}.  I.e., {\tt Arg} becomes the result of applying the operator
to all the elements in the bag that unify with {\tt SetPred}.  See the
{\tt bagSum} operator below to see an example of {\tt bagReduce}'s
use.

{\tt filterReduce/4} acts as {\tt bagReduce/4} with two differences.
First, it does not depend on HiLog, so that {\tt filterReduce/4} will
be more robust especially when XSB's module system is used.  In
addition, {\tt filterReduce/4} aggregates solutions to {\tt Pred}
using a variance rather than unification.  An example of the use of
{\tt filterReduce/4} is given in Chapter \ref{chap:TablingOverview}.

\ourrepeatstandarditem{bagPO(?SetPred,?Arg,+Order)}{bagPO/3}{HiLog,Tabling}
\ourstandarditem{filterPO(?SetPred,?Arg,+Order)}{filterPO/3}{Tabling}
%
    {\tt SetPred} must be a HiLog set specification, i.e., a unary
    HiLog predicate.  {\tt Order} must be a binary Hilog relation that
    defines a partial order.  {\tt bagPO} returns nondeterministically
    with {\tt Arg} bound to the maximal elements, under {\tt Order}, of
    the bag {\tt SetPred}.  {\tt bagPO/3} can be used with {\tt Order}
    being subsumption to reduce a set of answers and keep only the most
    general answers.

    See the {\tt bagMax} operator below to see an example of {\tt
    bagPO}'s use.

{\tt filterPO/3} acts as {\tt bagPO/3} with the single difference that
it does not depend on HiLog, so that {\tt filterPO/3} will be more
robust especially when XSB's module system is used.

\ourstandarditem{filterPO(\#Pred,+Order)}{filterPO/2}{Tabling} 
%
{\tt filterPO(\#Pred,+Order)} succeds only for a solution $Pred\theta$
of {\tt Pred} for which there is no solution $Pred\eta$ to {\tt Pred}
such that {\tt Order($Pred\eta$,$Pred\theta$)}.

Example:

For the following program
     \begin{center}
     {\tt
     \begin{tabular}{l}
          :- table p/2.	\\
          b(1,2).       \\
          p(1,3).       \\
          b(1,1).       \\
\\
	  prefer(b(X,X),b(X,Y)):- X \== Y. 
     \end{tabular}
     }
     \end{center}
the query 
\begin{center}
{\tt ?- filterPO(b(X,Y)}
\end{center}
will succeed only with the binding {\em X = 1,Y = 1}.

\ourstandarditem{bagMax(?SetPred,?Arg)}{bagMax/2}{HiLog,Tabling}
%
    {\tt SetPred} must be a HiLog set specification, i.e., a unary
    HiLog predicate.  {\tt bagMax} returns with {\tt Arg} bound to the
    maximum element (under the Prolog term ordering) of the set {\tt
    SetPred}.  To use this predicate, it must be imported from aggregs,
    and you must give the following definitions in the main module {\tt
    usermod}:
\begin{verbatim}
:- hilog maximum.
maximum(X,Y,Z) :- X @< Y -> Z=Y ; Z=X.
\end{verbatim}
    (These decarations are necessary because of a current limitation in
    how HiLog predicates can be used.  This requirement will be lifted in
    a future release.)  With this definition, {\tt bagMax/2} can be (and
    is) defined as follows:
\begin{verbatim}
bagMax(Call,Var) :- bagReduce(Call,Var,maximum,_).
\end{verbatim}
    (Where variables are minimal in the term ordering.)

Another possible definition of {\tt bagMax/2} would be:
\begin{verbatim}
:- hilog lt.
lt(X,Y) :- X @< Y.

bagMax(Call,Var) :- bagPO(Call,Var,lt).
\end{verbatim}
This definition would work, but it is slightly less efficient than the
previous definition since it is known that {\tt bagMax} is
deterministic.

\ourstandarditem{bagMin(?SetPred,?Arg)}{bagMin/2}{HiLog,Tabling}
%
    {\tt SetPred} must be a HiLog set specification, i.e., a unary
    HiLog predicate.  {\tt bagMin} returns with {\tt Arg} bound to the
    minimum element (under the Prolog term ordering) of the set {\tt
    SetPred}.  To use this predicate, it must be imported from aggregs,
    and you must give the following definitions in the main module {\tt
    usermod}:
\begin{verbatim}
:- hilog minimum.  
minimum(X,Y,Z) :- X @< Y -> Z=X ; Z=Y.
\end{verbatim}
    (These decarations are necessary because of a current limitation in
    how HiLog predicates can be used.  This requirement will be lifted in
    a future release.)  With this definition, {\tt bagMin/2} can be (and
    is) defined as:
\begin{verbatim}
bagMin(Call,Var) :- bagReduce(Call,Var,minimum,zz(zz)).
\end{verbatim}
    (where structures are the largest elements in the term ordering.)

\ourstandarditem{bagSum(?SetPred,?Arg)}{bagSum/2}{HiLog,Tabling}
%
    {\tt SetPred} must be a HiLog set specification, i.e., a unary
    HiLog predicate.  {\tt bagSum} returns with {\tt Arg} bound to the sum
    of the elements of the set {\tt SetPred}.  To use this predicate, it
    must be imported from aggregs, and you must give the following
    definitions in the main module {\tt usermod}:
\begin{verbatim}
:- hilog sum.
sum(X,Y,Z) :- Z is X+Y.
\end{verbatim}
    (These decarations are necessary because of a current limitation in
    how HiLog predicates can be used.  This requirement will be lifted in
    a future release.)  With this definition, {\tt bagSum/2} can be (and
    is) defined as:
\begin{verbatim}
bagSum(Call,Var) :- bagReduce(Call,Var,sum,0).
\end{verbatim}

\ourstandarditem{bagCount(?SetPred,?Arg)}{bagCount/2}{HiLog,Tabling}
%
    {\tt SetPred} must be a HiLog set specification, i.e., a unary
    HiLog predicate.  {\tt bagCount} returns with {\tt Arg} bound to the
    count (i.e., number) of elements of the set {\tt SetPred}.  To use
    this predicate, it must be imported from aggregs, and you must give
    the following definitions in the main module {\tt usermod}:
\begin{verbatim}
:- hilog successor.
successor(X,_Y,Z) :- Z is X+1.
\end{verbatim}
    (These decarations are necessary because of a current limitation in
    how HiLog predicates can be used.  This requirement will be lifted in
    a future release.)  With this definition, {\tt bagCount/2} can be (and
    is) defined as:
\begin{verbatim}
bagCount(Call,Var) :- bagReduce(Call,Var,successor,0).
\end{verbatim}

\ourstandarditem{bagAvg(?SetPred,?Arg)}{bagAvg/2}{HiLog,Tabling}
%
    {\tt SetPred} must be a HiLog set specification, i.e., a unary
    HiLog predicate.  {\tt bagAvg} returns with {\tt Arg} bound to the
    average (i.e., mean) of elements of the set {\tt SetPred}.  To use
    this predicate, it must be imported from aggregs, and you must give
    the following definitions in the main module {\tt usermod}:
\begin{verbatim}
:- hilog sumcount.
sumcount([S|C],X,[S1|C1]) :- S1 is S+X, C1 is C+1.
\end{verbatim}
    (These decarations are necessary because of a current limitation in
    how HiLog predicates can be used.  This requirement will be lifted in
    a future release.)  With this definition, {\tt bagAvg/2} can be (and
    is) defined as:
\begin{verbatim}
bagAvg(Call,Avg) :- 
    bagReduce(Call,[Sum|Count],sumcount,[0|0]),
    Avg is Sum/Count.
\end{verbatim}

\end{description}

%-------------------------------------------------------------------------

\section{Meta-Predicates} \label{meta_predicates}
\begin{description}
\isoitem{call(\#X)}{call/1}
%
    If {\tt X} is a non-variable term in the program text, then it is 
    executed exactly as if {\tt X} appeared in the program text instead 
    of {\tt call(X)},
    e.g.
    \begin{center}
        {\tt $\ldots$, p(a), call( (q(X), r(Y)) ), s(X), $\ldots$}
    \end{center}
    is equivalent to
    \begin{center}
        {\tt $\ldots$, p(a), q(X), r(Y), s(X), $\ldots$}
    \end{center}
    However, if {\tt X} is a variable in the program text,
    then if at runtime {\tt X} is instantiated to a term which 
    would be acceptable as the body of a clause, the goal 
    {\tt call(X)} is executed as if that
    term appeared textually in place of the {\tt call(X)},
    {\em except that} any cut (`!')\index{\texttt{"!/0}}\index{cut}
    occurring in {\tt X} will remove only those choice points in~{\tt X}.
    If~{\tt X} is not instantiated as described above,
    an error message is printed and {\tt call/1} fails.

{\bf Error Cases}
    \begin{description}
    \item[{\tt instantiation\_error}]
	{\tt X} is a variable
     \item[{\tt type\_error(callable,X)}]
	{\tt X} is not callable.
    \end{description}

\ouritem{\#X}					      
    (where {\tt X} is a variable) executes exactly the same as 
    {\tt call(X)}.
    However, the explicit use of {\tt call/1} is considered better
    programming practice.  The use of a top level variable subgoal
    elicits a warning from the compiler.

\isoitem{call(Goal,Arg,...)}{call/[2,10]}
%
{\tt call(Goal,Arg)} where {\tt Goal} is an N-ary callable term first
constructs a new N+1-ary term {\tt NewGoal} with the same functor and
first N arguments as {\tt Goal} and with {\tt Arg} as its N+1th
argument, and then calls {\tt NewGoal}.  As an example,

{\tt call(member(X),[a,b,c])}

is equivalent to {\tt call(member(X,[a,b,c])}.  {\tt Goal} must be a
callable term, but can be prepended by a module name using the {\tt
  :/2} symbol.  {\tt call(Goal,Arg1,Arg2,...)} will act similarly. 
Note that {\tt Goal} should usually be atomic -- if the outer functor 
of {\tt Goal} is, say, {\tt ,/2}, {\tt call/[2-10]} will try to add 
the extra argument(s) to the comma functor, which is generally not 
the intended behavior.

While meta calls are generally fast in XSB, the extra term
manipulation of {\tt call/[2-10]} makes it somewhat slower than {\tt
  call/1}.

\isoitem{once(\#X)}{once/1}
%
    {\tt once/1} is defined as {\tt once(X):- call(X),!.}  {\tt
    once/1} should be used with care in tabled programs.  The compiler
    can not determine whether a tabled predicate is called in the
    scope of {\tt once/1}, and such a call may lead to runtime errors.
    If a tabled predicate may occur in the scope of {\tt once/1}, use
    {\tt table\_once/1} instead.

    Error cases are the same as {\tt call/1}.

\ourstandarditem{table\_once(\#X)}{table\_once/1}{Tabling}
    {\tt table\_once/1} is a weaker form of {\tt once/1}, suitable for
    situations in which a single solution is desired for a
    subcomputation that may involve a call to a tabled predicate.  {\tt
    table\_once(?Pred)} succeeds only once even if there are many
    solutions to the subgoal {\tt Pred}.  However, it does not ``cut
    over'' the subcomputation started by the subgoal {\tt Pred},
    thereby ensuring the correct evaluation of tabled subgoals.

\isoitem{call\_cleanup(\#Goal,\#Handler)}{call\_cleanup/2}
%
{\tt call\_cleanup(Goal, Cleanup)} calls {\tt Goal} just as if it were
called via {\tt call/1}, but it is ensures that {\tt Handler} will be
called after {\tt Goal} finishes execution.  {\tt call\_cleanup/2} is
thus useful when {\tt Goal} uses a resource, (such as a stream, mutex,
database cursor, etc.) that should be released when {\tt Goal}
finishes execution.

More precisely, {\tt Goal} finishes execution either 1) by failure, 2)
by determining that the success of {\tt Goal} is deterministic, 3)
when an error is thrown and not handled by {\tt Goal} or one of its
subgoals; or 4) when {\tt Goal} is cut over.  In all of these cases,
{\tt Handler} will be called and will succeed non-deterministically.
We illustrate these cases through examples.
\begin{itemize}
\item Failure of {\tt Goal}:
\begin{verbatim}
   ?- call_cleanup(fail,writeln(failed(Goal))).
\end{verbatim}
In this case, {\tt Goal} has no solutions, and the handler is invoked
when the engine backtracks out of {\tt Goal}.
%
\item Deterministic success of {\tt Goal}.  Assume that {\tt p(1)} and
  {\tt p(2)} have been asserted.  Then
\begin{verbatim}
   ?- call_cleanup((p(X),writeln(got(p(X)))),writeln(handled(p(X)))).
   got(p(1))

   X = 1;
   got(p(2))
   handled(p(2))

   X = 2;

  no
\end{verbatim}
Note that {\tt Handler} is called only after the last solution of the
goal {\tt p(X)} has been obtained.  XSB decides to call {\tt Handler}
only when it can be determined that the success of {\tt Goal} has left
no choice points.  In such a case, the final solution has been
obtained for {\tt Goal}.  Of course, it may be that a solution $S$ to
{\tt Goal} leaves a choice point but the choice point will produce no
further solutions for {\tt Goal}.  XSB will not call {\tt Handler} in
this case, rather it will wait until there are no choice points left
for {\tt Goal}.

\item An uncaught error $E$ is thrown out of {\tt Goal}.  In this
  case, {\tt Handler} will be called, and then, if $E$ is uncaught,
  $E$ will be rethrown.  This is illustrated in the following example
  (Error handling is discussed further in Section~\ref{sec:catch}):
\begin{verbatim}
   ?- catch(call_cleanup(throw(my_error),writeln(invoking_handler)),Ball,write(Ball)).
   invoking_handler
   my_error
   yes
\end{verbatim}
Of course, {\tt Handler} itself can be wrapped in a {\tt catch/3} so
that any errors will be caught by {\tt call\_cleanup/2}.

\item Choice points for {\tt Goal} are removed via a cut.  Consider an
  example in which {\tt p/1} has the same extension as above ({\tt p(1),p(2)}:
\begin{verbatim}
   call_cleanup(p(X),writeln(handled_1)),!.
   handled_1

X = 1

yes	
\end{verbatim}
The handler is invoked immediately when the choice point laid down by
{\tt p(X)} is cut over -- before returning to the command line.  If a
cut cuts over more than goal to be cleaned, more than one handler will be executed:
\begin{verbatim}
   ?-call_cleanup(p(X),writeln(handled_4_1)),
       call_cleanup(p(Y),writeln(handled_4_2)),
       call_cleanup(p(Z),writeln(handled_4_3)),
       !.
   handled_4_3
   handled_4_2
   handled_4_1
 
   X = 1
   Y = 1
   Z = 1
\end{verbatim}
\end{itemize}

{\tt call\_cleanup/2} is thus an extremely powerful and flexible
mechanism when used in a simple manner.  While {\tt Handler} is
``guarenteed'' to be invoked whenever {\tt Goal} finishes
execution~\footnote{In fact we don't guarentee anything, see XSB's
  license.}, it may be difficult to predict when {\tt Handler} will be
invoked, as {\tt Handler} may be invoked because of deeply non-local
cuts over {\tt Goal}, and even when such cuts are not present, the
invocation depends on XSB determining when the last solution for {\tt
  Goal} has been obtained.  Baroque usages, such as invoking {\tt
  call\_cleanup/2} and cuts in the handler are supported, but may lead
to code that is difficult to debug, since handlers may be invoked
based on the state of XSB's choice point stack.  

{\bf Error Cases}
\begin{description}
\item  {\tt Goal} is a variable
\bi
\item {\tt instantiation error}
\ei
\item  {\tt Goal} is neither a variable nor a callable term
\bi
\item  {\tt type error(callable, Goal)}
\ei
\item  {\tt Handler} is a variable
\bi
\item  {\tt instantiation error}
\ei
\item  {\tt Handler} is neither a variable nor a callable term
\bi
\item {\tt type error(callable, Handler)}
\ei
\end{description}

\end{description}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual1"
%%% End: 

