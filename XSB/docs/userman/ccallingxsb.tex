\chapter{Calling \ourprolog\ from C}
%===================================
\label{ccallingxsb}

There are many situations in which it may be desirable to use
\ourprolog\ as a rule-processing subcomponent of a larger system,
which is written in another language.  To do this, one wants to be
able to {\em call}\ \ourprolog\ from the host language, often C,
providing queries for \ourprolog\ to evaluate and retrieving back the
answers.  An interface for calling \ourprolog\ from C is provided for
this purpose and is described in this chapter.  Simple examples of
the use of this interface are given in the {\tt XSB/examples/c\_calling\_XSB}
subdirectory, in files {\tt cmain.c}, {\tt cmain2.c}, {\tt ctest.P}, and {\tt
Makefile}.

\section{C Functions for Calling \ourprolog}

\ourprolog\ provides several C functions (declared in {\tt
XSB/emu/cinterf.h} and defined in \\ {\tt XSB/emu/cinterf.c}), which can
be called from C to interact with \ourprolog\ as a subroutine. These
functions allow a C program to initialize \ourprolog\ (most easily with
a call to {\tt xsb\_init\_string(options)}) and then to interact with it
to have it perform various functions.  One can send commands to have
them evaluated by \ourprolog .  A command is a deterministic query which
simply succeeds or fails (without returning any interesting data value.)
One can also send a query to be evaluated and then retrieve, one at a
time, the answers produced for it.  There are several levels of
interface provided.  The highest level interface uses strings to
communicate queries to \ourprolog\ and to get answers back.  The {\tt
xsb\_command\_string(cmd)} function allows you to pass a command as a
(period-terminated) string to \ourprolog .  The {\tt
xsb\_query\_string\_string(query,buff,sizeof(buff),sep)} function allows
you to pass a query to XSB as a string, and have its (first) answer
returned as a string.  Subsequent answers can be calculated and
retrieved using {\tt xsb\_next\_string(buff,sizeof(buff),sep)}.

There are lower-level interfaces that allow you to manipulate directly
the \ourprolog\ data structures (both to construct queries and to
retrieve answers) and thus avoid the overhead of converting to and from
strings.  See the detailed descriptions of the routines below to see how
to use the lower level interface.

Currently, only one query can be active at a time.
I.e., one must completely finish processing one query (either by
retrieving all the answers for it, or by issuing a call to {\tt
xsb\_close\_query()}, before trying to evaluate another.  The
routines to perform all these functions are described following:

\begin{description}
\ouritem{int xsb\_init(int argc, char *argv[])} \index{{\tt xsb\_init}}
This is a C-callable function that initializes \ourprolog . It must be
called before any other calls can be made.  {\tt argc} is the count of
the number of arguments in the {\tt argv} vector.  The {\tt argv}
vector is exactly as would be passed from the command line to
\ourprolog .  It must contain at least the following two things:
%%
\begin{itemize}
\item $\tt argv[0]$ must be an absolute or relative path name of the XSB
  installation directory ({\it i.e.}, {\tt \$XSB\_DIR}.  Here is an
  example, which assumes that we invoke the C program from the XSB
  installation directory.
    %%
    \begin{verbatim}
int main(int argc, char *argv[])
{ 
  int myargc = 2;
  char *myargv[2];

  /* XSB_init relies on the calling program to pass the addr of the XSB
     installation directory. From here, it will find all the libraries */
  myargv[0] = ".";
  myargv[1] = "-n";

  /* Initialize xsb */
  xsb_init(myargc,myargv);
    \end{verbatim}
    %%
  \item $\tt argv[1]$ must be the {\tt -n} flag.  This flag tells
    \ourprolog\ not to start the read-eval-print top loop, but to act as a
    subroutine to a calling C routine.
\end{itemize}
%%
Other flags are optional, but can be used to modify sizes of the various
spaces used in \ourprolog.  In particular, if \ourprolog\ will be required
to load some other (usually C) program using the foreign language
interface, then the -E option must be used to specify the full path name of
the executable of the main C program.  See section \ref{emulator_options}
for more details.  {\tt xsb\_init} returns 0 if initialization is
completed, and 1 if some error is encountered.

\ouritem{int xsb\_init\_string(char *options)} \index{{\tt xsb\_init\_string}}
This is a variant of {\tt xsb\_init} which takes the command line as a
string argument (rather than as a argc/argv pair.)  For example, a call
could be
%%
\begin{verbatim}
   xsb_init_string(". -n");
\end{verbatim}
%%
Note that just as with {\tt xsb\_init}, you must pass the path name of the
XSB installation directory. In the above, we pass ``.'', assuming that we
are invoking the C program from the XSB installation directory.  The
parameters following the file name are just as those that could appear on a
command line.  The function of this subroutine is exactly the same as {\tt
  xsb\_init}, and its return codes are the same.

\ouritem{int xsb\_command()} \index{{\tt xsb\_command}}
This function passes a command to \ourprolog .  No query can be active
when this command is called.  Before calling {\tt xsb\_command}, the
calling program must construct the \ourprolog\ term representing the
command in register 1 in \ourprolog 's space.  This can be done by
using the {\tt c2p\_*} (and {\tt p2p\_*}) routines, which are
described in Section \ref{c2p_p2p_p2c} below.  Register 2 may also be
set before the call to {\tt xsb\_query} (using {\tt
xsb\_make\_vars(int)} and {\tt xsb\_set\_var\_*()}) in which case any
variables set to values in the {\tt ret/n} term will be so bound in
the call to the command goal.  {\tt xsb\_command} invokes the command
represented in register 1 and returns 0 if the command succeeds and 1
if it fails. In either case it resets register 1 back to a free
variable. If there is an error, it returns 2.

\ouritem{int xsb\_command\_string(char *cmd)} \index{{\tt xsb\_command\_string}}
This function passes a command to \ourprolog .  The command is a
string consisting of a term that can be read by the \ourprolog\
reader.  The string must be terminated by a period (.).  Any previous
query must have already been closed.  In all other respects, {\tt
xsb\_command\_string} is similar to {\tt xsb\_command}.

\ouritem{int xsb\_query()} \index{{\tt xsb\_query}}
This function passes a query to \ourprolog .  Any previous query must
have already been closed.  A query is expected to return possibly
multiple data answers.  The first is found and made available to the
caller as a result of this call.  To get subsequent answers, {\tt
xsb\_next} must be called.  Before calling {\tt xsb\_query} the caller
must construct the term representing the query in \ourprolog 's
register 1 (using routines described in Section \ref{c2p_p2p_p2c}
below.)  If the query has no answers (i.e., just fails), register 1 is
set back to a free variable and {\tt xsb\_query} returns 1.  If the
query has at least one answer, the variables in the query term in
register 1 are bound to those answers and {\tt xsb\_query} returns 0.
In addition, register 2 is bound to a term whose main functor symbol
is {\tt ret/n}, where n is the number of variables in the query. The
main subfields of this term are set to the variable values for the
first answer. (These fields can be accessed by the functions {\tt
p2c\_*}, or the functions {\tt xsb\_var\_*}, described in Section
\ref{c2p_p2p_p2c} below.)  Thus there are two places the answers are
returned. Register 2 is used to make it easier to access them.  To get
subsequent answers, {\tt xsb\_next} must be called.  Register 2 may
also be set before the call to {\tt xsb\_query} (using {\tt
xsb\_make\_vars(int)} and {\tt xsb\_set\_var\_*()}) in which case any
variables set to values in the {\tt ret/n} term will be so bound in
the call to the goal.

\ouritem{int xsb\_query\_string(char *query)} \index{{\tt xsb\_query\_string}}
This function passes a query to \ourprolog .  The query is a string
consisting of a term that can be read by the \ourprolog\ reader.  The
string must be terminated with a period (.).  Any previous query must
have already been closed.  In all other respects, xsb\_query\_string
is similar to xsb\_query, except the only way to retrieve answers is
through Register 2.  The ability to create the return structure and
bind variables in it is particularly useful in this function.

\ouritem{int xsb\_query\_string\_string(char *query,char *buff,int
len,char *sep)} \index{{\tt xsb\_query\_string\_string}} This function
is a variant of {\tt xsb\_query\_string} that returns its answer (if
there is one) as a string.  An example call is:
\begin{verbatim}
rc = xsb_query_string_string("append(X,Y,[a,b,c]).",buff,sizeof(buff),";");
\end{verbatim}
The first argument is the period-terminated query string.  The second
argument is a string buffer in which the subroutine returns the answer
(if any.)  The third argument is provided by the caller and is the
length of the buffer (to avoid overflow).  The last argument is a string
provided by the caller, which is used to separate fields in the returned
answer.  For the example query, buff would be set to the string:
\begin{verbatim}
        [];[a,b,c]
\end{verbatim}
which is the first answer to the append query.  There are two fields of
this answer, corresponding to the two variables in the query, \verb|X|
and \verb|Y|.  The bindings of those variables make up the answer and
the individual fields are separated by the \verb|sep| string, here the
semicolon (\verb|;|).  If the answer would overflow the buffer, the
subroutine returns 3 as its function value.  Otherwise its returns are
just as for {\tt xsb\_query\_string}.  In the answer string, \ourprolog\
atoms are printed in their in their standard print form (without
quotes).  Complex terms are printed in a canonical form, with atoms
quoted if necessary, and lists produced in the normal list notation.

\ouritem{int xsb\_next()} \index{{\tt xsb\_next}}
This routine is called after {\tt xsb\_query} (which must have
returned 0) to retrieve more answers.  It rebinds the query variables
in the term in register 1 and rebinds the argument fields of the {\tt
ret/n} answer term in register 2 to reflect the next answer to the
query.  It returns 0 if an answer is found, and returns 1 if there are
no more answers and no answer is returned. On a return of 1, the query
has been closed.  After a query is closed, another {\tt xsb\_command}
or {\tt xsb\_query} invocation can be made.

\ouritem{int xsb\_next\_string(char *buff,int len,char *sep)} \index{{\tt
xsb\_next\_string}}  This routine is a variant of {\tt xsb\_next} that
returns its answer (if there is one) as a string.  Its treatment of
answers is just as {\tt xsb\_query\_string\_string}.  For example after
the example call 
\begin{verbatim}
rc = xsb_query_string_string("append(X,Y,[a,b,c]).",buff,sizeof(buff),";");
\end{verbatim}
which returns with buff set to 
\begin{verbatim}
        [];[a,b,c]
\end{verbatim}
Then a call:
\begin{verbatim}
rc = xsb_next_string(buff,sizeof(buff),";");
\end{verbatim}
returns with buff set to 
\begin{verbatim}
        [a];[b,c]
\end{verbatim}
the second answer to the indicated query. {\tt xsb\_next\_string}
returns codes just as {\tt xsb\_next}, but returns 3 if the answer
buffer would overflow.

\ouritem{int xsb\_close\_query()} \index{{\tt xsb\_close\_query}}
This routine closes a query, before all its answers have been
retrieved.  Since \ourprolog\ is (usually) a tuple-at-a-time system,
answers that are not retrieved are not computed.
It is an error to call {\tt xsb\_query} again without
first either retrieving all the answers to the previous query or
calling {\tt xsb\_close\_query} to close it.

\ouritem{int xsb\_close()} \index{{\tt xsb\_close}}
This routine closes the entire connection to \ourprolog .  After this,
no more calls can be made (including calls to {\tt xsb\_init}.)

\end{description}

\section{Creating the Executable C Program}

To create an executable that includes calls to the above C functions,
these routines, and the \ourprolog\ routines that they call, must be
included in the link ({\tt ld}) step.

\paragraph{Unix instructions:}
First, you must create a relocatable file, named {\tt xsb.o}, that
contains all the \ourprolog\ routines.  To do this, get into the
{\tt XSB/build} subdirectory, and execute:
%%
\begin{verbatim}
    % makexsb module
\end{verbatim}
%%
This will place the relocatable file in:
%%
\begin{verbatim}
 $XSB_DIR/config/<your-system-architecture>/saved.o/xsb.o  
\end{verbatim}
%%$

Second, you must compile your C program, which includes a main
procedure.  You should include the file {\tt cinterf.h} located in the
{\tt XSB/emu} subdirectory, which defines the routines described here
that you will need to use.

Third, to create your executable, after you have created the object
file, say {\tt ruleproc.o}, for your C routine, you could execute:
\begin{verbatim}
    % gcc -o ruleproc ruleproc.o $XSB_DIR/config/<your-system-architecture>/saved.o/xsb.o
\end{verbatim}

The file {\tt \$XSB\_DIR/config/your-system-architecture/modMakefile} is a
makefile you can use to build your programs and link them with XSB.  It is
generated automatically and contains all the right settings for your
architecture, but you will have to fill in the name of your program, etc.

There are simple examples of C programs calling \ourprolog\ in the
{\tt \$XSB\_DIR/examples/c\_calling\_XSB} directory, in files {\tt cmain.c},
{\tt ctest.P}, {\tt cmain2.c}.

\paragraph{Windows instructions:}
To call XSB from C, you must build it as a DLL. To do this, you specify
DLL=''yes'' on command line. {\it E.g.}, 
%%
\begin{quote}
 {\tt NMAKE /f "MS\_VC\_Mfile.mak" CFG="release" DLL="yes"  }
\end{quote}
%%
The DLL, which you can call dynamically from your program is then found in 
%%
\[
 \tt
 \$XSB\_DIR\backslash config\backslash \mbox{\tt x86-pc-windows}\backslash
 saved.o \backslash xsb.dll
\]
%%

\section{Passing Data Between C and \ourprolog} \label{c2p_p2p_p2c}

For a C program and \ourprolog\ to communicate, they must be able to
pass data back and forth. \ourprolog\ uses a particular data
representation and C programs must use that representation to
interface with it.  The only data type that \ourprolog\ uses is {\tt
prolog\_term}.  Functions are provided, and described below, which convert
C data types to and from {\tt prolog\_term}.

Before explaining the low-level routines that construct terms, we will
describe some simpler higher-level routines that can be used for
passing atomic values to and from \ourprolog.  Only if you must
communicate structured data will you need to resort to the lower-level
routines described later.  (These following routines are actually
defined as macros which call the lower level functions.)

\begin{description}
\ouritem{void xsb\_make\_vars((int) N)} \index{{\tt xsb\_make\_vars}}
    {\tt xsb\_make\_vars} creates a return structure of arity {\tt N}
in Register 2.  So this routine may called before calling any of {\tt
xsb\_query}, {\tt xsb\_query\_string}, {\tt xsb\_command}, or {\tt
xsb\_command\_string} if parameters are to be set to be sent to the
goal.  It must be called before calling one of the {\tt
xsb\_set\_var\_*} routines can be called. {\tt N} must be the number
of variables in the query that is to be evaluated.

\ouritem{void xsb\_set\_var\_int((int) Val, (int) N)} 
\index{{\tt xsb\_set\_var\_int}}
    {\tt set\_and\_int} sets the {\tt N}$^{th}$ field in the return
structure to the integer value {\tt Val}.  It is used to set the value of
the {\tt N}$^{th}$ variable in a query before calling {\tt xsb\_query} or
{\tt xsb\_query\_string}.  When called in \ourprolog, the query will
have the {\tt N}$^{th}$ variable set to this value.

\ouritem{void xsb\_set\_var\_string((char *) Val, (int) N)} 
\index{{\tt xsb\_set\_var\_string}}
    {\tt set\_and\_string} sets the {\tt N}$^{th}$ field in the return
structure to the atom with name {\tt Val}.  It is used to set the
value of the {\tt N}$^{th}$ variable in a query before calling {\tt
xsb\_query} or {\tt xsb\_query\_string}.  When called in \ourprolog,
the query will have the {\tt N}$^{th}$ variable set to this value.

\ouritem{void xsb\_set\_var\_float((float) Val, (int) N)} 
\index{{\tt xsb\_set\_var\_float}}
    {\tt set\_and\_float} sets the {\tt N}$^{th}$ field in the return
structure to the floating point number with value {\tt Val}.  It is
used to set the value of the {\tt N}$^{th}$ variable in a query before
calling {\tt xsb\_query} or {\tt xsb\_query\_string}.  When called in
\ourprolog, the query will have the {\tt N}$^{th}$ variable set to this
value.

\ouritem{void xsb\_var\_int((int) N)} \index{{\tt xsb\_var\_int}}
    {\tt xsb\_var\_int} is called after {\tt xsb\_query} or {\tt
xsb\_query\_string} returns an answer.  It returns the value of the
{\tt N}$^{th}$ variable in the query as set in the returned answer.
This variable must have an integer value.

\ouritem{void xsb\_var\_string((int) N)} \index{{\tt xsb\_var\_string}}
    {\tt xsb\_var\_string} is called after {\tt xsb\_query} or {\tt
xsb\_query\_string} returns an answer.  It returns the value of the
{\tt N}$^{th}$ variable in the query as set in the returned answer.
This variable must have an atom value.

\ouritem{void xsb\_var\_float((int) N)} \index{{\tt xsb\_var\_float}}
    {\tt xsb\_var\_float} is called after {\tt xsb\_query} or {\tt
xsb\_query\_string} returns an answer.  It returns the value of the
{\tt N}$^{th}$ variable in the query as set in the returned answer.
This variable must have an floating point value.


\end{description}


The first set of functions support conversion of data elements of the
basic C types to the type {\tt prolog\_term}.  These {\tt c2p\_*}
functions all return a boolean value TRUE if successful and FALSE if
unsuccessful.  The \ourprolog\ term argument must always contain an
\ourprolog\ variable, which will be bound to the indicated value as a
side effect of the function call.  These routines can be used to
construct commands and queries into \ourprolog 's register 1, which is
necessary before calling {\tt xsb\_query()} or {\tt xsb\_command()}.

\begin{description}
\ouritem{bool c2p\_int((int) N, (prolog\_term) V)} \index{{\tt c2p\_int}}
    {\tt c2p\_int} binds the prolog\_term V (which must be a variable)
    to the integer value N.

\ouritem{bool c2p\_float((double) F, (prolog\_term) V)} \index{{\tt c2p\_float}}
    {\tt c2p\_float} binds the prolog\_term V (which must be a variable)
    to the (double) float value F.

\ouritem{bool c2p\_string((char *) S, (prolog\_term) V)} \index{{\tt c2p\_string}}
    {\tt c2p\_string} binds the prolog\_term V (which must be a
    variable) to the atom whose name is the value of S, which must be
    of type char *.

\ouritem{bool c2p\_functor((char *) S, (int) N, (prolog\_term) V)} \index{{\tt c2p\_functor}}
    {\tt c2p\_functor} binds the prolog\_term V (which must be a
    variable) to an open term whose main functor symbol is given by S
    (of type char *) and whose arity is N.  An open term is one with
    all arguments as new distinct variables.

\ouritem{bool c2p\_list((prolog\_term) V)} \index{{\tt c2p\_list}}
    {\tt c2p\_list} binds the prolog\_term V (which must be a variable)
    to an open list term, i.e., a list term with both car and cdr as
    new distinct variables.

\ouritem{bool c2p\_nil((prolog\_term) V)} \index{{\tt c2p\_nil}}
    {\tt c2p\_nil} binds the prolog\_term V (which must be a
    variable) to the atom \verb|[]| (nil).
\end{description}

To use the above functions, one must be able to get access to \ourprolog\
data elements of type {\tt prolog\_term}.  These elements are obtained
from an \ourprolog\ register, or from {\tt prolog\_term} values
obtained from others.  \ourprolog\ provides several {\tt p2p\_*}
functions for accessing these values.  In addition, there are functions
which allow you to test for the type of a {\tt prolog\_term} value.

\begin{description}
\ouritem{prolog\_term reg\_term((int) R)} \index{{\tt reg\_term}}
    Argument R is a register number (range 1 to 255) and {\tt
    reg\_term} returns the prolog\_term in that \ourprolog\ register.

\ouritem{prolog\_term p2p\_arg((prolog\_term) T, (int) A)} \index{{\tt p2p\_arg}}
    Argument T must be a prolog\_term that is a structured term (but
    not a list).  A is a positive integer no larger than the arity of
    the term.  {\tt p2p\_arg} returns the A$^{th}$ subfield of the term
    T.

\ouritem{prolog\_term p2p\_car((prolog\_term) T)} \index{{\tt p2p\_car}}
    Argument T must be a prolog\_term that is a list (not nil).  {\tt
    p2p\_car} returns the car (i.e., first subfield or head) of the
    term T.

\ouritem{prolog\_term p2p\_cdr((prolog\_term) T)} \index{{\tt p2p\_cdr}}
    Argument T must be a prolog\_term that is a list (not nil).  {\tt
    p2p\_car} returns the cdr (i.e., second subfield or tail) of the
    term T.

\ouritem{bool is\_var((prolog\_term) T)} \index{{\tt is\_var}}
    {\tt is\_var(T)} returns TRUE if {\tt T} represents an \ourprolog\
    variable, and FALSE otherwise.

\ouritem{bool is\_int((prolog\_term) T)} \index{{\tt is\_int}}
    {\tt is\_int(T)} returns TRUE if {\tt T} represents an \ourprolog\
    integer value, and FALSE otherwise.

\ouritem{bool is\_float((prolog\_term) T)} \index{{\tt is\_float}}
    {\tt is\_float(T)} returns TRUE if {\tt T} represents an \ourprolog\
    float value, and FALSE otherwise.

\ouritem{bool is\_string((prolog\_term) T)} \index{{\tt is\_string}}
    {\tt is\_string(T)} returns TRUE if {\tt T} represents an \ourprolog\
    atom value, and FALSE otherwise.

\ouritem{bool is\_functor((prolog\_term) T)} \index{{\tt is\_functor}}
    {\tt is\_functor(T)} returns TRUE if {\tt T} represents an
    \ourprolog\ structure value (not a list), and FALSE otherwise.

\ouritem{bool is\_list((prolog\_term) T)} \index{{\tt is\_list}}
    {\tt is\_list(T)} returns TRUE if {\tt T} represents an
    \ourprolog\ list value (not nil), and FALSE otherwise.

\ouritem{bool is\_nil((prolog\_term) T)} \index{{\tt is\_nil}}
    {\tt is\_nil(T)} returns TRUE if {\tt T} represents an \ourprolog\
    \verb|[]| (nil) value, and FALSE otherwise.

\end{description}

For example, to request that \ourprolog\ consult a file, one could use
the above functions to construct a term {\tt consult(ctest)} into
register 1 with the following two C statements:
\begin{verbatim}
        c2p_functor("consult",1,reg_term(1));
        c2p_string("ctest",p2p_arg(reg_term(1),1));
\end{verbatim}

\ourprolog\ provides a final set of functions to convert values from
\ourprolog\ data types back into C data types.  These {\tt c2p\_*}
functions can be used to retrieve the answers computed by a call to
{\tt xsb\_query}.

\begin{description}
\ouritem{int p2c\_int((prolog\_term) V)} \index{{\tt p2c\_int}}
    The prolog\_term argument must represent an integer, and {\tt
    p2c\_int} returns the value of that integer.

\ouritem{double p2c\_float((prolog\_term) V)} \index{{\tt p2c\_float}}
    The prolog\_term argument must represent a floating point number,
    and {\tt p2c\_float} returns the value of that floating point
    number.

\ouritem{char *p2c\_string((prolog\_term) V)} \index{{\tt p2c\_string}}
    The prolog\_term argument must represent an atom, and {\tt
    p2c\_string} returns the name of that atom as a string. The
    pointer returned points to the actual atom name in \ourprolog 's
    space, and thus it must NOT be modified by the calling program.

\ouritem{char *p2c\_functor((prolog\_term) V)} \index{{\tt p2c\_functor}}
    The prolog\_term argument must represent a structured term (not a
    list).  {\tt p2c\_functor} returns the name of the main functor
    symbol of that term as a string. The pointer returned points to
    the actual functor name in \ourprolog 's space, and thus it must
    NOT be modified by the calling program.

\ouritem{int p2c\_arity((prolog\_term) V)} \index{{\tt p2c\_arity}}
    The prolog\_term argument must represent a structured term (not a
    list).  {\tt p2c\_arity} returns the arity of the main functor
    symbol of that term as an integer.

\end{description}

As a simple example of the use of these functions, after calling {\tt
xsb\_query}, one could retrieve the value of the first variable in an
answer (assuming it must be an atom) into a local char * variable,
ans, with the following C statement:
\begin{verbatim}
        if (is_string(p2p_arg(reg_term(2),1))
          ans = p2c_string(p2p_arg(reg_term(2),1));
        else printf("Error in answer type\n");
\end{verbatim}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 
