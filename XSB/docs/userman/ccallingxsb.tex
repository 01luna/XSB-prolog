\chapter{Calling \ourprolog\ from C}
%===================================
\label{ccallingxsb}

There are many situations in which it may be desirable to use
\ourprolog\ as a rule-processing subcomponent of a larger system,
which is written in another language.  To do this, one wants to be
able to {\em call}\ \ourprolog\ from the host language, often C,
providing queries for \ourprolog\ to evaluate and retrieving back the
answers.  An interface for calling \ourprolog\ from C is provided for
this purpose and is described in this chapter.  Simple examples of
the use of this interface are given in the {\tt XSB/examples/c\_calling\_XSB}
subdirectory, in files {\tt cmain.c}, {\tt cmain2.c}, {\tt ctest.P}, and {\tt
Makefile}.

\section{C Functions for Calling \ourprolog}

\ourprolog\ provides several C functions (declared in {\tt
XSB/emu/cinterf.h} and defined in \\ {\tt XSB/emu/cinterf.c}), which can
be called from C to interact with \ourprolog\ as a subroutine. These
functions allow a C program to initialize \ourprolog\ (most easily with
a call to {\tt xsb\_init\_string(options)}) and then to interact with it
to have it perform various functions.  One can send commands to have
them evaluated by \ourprolog .  A command is a deterministic query which
simply succeeds or fails (without returning any interesting data value.)
One can also send a query to be evaluated and then retrieve, one at a
time, the answers produced for it.  There are several levels of
interface provided.  The highest level interface uses strings to
communicate queries to \ourprolog\ and to get answers back.  The {\tt
xsb\_command\_string(cmd)} function allows you to pass a command as a
(period-terminated) string to \ourprolog .  The {\tt
xsb\_query\_string\_string(query,buff,sizeof(buff),sep)} function allows
you to pass a query to XSB as a string, and have its (first) answer
returned as a string.  Subsequent answers can be calculated and
retrieved using {\tt xsb\_next\_string(buff,sizeof(buff),sep)}.

There are lower-level interfaces that allow you to manipulate directly
the \ourprolog\ data structures (both to construct queries and to
retrieve answers) and thus avoid the overhead of converting to and from
strings.  See the detailed descriptions of the routines below to see how
to use the lower level interface.

Currently, only one query can be active at a time.
I.e., one must completely finish processing one query (either by
retrieving all the answers for it, or by issuing a call to {\tt
xsb\_close\_query()}, before trying to evaluate another.  The
routines to perform all these functions are described following:

\begin{description}
\ouritem{int xsb\_init(int argc, char *argv[])} \index{{\tt xsb\_init}}
This is a C-callable function that initializes \ourprolog . It must be
called before any other calls can be made.  {\tt argc} is the count of
the number of arguments in the {\tt argv} vector.  The {\tt argv}
vector is exactly as would be passed from the command line to
\ourprolog .  It must contain at least the following two things:
%%
\begin{itemize}
\item $\tt argv[0]$ must be an absolute or relative path name of the XSB
  installation directory ({\it i.e.}, {\tt \$XSB\_DIR}.  Here is an
  example, which assumes that we invoke the C program from the XSB
  installation directory.
    %%
    \begin{verbatim}
int main(int argc, char *argv[])
{ 
  int myargc = 2;
  char *myargv[2];

  /* XSB_init relies on the calling program to pass the addr of the XSB
     installation directory. From here, it will find all the libraries */
  myargv[0] = ".";
  myargv[1] = "-n";

  /* Initialize xsb */
  xsb_init(myargc,myargv);
    \end{verbatim}
    %%
  \item $\tt argv[1]$ must be the {\tt -n} flag.  This flag tells
    \ourprolog\ not to start the read-eval-print top loop, but to act as a
    subroutine to a calling C routine.
\end{itemize}
%%
Other flags are optional, but can be used to modify sizes of the various
spaces used in \ourprolog.  In particular, if \ourprolog\ will be required
to load some other (usually C) program using the foreign language
interface, then the -E option must be used to specify the full path name of
the executable of the main C program.  See the section on Command Line
Options in Volume 1 
for more details.  {\tt xsb\_init} returns 0 if initialization is
completed, and 1 if some error is encountered.

\ouritem{int xsb\_init\_string(char *options)} \index{{\tt xsb\_init\_string}}
This is a variant of {\tt xsb\_init} which takes the command line as a
string argument (rather than as a argc/argv pair.)  For example, a call
could be
%%
\begin{verbatim}
   xsb_init_string(". -n");
\end{verbatim}
%%
Note that just as with {\tt xsb\_init}, you must pass the path name of the
XSB installation directory. In the above, we pass ``.'', assuming that we
are invoking the C program from the XSB installation directory.  The
parameters following the file name are just as those that could appear on a
command line.  The function of this subroutine is exactly the same as {\tt
  xsb\_init}, and its return codes are the same.

\ouritem{int xsb\_command()} \index{{\tt xsb\_command}}
This function passes a command to \ourprolog .  No query can be active
when this command is called.  Before calling {\tt xsb\_command}, the
calling program must construct the \ourprolog\ term representing the
command in register 1 in \ourprolog 's space.  This can be done by
using the {\tt c2p\_*} (and {\tt p2p\_*}) routines, which are
described in Section \ref{c2p_p2p_p2c} below.  Register 2 may also be
set before the call to {\tt xsb\_query} (using {\tt
xsb\_make\_vars(int)} and {\tt xsb\_set\_var\_*()}) in which case any
variables set to values in the {\tt ret/n} term will be so bound in
the call to the command goal.  {\tt xsb\_command} invokes the command
represented in register 1 and returns 0 if the command succeeds and 1
if it fails. In either case it resets register 1 back to a free
variable. If there is an error, it returns 2.

\ouritem{int xsb\_command\_string(char *cmd)} \index{{\tt xsb\_command\_string}}
This function passes a command to \ourprolog .  The command is a
string consisting of a term that can be read by the \ourprolog\
reader.  The string must be terminated by a period (.).  Any previous
query must have already been closed.  In all other respects, {\tt
xsb\_command\_string} is similar to {\tt xsb\_command}.

\ouritem{int xsb\_query()} \index{{\tt xsb\_query}}
This function passes a query to \ourprolog .  Any previous query must
have already been closed.  A query is expected to return possibly
multiple data answers.  The first is found and made available to the
caller as a result of this call.  To get subsequent answers, {\tt
xsb\_next} must be called.  Before calling {\tt xsb\_query} the caller
must construct the term representing the query in \ourprolog 's
register 1 (using routines described in Section \ref{c2p_p2p_p2c}
below.)  If the query has no answers (i.e., just fails), register 1 is
set back to a free variable and {\tt xsb\_query} returns 1.  If the
query has at least one answer, the variables in the query term in
register 1 are bound to those answers and {\tt xsb\_query} returns 0.
In addition, register 2 is bound to a term whose main functor symbol
is {\tt ret/n}, where n is the number of variables in the query. The
main subfields of this term are set to the variable values for the
first answer. (These fields can be accessed by the functions {\tt
p2c\_*}, or the functions {\tt xsb\_var\_*}, described in Section
\ref{c2p_p2p_p2c} below.)  Thus there are two places the answers are
returned. Register 2 is used to make it easier to access them.  To get
subsequent answers, {\tt xsb\_next} must be called.  Register 2 may
also be set before the call to {\tt xsb\_query} (using {\tt
xsb\_make\_vars(int)} and {\tt xsb\_set\_var\_*()}) in which case any
variables set to values in the {\tt ret/n} term will be so bound in
the call to the goal.

\ouritem{int xsb\_query\_string(char *query)} \index{{\tt xsb\_query\_string}}
This function passes a query to \ourprolog .  The query is a string
consisting of a term that can be read by the \ourprolog\ reader.  The
string must be terminated with a period (.).  Any previous query must
have already been closed.  In all other respects, xsb\_query\_string
is similar to xsb\_query, except the only way to retrieve answers is
through Register 2.  The ability to create the return structure and
bind variables in it is particularly useful in this function.

\ouritem{int xsb\_query\_string\_string(char *query,char *buff,int
len,char *sep)} \index{{\tt xsb\_query\_string\_string}} This function
is a variant of {\tt xsb\_query\_string} that returns its answer (if
there is one) as a string.  An example call is:
\begin{verbatim}
rc = xsb_query_string_string("append(X,Y,[a,b,c]).",buff,sizeof(buff),";");
\end{verbatim}
The first argument is the period-terminated query string.  The second
argument is a string buffer in which the subroutine returns the answer
(if any.)  The third argument is provided by the caller and is the
length of the buffer (to avoid overflow).  The last argument is a string
provided by the caller, which is used to separate fields in the returned
answer.  For the example query, buff would be set to the string:
\begin{verbatim}
        [];[a,b,c]
\end{verbatim}
which is the first answer to the append query.  There are two fields of
this answer, corresponding to the two variables in the query, \verb|X|
and \verb|Y|.  The bindings of those variables make up the answer and
the individual fields are separated by the \verb|sep| string, here the
semicolon (\verb|;|).  If the answer would overflow the buffer, the
subroutine returns 3 as its function value.  Otherwise its returns are
just as for {\tt xsb\_query\_string}.  In the answer string, \ourprolog\
atoms are printed in their in their standard print form (without
quotes).  Complex terms are printed in a canonical form, with atoms
quoted if necessary, and lists produced in the normal list notation.

\ouritem{int xsb\_next()} \index{{\tt xsb\_next}}
This routine is called after {\tt xsb\_query} (which must have
returned 0) to retrieve more answers.  It rebinds the query variables
in the term in register 1 and rebinds the argument fields of the {\tt
ret/n} answer term in register 2 to reflect the next answer to the
query.  It returns 0 if an answer is found, and returns 1 if there are
no more answers and no answer is returned. On a return of 1, the query
has been closed.  After a query is closed, another {\tt xsb\_command}
or {\tt xsb\_query} invocation can be made.

\ouritem{int xsb\_next\_string(char *buff,int len,char *sep)} \index{{\tt
xsb\_next\_string}}  This routine is a variant of {\tt xsb\_next} that
returns its answer (if there is one) as a string.  Its treatment of
answers is just as {\tt xsb\_query\_string\_string}.  For example after
the example call 
\begin{verbatim}
rc = xsb_query_string_string("append(X,Y,[a,b,c]).",buff,sizeof(buff),";");
\end{verbatim}
which returns with buff set to 
\begin{verbatim}
        [];[a,b,c]
\end{verbatim}
Then a call:
\begin{verbatim}
rc = xsb_next_string(buff,sizeof(buff),";");
\end{verbatim}
returns with buff set to 
\begin{verbatim}
        [a];[b,c]
\end{verbatim}
the second answer to the indicated query. {\tt xsb\_next\_string}
returns codes just as {\tt xsb\_next}, but returns 3 if the answer
buffer would overflow.

\ouritem{int xsb\_close\_query()} \index{{\tt xsb\_close\_query}}
This routine closes a query, before all its answers have been
retrieved.  Since \ourprolog\ is (usually) a tuple-at-a-time system,
answers that are not retrieved are not computed.
It is an error to call {\tt xsb\_query} again without
first either retrieving all the answers to the previous query or
calling {\tt xsb\_close\_query} to close it.

\ouritem{int xsb\_close()} \index{{\tt xsb\_close}}
This routine closes the entire connection to \ourprolog .  After this,
no more calls can be made (including calls to {\tt xsb\_init}.)
\end{description}

\section{Passing Data into an XSB Module}

The previous chapter described the low-level XSB/C interface that supports
passing the data of arbitrary complexity between XSB and C. However, in
cases when data needs to be passed into an executable XSB module by the
main C program, the following higher-level interface should suffice.  (This
interface is actually implemented using macros that call the lower level
functions.)  These routines can be used to construct commands and queries
into \ourprolog 's register 1, which is necessary before calling {\tt
  xsb\_query()} or {\tt xsb\_command()}.


\begin{description}
\ouritem{void xsb\_make\_vars((int) N)} \index{{\tt xsb\_make\_vars}}
    {\tt xsb\_make\_vars} creates a return structure of arity {\tt N}
in Register 2.  So this routine may called before calling any of {\tt
xsb\_query}, {\tt xsb\_query\_string}, {\tt xsb\_command}, or {\tt
xsb\_command\_string} if parameters are to be set to be sent to the
goal.  It must be called before calling one of the {\tt
xsb\_set\_var\_*} routines can be called. {\tt N} must be the number
of variables in the query that is to be evaluated.

\ouritem{void xsb\_set\_var\_int((int) Val, (int) N)} 
\index{{\tt xsb\_set\_var\_int}}
    {\tt set\_and\_int} sets the {\tt N}$^{th}$ field in the return
structure to the integer value {\tt Val}.  It is used to set the value of
the {\tt N}$^{th}$ variable in a query before calling {\tt xsb\_query} or
{\tt xsb\_query\_string}.  When called in \ourprolog, the query will
have the {\tt N}$^{th}$ variable set to this value.

\ouritem{void xsb\_set\_var\_string((char *) Val, (int) N)} 
\index{{\tt xsb\_set\_var\_string}}
    {\tt set\_and\_string} sets the {\tt N}$^{th}$ field in the return
structure to the atom with name {\tt Val}.  It is used to set the
value of the {\tt N}$^{th}$ variable in a query before calling {\tt
xsb\_query} or {\tt xsb\_query\_string}.  When called in \ourprolog,
the query will have the {\tt N}$^{th}$ variable set to this value.

\ouritem{void xsb\_set\_var\_float((float) Val, (int) N)} 
\index{{\tt xsb\_set\_var\_float}}
    {\tt set\_and\_float} sets the {\tt N}$^{th}$ field in the return
structure to the floating point number with value {\tt Val}.  It is
used to set the value of the {\tt N}$^{th}$ variable in a query before
calling {\tt xsb\_query} or {\tt xsb\_query\_string}.  When called in
\ourprolog, the query will have the {\tt N}$^{th}$ variable set to this
value.

\ouritem{void xsb\_var\_int((int) N)} \index{{\tt xsb\_var\_int}}
    {\tt xsb\_var\_int} is called after {\tt xsb\_query} or {\tt
xsb\_query\_string} returns an answer.  It returns the value of the
{\tt N}$^{th}$ variable in the query as set in the returned answer.
This variable must have an integer value.

\ouritem{void xsb\_var\_string((int) N)} \index{{\tt xsb\_var\_string}}
    {\tt xsb\_var\_string} is called after {\tt xsb\_query} or {\tt
xsb\_query\_string} returns an answer.  It returns the value of the
{\tt N}$^{th}$ variable in the query as set in the returned answer.
This variable must have an atom value.

\ouritem{void xsb\_var\_float((int) N)} \index{{\tt xsb\_var\_float}}
    {\tt xsb\_var\_float} is called after {\tt xsb\_query} or {\tt
xsb\_query\_string} returns an answer.  It returns the value of the
{\tt N}$^{th}$ variable in the query as set in the returned answer.
This variable must have an floating point value.


\end{description}


\section{Creating an XSB Module that Can be Called from C}

To create an executable that includes calls to the above C functions,
these routines, and the \ourprolog\ routines that they call, must be
included in the link ({\tt ld}) step.

\paragraph{Unix instructions:}
First, you must create a relocatable file, named {\tt xsb.o}, that
contains all the \ourprolog\ routines.  To do this, get into the
{\tt XSB/build} subdirectory, and execute:
%%
\begin{verbatim}
    % makexsb module
\end{verbatim}
%%
This will place the relocatable file in:
%%
\begin{verbatim}
 $XSB_DIR/config/<your-system-architecture>/saved.o/xsb.o  
\end{verbatim}
%%$

Second, you must compile your C program, which includes a main
procedure.  You should include the file {\tt cinterf.h} located in the
{\tt XSB/emu} subdirectory, which defines the routines described here
that you will need to use.

Third, to create your executable, after you have created the object
file, say {\tt ruleproc.o}, for your C routine, you could execute:
\begin{verbatim}
    % gcc -o ruleproc ruleproc.o $XSB_DIR/config/<your-system-architecture>/saved.o/xsb.o
\end{verbatim}

The file {\tt \$XSB\_DIR/config/your-system-architecture/modMakefile} is a
makefile you can use to build your programs and link them with XSB.  It is
generated automatically and contains all the right settings for your
architecture, but you will have to fill in the name of your program, etc.

There are simple examples of C programs calling \ourprolog\ in the
{\tt \$XSB\_DIR/examples/c\_calling\_XSB} directory, in files {\tt cmain.c},
{\tt ctest.P}, {\tt cmain2.c}.

\paragraph{Windows instructions:}
To call XSB from C, you must build it as a DLL. To do this, you specify
DLL=''yes'' on command line. {\it E.g.}, 
%%
\begin{quote}
 {\tt NMAKE /f "MS\_VC\_Mfile.mak" CFG="release" DLL="yes"  }
\end{quote}
%%
The DLL, which you can call dynamically from your program is then found in 
%%
\[
 \tt
 \$XSB\_DIR\backslash config\backslash \mbox{\tt x86-pc-windows}\backslash
 saved.o \backslash xsb.dll
\]
%%


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual2"
%%% End: 
