\chapter{Debugging} \label{debugging}
%====================================
\index{debugger}

\section{High-Level Tracing}
%===========================
\index{high-level tracing}
\index{tracing!high-level}

\ourprolog\ supports a version of the Byrd four-port debugger for debugging
Prolog code.  In this release (\version), it does not work very well
when debugging code involving tabled predicates.  If one only creeps
(see below), the tracing can provide some useful information.  We do
intend that future versions will have more complete debugging help for
tabled evaluation.

To turn on tracing, use {\tt trace/0}.  To turn tracing off, use 
{\tt notrace/0}.  When tracing is on, the system will print a message each
time a predicate is:
\begin{enumerate} \index{debugger!ports}
\item initially entered (Call), 
\item successfully returned from (Exit), 
\item failed back into (Redo), and
\item completely failed out of (Fail).  
\end{enumerate}
At each port, a message is printed and the tracer stops and prompts
for input.  (See the predicates {\tt show/1} and {\tt leash/1} described
below to modify what is traced and when the user is prompted.)

In addition to single-step tracing, the user can set spy points to influence
how the tracing/debugging works.  A spy point is set using {\tt spy/1}.
Spy points can be used to cause the system to enter the tracer when
a particular predicate is entered. Also the tracer allows ``leaping'' from
spy point to spy point during the debugging process.

When the tracer prompts for input, the user may enter a return, or a single
character followed by a return, with the following meanings:
\index{trace!options}
\begin{description}
\item[{\tt c, <CR>}: Creep]
    Causes the system to single-step to the next port
    (i.e.\ either the entry to a traced predicate called by the executed clause,
    or the success or failure exit from that clause).
\item[{\tt a}: Abort]\index{abort!trace facility}
    Causes execution to abort and control to return to the top level
    interpreter.
\item[{\tt b}: Break]
    Calls the evaluable predicate {\em break}, thus invoking recursively
    a new incarnation of the system interpreter.
    The command prompt at break level $n$ is
    \begin{center}
    {\tt $n$: \tt ?-}
    \end{center}
    The user may return to the previous break level by entering the system
    end-of-file character (e.g.\ {\tt ctrl-D}), or typing in the atom 
    {\tt end\_of\_file}; or to the top level interpreter by typing in
    {\tt abort}.
\item[{\tt f}: Fail] Causes execution to fail, thus transferring control to
    the Fail port of the current execution.
\item[{\tt h}: Help] Displays the table of debugging options.
\item[{\tt l}: Leap] Causes the system to resume running the program,
    only stopping when a spy-point is reached or the program terminates.
    This allows the user to follow the execution at a higher level than
    exhaustive tracing.
\item[{\tt n}: Nodebug] Turns off debug mode.
\item[{\tt q}: Quasi-skip] This is like Skip except that it does not mask
    out spy points.
\item[{\tt r}: Retry (fail)] Transfers to the Call port of the current goal.
    Note, however, that side effects, such as database modifications etc.,
    are not undone.
\item[{\tt s}: Skip] Causes tracing to be turned off for the entire execution
    of the procedure.  Thus, nothing is seen until control comes back to that
    procedure, either at the Success or the Failure port.
\item[{\tt e}: Exit] Causes immediate exit from \ourprolog\ back to the
    operating system.
\end{description}

Other standard predicates that are useful in debugging are:

\begin{description}
\ouritem{spy(Preds)} \index{{\tt spy/1}}
%\predindex{spy/1~(L)}
    where {\tt Preds} is a spy specification or a list of such
    specifications, and must be instantiated. This predicate sets spy
    points (conditional or unconditional) on predicates.  A spy
    specification can be of several forms. Most simply, it is a term
    of the form $P$/$N$, where $P$ is a predicate name and $N$ its
    arity.  Optionally, only a predicate name can be provided, in
    which case it refers to all predicates of any arity currently
    defined in {\tt usermod}.  It may optionally may be prefixed by a
    module name, e.g.  $ModName$:$P$/$N$. (Again, if the arity is
    omitted, the specifaction refers to all predicates of any arity
    with the given name currently defined in the given module.)  A spy
    specification may also indicate a conditional spy point. A
    conditional spy specification is a Prolog rule, the head
    indicating the predicate to spy, and the body indicating
    conditions under which to spy. For example, to spy the predicate
    p/2 when the first argument is not a variable, one would write:
    $spy (p(X,\_):-nonvar(X)).$ (Notice that the parentheses around
    the rule are necessary). The body may be empty, i.e., the rule may
    just be a fact.  The head of a rule may also be prefixed (using
    $:$) with a module name. One should not put both conditional and
    unconditional spy points on the same predicate.

\ouritem{nospy(Preds)} \index{{\tt nospy/1}}
%\predindex{nospy/1~(L)}
    where {\tt Preds} is a spy specification, or a list of such
    specifications, and must be instantiated at the time of call.  What
    constitutes a spy specification is described above under {\tt spy}.
    {\tt nospy} removes spy points on the specified predicates. If a
    specification is given in the form of a fact, all conditional spy points
    whose heads match that fact are removed.

\ouritem{debug} \index{{\tt debug/0}} 
%\predindex{debug/0~(L)}
    Turns on debugging mode.
    This causes subsequent execution of predicates with trace or spy
    points to be traced, and is a no-op if there are no such predicates.
    The predicates {\tt trace/1} and {\tt spy/1} cause debugging mode
    to be turned on automatically.

\ouritem{nodebug} \index{{\tt nodebug/0}}
%\predindex{nodebug/0~(L)}
    Turns off debugging mode.  This causes trace and spy points to be ignored.

\ouritem{debugging} \index{{\tt debugging/0}}
%\predindex{debugging/0~(L)}
    Displays information about whether debug mode is on or not, and lists
    predicates that have trace points or spy points set on them.

\ouritem{show(PortList)} \index{{\tt show/1}}
%\predindex{show/1~(L)}
    Allows the user to specify at which ports should trace messages be
    printed. {\tt PortList} must be a list of port names, i.e., a sublist
    of ['Call', 'Exit', 'Redo', 'Fail']. {\tt show/1} is not a standard
    predicate but must be imported from the module {\tt debugger} before
    it can be called.

\ouritem{leash(PortList)} \index{{\tt leash/1}}
%\predindex{leash/1~(L)}
    Allows the user to specify at which ports the tracer should stop
    and prompt the user for direction.  {\tt PortList} must be a list of
    port names, i.e., a sublist of ['Call', 'Exit', 'Redo', 'Fail'].  Only
    ports that are {\tt show}-n can be {\tt leash}-ed.  {\tt leash/1} is
    not a standard predicate but must be imported from the module {\tt
    debugger} before it can be called.
\end{description}


\section{Low-Level Tracing}
%--------------------------------------------------
\index{low-level tracing} \index{tracing!low-level}

\ourprolog\ also provides a facility for low-level tracing of execution.
This can be activated by invoking the emulator with the {\tt -T} option
(see section~\ref{emulator_options}), or through the predicate {\tt trace/0}.
\index{\$trace/0} %\predindex{\$trace/0~(L)}
It causes trace information to be printed out at every call (including
those to system trap handlers).  The volume of such trace information
can very become large very quickly, so this method of tracing is not
recommended in general.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual"
%%% End: 
