%-----------------------------------------------------------------------------

\section{Inspecting a Tabled Derivation} \label{sec:suspend-analyze}

As described in the previous section, Forest Logging~\cite{Swif14b} is
a powerful technique for understanding the operational aspects of a
tabled derivation, and is based on the idea that a derivation is
itself a mathematical entity that can be represented and analyzed.
This basis allows Forest Logging to support various types of analysis
including profiling the derivation, and understanding its its
termination properties~\cite{LiaK13,LiaK13a}.  At the same time,
Forest Logging may not always be convenient to use.  Since it is a
trace-based analysis a (sometimes very large) trace file must be
created and loaded before being analyzed.

An alternate approach is to use {\em inspection predicates} -- a term
that loosely includes predicates useful for understanding a tabled
derivation.  Most of these predicates can be used in two ways.  First,
they can inspect on-going derivation that has been suspended through
various means.  Alternately, they may be used to retroatively inspect
a derivation that has completed.  In this section, we first describe
two important sets of interactive inspection predicates.  First the
{\tt table\_dump} library for inspecting tables
(Section~\ref{sec:table-dump}). (Other, predicates for table
inspection that are generally lower-level are described in
Section~\ref{sec:TablingPredicates}.)  Next we discuss a set of
predicates for inspecting various dependency graphs of a computation
(Section~\ref{sec:dep-graph}.  We then discuss how {\em tripwires} can
automatically suspend a derivation for inspection at a point where the
derivation becomes inefficient (Section~\ref{sec:tripwire}).

\subsection{Inspecting Tables with {\tt table\_dump}} \label{sec:table-dump}

\begin{description}
\ourrepeatmoditem{table\_dump(+Term,+OptionList)}{table\_dump/2}{dump\_table}
%
\ourmoditem{table\_dump(+Stream,\#Term,+OptionList)}{table\_dump/3}{dump\_table}
%
{\tt table\_dump/[2,3]} provides an easy method to view subgoals and
answers that are present in a table.  Given an input {\tt Term}, {\tt
  table\_dump/[2,3]} provides information about all tabled subgoals
that are subsumed by {\tt Term}; if {\tt Term} is a variable,
information is provided about all tables.

The information can be provided at three levels of aggregation, and
the form of the information is determined by the options in {\tt
  OptionsList}.
%
\begin{itemize}
\item If the option {\tt summary(true)} is set, the aggregate sum
  of subgoals and answers that are subsumed by {\tt Term} is
  collected, along with the aggregate sum of calls {\it to} these
  subgoals.  If {\tt Term} is a variable this information is broken
  down by tabled predicates.
%
\begin{itemize}
\item If {\tt details(answers)} is set, a list is collected of every
  tabled subgoal $S$ such that $S$ is subsumed by {\tt Term} along
  with the number of answers for each $S$ along with a list of those
  answers and the truth value of each answer ({\tt t} if true and {\tt
    u} if undefined).  If {\tt Term} is a variable this information is
  broken down by tabled predicates.
%
\item If {\tt details(subgoals)} is set, a list is collected of all
  subgoals $S$ such that $S$ is subsumed by {\tt Term} along with the
  number of answers for each $S$.  However, unlike the action for {\tt
    details(answers)} the actual list of answers for $S$ is not
  returned.  If {\tt Term} is a variable this information is broken
  down by tabled predicates.
%
\item If {\tt details(false)} is set, no detail information is
  provided for the actual subgoals or their answers.
\end{itemize}
%
\item If {\tt OptionsList} contains the option {\tt results(X)} for
  some variable {\tt X}, {\tt X} will be instantiated upon
  backtracking to all infomation collected about the tables.
%
\item If the option {\tt output(true)} is set, the information is
  written to {\tt Stream} or to {\tt userout} in Prolog-readable form.
\end{itemize}
%
If not otherwise specified the default options are {\tt
  summary(true)}, {\tt details(false)}, {\tt output(true)}.

{\bf Example}  Consider the program:
\begin{verbatim}
:- table p/2.
p(1,a).
p(1,b) :- p(2,b).
p(2,b) :- p(1,a).
p(3,X) :- q(X).

:- table q/1.
q(1).              q(2).

:- table r/1.
r(a).

:- table s/2.
s(1,a).            s(2,b).           s(1,a1).            s(2,b1).
\end{verbatim}
and suppose the top-level query {\tt ?- p(X,Y)} has been made.  Then
{\tt table\_dump/2} provides the following information {\bf
 (reformatted for readability)}:
%
{\small
\begin{verbatim}
| ?- table_dump(_X,[summary(true)]).

summary = p(A,B) - subgoals(3) - total_times_called(4) - total_answers(7)

X = p(_h243,_h244);

summary = q(A) - subgoals(1) - total_times_called(1) - total_answers(2).

X = q(_h228)

yes
| ?- table_dump(_X,[details(answers)]).

summary = p(A,B) - subgoals(3) - total_times_called(4) - total_answers(7).
details = p(A,B) - subgoals(3) - details([
    p(C,D) - times_called(1) - answers(5) - [p(3,1)-t,p(3,2)-t,p(2,b)-t,p(1,b)-t,p(1,a)-t] 
                                          - completed,
    p(1,a) - times_called(2) - answers(1) - [p(1,a)-t]                         - completed,
    p(2,b) - times_called(1) - answers(1) - [p(2,b)-t]                         - completed]).

X = p(_h232,_h233);

summary = q(A) - subgoals(1) - total_times_called(1) - total_answers(2).
details = q(A) - subgoals(1) - details([
     q(B) - times_called(1) - answers(2) - [q(2)-t,q(1)-t] - completed]).

X = q(_h232)

yes
\end{verbatim}
}

As the above example shows, each line of the summary has the form:

\begin{tabbing}
fooo\=foo\=foo\=foo\=fooooooooooooooooooooooooooooooo\=ooooooooooooo\=\kill
%
{\em   summary = } \\
\> {\em Pred/Goal  - subgoals($N_{subgoals}$) - total\_times\_called($N_{called}$) - total\_answers($N_{answers}$)}
%
\end{tabbing}
where 
\bi
\item $Pred/Goal$ is either a term indicator, if the {\tt Term}
  argument of {\tt table\_dump/[2,3]} was a variable (to indicate there
  should be no filtering of tabled calls); or {\tt Term} itself.
%
\item $N_{subgoals}$ are the total number tabled subgoals that are
  subsumed by $Pred/Goal$ (perhaps including $Pred/Goal$ itself).
%
\item $N_{called}$ is the total number of times all subgoals subsumed
  by $Pred/Goal$ have been called.
%
\item $N_{answers}$ is the total number of answers currently derived
  by all subgoals subsumed by $Pred/Goal$.
\ei

Each line of details has the form:

\begin{tabbing}
fooo\=foo\=foo\=foo\=fooooooooooooooooooooooooooooooo\=ooooooooooooo\=\kill
%
{\em   Details = } \\
\> {\em Pred/Goal  - subgoals($N_{subgoals}$) - details(List)}
%
\end{tabbing}
%
where {\em Pred/Goal} and $N_{subgoals}$ are as above.  If {\tt
  details(answers)} was an input option
%
\begin{tabbing}
fooo\=foo\=foo\=foo\=fooooooooooooooooooooooooooooooo\=ooooooooooooo\=\kill
%
{\em List = }\\
\>  {\em Subgoal - times\_called($N_{called}$) - answers($N_{answers}$) - List\_of\_Answers - Status}
%
\end{tabbing}
%
for each $Subgoal$ in the table subsumed by $Pred/Goal$.  $N_{called}$
and $N_{answers}$ are as above, while {\em List\_of\_Answers} contains
$A-TV$ for each answer $A$ with truth value $TV$ that is currently
derived for $Subgoal$.  On the other hand, if {\tt details(subgoals)}
was an input option
\begin{tabbing}
fooo\=foo\=foo\=foo\=fooooooooooooooooooooooooooooooo\=ooooooooooooo\=\kill
%
{\em List = }\\
\>  {\em Subgoal - times\_called($N_{called}$) - answers($N_{answers}$) - Status}
%
\end{tabbing}
%
where all elements are as before.  Finally $Status$ is
%
\bi
\item {\tt completed} if $Subgoal$ has been completed; and
%
\item {\tt scc($N_{SCC}$}) if $Subgoal$ is incomplete.  $N_{SCC}$ is
  relative: if $N_{SCC}$ is greater than $M_{SCC}$ then $N_{SCC}$ is a
  descendent of $M_{SCC}$: i.e., subgoals in SCC $M_{SCC}$ depend on
  subgoals in SCC $N_{SCC}$.  However, these numbers should only be
  used relatively: at a given state in the computation there may be
  fewer than $M_{SCC}$ Sccs~\footnote{XSB keeps track of SCCs through
    an algorithm similar to depth-first search: the numbers associated
    with subgoals are the depth-first numbers of the minimal
    back-dependency of a subgoal (cf.~\cite{SaSw98})}.
\ei


{\bf Error Cases}
\bi
\item {\tt OptionList} is a variable, or contains a variable as an element
\bi
\item {\tt instantiation\_error}
\ei
\item {\tt OptionList} is not a list
\bi
\item {\tt type\_error(list,OptionList)}
\ei
\item {\tt OptionList} contains an element, {\tt O}, that is not a
  valid {\tt table\_dump\_option}.
\bi
\item {\tt domain\_error(table\_dump\_option,O)}
\ei
\ei
\end{description}

\subsection{Inspection Predicates for Dependency Graphs} \label{sec:dep-graph}

Recall that Forest Logging is based on a representation of the tabling
operations of an entire SLG evaluation, even those for completed
tables.  Maintaining such information within XSB's engine would be
prohibitively expensive, which is why Forest Logging needs a trace.
Nonetheless, XSB's engine does maintain certain information that
indicates critical aspects of a tabled derivation.  As discussed in
the previous section, the tables themselves can be viewed and can
offer useful information.  However, the tables don't provide
information about how the different subgoals depend on one another, an
aspect that is often central to optimizing a derivation.  

However, such dependency information is available in some cases.  For
incremental tables, dependencies among subgoals may be obtained
through the Incremental Dependency Graph (IDG).  In addition, XSB
maintains extra information about the dependencies among incomplete
subgoals, and this information can be viewed through the Subgoal
Dependency Graph (SDG).\footnote{Maintenance of the Subgoal Dependency
  Graph is in fact necessary to ensure that all appropriate answers
  are returned to each incomplete subgoal.}  As an separate matter, it
can be difficult to understand why certain atoms are undefined from
looking directly at the tables.  For this, the Residual Dependency
Graph (RDG) can be inspected.

In this section we first present an adjacency list format for
representing dependency graphs in Porlog.  We then consider predicates
for containing information about each type of dependency graph.  As
dependency graphs may be too large for humans to productively read, we
also present predicates that allow filtering, manipulation and summary
of these graphs.

\subsubsection{A Prolog Format for Dependency Graphs} \label{sec: adjacency-lists}

Several of the inspection predicates produce a dependency graph in Prolog
in the format of adjacency lists.  THis format also annotates
information abut each subgoal.  Specifically, an adjacency list as
used here is a list of terms of the form:

{\tt subgoal(Subgoal,SCCIndex,TableEntryHandle,CallsTo,Answers,PosEdges,NegEdges)} 

such that:

\bi
\item {\tt Subgoal} is a subgoal (or atom) in the current state of 
  dependency graph.
\item {\tt SCCIndex} is an index of the SCC to which the subgoal
  belongs.  
%For local evaluation, if $SCCIndex_1 < SCCIndex_2$, then
%  subgoals in $SCCIndxex_2$ affect subgoals in $SCCIndex_1$ (although
%  the affects relation may not be direct).
\item {\tt TableEntryHandle} either 
  \bi
  \item An integer value that represents the handle to the table
    entry, and uniquely identifies {\tt Subgoal}; or 
  \item An atom that represents a unique key for the node of the
    dependency graph, if a morphism has been applied to the dependency graph.
\ei
\item {\tt CallsTo} is the number of calls that have been made to the
  subgoal so far.  
\item {\tt Answers} is the number of distinct answers that {\tt
  Subgoal} has so far.~\footnote{If the same answer was derived more
  than once, it is counted only one time.}
\item {\tt PosEdges} is a list of table entry handles for subgoals
  that {\tt Subgoal} positively directly affects.  In the case of
  dependency graphs that do not have signed edges, all edge
  information is kept in this argument.
\item {\tt NegEdges} is a list of table entry handles for subgoals
  that {\tt Subgoal} negatively directly affects.  In the case of
  dependency graphs that do not have signed edges, no edge information
  is kept in this argument.  \ei

\subsubsection{Predicates to Access the Subgoal Dependency Graph}

The Subgoal Dependency Graph (SDG) has as vertices those tabled
subgoals that are incomplete in the state of a suspended derivation.
A {\em depends} edge exists from $S_1$ to $S_2$ iff a
call is made to $S_2$ while answers for $S_1$, and if there are no
intervening tabled subgoals between $S_1$ and $S_2$.  An {\em affects}
edge is the inverse of a depends edge.  Edges in the SDG are signed
indicating positve or negative dependence.  A subgoal and its incident
edges are removed from the SDG when the subgoal is completed.

The main predicate for accessing information about the SDG is {\tt
  get\_sdg\_info/1}.  Note that {\tt get\_sdg\_info/1} returns
information concerning incomplete subgoals {\em only}.

\begin{description}
\ourmoditem{get\_sdg\_info(-SDG)}{get\_sdg\_info/1}{tables}
%
For a suspended derivation, returns information about the {\em
  Subgoal Dependency Graph} (SDG) as an adjacency list whose form is
described in Section~\ref{sec: adjacency-lists}.

If there are no incomplete tables in the current state, an empty list
is returned.

This predicate has no error conditions.

\begin{example} \rm \label{ex:get-sdg}
Consider the goal {\tt ?- q(3,3)} to the program:

\begin{verbatim}
:- import get_sdg_info/1 from tables.
:- import between/3 from basics.

:- table q/2 as incremental.
q(M,N):- between(1,N,X),
         (M = N,N = X -> break ; true),q(X,N).
\end{verbatim}
Execution of this query creates a number of tabled subgoals, but
breaks before the initial goal is completely evaluated.  The SDG at
the time of the break is shown in Figure~\ref{fig:sdg-break-1}

\begin{figure}[htbp]
\centering
\includegraphics[width=.4\textwidth]{sdg-q-2}
%%\mbox{
%%{\epsfig{file=slg-forest-local,width=.99\textwidth}}}
\caption{SDG for {\tt ?- q(3,3)} when the derivation is suspended by
  {\tt break/0}} \label{fig:sdg-break-1}
\end{figure}
%
This SDG can be produced as follows:
\begin{small}
\begin{verbatim}
| ?- q(3,3).
[ Break (level 1) ]

1: ?- get_sdg_info(F).

F = [subgoal(q(2,3),1,140253373671912,3,0,
             [140253373671672,140253373671792,140253373671912],[]),
     subgoal(q(1,3),1,140253373671792,3,0,
             [140253373671792,140253373671672,140253373671912],[]),
     subgoal(q(3,3),1,140253373671672,3,0,
             [140253373671912,140253373671792],[])]
\end{verbatim}
\end{small}

\end{example}

\end{description}

\subsubsection{Predicates to Access the Incremental Dependency Graph}

The Incremental Dependency Graph (IDG) is used by XSB's incremental
tabling subsystems to ensure that tables that depend on dynamic facts
or rules are properly updated when the underlying dynamic code
changes.

The Incremental Dependency Graph (IDG) has as vertices those subgoals
whose predicate symbols are incrementally tabled, along with calls to
dynamic predicates that are declared as incremental.  A {\em depends}
edge exists from $S_1$ to $S_2$ iff a call is made to $S_2$ while
answers for $S_1$, and if there are no intervening tabled subgoals
between $S_1$ and $S_2$.  An {\em affects} edge is the inverse of a
depends edge.  Edges in the IDG are unsigned.  XSB maintains both
completed and incomplete subgoals in the IDG. (As long as the tables
for these subgoals are not abolished.)

\begin{description}
\ourmoditem{get\_idg\_info(-SDG)}{get\_idg\_info/1}{tables}
%
Returns information about the {\em Incremental Dependency Graph} (IDG)
as an adjacency list whose form is described in Section~\ref{sec:
  adjacency-lists}.
\end{description}

\subsubsection{Predicates to Access the Residual Dependency Graph}

The Residual Dependency Graph (RDG) has as vertices those answer
  atoms whose truth value is {\em undefined} in the state of a
  suspended computation.  A {\em depends} edge exists from $A_1$ to
  $A_2$ iff $S_2$ is a delay literal in a conditional answer for
  $S_1$.  Edges in the RDG are signed indicating positve or negative
  dependence.  An atom $A$ and its incident edges are removed from the
  RDG when the truth value of $A$ changes.\footnote{The truth value of
    an atom may change when a suspended state is further evaluated.
    It may also change for completed subgoals when the {\sc answer
      completion} operation is performed.}

\begin{description}
\index{residual program}
\index{\texttt{get\_residual/2}}
\index{\texttt{variant\_get\_residual/2}}
\index{Incremental Dependency Graph (IDG)}
\index{residual dependency graph}
\ourmoditem{get\_rdg\_info(-SDG)}{get\_rdg\_info/1}{tables}
%
Returns information about the {\em Residual Dependency Graph} (RDG) as
an adjacency list whose form is described in Section~\ref{sec:
  adjacency-lists}.

\ourrepeatmoditem{get\_residual\_sccs(+Subgoal,+Answer,-SCCList)}{get\_residual\_sccs/3}{tables}
\ourmoditem{get\_residual\_sccs(+Subgoal,+Answer,-SCCList,-DepList,-SignList)}{get\_residual\_sccs/5}{tables}
%
As discussed in Section~\ref{sec:non-strat}, answers that are
undefined in the well-founded semantics are stored in XSB along with
their delay lists, forming a residual program.  This residual program
can be materialized through the various predicates discussed above, in
particular {\tt get\_residual/2} and {\tt variant\_get\_residual/2}.

At times it can be useful to view the residual program as a directed
graph, for instance in order to understand why a given answer might be
undefined.  In a manner somewhat analogous to the incremental
dependency graph (Section ~\ref{sec:incremental_tabling}) the {\em
  residual dependency graph} is a directed graph whose nodes are
subgoal/atom pairs and whose edges are labelled with: 1) a sign
indicating whether the edge is positive or negative; and 2) the label
{\em depends on} or {\em affects}.

\begin{example} \rm
Consider the program 
% 
{\tt 
\begin{tabbing}
fooo\=fooooooooooooooooooooooooooooooo\=ooooooooooooo\=\kill
 \>  :- table p/2. \\
\>           p(1,2). \\
\>           p(1,3):- tnot(p(2,3)).  \\
\>           p(2,3):- tnot(p(1,3)). \> p(2,3):- r(a).\\
\>           r(a):- tnot(r(b)) \\
\>           r(b):- tnot(r(a)).   
\end{tabbing}
}
%
to which the query {?- p(1,X)} was made, generating the tables:
\begin{center}
\begin{tabular}{||l|l||}   \hline
     {\em Subgoal}                 & {\em Answers} \\ \hline \hline
     p(1,X)                     & p(1,2) \\ 
                                & p(1,3):- tnot(p(2,3))| \\ \hline
     p(1,3)                     & p(1,3):- tnot(p(2,3))| \\ \hline
     p(2,3)                     & p(2,3):- tnot(p(1,3))| \\ \hline
                                & p(2,3):- tnot(r(a))| \\ \hline
     r(a)                       & r(a):- tnot(r(b))| \\ \hline
     r(b)                       & r(b):- tnot(r(a))| \\ \hline
\end{tabular}
\end{center}

The residual dependency graph for this program and query would have a
node for each subgoal/answer combination with an undefined truth
value, and a dependency edge for nodes $S_1/A_1$ and $S_2/A_2$ if
$A_2$ occurs in a literal in the delay list for $S_1/A_1$, and the
original subgoal for $A_2$ was $S_2$ in the subcomputation for $S_1$.
The edge also has a sign indicating whether $A_2$ occurs positively or
negatively in the delay list for $A_1$.  In this example, the residual
dependency graph could be represented as 
%
\begin{verbatim}
     depends_on(p(1,X),p(1,3),p(2,3),p(2,3),neg).
     depends_on(p(1,3),p(1,3),p(2,3),p(2,3),neg).
     depends_on(p(2,3),p(2,3),p(1,3),p(1,3),neg).
     depends_on(p(2,3),p(2,3),r(a),r(a),pos).
     depends_on(r(a),r(a),r(b),r(b),neg).
     depends_on(r(b),r(b),r(a),r(a),neg).
\end{verbatim}
\end{example}

\index{termination!radial restraint} 
\index{\texttt{u\_not/1}} 
%
Using the residual dependency graph, a user may be able to determine
why an answer $A$ to a subgoal $S$ was unexpectedly undefined either
because $S/A$ was involved in or depended on a loop through negation;
or because $S/A$ depended on some other answer that was undefined
because of the use of bounded rationality
(Section~\ref{sec:tabling-termination}) or because of floundering and
the use of {\tt u\_not/1}.  

The residual dependency graph can be constructed in a straightforward
way from {\tt variant\_get\_residual/2}.  {\tt
  get\_residual\_sccs/[3,5]} provides an alternate view that is
slightly higher-level and much faster.  Given a subgoal/answer pair as
input, each of these predicates constructs SCC-based information about
the residual dependency graph via structures of the form:
%
\begin{center}
{\tt ret(Subgoal,Answer,SCCIndex)}.
\end{center}
%
where {\tt SCC} is a numerical index for the SCCs of Subgoal. Two
subgoals are in the same SCC iff they have the same index, however no
other dependency information can be otherwise directly inferred from
the index~\footnote{The actual number for
  each SCC index depends on how the residual dependency graph happens
  to be traversed; as a result it is best to rely on the index only as
  a ``generated'' name for each SCC.}.

To obtain dependency information, {\tt get\_residual\_sccs/5} also returns a
list indicating the direct dependencies among the SCCs, along with a
list indicating whether given SCCs contain a negative edge.  For the
example above, the SCC information would have a form such as:
\begin{verbatim}
[ ret(p(1,X),p(1,3),1), ret(p(1,3),p(1,3),2), ret(p(2,3),p(2,3),2),
  ret(r(a),r(a),3), ret(r(b),r(b),3) ]
\end{verbatim}
%
The dependency list would have a form such as:
\begin{verbatim}
[ depends(1,2), depends(2,3) ]
\end{verbatim}
while the sign list would have a form such as:
\begin{verbatim}
[ sign(1,no_neg), sign(2,neg), sign(3,neg) ]
\end{verbatim}
If it is necessary to know which subgoal(s) in {\tt SCC1} directly
depends on which subgoal(s) in {\tt SCC2}, the information can be
easily reconstructed from the output of {\tt
  get\_residual\_sccs/[4,5]} using {\tt variant\_get\_residual/2}.  A
similar approach can be used to determine the actual edges within a
given SCC.

SCC detection is implemented using Tarjan's algorithm~\cite{Tarj72} in
C working directly on XSB's data structures.  The algorithm is
$\cO(|V| + |E|)$ where $|V|$ is the number of vertices and $|E|$ the
number of edges in the dependency graph.  As a result, {\tt
  get\_residual\_sccs/3} provides an efficient means to materialize
the high-level topography of the dependency graph~\footnote{Currently,
  the materialization of dependency information between SCCs is
  implemented in a naive manner, so that {\tt get\_residual\_sccs/6}
  is $\cO(|V|^2)$.}.

%These predicates implement Tarjan's algorithm~\cite{Tarj72} in C
%working directly on XSB's data structures.  The algorithm is $\cO(|V|
%+ |E|)$ where $|V|$ is the number of vertices and $|E|$ the number of
%edges in the dependency graph.  As a result, these predicates provide
%an efficient means to materialize the dependency graph, even if SCC
%information per se is not required
  
\index{radial restraint}
\index{termination!radial restraint}
\index{\texttt{u\_not/1}}
\index{\texttt{get\_residual\_sccs/5}}
\ourrepeatmoditem{explain\_u\_val(+Subgoal,+Answer,-Reason)}{explain\_u\_val/3}{tables}	
\ourmoditem{explain\_u\_val(+Subgoal,+Answer,-Sccs,-Deps,-Signs,-Reason)}{explain\_u\_val/6}{tables}	
%
The XSB predicate
%
{\tt explain\_u\_val(+Subgoal,+Answer,?Reason)}
\noindent
can be used to query why {\tt Answer} is undefined when derived in an
evaluation of {\tt Subgoal}.  {\tt Reason} may be
\begin{itemize}
\item {\tt negative\_loops(cycle)} if the derivation of {\tt Answer} involves a
  loop through though negation that includes {\tt Answer} itself.
%
\item {\tt negative\_loops(dependent)} if the derivation of {\tt
  Answer} depends on an atom that is involved in a loop through though
  negation.
%
\item {\tt unsafe\_negation} if the derivation of {\tt Answer} depends
  on a negative subgoal that is non-ground (XSB does not automatically
  perform subgoal reordering).  The action of making a non-ground
  subgoal undefined is performed by {\tt u\_not/1}.
%
\item {\tt bounded\_rationality} if the derivation of answer depends
  on bounded rationality based on radial restraint~\cite{GroS13}.
\end{itemize}
%
These reasons are not exclusive, and complex derivations may well
involve several of the above reasons.

{\tt explain\_u\_val/[3,6]} is based on the structures returned by
{\tt get\_residual\_sccs/[3,5]}.  While {\tt
  get\_residual\_sccs/[3,5]} is reasonably fast, it can take a
peceptable time to analyze large residual programs containing many
thousands of SCCs.  Accordingly, {\tt explain\_u\_val/6} can reuse
dependency structures returned by {\tt get\_residual\_sccs/[3,5]},
which can be useful for justification systems and other applciations.

\begin{example} \rm
After executing the query {\tt p} to the program
%
\begin{verbatim}
:- table p/0, q/0, r/0, s/1.
p:- q,tnot p.                 p:- s(f(f(f(f(0))))).

q:- tnot r.                   r:- tnot q.

s(f(X)):- s(X).               s(0).
\end{verbatim}
%
where the bounded rationality depth has been set to 3.  The query {\tt
  explain\_u\_value(p,P,Reason)} will bind {\tt Reason} to {\tt
  negative\_loops(cycle)}, to {\tt negative\_loops(dependent)}, and
to {\tt bounded\_rationality} (this ordering is not guaranteed).
\end{example}
\end{description}

\subsubsection{Filtering, Manipulating, and Summarizing Information About Dependency Graphs} \label{sec:dependency-graph-manipulation}

\begin{description}
\item  \ourmoditem{morph\_dep\_graph(+SDGIn,+Morph,-SDGOut)}{morph\_dep\_graph/3}{tables}
%
This predicate takes as input {\tt SDGIn}, an SDG in adjacency list
format and returns its image, {\tt SDGOut}, under the graph
homomorphism {\tt Morph}.  {\tt Morph} is a predicate symbol that
identifies a 2-ary predicate, {\tt Morph(+In,-Out)} that is functional
on {\tt In} and that maps the Herbrand Base of the current program
into itself.  The syntax of {\tt SDGIn} and {\tt SDGOut} are as
described at the beginning of this section.

To recall the definition of a graph homomorphism (cf. e.g.,
~\cite{Hara69}) a functional notation is used for {\tt Morph/2}.  {\tt
  SdgOut} is a graph such that the vertices of {\tt SDGOut},
$vertices({\tt SDGOut})$ is the set:
\[
\{ morph(Subgoal) | Subgoal \in vertices({\tt SDGIn}) \}
\]
while the edges of {\tt SDGOut}, $edges({\tt SDGOut})$ are the sets
\[
\{ \langle morph(Subgoal_1),morph(Subgoal_2) \rangle | \langle Subgoal_1,Subgoal_2 \rangle \in edges({\tt SDGIn}) \}
\]
We adapt this definition to SDGs by mapping all positive adjacenct
edges into a positive set, and negative adjacent edges into a negative
set.

The power of {\tt morph\_dep\_graph/3} arises when the numbers of vertices
and edges of {\tt SdgIn} is large, and {\tt morph/2} ensures that
numbers for {\tt SDG} are much smaller -- thus allowing recognizable
patterns to emerge.  

For efficiency reasons, a special condition, ${\cal C}_1$, is assumed
  about {\tt morph/2}: that if two elements of its range unify, then
  they must be identical.  For instance, a morphism $M_1$ that reduced
  the maximum depth of each non-variable argument of a term by 1 would
  not fit this condition, since $M_1(f(a,g(h(b)))) = f(X_1,g(h(X_2)))$
  while $M_1(f(a,g(b))) = f(X_1,g(X_2))$, which unify.  On the other
  hand, a morphism that abstracts each argument to have a maximal
  fixed depth would fulfill the condition.  In any case, as long as
  ${\cal C}_1$ is observed, {\tt morph/2} may instantiated by an
  abstraction function as used elsewhere in this manual: i.e., a
  function such that $morph(Term)$ subsumes $Term$.  However, other
  morphisms may also be useful as demonstrated in
  Example~\ref{ex:morph-sdg} below.

While the syntax of {\tt SdgOut} is the same as that of {\tt SDGIn},
the meaning of the arguments differs slightly.  {\tt SdgOut} is a
list of terms of the form:

{\tt subgoal(MorphSubg,null,Key,CallsTo,Answers,PosKeyList,NegKeyList)} 

such that 

\bi
\item {\tt MorphSubg} is $morph({\tt Subgoal})$ for one or more subgoals
  that are vertices of {\tt SDGIn}
\item The second argument, which represents SCC information in the
  original SDG, is the atom {\tt null} when a morphism is applied, since SCC
  information is not preserved in general.
\item {\tt Key} is an atom identifying {\tt MorphSubg}.  Note that
  while each subgoal in {\tt SDGIn} corresponds to a tabled subgoal, a
  given subgoal image in {\tt SDGOut} may not correspond to a tabled
  subgoal in the current state.  Thus a table entry handle may not be
  available, so generated keys are used in {\tt SDGOut}.
\item {\tt CallsTo} is the sum of calls to every subgoal $S \in$ {\tt
  SubgIn} such that $morph(S) = {\tt MorphSubg}$.
\item {\tt Answers} is the sum of the number of answers for every
  subgoal $S \in$ {\tt SubgIn} such that $morph(S) = {\tt MorphSubg}$.
\item {\tt PosKeyList} is a list of the keys to those vertices adjacent
  to {\tt MorphSubg} with positive sign as described above.
\item {\tt NegKeyList} is a list of the keys to those vertices adjacent
  to {\tt MorphSubg} with negative sign as described above.
\ei

\begin{example} \rm \label{ex:morph-sdg}
Continuing Example~\ref{ex:get-sdg}, let {\tt mymorph} identify the
predicate

\begin{verbatim}
mymorph(Term,NewTerm):-
        Term =.. [F,A1,A2],
        map_arg_1(A1,NewA1),
        NewTerm =.. [F,NewA1,A2].

map_arg_1(2,1):- !.
map_arg_1(X,X).
\end{verbatim}
Thus {\tt mymorph/2} maps {\tt q(2,1)} to {\tt q(1,1)} and maps
both {\tt q(1,1)} and {\tt q(3,1)} to themselves.  Then if {\tt SdgIn}
is instantiated to the SDG produced in Example~\ref{ex:get-sdg}, the
goal {\tt ?- morph\_dep\_graph(SdgIn,mymorph,SdgOut} would produce:

\begin{verbatim}
SdgOut = [subgoal(morph80,q(1,3),6,0,[morph80,morph81],[]),
          subgoal(morph81,q(3,3),3,0,[morph80],[])
\end{verbatim}
\end{example}

{\bf Error Cases} 
\bi
\item 	{\tt Morph} is not an atom
\bi
\item 	{\tt type\_error}
\ei
%
\item 	{\tt SDGOut} is not a variable
\bi
\item 	{\tt type\_error}
\ei
%
\item 	{\tt SDGIn} is not an adjacency list as described above
\bi
\item 	{\tt misc\_error}
\ei
\ei
%
\item \ourmoditem{dep\_graph\_scc\_info(+SDG,-ListOut)}{dep\_graph\_scc\_info/2}{tables}
%
Given an SDG representation in the adjacency list format described
above, this predicate returns information about the SCCs that are
currently under evaluation.  Upon success {\tt ListOut} will contain a
term

{\tt scc(SCCIndex,NumSubgoals,NumAnswers,NumPosEdges,NumNegEdges)}

for each SCC under evaluation, such that:

\bi
\item {\tt SCCIndex} is the index of the SCC
\item {\tt NumSubgoals} is the number of subgoals in the SCC
\item {\tt NumAnswers} is the total number of answers for all subgoals in the SCC
\item {\tt NumPosEdges} is the total number of positive edges within the SCC.
\item {\tt NumNegEdges} is the total number of negative edges within the SCC.
  \ei
\end{description}

\subsection{Summary: Suspending and Inspecting a Derivation}

Thus, information about a tabled derivation can be inspected in a
number of ways, including directly through the tables, or through one
of the dependency graphs: the IDG, RDG or SDG.  As an overview, the
following predicates can be used for inspection, in a manner that will be
explained below.

Some useful inspection predicates
available in XSB are: 

\begin{itemize} 
\item {\tt statistics/[0,1,2]} (Section~\ref{environmental}) is a
  general-purpose predicate that provides an important summary of how
  memory is used by the XSB process or thread, the amount of time used
  by the process or thread, along with various counts of tabling
  operations and measures of table space.

\item {\tt table\_dump/[2,3]} (Section~\ref{sec:table-dump}) allows
  directed and iterative inspection of the current set of tabled
  subgoals and their answers, at various levels of summary
  aggregation.

\index{Incremental Dependency Graph (IDG)} 
\index{residual program}
\index{residual dependency graph}
\item Inspection of the Incremental Dependency Graph can be made via
  the predicate {\tt get\_idg\_info/[1,2]}\footnote{These predicates
    are not yet implemented: although {\tt tt get\_incr\_sccs/[1,2]},
    and {\tt get\_incr\_sccs\_with\_deps/[2,3]} have been.} together
  with predicates for dependency graph manipulation such as {\tt
    morph\_dep\_graph/3} and {\tt dep\_graph\_scc\_info/3}
  (cf. Section~\ref{sec:dependency-graph-manipulation}).
%
 More targeted inspection of specific edges and dependencies of the
 Incremental Dependency Graph is supported through {\tt
   incr\_directly\_depends/2} and {\tt incr\_trans\_depends/2}
 (cf. Section~\ref{sec:incr-preds1}).

\item Inspection of the Subgoal Dependency Graph can be obtained
  through the predicate {\tt get\_sdg\_info/1}, and its information
  analyzed through predicates for dependency graph manipulation such
  as {\tt morph\_dep\_graph/3}, and {\tt dep\_graph\_scc\_info/2}
  (cf. Section~\ref{sec:dependency-graph-manipulation}).  Note that
  {\tt get\_sdg\_info/1} returns information concerning incomplete 
  subgoals {\em only}.

\item Inspection of the Residual Dependency Graph can be made via the
  predicate {\tt get\_rdg\_info/[1,2]},\footnote{This predicate is not
    yet implemented: although {\tt tt get\_residual\_sccs/[1,2]} has
    been.} together with dependency graph manipulation predicates such
  as {\tt morph\_dep\_graph/3} and {\tt dep\_graph\_scc\_info/3}.
  (cf. Section~\ref{sec:dependency-graph-manipulation}).  The
  predicates {\tt get\_residual/2} and {\tt variant\_get\_residual/2}
  allow the residual program to be viewed as sets of clauses.
s  Finally, {\tt explain\_u\_val/3} can be used to indicate why a given
  atom has the truth value {\em undefined} rather than {\em true} or
  {\em false} (cf. Section~\ref{sec:table-inspection}).
\end{itemize}

Except for {\tt get\_sdg\_info/1}, these predicates can be used to
retrospecitively analyze a completed derivation, but they also can be
used to analyze an onkoging derivation by suspending the derivation
and then examining the computation from a subsidiary command-line
interpreter.  In XSB, a computation can be suspended in several ways,
depending a user's tastes in and needs for debugging:

\bi 
\item By an explicit call to {\tt break/0}.  This is usually best done
  by calling {\tt break/0} as part of a handler for {\tt
    timed\_call/2}, but {\tt break/0} can also be called explicitly
  from a program.
%
\item By hitting ctrl-C while XSB is running in stand-alone mode

\item By setting a {\em tripwire} as introduced below
  (Section~\ref{sec:tripwire}).  
%
\ei

\index{tripwires}
\subsection{Setting Tripwires on Tabled Derivations} \label{sec:tripwire}
%
A tripwire represents an unexpected property of a derivation: such as
an excessive use of time or memory; an unexpected number or complexity
of tabled subgoals or answers; or an unexpected number of mutually
dependent tabled subgoals.  Depending on both the class of a tripwire
and on how runtime settings are given for XSB, a tripwire may have
different effects.  Any tripwire may be treated as an error throwing
an exception just as any other error.  {\em Inspectable} tripwires may
may additionally be considered as inspection points, and when hit may
suspend the derivation and create a break point.~\footnote{Note that
  such a suspension makes available for inspection the state of the
  derivation at the point the tripwire was activated.  If inspection
  points were implemented using ISO errors state could only be made
  available at the point where the error was caught, whose state may
  differ greatly from the point where the error occurred (i.e., where
  the tripwire was hit).}
%
In such a case, a short explanation will be made of how a tripwire was
encountered, along with suggestions about how to further inspect the
suspended derivation.  {\em Correctable} tripwires are a subset of
inspectionable tripwires for which an action may be taken to remedy
the situation, such as rewriting a subgoal or answer whose depth is
more than a given level via subgoal abstraction or answer restraint.


\subsubsection{Tripwires Based on Resource Limits}
%
Hitting a resource tripwire reflects the fact that a derivation is
taking more time or using more memory than expected.  A resource
tripwire is a user-imposed limit, rather than an external limit
imposed by the platform or operating system, and thus differs from an
ISO resource error.

Time-based resource tripwires can easily be programmed directly using
a handler to {\tt timed\_call/2}.  Time-based tripwires are
inspectable, so such a handler might throw an error after a derivation
has taken a certain amount of CPU time, or call {\tt break/0} to
implement periodic inspection points, or implement other periodic
analytics or monitoring.

A memory-based resource tripwire can be set via the Prolog flag {\tt
  max\_memory}, so that an error will be thrown whenever XSB uses more
than a given total amount of memory.  This amount can be set either as
an absolute number of kilobytes or as a percentate of the RAM of the
platform upon which XSB is executing.  Currently, a memory-based
tripwire can only throw an error.

\paragraph{Guidelines for Analysis of Resource-based Tripwires} 
If a resource tripwire is hit, the best course of analysis usually
starts with viewing the output of {\tt statistics/[0,1]}.  
\bi
\item If there are a large number of incomplete tables, XSB's stask
  space is likely to be high also.  In this case, the predicates for
analyzing the Subgoal Dependency Graph of the suspended derivation can
be used (Section~\ref{sec:sdg-preds}).  
\item Otherwise, if the table space seems large, {\tt
  statistics/[0,1,2]} indicates both the number of tabled subgoals and
  the number of answers.  In this case, {\tt table\_dump/[2,3]} can be
  called to provide further information.
\bi
\item If {\tt statistics/[0,1,2]} indicates that incremental tabling
  is being used heavily, {\tt get\_incr\_sccs/[1,2]}, and {\tt
      get\_incr\_sccs\_with\_deps/[2,3]} can be used to obtain a
    global view of the incremental dependency graph.
\item If {\tt statistics/[0,1,2]} indicates that there are a large
  number of answers with truth value {\em undefined} (as indicated by
  a large number of DEs and DLs) {\tt get\_residual\_sccs/[3,5]} can
  be used to understand the dependencies among these answers.
\ei
\ei


\subsubsection{Tripwires Based on Properties of a Tabled Derivation}
%
Theoretically speaking, if a tabled derivation is not terminating it
is because there are an unbounded number of SLG trees, or one or more
of the SLG tress is of unbounded size.  Similarly, terminating but
expensive derivations also may have too many trees, trees that are too
big, or too many dependencies among trees for incomplete subgoals.  We
consider these cases in turn.

\bi
\item {\em There are too many trees (subgoals)} 
\bi
\item {\em There are a potentially unbounded number of trees
  (subgoals)} In this case, there must also be a potentially unbounded
  number of distinct tabled subgoals in the derivation.  If call
  variance is being used, this situation can sometimes be addressed by
  using call subsumption.  However termination can be ensured by using
  subgoal abstraction, as long as a derivation produces only a finite
  number of answers~\cite{RigS14}.  XSB allows subgoal abstraction to
  be declared at a predicate level, based on term depth
  (cf. Section~\ref{sec:tabling-termination}).  In other words, when a
  tabled subgoal, $S_{deep}$, is called whose depth is greater then
  the limit specified for its predicate, a tripwire is activated, and
  various actions can be specified.  In many -- perhaps most -- cases,
  the best action is simply to abstract $S_{deep}$.  However it is
  also possible to suspend and inspect the derivation so that the
  causes that led to $S_{deep}$ can be analyzed.  Alternatively an
  error can be thrown, which may be useful in certain cases.

  {\bf Guidelines for Analysis} If the computation is producing a
  potentially unlimited number of subgoals, this will be likely be
  apparent by investigating the 

\ei

\item Checking for the depth of a subgoal may not catch certain causes
  of inefficency. If a program is written over a language that has a
  large number of constant symbols $n_c$, then a program that
  generates subgoals of the form
\[
   p(c_i,c_j,c_k,X)
\]
  will theoretically terminate, but may be too inefficient for
  practical purposes.  

  To address situations in which a derivation produces too many tabled
  subgoals of whatever form XSB has two further tripwires.
\bi
\item The derivation has a state in which there are a large number of
  incomplete subgoals that do not necessarily occur in the same
  recursive component.  XSB allows a limit to be set on the maximal
  number of incomplete subgoals.  If a derivation exceeds that limit,
  the computation may be suspended, or an error thrown.

\item The derivation has a state in which there is a large number of
  incomplete subgoals in the same recurive component.  XSB allows a
  limit to be set on the maximal number of incomplete subgoals in any
  recursive component.  If a derivation exceeds that limit, the
  computation may be suspended, or an error thrown.  This situation is
  similar to the previous one, but may suggest a different focus when
  analyzing a suspended computation.
\ei
\ei
\bi
\item Alternatively, if a derivation has one or more unbounded SLG
  trees, then it has an infinite number of answers and will not
  terminate.  The approaches to this situation are similar in spirit
  to the cases of an unbounded number of SLG trees.

\bi
\item XSB allows answer abstraction (also called restraint) to be
  declared at a predicate level, based on term depth.  In other words,
  when an answer, $A_{deep}$, is to be added to a table, and its depth
  is greater then the limit specified for its predicate, a tripwire is
  activated, and various actions can be specified.  In most cases, the
  best action is simply to abstract $A_{deep}$, which gives it the
  truth value {\em undefined}. Hoowever it is also possible for the
  derivation to be suspended so that the causes that led to $A_{deep}$
  can be analyzed; alternatively an error can be thrown, which may be
  useful in certain cases.  

\item Checking for the depth of an answer may not catch certain causes
  of inefficency. If a program is written over a language that has a
  large number of constant symbols $n_c$, then a program that
  generates answers of the form
\[
   p(c_i,c_j,c_k,c_l)
\]
  will theoretically terminate, but may be too inefficient for
  practical purposes.  

\ei \ei

