%=====================================================================

\section{Modification of the Database} \label{sec:assert}

XSB provides an array of features for modifying the dynamic database.
Using {\tt assert/1}, clauses can be asserted using first-argument
indexing in a manner that is now standard to Prolog implementations.
While this is the default behavior for XSB, other behavior can be
specified using the (executable) directives {\tt index/3} and {\tt
index/2}.  For instance, dynamic clauses can be declared to have
multiple or joint indexes, while this indexing can be either
hash-based as is typical in Prolog systems or based on {\em tries}.
No matter what kind of indexing is used, space is dynamically
allocated when a new clause is asserted and, unless specified
otherwise, released when it is retracted.  Furthermore, the size of
any index table expands dynamically as clauses are asserted.

Consider first dynamic predicates that use traditional hash-based
indexing.  XSB asserts WAM code for such clauses, leading to execution
times similar to compiled code for unit and binary clauses.
Furthermore, tabling can be used with a dynamic predicate by
explicitly declaring a predicate to be both dynamic and tabled.  For
clauses that are asserted as WAM code, the {\em ``immediate
semantics''} of dynamic predicates is used, not the so-called {\em
``logical semantics''} of assert/retract \cite{LiOk87}. This means
that significant care must be taken when modifying the definition of a
predicate which is currently being executed. Notice that this makes
some operations difficult. For example, one might try to retract from
dynamically asserted predicates, {\tt p/1} and {\tt q/1}, exactly
their intersection, by issuing the following query:
\begin{center} 
{\tt :- p(X), q(X), retract(p(X)), retract(q(X)), fail.}
\end{center}
Neither {\tt retract/1} nor {\tt retractall/1} support this behavior,
due to their techniques for space reclamation.  One alternative is to
use {\tt findall/3} to collect the intersection first, before retracting.
Another is to use the predicates {\tt retract\_nr/1} and {\tt
reclaim\_space/1}, described below.  

Asserting clauses as WAM code might be considerably slow for some
applications.  To remedy this, XSB provides an alternative to {\tt
assert/1} which implements assert's functionality using the trie-based
tabling data structures \cite{RRSSW98}.  Though trie-based dynamic
code can be created (and usually executed) significantly faster than
using {\tt assert/1}, users of the following predicates should be
aware that trie-based assert can be used only for unit clauses where a
relation is viewed as a set, and where the order of the facts is not
important.

XSB does not at this time fully support dynamic predicates defined
within compiled code.  The only way to generate dynamic code is by
explicitly asserting it, or by using the standard predicate {\tt
load\_dyn/1} to read clauses from a file and assert them (see
the section {\it Asserting Dynamic Code} in Volume 2).  There is a
{\tt dynamic/1} predicate (see 
page~\pageref{dynamic/1}) that declares a predicate within the system
so that if the predicate is called when no clauses are presently
defining it, the call will quietly fail instead of issuing an {\sf
``Undefined predicate''} error message.

\begin{description}

\ouritem{assert(+Clause)}\index{{\tt assert/1}}
adds a dynamic clause, {\tt Clause}, to the database. {\tt Clause}
must be of one of the forms: {\tt Head} or {\tt Head :- Body}. Note
that because of the precedence of {\tt :-/2}, using the second form
requires an extra set of parentheses: {\tt assert((Head :- Body))}.
Default: first-argument indexing.

\ouritem{asserta(+Clause)}\index{{\tt asserta/1}}
If the index specification for the preicate is not {\tt tries}, this
predicate adds a dynamic clause, {\tt Clause}, to the database {\em
before} any other clauses for the same predicate currently in the
database.  If the index specification for the predicate is {\tt trie},
the clause is asserted arbitrarily within the trie, and a warning
message sent to {\tt stderr}.


\ouritem{assertz(+Clause)}\index{{\tt assertz/1}}
If the index specification for the predicate is not {\tt tries}, this
predicate adds a dynamic clause, {\tt Clause}, to the database {\em
after} any other clauses for the same predicate currently in the
database.  If the index specification for the predicate is {\tt trie},
the clause is asserted arbitrarily within the trie, and a warning
message sent to {\tt stderr}.

\ouritem{retract(+Clause)}\index{{\tt retract/1}}
removes through backtracking all clauses in the database that match with
{\tt Clause}.  {\tt Clause} must be of one of the forms:  {\tt Head} or
{\tt Head :- Body}.  Note, that because of the precedence of {\tt :-/2},
using the second form requires an extra set of parentheses:
{\tt retract((Head :- Body))}.  Space is reclaimed when a 
clause is retracted.

\ouritem{retractall(+Head)}\index{{\tt retractall/1}}
removes every clause in the database whose head matches with {\tt Head}.
The predicate whose clauses have been retracted retains the {\tt dynamic}
property (contrast this behavior with that of predicates 
{\tt abolish/[1,2]} below).
Predicate {\tt retractall/1} is determinate and always succeeds.
The term {\tt Head} is not further instantiated by this call.

\ouritem{abolish(+PredSpec)}\index{{\tt abolish/1}}
Removes the definition of the specified predicate.  {\tt PredSpec}
is of the form {\tt Pred/Arity}.  Everything about the abolished
predicate is completely forgotten by the system (including the
{\tt dynamic} property).  There is also an {\tt abolish/2} which
takes {\tt Pred} and {\tt Arity} as its two arguments.

\ouritem{clause(+Head,?Body)}\index{{\tt clause/2}}
Returns through backtracking all dynamic clauses in the database whose head
matches {\tt Head} and Body matches {\tt Body}.  For facts the {\tt Body} is
{\tt true}.  

\ouritem{retract\_nr(+Clause)}\index{{\tt retract\_nr/1}}
Performs just as {\tt retract/1} does, except that it does not reclaim the
space used by the retracted clause. This is provided to allow programmers
to modify dynamic clauses while executing them (a practice that is 
discouraged.) For example, to retract an intersection, as described above,
one could do:
\begin{center}
{\tt :- p(X), q(X), retract\_nr(p(X)), retract\_nr(q(X)), fail.}
\end{center}
In order to reclaim space after using {\tt retract\_nr/1}, see 
{\tt reclaim\_space/1} below.  Predicate {\tt retract\_nr/1}
is not a standard predicate and must be imported from module {\tt assert}.
{\tt retract\_nr/1} is provided for (partial)
compatibility with the {\tt retract/1} predicate of SB-Prolog.

%In this case, the {\tt retract\_nr/1} deletes the clauses, but will not
%drastically modify the clause data structure,
%and this code will execute. Of course, space is not reclaimed for further
%use (but see {\tt reclaim\_space/1} below).  Predicate {\tt retract\_nr/1}
%is not a standard predicate but must be imported from module {\tt assert}.
%The use of this predicate is discouraged; it is provided for (partial)
%compatibility with the {\tt retract/1} predicate provided by SB-Prolog that
%did not reclaim space.

\ouritem{reclaim\_space(+Head)}\index{{\tt reclaim\_space/1}}
Runs through the dynamic code for the predicate indicated by {\tt Head}, and
reclaims space for any clauses that have been deleted from that predicate by
{\tt retract\_nr/1}.  This cannot safely be used when execution is still
within some invocation of the specified predicate, or will backtrack into
such a scope.  To complete our example of retracting the intersection of
dynamic predicates:
\begin{center}
{\tt :- p(X), q(X), retract\_nr(p(X)), retract\_nr(q(X)), fail\ ;\\
     reclaim\_space(p(\_)), reclaim\_space(q(\_)).}
\end{center}
would do the trick. Notice that the {\tt reclaim\_space} calls 
must be made after execution has completely failed
out of choice points for {\tt q(X)} and {\tt p(X)}.  Predicate 
{\tt reclaim\_space/1} is not
standard but must be imported from module {\tt assert}.
As with {\tt retract\_nr}, the use of this predicate is discouraged; 
it is provided for (partial) compatibility with SB-Prolog.

\comment{ 
TLS: I dont think we need hashtable size given that we use dynamic
hashing.  We still are supporting it, but we dont need to encourage it
\vspace{-.35in}
\ouritem{index(+PredSpec, +IndexSpec, +HashTableSize)}\index{{\tt index/3}}

If {\tt index/3} is used, then the predicate indicated by {\tt
PredSpec} is declared to be indexed according to {\tt IndexSpec} using
initial hash table of sizes of {\tt HashTableSize}.  After this
directive is given, all clauses asserted to {\tt PredSpec} will be so
indexed.  

For dynamic predicates,
{\tt index/2} is an executable directive that can be used to specify
the indexing of a predicate before clauses to that predicate have been
asserted.  


As an example, one could specify: {\tt index(p/5,[1+2,1,4],300)}.
After clauses are asserted to it, a call to {\tt p/5} would first
check to see if both the first and second arguments are nonvariable
and if so, use an index based on both those values. Otherwise, it
would see if the second argument is nonvariable and if so, use an
index based on it. Otherwise, it would see if the fourth argument is
nonvariable and if so use an index based on it. As a last resort, it would
use no index but backtrack through all the clauses in the predicate.
(Notice that it may well make sense to include an argument that 
appears in a joint specification later alone, as 1 in this example,
but it never makes sense foring the single argument to appear earlier. In
that case the joint index would never be used.)

}

\ouritem{index(+PredSpec, +IndexSpec)}\index{{\tt index/2}}
\label{index_dynamic} \index{indexing!dynamic predicates}

In general, XSB supports hash-based indexing on alternate arguments or
combinations of arguments, along with trie-based indexing.  The
availability of various kinds of indexing depends on whether code is
static (e.g. compiled) or dynamic (e.g. asserted or loaded with {\tt
load\_dyn/1}).  The executable directive {\tt index/2} does {\em
not\/} re-index an already existing predicate but takes effect only if
the program store contains no clauses for {\tt PredSpec}.  Index
directives can be given to the compiler as part of source code or
executed during program execution (analogously to {\tt op/3}).

\begin{itemize}
\item {\em Hash-based Indexing} 
\begin{itemize}
\item {\em Static Predicates}\ 
In this case {\tt IndexSpec} must be a non-negative integer which
indicates the argument on which an index is to be constructed.  If
{\tt IndexSpec} is~0, then no index is kept (possibly an efficient
strategy for predicates with only one or two clauses.)
\item {\em Dynamic Predicates}
For a dynamic predicate, (to which no clauses have yet been asserted),
{\tt IndexSpec} is either an {\tt IndexElt} or a list of {\tt
IndexElt}s.  Each {\tt IndexElt} specifies an argument or group of
arguments on which to build an index.  Syntactically, an {\tt
IndexElt}, in its turn is a non-negative integer or a sequence of up
to three non-negative integers separated by {\tt +}, e.g., {\tt
1+2+3}.

For example, {\tt index(p/3,[2,1])} indicates that clauses asserted to
the predicate {\tt p/3} should be indexed on both the second and the
first argument.  Subsequent calls to {\tt p/3} will first check to see
if the second argument is nonvariable, and if so use that index. If
the second argument is variable, it will check to see if the first
argument is nonvariable and if so, use that index.

As another example, one could specify: {\tt index(p/5,[1+2,1,4])}.
After clauses are asserted to it, a call to {\tt p/5} would first
check to see if both the first and second arguments are nonvariable
and if so, use an index based on both those values. Otherwise, it
would see if the second argument is nonvariable and if so, use an
index based on it. Otherwise, it would see if the fourth argument is
nonvariable and if so use an index based on it. As a last resort, it
would use no index but backtrack through all the clauses in the
predicate.  (Notice that it may well make sense to include an argument
that appears in a joint specification later alone, as 1 in this
example, but it never makes sense forcing the single argument to appear
earlier. In that case the joint index would never be used.)
\end{itemize}

\item {\em Trie-based Indexing}
The executable declaration {\tt index(Predspec,trie)} causes clauses
for {\tt Predspec} to be asserted using tries (see \cite{RRSSW98},
which is available through the XSB web page).  The name trie indexing
is something of a misnomer since the trie itself both indexes the term
and represents it.  In XSB, the above trie index is formed using a
left-to-right traversal of the unit clauses.  These indexes can be
very effective if discriminating information lies deep within a term,
and if there is sharing of left-prefixes of a term, can reduce the
space needed to represent terms.  Furthermore, asserting a unit clause
as a trie is much faster than asserting it using default WAM code.
\comment{
Trie indexing can be used with alternative or joint indexes.  For the
directive {\tt index(p/3,[2,1],trie)}, two trie indices would be
formed for {\tt p/3}: one that traversed arguments in order {\em
2,1,3} and another that traversed arguments in order {\em 1,2,3}.  The
actual implementation seeks to reduce redundant storage of code for
alternative indices.
}

Despite these advantages, representing terms as tries leads to
semantic differences from asserted code, of which the user should be
aware.  First, the order of clauses within a trie is arbitrary: using
{\tt asserta/1} or {\tt assertz} for a predicate currently using trie
indexing will give the same behavior as using {\tt assert}.  Also, the
current version of XSB only allows trie indexing for unit clauses.

Trie-based indexing is available only for dynamic predicates.
\end{itemize}

\ouritem{dynamic(+PredSpec)}\index{{\tt dynamic/1}}\label{dynamic/1}
is an executable predicate which converts a predicate specified as
(Predicate/Arity) to a dynamic predicate. If {\tt Predicate} is not
previously defined, it will be initialized to empty (so that calls to
it quietly fail, instead of issuing {\sf ``Undefined predicate''}
error messages.) If the predicate is previously defined and dynamic,
{\tt dynamic/1} is a noop. If previously defined as compiled, {\tt
Predicate} will be converted to dynamic, which means that clauses can
be added, although the compiled portion cannot be manipulated.  Note
that {\tt dynamic/1} can be used like a compiler directive, since it
will be passed through to be executed when the module is loaded. Note,
however, that the semantics is different from that of the standard
\cite{ISO-Prolog} when the file contains clauses defining the
so-specified predicate.

\ouritem{table(+PredSpec)}\index{{\tt table/1}}
is an executable predicate, where PredSpec is a predicate
specification for a dynamic predicate. (This is also a compiler
directive when {\tt PredSpec} specifies a compiled predicate. See the
section of this manual on compiler directives.) This predicate
declares a dynamic predicate to be tabled. It simply saves information
to be used at the time of assert and so it must be called before any
clauses are asserted into the specified predicate in order for the
predicate to be tabled.

\end{description}

%----------------------------------------------------------------------
%\input{tr_assert}	% To be uncommented when they become standard.
%----------------------------------------------------------------------

\subsection{The {\tt storage} Module: Associative Arrays and Backtrackable Updates}

\label{storage module}
XSB provides a high-level interface that supports efficient storage and
querying of key-value pairs. A \emph{key-value pair} is an association
between keys and the corresponding values. There can be at most one value
associated with a given key. A key-value pair can be stored, deleted or
queried. XSB provides two sets of predicates for handling such pairs:
backtrackable and non-backtrackable. The backtrackable primitives for
insertion and deletion of key-value pairs commit their changes to the
database only if the goal succeeds. Otherwise, if the goal fails, the
change is undone. Similarly, XSB provides primitive for backtrackable
updates analogous to {\tt assert} and {\tt retract}. The semantics of
backtrackable updates is defined using Transaction logic \cite{BoKi94}.

All the predicates described in this section must be imported from
module {\tt storage}.

\subsubsection{Non-backtrackable Storage}

\begin{description}
\ouritem{storage\_insert\_keypair(+StorageName,+Key, +Value, ?Inserted)}\index{{\tt storage\_insert\_keypair/4}}
%%
Insert the given Key-Value pair into the database. If the pair is new, then
{\tt Inserted} unifies with 1. If the pair is already in the database, then
{\tt Inserted} unifies with 0. If the database already contains a pair with
the given key that is associated with a \emph{different} value, then
{\tt Inserted} unifies with -1.
The first argument, {\tt Storage}, must be an atom naming the storage to be
used. Different names denote different storages.
In both cases the predicate succeeds.

\ouritem{storage\_delete\_keypair(+StorageName, +Key, ?Deleted)}
\index{{\tt storage\_delete\_keypair/3}}
%%
Delete the key-value pair with the given key from the databases. If
the pair was in the database then {\tt Deleted} unifies with 1.
If it was \emph{not} in the databases then {\tt Deleted} unifies with 0.
The first argument, {\tt Storage}, must be an atom naming the storage to be
used. Different names denote different storages.
In both cases the predicate succeeds.

\ouritem{storage\_find\_keypair(+StorageName, +Key, ?Value)}
\index{{\tt storage\_find\_keypair/3}}
%%
If the database has a key pair with the given key, then {\tt Value} unifies
with the value stored in the database. If no such pair exists in the
database, then the goal fails.

Note that this predicate works with non-backtrackable associative arrays
described above as well as with the backtrackable ones, described below.

\ouritem{storage\_insert\_fact(+StorageName, +Fact, ?Inserted)}\index{{\tt storage\_insert\_fact/3}}
Similar to keypair insertion, but this primitive inserts facts rather than
key pairs.

\ouritem{storage\_delete\_fact(+StorageName, +Fact, ?Inserted)}\index{{\tt storage\_delete\_fact/3}}
Similar to keypair deletion, but this primitive deletes facts rather than
key pairs.

\ouritem{storage\_find\_fact(+StorageName, +Fact)}\index{{\tt storage\_find\_fact/2}}
Similar to keypair finding, but this primitive finds facts facts rather than
key pairs.
%%
\end{description}

\subsubsection{Backtrackable Updates}
\label{backtrackable update}

\begin{description}
\ouritem{storage\_insert\_keypair\_bt(+StorageName, +Key, +Value, ?Inserted)}
\index{{\tt storage\_insert\_keypair\_bt/4}}
This predicate works exactly as its non-backtrackable counterpart,
{\tt storage\_insert\_keypair/4}, when the top-level goal succeeds.
However, if the top-level goal fails, then the result of the insertion is
undone. In other words, the pair remains in the database until it is
explicitly deleted or until the top-level query fails. The exact semantics
is defined by Transaction Logic \cite{BoKi94}.

Backtrackable key-value pairs are kept in the same database as
non-backtrackable pairs and are queried through the same predicate
{\tt keypair\_find/2}.

\ouritem{storage\_delete\_keypair\_bt(+StorageName, +Key, ?Deleted)}
\index{{\tt storage\_delete\_keypair\_bt/3}}
%%
Like {\tt storage\_delete\_keypair/3}, but backtrackable.


\ouritem{storage\_insert\_fact\_bt(+StorageName, +Goal)} \index{{\tt storage\_insert\_fact\_bt/2}}
%%
Like {\tt storage\_insert\_fact/2}, but backtrackable.

\ouritem{storage\_delete\_fact\_bt(+StorageName, +Goal)} 
\index{{\tt storage\_delete\_fact\_bt/2}}
%%
This is a backtrackable version of {\tt storage\_delete\_fact/2}.

\ouritem{storage\_reclaim\_space(+StorageName)} \index{{\tt storage\_reclaim\_space/1}}
%%
This is similar to {\tt reclaim\_space/1} for {\tt assert} and {\tt
  retract}, but it is used for storage managed by the primitives defined in
the {\tt storage} module. As with {\tt reclaim\_space/1}, this goal is
typically called just before returning to the top level.
%%
\end{description}


%=====================================================================

\section{Execution State}\label{environmental}

\begin{description}

\ouritem{break}\index{{\tt break/0}}
    Causes the current execution to be suspended at the beginning of the next 
    call.  The interpreter then enters break level 1 and is ready to accept
    input as if it were at top level.  If another call to {\tt break/0} is 
    encountered, it moves up to break level 2, and so on.  While execution 
    is done at break level $n>0$ the prompt changes to {\tt $n$: ?-}.

    To close a break level and resume the suspended execution, the user can 
    type the the atom {\tt end\_of\_file} or the end-of-file character 
    applicable on the system (usually {\tt CTRL-d} on UNIX systems).  
    Predicate {\tt break/0} 
    then succeeds (note in the following example that the calls to {\tt break/0}
    do not succeed), and the execution of the interrupted program is resumed.  
    Alternatively, the suspended execution can be abandoned by calling the 
    standard predicate {\tt abort/0}, which causes a return to the top level.

    An example of {\tt break/0} 's use is the following:

    \stuff{
	\>   \>     | ?- break. \\
	\>   \>     [ Break (level 1) ] \\
	\>   \>     1: ?- break. \\
	\>   \>     [ Break (level 2) ] \\
	\>   \>     2: ?- end\_of\_file. \\
	\>   \>     [ End break (level 2) ] \\
	\\
	\>   \>     yes \\
	\>   \>     1: ?-
    }

    Entering a break closes all incomplete tables (those which may not have a 
    complete set of answers).  Closed tables are unaffected, even if 
    the tables were created during the computation for which the break was
    entered.

\ouritem{halt}\index{{\tt halt/0}}
    Exits the \ourprolog\ session regardless of the break level.  On exiting
    the system cpu and elapsed time information is displayed.

\ouritem{prompt(+NewPrompt, ?OldPrompt)}\index{{\tt prompt/2}}
    Sets the prompt of the top level interpreter to {\tt NewPrompt} and 
    returns the old prompt in {\tt OldPrompt}.

    An example of {\tt prompt/2} 's use is the following:

    \stuff{
	\>   \>     | ?- prompt('Yes master > ', P). \\
	\\
	\>   \>     P = | ?- ; \\
	\\
	\>   \>     no \\
	\>   \>     Yes master > fail. \\
	\\
	\>   \>     no \\
	\>   \>     Yes master >
    }

\ouritem{garbage\_collection(+Option)}\index{{\tt
    garbage\_collection/1}} Sets the system so that subsequent heap
    garbage collecting will be done according to the specified {\tt
    Option}.  {\tt Option} may be the atom \verb|none| indicating that
    heap garbage collection is turned off; it may be the atom
    \verb|sliding| indicating that sliding garbage collection will be
    done; the atom \verb|copying| indicating that the copying garbage
    collector will be used; or it may be the atom \verb|indirection|
    indicating that the indirect-sliding garbage collector will be
    used.  The indirect-sliding garbage collector is not implemented
    for CHAT, therefore this option will have no effect on engines
    configured for CHAT.
 
\ouritem{cputime(-CPU\_Time)}\index{{\tt cputime/1}}
    Returns the {\tt CPU\_Time} at the time of the call in seconds.
    The difference between results of successive calls to this
    predicate can measure the time spent in specific predicates.

\ouritem{statistics}\index{{\tt statistics/0}} Prints on the current
    output stream: 
\begin{itemize} 
\item Information about allocation of memory  containing the 
\begin{itemize} 
\item Global stack (heap) and local (environment) stack (see e.g.
\cite{AitK90}). Memory for these two WAM stacks is allocated as a
single unit so that each stack grows together; information is provided
on the current allocation for the stacks as well as on the stack sizes
themselves.  (See Section~\ref{sec:EmuOptions} for the memory
re-allocation algorithm).  For maximum space used by each of these
stacks, use the {\tt '-s'} command-line option.
%
\item Trail and choice point stack (see e.g. \cite{AitK90}).  Memory
for these two WAM stacks is allocated as a single unit so that each
stack grows together; information is provided on the current
allocation for the stacks as well as on the stack sizes themselves.
The (re-)allocation follows the algorithm sketched in
Section~\ref{sec:EmuOptions}).  (See Section~\ref{sec:EmuOptions} for
the memory re-allocation algorithm).  For maximum space used by each
of these stacks, use the {\tt '-s'} command-line option.
% TLS: this had been taken out a version or two ago.
%	  \item SLG subgoal space (tablestack)
\item SLG unification stack.  This stack is used as a space to copy
terms from the execution stacks into table space, or back out.  This
stack will not be reallocated unless extremely large terms are tabled.
%
\item SLG completion stack.  The completion stack is used to perform
incremental completion for sets of mutually dependant tabled
subgoals.  One completion stack frame is allocated per tabled subgoal
\cite{SaSw98} but the size of these frames is version-dependent.
%
\item the space occupied by subgoal and answer tables (in the form of
tries) \cite{RRSSW98}.
\end{itemize}
\item Information about the number of tabling operations performed in
the session.  Note that the statistics are divided up between calls to
predicates that use variant tabling and those that use (call)
subsumptive tabling (see Section \ref{sec:TablingStrategies} and
\cite{TST99}).
\begin{itemize}
\item Call Subsumption Subgoal Operations.  For predicates that use
subsumptive tabling, the total number of subsumptive subgoal calls is
given, as is the number of new calls ({\tt producers}) and the number
of repeated calls to non-completed tables ({\tt variants}).
Furthermore, the number of properly subsumed calls to incomplete
tables is given, along with the number of subsumed calls to completed
tables.  Finally, the total number of subsumptive table entries
overall is given, including all producer and consumer calls.
%
\item Call Subsumption Answer Operations.  In call subsumptive
tabling, answer lists are copied from producer subgoals to subsumed
consumer subgoals (this opration is not required in variant tabling).
The number of {\tt answer ident} operations represents the number of
times this copy is done.  In addition, the number of consumptions
performed by all consuming subsumptive table entries is also given.
%
\item Call Variance Subgoal Operations.  For call variance the number
of subgoal check/insert operations is given along with the unique
number of subgoals encountered ({\tt generator}) and the number of
redundant consumer encountered ({\tt consumer}).
%
\item Total Answer Operations.  For both variant and subsumptive
tables, the number of answer check insert operations is given along
with the number of answers actually inserted into the table and the
number of redundant answers derived.
\end{itemize}
%
\item CHAT memory operations (compilation under CHAT only).  As
described in \cite{CHAT@PADL-99} CHAT requires an extra memory area
beyond the WAM execution stacks, completion stack and table space.
This memory area is used to copy parts of suspended environments for
tabled subgoals that may be awaiting answers.  The first line
represents the current amount of CHAT memory, the maximal amount, and
unused CHAT space not restored to the operating system.  The second
line represents the number of suspended tabled environments saved, as
well as the number of CHAT increments (portions of an envionment)
required to save these suspensioons and the number of these increments
that are shared.  The third line represents the number of tabled
environments that have been restored, or copied back into execution
stacks, along with the total amount of memory copied.

\item Garbage Collection Information.  Time spent garbage collecting
and number of heap cells collected.

\item Information about process CPU and clock time.
    \end{itemize}

As mentioned above, if the emulator is invoked with the {\tt '-s'}
    option (see Section~\ref{sec:EmuOptions}), additional information
    is printed out about maximum use of each execution stack and table
    space.  However, the {\tt '-s'} option can substantially slow down
    the emulator so benchmarks of time should be performed separately
    from benchmarks of space.

{\bf Example}: The following printout shows how the {\tt statistics/0}
output looks if it is invoked with the {\tt '-s'} option (without it
the {\tt Maximum stack used}, and {\tt Maximum table space used} lines
are not shown).  Information about the allocation size is provided
since the sizes can be changed through emulator options (see
Section~\ref{sec:EmuOptions}).

    {\footnotesize
     \begin{verbatim}
     | ?- statistics.

Memory (total)         1941216 bytes:       238120 in use,      1703096 free
  permanent space       237280 bytes:       237280 in use,            0 free
  glob/loc space        786432 bytes:          524 in use,       785908 free
    global                                     284 bytes
    local                                      240 bytes
  trail/cp space        786432 bytes:          316 in use,       786116 free
    trail                                       24 bytes
    choice point                               292 bytes
  SLG unific. space      65536 bytes:            0 in use,        65536 free
  SLG completion         65536 bytes:            0 in use,        65536 free
  SLG table space            0 bytes:            0 in use,            0 free

        Maximum stack used: global 224, local 1384, trail 240, cp 492,
                            SLG completion 0 (0 subgoals)
        Maximum table space used:  0 bytes

Tabling Operations
  Call Subsumption Subgoal Operations:
            0 call check/insert ops: 0 producers, 0 variants,
            0 properly subsumed. 0 used completed table, 
	    0 table entries overall.
  Call Subsumption Answer Operations:
            0 relevant answer ident ops.  0 consumptions via answer list.
  Call Variance Subgoal Operations: 
            0 call check/insert ops: 0 generators, 0 consumers.
  Total Answer Operations: 
            0 answer check/insert ops: 0 unique inserts, 0 redundant.

CHAT Operations
  total size CHAT areas: 0 b; high water mark: 0 b; not freed: 0 b
  suspensions saved: 0; increments saved: 0; shared increments: 0
  number of restored suspensions: 0; total restored memory: 0 b

{GC}    0 heap garbage collections by copying: collected 0 cells in 0.000000 millisecs

      0.570 sec. cputime, 5.088 sec. elapsetime 
\end{verbatim}} 
     For expert users of XSB, further information about resources
     required by the system can be obtained through the non-supported
     predicate {\tt statistics/1} in {\tt \$XSB\_DIR/emu/trace.c}.

%\ouritem{analyze\_table(+Pred\_indicator)}\index{{\tt analyze\_table/1}}
%    This predicate provides additional means for the user to profile
%    execution of tabled predicates.  Given a predicate indicator for a 
%    tabled predicate, {\tt analyze\_table/1} prints the following information.
%    \begin{itemize}
%    \item  "$\langle$Num$\rangle$ call hash buckets used out of 
%	   $\langle$Total$\rangle$".  The number
%           of call hash buckets containing at least one element.
%    \item  "avg call bucket length (of used) $\langle$Avg$\rangle$".  
%	   The average length of call hash buckets containing at least one
%	   element.
%    \item  "max call bucket length $\langle$Length$\rangle$".
%    \item  "$\langle$Num$\rangle$ ret hash buckets used out of 
%	   $\langle$Total$\rangle$".  The number
%           of ret hash buckets containing at least one element.
%    \item  "avg ret bucket length (of used) $\langle$Avg$\rangle$".
%	   The average length of ret hash buckets containing at least
%	   one element.
%    \item  "max ret bucket length $\langle$Length$\rangle$".
%    \end{itemize}

%    In \version, {\tt analyze\_table/1} is most readily used to 
%    determine proper call and return hash sizes.  The hash table sizes can
%    be reset using {\tt set\_table\_prop/3} from the interpreter level
%    (see Section~\ref{sec:TablingPredicates}) or by recompiling the source code
%    with new declarations (see Section~\ref{compiler_directives}).

%    Example:
%    {\footnotesize
%     \begin{verbatim}
%     | ?- analyze_table(ancestor/2).
%                 1 hash buckets full out of 97
%                 avg call bucket length (of filled) 1.00
%                 max call bucket length 1
%                 ret buckets used 97 out of 97
%                 avg return bucket length 11.92
%                 max ret bucket length 17
%
%     yes
%     \end{verbatim}}
%    The output of {\tt analyze\_table} indicates that the return hash size for
%    ancestor is too small for the query.  Changing the return hash size will
%    speed up similar queries which add answers to tables, but the size of the
%    return hash table has no effect on the speed of queries which use completed
%    tables.

\ouritem{shell(+SystemCall)}\index{{\tt shell/1}}
    Calls the operating system with the atom {\tt SystemCall} as argument.
    It succeeds if {\tt SystemCall} is executed successfully, otherwise it
    fails.  As a notational convenience, the user can supply {\tt SystemCall} 
    in the form of a list (something currently not possible for {\tt shell/2}).

    For example, the call:

    \demo{{\tt $|$ ?- shell('echo \$HOME').}}

    \noindent
    will output in the current output stream of \ourprolog\ the name of
    the user's home directory; while the call:

    \demo{{\tt $|$ ?- File = 'test.c', shell(['cc -c ', File]).}}

    \noindent
    will call the C compiler to compile the file {\tt test.c}.

    Note that in UNIX systems, since {\tt shell/1} is executed by
    forking off a shell process, it cannot be used, for example, to
    change the working directory of the interpreter.  For that reason
    the standard predicate {\tt cd/1} described below should be used.

%    {\em Note to DOS users.} \index{DOS}  The {\tt shell/1} command works
%    for DOS through the underlying GNU djgpp mechanism used to port \ourprolog.

\ouritem{shell(+SystemCall, -Result)}\index{{\tt shell/2}}
    Calls the operating system with the atom {\tt SystemCall} as argument
    and returns the result of the call in {\tt Result}.  In comparison with
    {\tt shell/1} this predicate always succeeds, even if the {\tt SystemCall} 
    cannot be successfully executed.

%    {\em Note to DOS users.} \index{DOS}  The {\tt shell/2} command works
%    for DOS through the underlying GNU djgpp mechanism used to port \ourprolog.

\ouritem{ls}\index{{\tt ls/0}} 
    Under UNIX, this command lists in the current output stream the files 
    in the system's current directory if it can do so.  If so, it succeeds.
    It is the same as {\tt shell('ls -F', 0)}.  

\ouritem{cd(+Dir)}\index{{\tt cd/1}}
    Under UNIX and Windows, this predicate changes the interpreter's
    working directory to {\tt Dir}.  If the directory specified does
    not exist or is not a directory, or the user does not have execute
    permission for that directory, predicate {\tt cd/1} simply fails
    raising no permission error.

    Exceptions:
    \begin{description}
    \item[{\tt instantiation\_error}]
	{\tt Dir} is not instantiated at the time of call.
    \item[{\tt type\_error}]
	{\tt Dir} is not an atom.
    \end{description}

\ouritem{edit(+Module)}\index{{\tt edit/1}}
    Provided that the environment variable {\tt EDITOR} has been set,
    and the system is executing under UNIX, 
    a call to {\tt edit(foo)} will call the default editor on the file
    named {\tt foo.P}.  The argument to {\tt edit/1}, should be instantiated,
    it can be an absolute or a relative file name, but it should {\em not}
    contain the suffix {\tt .P}.  Users can also set their preferred options
    of calling the default editor by setting an environment variable named
    {\tt EDITOR\_OPTIONS}.

    Examples of possible uses of predicate {\tt edit/1} are:
    \begin{enumerate}
    \item If the environment variables have been set as follows:
          \begin{verbatim}
	        setenv EDITOR /usr/ucb/vi
	        setenv EDITOR_OPTIONS -l
          \end{verbatim}
          a call like:
          \begin{verbatim}
	        | ?- edit(foo).
          \end{verbatim}
          will call the vi editor in the mode where left and right parentheses
	  and curly brackets are checked for balance for the file {\tt foo.P}
	  in the current working directory.
    \item If, on the other hand, they have been set as follows:
          \begin{verbatim}
	        setenv EDITOR /usr/local/bin/emacs
	        setenv EDITOR_OPTIONS -r
          \end{verbatim}
          a call like:
          \begin{verbatim}
	        | ?- edit('~/foo').
          \end{verbatim}
          will call the emacs editor in reverse video for the file {\tt foo.P}
	  in user's home directory.
    \end{enumerate}

\end{description}

%need op (just so we dont forget ???


%=====================================================================

\section{Exception Handling}\label{exception}
\index{exceptions}

\begin{description}

\ouritem{abort}\index{{\tt abort/0}} 
    Abandons the current execution and returns to the top level.  This
    predicate is normally used in one of the following two cases: 
    \begin{itemize} 
    \item when some error condition or exception has occurred and carrying
	  on the computation is of no further use.
    \item when using the debugger (see Chapter~\ref{debugging}).  
    \end{itemize}
    Currently, all exception handling routines terminate with a call to 
    predicate {\tt abort/0}, so an exception encountered at some break level 
    other than the top level will return the interpreter at the top level.

    The user should be aware of the fact that {\tt abort/0} does not close 
    any files which may have been opened.  If the program under execution is 
    doing file manipulation using {\tt see/1} and {\tt tell/1}, then strange 
    behavior may occur after the program is aborted and restarted, unless
    the user manually closes the files.

    Aborting closes all incomplete tables (those which may not have a 
    complete set of answers).  Closed tables are unaffected, even if 
    the tables were created during the aborted computation.

\ouritem{abort(+Message)}\index{{\tt abort/1}} \index{{\tt STDERR}}
    Acts as {\tt abort/0} but sents {\tt Message} to {\tt STDERR}
    before aborting.

\ouritem{catch(?Goal,?Catcher,?Handler)}\index{{\tt catch/3}} 
\vspace{-7mm}
\ouritem{throw(+Handler)}\index{{\tt throw/1}} 
%%
While very simple exceptions can be handled by {\tt abort/0}, more
sophisticated exception handling is performed by using {\tt catch/3}
and {\tt throw/1} together.  When {\tt catch(Goal,Catcher,Handler)} is
called, a continuation is saved, and {\tt Goal} is called.  If no
exceptions are encountered, answers for {\tt Goal} are obtained as
usual.  Within the execution of {\tt Goal}, an exception can be
signalled by a call to {\tt throw(Catcher)}.  This predicate searches
for an ancestor of the current environment in which a catch was set up
whose catcher (second argument) unifies with {\tt Catcher}.  If such
an ancestor is found, program execution reverts to the ancestor and
all intervening choice points are removed.  The ancestor's handler
(third argument) is called and the exception is thereby handled.  The
following, somewhat fanciful example, helps clarify these concepts.

The following predicate {\tt userdiv/2} is designed to be called with
the first argument instantiated to a number.  A second number is then
read from a console, and the first number is divided by the second,
and unified with the second argument of {\tt userdiv/2}.  By using
{\tt catch/3} and {\tt throw/1} together the various types of errors
can be caught.

\begin{small}
\begin{verbatim}
userdiv(X,Ans):- 
        catch(userdiv1(X,Ans),mydiv1(Y),handlefoo(Y,X)).

userdiv1(X,Ans):- 
        (number(X) -> true; throw(mydiv1(exception1))),
        write('Enter a number: '),read(Y),
        (number(Y) -> true ; throw(mydiv1(exception2(Y)))),
        (Y =;= 0 -> throw(mydiv1(exception3(Y))); true),
        Ans is X/Y.
\end{verbatim}
\end{small}

The behavior of this program on some representative inputs is shown
below.

\begin{small}
\begin{verbatim}
| ?- userdiv(X,Y).
userdiv/1 called with non-numeric numerator: _h76

X = _h76
Y = _h90

yes
| ?- userdiv(3,Y).
Enter a number: foo.
in userdiv/1 a non-numeric denominator was entered: foo

Y = _h84

yes
| ?- userdiv(3,Y).
Enter a number: 0.
in userdiv/1 a denominator of 0 was entered.
Y = _h84

yes
| ?- userdiv(3,Y).
Enter a number: 2.

Y = 1.5000

yes
\end{verbatim}
\end{small}

The actions of {\tt catch/3} and {\tt throw/1} resemble that of the
Prolog cut in that they remove choice points that lie between a call
to {\tt throw/1} and the matching {\tt catch/3} that serves as its
ancestor.  However, if this process encounters a choice point for an
incomplete table, execution is aborted to the top user level.

\end{description}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "manual1"
%%% End: 
