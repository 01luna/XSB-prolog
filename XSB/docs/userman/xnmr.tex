\documentclass{article}
\usepackage{moreverb}

\title{XNMR Manual}
\author{Lu\'\i s Castro \and David S. Warren}
\date{November, 1999}

\begin{document}
\maketitle
\section{Introduction}

XNMR is a module of the XSB system which attempts to provide an
unified environment for non-monotonic reasoning. It consists of a new
top-loop for XSB which benefits from the integration of SMODELS and
XSB to compute different semantics for non-monotonic programs.

SMODELS is a program which computes the stable model semantics for
logic programs. 

\section{The XNMR Top-Loop}

The XNMR top-loop is the interface between XNMR and the user. It adds
extra functionalities to the standard top-loop of XSB to provide means
to compute different semantics  for Prolog programs.

There are two distinct modes for the XNMR top-loop. The 'nmr' mode
allows for the computation of (partial) stable model semantics and
answerset semantics of normal logic programs. The 'answerset' mode is
designed to compute the answerset semantics of logic programs with
explicit negation.

\subsection{The 'nmr' mode}

The 'nmr' mode is the default mode of XNMR. It provides support for
computing the stable model and answerset semantics of normal logic
programs. This mode can be identified by the 'nmr| ?-' prompt. If you
change the mode to a different one, you can come back to 'nmr' mode
using the predicate 'set_nmr_mode/0'.

The prompt works much like a standard Prolog top-level. The difference
arises when the user issues a query which has an answer which depends
on undefined goals, that is, it returns a delay list. In this case,
the user can either ignore the delay list and assume the query (with
the given instantiations for the variables) is undefined under the
well-founded semantics, or it can ask XNMR to call SMODELS to compute
different semantics for the residual program.

Three options are available in such cases: 

\begin{enumerate}

\item['s'] computes and prints all (partial) stable models of the residual
  program, one at a time;

\item['t'] computes and prints the (partial) stable models of the residual
  program where the query is true, one at a time;

\item['a'] computes the answerset semantics of the residual program,
  ie. it says 'yes' if the query is true in all stable models of the
  residual program.

\end{enumerate}

Figure~\ref{fig:stable} shows the 's' operator in action. The
'exwfs.P' program is shown in figure~\ref{fig:exwfs}. 

At the ``more answers'' prompt, when there is a delay list, the user
can type 's<cr>' and obtain the stable models of the residual program.
Note that one model is computed and printed at each time. After a
model is printed, the user can ask for the next one by typing ';<cr>',
or she can give up by pressing only <cr>.

\begin{figure}
\label{fig:exwfs}
\centering
\scriptsize
\begin{boxedverbatim}
:- table win/1, p/0, q/0, r/0.

win(X) :- move(X,Y), tnot(win(Y)).

move(a,b).
move(b,a).
move(b,c).
move(c,d).

p :- tnot(q).
q :- tnot(p).
r :- p.
r :- q.
\end{boxedverbatim}
\caption{The exwfs.P program.}
\end{figure}

\begin{figure}
\label{fig:stable}
\centering
\scriptsize
\begin{boxedverbatim}
lfmobile:~/Programs/Prolog/WFS> xsb xnmr
[xsb_configuration loaded]
[sysinitrc loaded]
[packaging loaded]
[sModels loaded]

XSB Version 2.01 (Gouden Carolus) of August 20, 1999
[i686-pc-linux-gnu; mode: optimal; engine: chat; scheduling: batched]
nmr| ?- [exwfs].
[exwfs loaded]

yes
nmr| ?- win(X).

X = c ? ;

X = b
DELAY LIST = [tnot(win(a))] ? s

Stable Models: 
  {win(a)} ? ;

  {win(b)} ? ;
  no

X = a
DELAY LIST = [tnot(win(b))] ? s

Stable Models: 
  {win(b)} ? ;

  {win(a)} ? ;
  no

no
nmr| ?- 
\end{boxedverbatim}
\caption{Using the 's' operator}
\end{figure}


Figure~\ref{fig:tstable} shows the use of the 't' option. Note that
the models computed with this option form a subset of the models
computed with the 's' option, namely those models where the query is
true.

\begin{figure}
\label{fig:tstable}
\centering
\scriptsize
\begin{boxedverbatim}
lfmobile:~/Programs/Prolog/WFS> xsb xnmr
[xsb_configuration loaded]
[sysinitrc loaded]
[packaging loaded]
[sModels loaded]

XSB Version 2.01 (Gouden Carolus) of August 20, 1999
[i686-pc-linux-gnu; mode: optimal; engine: chat; scheduling: batched]
nmr| ?- [exwfs].
[exwfs loaded]

yes
nmr| ?- win(X).

X = c ? ;

X = b
DELAY LIST = [tnot(win(a))] ? t

Stable Models: 
  {win(b)} ? ;
  no

X = a
DELAY LIST = [tnot(win(b))] ? t

Stable Models: 
  {win(a)} ? ;
  no

no
nmr| ?- 
\end{boxedverbatim}
\caption{Using the 't' operator}
\end{figure}

Finally, figure~\ref{fig:answerset} shows one application of the 'a'
operation, to compute the answerset semantics of the residual
program. You can see that, when we use 's' to compute the stable
models of the residual program, all computed models have the query as
true. Therefore, it's clear that the query is true under the answerset
semantics of the residual program. 

\begin{figure}
\label{fig:answerset}
\centering
\scriptsize
\begin{boxedverbatim}
lfmobile:~/Programs/Prolog/WFS> xsb xnmr
[xsb_configuration loaded]
[sysinitrc loaded]
[packaging loaded]
[sModels loaded]

XSB Version 2.01 (Gouden Carolus) of August 20, 1999
[i686-pc-linux-gnu; mode: optimal; engine: chat; scheduling: batched]
nmr| ?- [exwfs].
[Compiling ./exwfs]
[exwfs compiled, cpu time used: 0.2490 seconds]
[exwfs loaded]

yes
nmr| ?- r.

DELAY LIST = [q]
DELAY LIST = [p] ? s

Stable Models: 
  {r; q} ? ;

  {r; p} ? ;
  no

no
nmr| ?- r.

DELAY LIST = [q]
DELAY LIST = [p] ? a
  yes

no
nmr| ?- 
\end{boxedverbatim}
\caption{Using the 'a' option}
\end{figure}

\subsection{The 'answerset' mode}

The 'answerset' mode is entered using the predicate
'set_answerset_mode/0'. This mode has been designed to deal with logic
programs with explicit negation.

Explicit negated predicates are represented by prepending their names
with '-'. For example, if 'p' is a predicate, its explicitly-negated
counterpart is '-p'. 

In this mode, when a query is issued, XNMR computes the answerset
semantics for all possible instantiations of the given query, and says
'yes' to all instantiations which are true under this semantics. 

After that, XNMR performs the same computation for the
explicitly-negated counterpart of the query. It, then, says 'no' to
all computed instantiations. 

It is assumed that the knowledge about all other instantiations not
shown is unknown.



\end{document}
















