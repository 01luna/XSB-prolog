/* File:      xsb_tok.P
** Author(s): Saumya K. Debray, Jiyang Xu
**    	      (adapted from D.H.D.Warren and Richard O'Keefe)
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** Copyright (C) ECRC, Germany, 1990
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: xsb_tok.P,v 1.1.1.1 1998-11-05 16:59:56 sbprolog Exp $
** 
*/


/* ======================================================================
   NOTE: This file is out of date! It cannot be used to read HiLog terms!
   ======================================================================*/


/* temporarily, should change to string later */

/*======================================================================*/
/* The following predicates just classify characters, you can change 	*/
/* them so that you get different partitions, for example, put '$' and	*/
/* '#" as lowercase letters.						*/
/*======================================================================*/

%% illegal characters
char_illegal(Ch) :-	Ch >= 127.

%% new_line char: same as blank, but needed to detect type declarations
char_newline(10).

%% charcters ignored (treat as blanks)
char_blank(Ch) :-	Ch >= 0, Ch =< 9.
char_blank(Ch) :-	Ch >= 11, Ch =< 32.

%% digits
char_digit(Ch) :-	Ch >= 48, Ch =< 57.

%% uppercase letters
char_uppercase(Ch) :-	Ch >= 65, Ch =< 90.

%% lowercase letters	% old version also include '$' and '#'
char_lowercase(Ch) :-	Ch >= 97, Ch =< 122.

%% operators, which are: < = > ? @ : & * + - \ ^ ` ~ # $
%%	'.' and '/' are also used as operators, but there are other uses.
char_operator(Ch) :- 	Ch >= 60, Ch =< 64.
char_operator(58).
char_operator(38).
char_operator(35).
char_operator(36).
char_operator(42).
char_operator(43).
char_operator(45).
char_operator(92).
char_operator(94).
char_operator(96).
char_operator(126).

%% puctuations:   , [ ] ) { } |
%%	'(' and '.' are also puncutation, but with other uses as well
char_punctuation(44, ',').
char_punctuation(41, ')').
char_punctuation(91, '[').
char_punctuation(93, ']').
char_punctuation(123, '{').
char_punctuation(124, '|').
char_punctuation(125, '}').

/* other chars: ", %, !, ', (, ., /, ;, _, */

/*======================================================================*/
/*   read_next_token(+Char, -TokenType, -TokenValue, -NextChar)		*/
%   The way end of file is handled is that everything else FAILS when it
%   hits character "26", sometimes printing a warning.  It might have been
%   an idea to return the atom 'end_of_file' instead of the same token list
%   that you'd have got from reading "end_of_file. ", but (1) this file is
%   for compatibility, and (b) there are good practical reasons for wanting
%   this behaviour. 
/*======================================================================*/

read_next_token(Ch, Type, Value, NCh) :- read_tok_0(Ch, Type, Value, NCh).

/*======================================================================*/
/* read_tok_0 is the starting point of the finite automata 		*/
/*======================================================================*/

read_tok_0(Ch, Type, Value, NCh) :- char_blank(Ch), !,
	read_get0(NextCh), read_tok_0(NextCh,Type, Value, NCh).
read_tok_0(Ch, Type, Value, NCh) :- char_newline(Ch), !,
	read_get0(Ch1), 
	( Ch1 = 37, !, read_get0(Ch2),
	  ( Ch2 = 33, !, read_get0(NextCh)		% '%!' combo
	  ; read_skip_comment, read_get0(NextCh) 	% '%' comments
	  )
	; NextCh = Ch1
	),
	read_tok_0(NextCh,Type, Value, NCh).
read_tok_0(Ch, Type, Value, NCh) :- char_uppercase(Ch), !,
	read_name(Ch, Value,NCh),
	( NCh = 40 -> Type = tk_varfunc			% '('
	; Type = tk_var
	).
read_tok_0(Ch, Type, Value, NCh) :- char_lowercase(Ch), !,
	read_name(Ch, Value, NCh),
	( NCh = 40 -> Type = tk_func			% '('
	; Type = tk_atom
	).
read_tok_0(Ch, Type, Value, NCh) :- char_operator(Ch), !,
	Type = tk_atom,
	read_symbol(Ch, Value, NCh).
read_tok_0(Ch, Type, Value, NCh) :- char_digit(Ch), !,
	Type = tk_int,
	read_integer(Ch, Value, NCh).
read_tok_0(Ch, Type, Value, NCh) :- char_punctuation(Ch, _Tok), !,
	Type = tk_punc, Value = Ch, read_get0(NCh).
read_tok_0(34, Type, Value, NCh) :-			% ' " '
	Type = tk_list, read_string(Value, 34, NCh).
read_tok_0(37, Type, Value, NCh) :- 			% '%'
	read_skip_comment, read_get0(NextCh), 
	read_tok_0(NextCh,Type, Value, NCh).
read_tok_0(33, Type, Value, NCh) :-			% '!'
	Type = tk_atom, str_fromlist(Value, [33]), read_get0(NCh).
read_tok_0(39, Type, Value, NCh) :-			% ' ' '
	read_string(Value, 39, NCh),
	( NCh = 40 -> Type = tk_func			% '('
	; Type = tk_atom
	).
read_tok_0(40, Type, Value, NCh) :-			% '('
	Type = tk_punc, Value = 40, read_get0(NCh).
read_tok_0(46, Type, Value, NCh) :-			% '.'
	read_get0(NextCh), 
	read_tok_fullstop(NextCh, Type, Value, NCh).
read_tok_0(47, Type, Value, NCh) :-			% '/'
	read_get0(NextCh), 
	read_tok_slash(NextCh,Type, Value, NCh).
read_tok_0(59, Type, Value, NCh) :-			% ';'
	Type = tk_atom, str_fromlist(Value, [59]), read_get0(NCh).
read_tok_0(95, Type, Value, NCh) :-			% '_'
	Type = tk_vvar,
	read_name(95, Value, NCh).
read_tok_0(-1, Type, Value, _NCh) :- !, Type = tk_eof, Value = 0.
read_tok_0(Ch, _Type, _Value, _NCh) :- char_illegal(Ch), !, fail.

/*======================================================================*/
/* read_tok_fullstop(Char, Type, Value, NCh):				*/
/*	The third state of the finite automator, entered after a '.'.	*/
/* It looks at the next character after a full stop. There are 3 cases: */
/*      (a) the next character is an end of file.  We treat this	*/
/*          as an unexpected end of file.  The reason for this is	*/
/*          that we HAVE to handle end of file characters in this	*/
/*          module or they are gone forever; if we failed to check	*/
/*          for end of file here and just accepted .<EOF> like .<NL>	*/
/*          the caller would have no way of detecting an end of file	*/
/*          and the next call would abort.				*/
/*      (b) the next character is a layout character.  This is a	*/
/*           clause terminator.						*/
/*      (c) the next character is anything else.  This is just an	*/
/*           ordinary symbol and we call read_symbol to process it.	*/
/*======================================================================*/
read_tok_fullstop(26, _, _, _) :- !,
        read_message('! end of file just after full stop'),
        fail.
read_tok_fullstop(Ch, tk_eoc, 0, Ch) :-
        Ch =< 32, !.            /* END OF CLAUSE */
read_tok_fullstop(Ch, tk_atom, Value, NCh) :-
        read_symbol0(Ch, List, NCh),
	str_fromlist(Value, [46|List]).

/*======================================================================*/
/* read_tok_slash(Ch, Type, Value, NCh):				*/
/*	This is the 4th state of the FA, entered after read a '/'.	*/
/*  It checks to see whether /Ch is a /* comment or a symbol.  If the	*/
/*  former, it skips the comment. If the latter it just calls read_symbol. */
/*  We have to take great care with /* comments to handle end of file	*/
/*  inside a comment, which is why read_tok_slash/2 passes back an end of */
/*  file character or a (forged) blank that we can give to read_tokens.*/
/*======================================================================*/
read_tok_slash(42, Type, Value, NCh) :- !,
        read_get0(Ch),
        read_solidus(Ch, NextCh),
        read_tok_0(NextCh, Type, Value, NCh).
read_tok_slash(Ch, tk_atom, Value, NCh) :-
        read_symbol0(Ch, Chars, NCh),         /* might read 0 chars */
	str_fromlist(Value, [47|Chars]).

/*======================================================================*/
/* read_solidus: local FA, read block comments.				*/
/*======================================================================*/
read_solidus(Ch, LastCh) :-
	Ch =:= -1, read_message('! end of file in /*comment');
	Ch =\= -1,
	 (Ch =:= 26, read_message('! end of file in /*comment');
	  Ch =\= 26,read_get0(NextCh),
	   (Ch =:= 42,
	     (NextCh =\= 47, read_solidus(NextCh,LastCh);
	      NextCh =:= 47, LastCh=32)
	   ;
	    Ch =\= 42, read_solidus(NextCh,LastCh)
	   )
	 ).

/* old read_solidus/2
read_solidus(Ch, Ch) :- (Ch is -1 ; Ch is 26), !,
        read_message('! end of file in /*comment').
read_solidus(42, LastCh) :-
        read_get0(NextCh),
        NextCh =\= 47, !,      
        read_solidus(NextCh, LastCh).
read_solidus(42, 32) :- !.
read_solidus(_, LastCh) :-
        read_get0(NextCh),
        read_solidus(NextCh, LastCh).
*/
/*======================================================================*/
/* read_skip_comment: local FA, read '%' comments.			*/
/*======================================================================*/
read_skip_comment :-
	l_repeat,
		read_get0(Ch),
		(Ch = 10 ; Ch < 0 ; Ch = 31 ; Ch = 26),
	!,
	Ch =\= 26,
	Ch > 0.		/*  fail on EOF */

l_repeat.
l_repeat :- l_repeat.

/*======================================================================*/
/* read_string:	local FA, read a string in '....'			*/
/* 	It reads the body of a string delimited by Quote characters.	*/
/* The result is a list of ASCII codes.  There are two complications.	*/
/* If we hit the end of the file inside the string this predicate FAILS.*/
/* It does not return any special structure.  That is the only reason	*/
/* it can ever fail. The other complication is that when we find a Quote*/
/* we have to look ahead one character in case it is doubled.  Note that*/
/* if we find an end-of-file after the quote we *don't* fail, we return	*/
/* a normal string and the end of file character is returned as NextCh.	*/
/* If we were going to accept C-like escape characters, as I think we	*/
/* should, this would need changing (as would the code for 0'x).  But	*/
/* the purpose of this module is not to present my ideal syntax but to	*/
/* present something which will read present-day Prolog programs.	*/
/*======================================================================*/
read_string(String, Quote, NextCh) :-
	read_string0(Chars, Quote, NextCh),
	str_fromlist(String, Chars).

read_string0(Chars, Quote, NextCh) :-
        read_get0(Ch),
        read_string0(Ch, Chars, Quote, NextCh).

read_string0(Eofsym, _Chars, _Quote, Eofsym) :- 
	(Eofsym is 26; Eofsym is -1),  /* new */
        read_message('! end of line or file in quoted names'),
        !, fail.
read_string0(Quote, Chars, Quote, NextCh) :- !, 
	read_get0(Ch),                          /* closing or doubled quote */
        read_more_string(Ch, Quote, Chars, NextCh).
read_string0(Char, [Char|Chars], Quote, NextCh) :-
        read_string0(Chars, Quote, NextCh).      /* ordinary character */

read_more_string(Quote, Quote, [Quote|Chars], NextCh) :- !,
        read_string0(Chars, Quote, NextCh).      /* doubled quote */
read_more_string(NextCh, _, [], NextCh).             /* end */


/*======================================================================*/
/* read_name: a local FA for reading a name.				*/
/* read_name(Char, String, LastCh)					*/
/* reads a sequence of letters, digits, and underscores, and returns	*/
/* them as String.  The first character which cannot join this sequence	*/
/* is returned as LastCh.						*/
/*======================================================================*/
read_name(Char, String, LastCh) :-
	read_name0(Char, List, LastCh),
	str_fromlist(String, List).

read_name0(Char, [Char|Chars], LastCh) :-
        ( char_lowercase(Char)
        ; char_uppercase(Char)
        ; char_digit(Char)
        ; Char = 95                     %  _ 
        ), !,
        read_get0(NextCh),
        read_name0(NextCh, Chars, LastCh).
read_name0(LastCh, [], LastCh).

/*======================================================================*/
/* read_symbol(Ch, String, NextCh): a local FA reading operators	*/
/*	It reads the other kind of atom which needs no quoting: one 	*/
/* which is a string of "symbol" characters.  Note that it may accept 0 */
/* characters, this happens when called from read_tok_fullstop. 	*/
/*======================================================================*/
read_symbol(Ch, String, NCh) :-
	read_symbol0(Ch, List, NCh),
	str_fromlist(String, List).

read_symbol0(Char, [Char|Chars], LastCh) :-
	( char_operator(Char) 			% operator
	; Char = 46 				% '+'
	; Char = 47 				% '-'
	), !,
        read_get0(NextCh),
        read_symbol0(NextCh, Chars, LastCh).
read_symbol0(LastCh, [], LastCh).

/*======================================================================*/
/*
%   read_integer is complicated by having to understand radix notation.
%   There are three forms of integer:
%       0 ' <any character>     - the ASCII code for that character
%       <digit> ' <digits>      - the digits, read in that base
%       <digits>                - the digits, read in base 10.
%   Note that radix 16 is not understood, because 16 is two digits,
%   and that all the decimal digits are accepted in each base (this
%   is also true of C).  So 2'89 = 25.  I can't say I care for this,
%   but it does no great harm, and that's what Dec-10 Prolog does.
%   The X =\= 26 tests are to make sure we don't miss an end of file
%   character.  The tokeniser really should be in C, not least to
%   make handling end of file characters bearable.  If we hit an end
%   of file inside an integer, read_integer will fail.
*/
/*======================================================================*/
read_integer(BaseChar, IntVal, NextCh) :-
        Base is BaseChar - 48,
        read_get0(Ch),
        Ch =\= 26,
        (   Ch =\= 39, read_digits(Ch, Base, 10, IntVal, NextCh)
        ;   Base >= 1, read_digits(0, Base, IntVal, NextCh)
        ;   read_get0(IntVal), IntVal =\= 26, read_get0(NextCh)
        ),  !.

read_digits(SoFar, Base, Value, NextCh) :-
        read_get0(Ch),
        Ch =\= 26,
        read_digits(Ch, SoFar, Base, Value, NextCh).

read_digits(Digit, SoFar, Base, Value, NextCh) :-
	char_digit(Digit),
        !,
        Next is SoFar*Base-48+Digit,
        read_digits(Next, Base, Value, NextCh).
read_digits(LastCh, Value, _, Value, LastCh).


read_get0(X) :- stat_flag(51, File), 
	( File < 256, !, file_get(File, X)
	; buff_word(File, 0, Buf),
	  buff_word(File, 4, Size),
	  buff_word(File, 8, Ptr),
	  ( Ptr < Size, !,
		buff_byte(Buf, Ptr, X),
		NPtr is Ptr + 1,
		buff_set_word(File, 8, NPtr)
	  ; X is -1
	  )
	).

read_message(Message) :-
	term_psc(Message, PSC),
	psc_name(PSC, String),
	file_write0(1, String),
	file_nl(1).		% nl


/* ------------------- end of file file_token.P ------------------- */
