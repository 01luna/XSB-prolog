/* File:      thread.P
** Author(s): Rui Marques
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: thread.P,v 1.17 2007/06/19 09:56:09 ruim Exp $
** 
*/

:- compiler_options([xpp_on,sysmod]).
#include "standard.h"
#include "thread_defs_xsb.h"
#include "flag_defs_xsb.h"
#include "io_defs_xsb.h"

/* ==================================================================  */
/* User-level API */
:- import writeln/1 from standard.
/* Error checking for pthread_create() done in C -- all args are input.*/
thread_create( Goal, ThreadId , Options) :- 
%	check_callable(Goal,thread_create/2,1),
%	check_var(ThreadId,thread_create/2,2),
	check_options_list(Options,GLSize,TCSize,ComplSize,PDLSize,Detached,Alias),
	(Alias == [] -> 
	    Aliased = 0
	 ;  Aliased = 1),
	thread_request( XSB_THREAD_CREATE, Goal, ThreadId, 
	                GLSize,TCSize,ComplSize,PDLSize,Detached,Aliased),
	(Aliased == 1 -> add_aliases(Alias,THREAD_ALIAS,ThreadId,thread_create/3) ; true).
    
check_options_list(Options,GLSize,TCSize,ComplSize,PDLSize,Detached,Alias):- 
	check_nonvar(Options,thread_create/3,3),
	check_options_list_1(Options,GLSize,TCSize,ComplSize,PDLSize,Detached,Alias).

check_options_list_1([],GLSize,TCSize,ComplSize,PDLSize,Detached,[]):- !,
	(var(GLSize) -> GLSize = 0 ; true),
	(var(TCSize) -> TCSize = 0 ; true),
	(var(ComplSize) -> ComplSize = 0 ; true),
	(var(PDLSize) -> PDLSize = 0 ; true),
	(var(Detached) -> Detached = 0 ; true).
check_options_list_1([Option|Rest],GLSize,TCSize,ComplSize,PDLSize,Detached,Alias):- !,
	check_nonvar(Option,thread_create/3,3),
	(Option @= glsize(_) ->  Option = glsize(N),set_thread_create_arg(N,GLSize,glsize)
          ; (Option @= tcsize(_) -> Option = tcsize(N),set_thread_create_arg(N,TCSize,tcsize)
            ; (Option @= complsize(_) -> Option = complsize(N),set_thread_create_arg(N,ComplSize,complsize)
              ; (Option @= pdlsize(_) -> Option = pdlsize(N),set_thread_create_arg(N,PDLSize,pdlsize)
                ; (Option @= detached(Boolean) -> 
		    (Boolean == true -> Detached = 1 ; Detached = 0)
		  ; (Option @= alias(_) -> 
		        Option = alias(A),check_atom(A,thread_create/3,3),Alias = [A|R]
	            ; 	domain_error(thread_option,Option,thread_create/3,3,'') ) ) ) ) ) ),
       check_options_list_1(Rest,GLSize,TCSize,ComplSize,PDLSize,Detached,R).
check_options_list_1(Culprit,_GLSize,_TCSize,_ComplSize,_PDLSize,_Detached,_Alias):- 
	type_error(list,Culprit,thread_create/3,3).

set_thread_create_arg(Option,Arg,OptionName):- 
	(\+ (Option = Arg) -> 
	    misc_error(('Conflicting options in thread_create/3: ',
	                 OptionName,' set to ',Arg,' and ',Option))
         ; Arg = Option).

/*---------------*/
	    
thread_create( Goal, ThreadId ) :- 
%	check_callable(Goal,thread_create/2,1),
%	check_var(ThreadId,thread_create/2,2),
	thread_request( XSB_THREAD_CREATE, Goal, ThreadId, 0,0,0,1,0,0).

/*---------------*/


thread_create( Goal ) :- 
	thread_create( Goal, _, [detached(true)] ).

/*---------------*/

thread_exit( ExitCode ) 	    :- 
	check_integer(ExitCode,thread_exit/1,1),
	thread_request( XSB_THREAD_EXIT, ExitCode,_, _,_,_,_,_,_).

thread_exit 		    :- thread_exit( 0).

/*---------------*/

/* Need to check errorval on return, as well as checking input state
   of exitcode */
thread_join(Input, ExitCode) :-
%	check_var(ExitCode,thread_join/2,2),
	(var(Input) -> 
	    instantiation_error(thread_join/2,1,ground)
	;  (integer(Input) -> 
	       thread_request( XSB_THREAD_JOIN,Input,Exit,Aliased,_,_,_,_ ,_),
	       (Aliased == 1 -> remove_alias(_Alias,THREAD_ALIAS,Id) ; true),
	       ExitCode = Ball - Exit,
	       ('_$thread_exit_ball'(Id,Ball) -> 
		     retractall('_$thread_exit_ball'(Id,_))
		   ; Ball = no_error_ball)
	    ; (Input = [Id|Rest] -> 
	         ExitCode = [Ball-Exit|ERest],
	         thread_request(XSB_THREAD_JOIN, Id,Exit,Aliased,_,_,_,_,_),
		 (Aliased == 1 -> remove_alias(_Alias,THREAD_ALIAS,Id) ; true),
		 ('_$thread_exit_ball'(Id,Ball) -> 
		     retractall('_$thread_exit_ball'(Id,_))
		   ; Ball = no_error_ball),
	         thread_join(Rest, ERest) 
	       ; (Input = [] -> 
		    ExitCode = []
		  ; domain_error(listof_threadid,Input,thread_join/1,2,'')
	      ) ) ) ).

thread_join( ThreadId )	    :- thread_join( ThreadId, _).

/*---------------*/

thread_self( ThreadId )	    :- 
	check_var(ThreadId,thread_self/1,1),
	thread_request( XSB_THREAD_SELF, ThreadId, _, _, _, _, _, _ ,_).

/*---------------*/

thread_detach(ThreadId) :-
	check_integer(ThreadId,thread_detach/1,1),
	thread_request( XSB_THREAD_DETACH, ThreadId, _, _, _ , _, _, _,_).

/*---------------*/

thread_property(Id,Property) :- 
	thread_request( XSB_THREAD_PROPERTY, Id,Prop1, _, _, _, _, _,_ ),
	(Prop1 == 1 -> Property = detached ; Property = joinable).

/*---------------*/

thread_cancel(Id):- 
	check_nonvar(Id,thread_cancel/1,1),
	(Id == 0 -> 
	    permission_error(cancel,main_thread,0,thread_cancel/1)
	  ; true),
	thread_request( XSB_THREAD_INTERRUPT, Id,_, _, _, _, _, _ ,_).
	
/*---------------*/

thread_yield:-
	thread_request( XSB_THREAD_YIELD, _,_,_, _, _, _, _,_).

/*---------------*/

abolish_private_tables:-
	thread_request( ABOLISH_PRIVATE_TABLES, _,_,_, _, _, _, _,_).

abolish_all_private_tables:-
	thread_request( ABOLISH_ALL_PRIVATE_TABLES, _,_,_, _, _, _, _,_).

/*---------------*/

abolish_shared_tables:-
	thread_request( ABOLISH_SHARED_TABLES, _,_,_, _, _, _, _,_).

abolish_all_shared_tables:-
	thread_request( ABOLISH_ALL_SHARED_TABLES, _,_,_, _, _, _, _,_).

set_xsb_ready:- 
	thread_request( SET_XSB_READY, _,_,_, _, _, _, _,_).

/* ==================================================================  */
/* Routines used internally. */

'_$thread_run'( Goal ) :-
	(catch(call(Goal),Ball,(default_error_handler(Ball))), thread_exit
	 ;
	 thread_exit
	).

/* store thread flag predicate in THREAD_RUN flag */

:- init_multi_threading.

init_multi_threading:- 
	term_psc('_$thread_run'(_), PSC), 
	stat_set_flag(THREAD_RUN, PSC).

xsb_show_mutexes:- 
	thread_request( XSB_SHOW_MUTEXES, _,_,_, _,_,_,_,_).

xsb_sys_mutex_lock(Id) :- 
	thread_request( XSB_SYS_MUTEX_LOCK, Id, _, _, _, _, _, _ ,_).
xsb_sys_mutex_unlock(Id) :- 
	thread_request( XSB_SYS_MUTEX_UNLOCK, Id, _, _, _, _, _, _ ,_).

/* ==================================================================  */
/* Obsolescent, but may still be used in parts of the system.  */
xsb_thread_create(One,Two,Three):- thread_create(One,Two,Three).
xsb_thread_create(One,Two):- thread_create(One,Two).

xsb_thread_cancel(Id):- thread_cancel(Id).

xsb_thread_detach(ThreadId):- thread_detach(ThreadId).

xsb_thread_exit(ExitCode):- thread_exit(ExitCode).
xsb_thread_exit:- thread_exit.

xsb_thread_join(Input, ExitCode) :- thread_join(Input, ExitCode).
xsb_thread_join(Input) :- thread_join(Input).

xsb_thread_property(Id,Property) :- thread_property(Id,Property).

xsb_thread_self(ThreadId):- thread_self(ThreadId).

xsb_thread_yield:- thread_yield.

/**************************************************************/
/** Higher level stuff (Rui) **/

par_execute( GoalList ) :-
	par_spawn( GoalList, ThreadList ),
	par_wait( ThreadList ).

n_par_execute( Goal, N ) :-
	n_list( Goal, N, GoalList ),
	par_execute( GoalList ).

n_list( _, 0, [] ) :- !.
n_list( X, N, [X|L] ) :- N1 is N - 1, n_list( X, N1, L ).


par_spawn( [], [] ).
par_spawn( [G|GL], [T|TL] ) :- 
	thread_create( G, T ), par_spawn( GL, TL ).

par_wait( [] ).
par_wait( [T|L] ) :- thread_join(T), par_wait(L).

end_of_file.

%xsb_mutex_init_np( fast, MutexId) :-
%	xsb_mutex_init_np0( MutexId, XSB_FAST_MUTEX).
%xsb_mutex_init_np( recursive, MutexId) :-
%	xsb_mutex_init_np0( MutexId, XSB_RECURSIVE_MUTEX).
%xsb_mutex_init_np( error_check, MutexId) :-
%	xsb_mutex_init_np0( MutexId, XSB_ERRORCHECK_MUTEX).

% exmut_execute( G, M ) :-
% 	xsb_user_mutex_lock(M), G, !, xsb_user_mutex_unlock(M).
% exmut_execute( _, M ) :- xsb_user_mutex_unlock(M).

% console_exmut( G ) :- 
% 	xsb_user_mutex_lock(MUTEX_CONSOLE), 
% 	G, !, xsb_user_mutex_unlock(MUTEX_CONSOLE).
% console_exmut( _ ) :- 
% 	xsb_user_mutex_unlock(MUTEX_CONSOLE).

/* System provided mutexes for users */
% user_mutex( N, N1, Call) :-
% 	check_integer(N,Call,1),
% 	(N1 is N + MUTEX_USER1 - 1,
% 	 N1 >= MUTEX_USER1,
% 	 N1 < MAX_SYS_MUTEXES -> 
% 	   true
%          ; domain_error(user_mutex,N,Call,1,'') ).

% xsb_user_mutex_lock(N) :- 
% 	user_mutex(N,N1,xsb_user_mutex_unlock/1), 
% 	xsb_sys_mutex_lock(N1).
% xsb_user_mutex_unlock(N) :- 
% 	user_mutex(N,N1,xsb_user_mutex_unlock/1), 
% 	xsb_sys_mutex_unlock(N1).

