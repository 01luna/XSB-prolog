/* File:      thread.P
** Author(s): Rui Marques
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: thread.P,v 1.2 2005/01/14 18:32:05 ruim Exp $
** 
*/

:- compiler_options([xpp_on,sysmod]).
#include "standard.h"
#include "thread_defs_xsb.h"
#include "flag_defs_xsb.h"

:- import (:-)/2 from usermod.

xsb_thread_create( Goal, ThreadId, ErrorVal ) :-
	thread_request( XSB_THREAD_CREATE, Goal, ThreadId, _, ErrorVal ).
xsb_thread_exit( ExitCode, ErrorVal ) :-
	ts_abolish_tables,
	ts_abolish,
	ds_abolish_tables,
	ds_abolish,
	thread_request( XSB_THREAD_EXIT, ExitCode, _, _, ErrorVal ).
xsb_thread_join( ThreadId, ExitCode, ErrorVal ) :-
	thread_request( XSB_THREAD_JOIN, ThreadId, ExitCode, _, ErrorVal ).
xsb_thread_detach( ThreadId, ErrorVal ) :-
	thread_request( XSB_THREAD_DETACH, ThreadId, _, _, ErrorVal ).
xsb_thread_self( ThreadId, ErrorVal ) :-
	thread_request( XSB_THREAD_SELF, ThreadId, _, _, ErrorVal ).
xsb_thread_yield(ErrorVal) :-
	thread_request( XSB_THREAD_YIELD, _,_,_, ErrorVal).

xsb_mutex_init_np0( MutexId, KindNP, ErrorVal ) :-
	thread_request( XSB_MUTEX_INIT, KindNP, MutexId, _, ErrorVal ).
/* "mutex kind" is a non portable extension to POSIX */
xsb_mutex_init( MutexId, ErrorVal ) :-
	thread_request( XSB_MUTEX_INIT, XSB_FAST_MUTEX, MutexId, _, ErrorVal ).
xsb_mutex_lock( MutexId, ErrorVal ) :-
	thread_request( XSB_MUTEX_LOCK, MutexId, _, _, ErrorVal ).
xsb_mutex_trylock( MutexId, ErrorVal ) :-
	thread_request( XSB_MUTEX_TRYLOCK, MutexId, _, _, ErrorVal ).
xsb_mutex_unlock( MutexId, ErrorVal ) :-
	thread_request( XSB_MUTEX_UNLOCK, MutexId, _, _, ErrorVal ).
xsb_mutex_destroy( MutexId, ErrorVal ) :-
	thread_request( XSB_MUTEX_DESTROY, MutexId, _, _, ErrorVal ).

xsb_mutex_init_np( fast, MutexId, ErrorVal ) :-
	xsb_mutex_init_np0( MutexId, XSB_FAST_MUTEX, ErrorVal ).
xsb_mutex_init_np( recursive, MutexId, ErrorVal ) :-
	xsb_mutex_init_np0( MutexId, XSB_RECURSIVE_MUTEX, ErrorVal ).
xsb_mutex_init_np( error_check, MutexId, ErrorVal ) :-
	xsb_mutex_init_np0( MutexId, XSB_ERRORCHECK_MUTEX, ErrorVal ).

xsb_sys_mutex_lock( Id, ErrorVal ) :- 
	thread_request( XSB_SYS_MUTEX_LOCK, Id, _, _, ErrorVal ).
xsb_sys_mutex_unlock( Id, ErrorVal ) :- 
	thread_request( XSB_SYS_MUTEX_UNLOCK, Id, _, _, ErrorVal ).


/* Shortcuts */

xsb_thread_create( Goal )	    :- xsb_thread_create( Goal, _, _ ).
xsb_thread_create( Goal, ThreadId ) :- xsb_thread_create( Goal, ThreadId, _ ).

xsb_thread_exit( ExitCode ) 	    :- xsb_thread_exit( ExitCode, _ ).
xsb_thread_exit 		    :- xsb_thread_exit( 0, _ ).

xsb_thread_join( ThreadId, ExitCode ) :-
	xsb_thread_join( ThreadId, ExitCode, _ ).
xsb_thread_join( ThreadId )	    :- xsb_thread_join( ThreadId, _, _ ).


xsb_thread_detach( ThreadId )	    :- xsb_thread_detach( ThreadId, _ ).

xsb_thread_self( ThreadId )	    :- xsb_thread_self( ThreadId, _ ).

xsb_mutex_init( MutexId )	:- xsb_mutex_init( MutexId, _ ).
xsb_mutex_init_np( Type, MutexId ) :-
				   xsb_mutex_init_np( Type, MutexId, _ ).
xsb_mutex_lock( MutexId )	:- xsb_mutex_lock( MutexId, _ ).
xsb_mutex_trylock( MutexId )	:- xsb_mutex_trylock( MutexId, _ ).
xsb_mutex_unlock( MutexId )	:- xsb_mutex_unlock( MutexId, _ ).
xsb_mutex_destroy( MutexId )	:- xsb_mutex_destroy( MutexId, _ ).


xsb_sys_mutex_lock( Id ) :- 
	thread_request( XSB_SYS_MUTEX_LOCK, Id, _, _, _ ).
xsb_sys_mutex_unlock( Id ) :- 
	thread_request( XSB_SYS_MUTEX_UNLOCK, Id, _, _, _ ).

xsb_thread_yield :- xsb_thread_yield(_).

/***************************************************************/

/* private predicate that runs a thread */

/***'_$thread_run'( Goal ) :- ts_init_tables, call(Goal), xsb_thread_exit(0,_).
'_$thread_run'( _ ) :- xsb_thread_exit(0,_).***/

'_$thread_run'( Goal ) :-
	ds_init_thread,
	ts_init_tables,
	(catch(call(Goal),Ball,default_error_handler(Ball)), xsb_thread_exit
	 ;
	 xsb_thread_exit
	).

/* store thread flag predicate in THREAD_RUN flag */

:- init_multi_threading.

init_multi_threading:- 
	term_psc('_$thread_run'(_), PSC), 
	stat_set_flag(THREAD_RUN, PSC).


/* System provided mutexes for users */

user_mutex( N, N1 ) :-
	N1 is N + MUTEX_USER1 - 1,
	N1 >= MUTEX_USER1,
	N1 < MAX_SYS_MUTEXES.

xsb_user_mutex_lock(N) :- user_mutex(N,N1), xsb_sys_mutex_lock(N1, Rc), 
			  Rc == 0, !.
xsb_user_mutex_lock(N) :- writeln(userout, 'Error trying to lock mutex '(N) ).

xsb_user_mutex_unlock(N) :- user_mutex(N,N1), xsb_sys_mutex_unlock(N1, Rc),
			  Rc == 0, !.
xsb_user_mutex_unlock(N) :- writeln(userout, 'Error trying to unlock mutex '(N) ).


/**************************************************************/

/** Thread specific assert and call **/

/* make_ts_goal transforms a goal into a thread specific term */

ts_prefix("$ts_").

make_ts_goal(Goal, TSGoal) :-
	xsb_thread_self(TID), name(TID, LTID),
	ts_prefix(LPrefix),
	append(LPrefix, LTID, LTSName ),
	name(TSName, LTSName),
	TSGoal =.. [TSName,Goal].

ts_assert( (G:-C) ) :-
	!,
        make_ts_goal(G, TSG),
	assert((TSG:-C)).
ts_assert( G ) :-
        make_ts_goal(G, TSG),
	assert(TSG).

ts_call( G ) :-
	make_ts_goal(G, TSG), call(TSG).

ts_abolish_table_call( G ) :-
	make_ts_goal(G, TSG),
	abolish_table_call(TSG).

ts_tnot( G ) :-
	make_ts_goal(G, TSG),
	tnot(TSG).

ts_init_tables :-
	xsb_sys_mutex_lock( MUTEX_TABLE ),
        make_ts_goal(_, TSG),
        functor(TSG,NameTSG,ArityTSG),
        table(NameTSG/ArityTSG),
        dynamic(NameTSG/ArityTSG),
	xsb_sys_mutex_unlock( MUTEX_TABLE ).

ts_abolish_tables :-
	make_ts_goal(_, TSPred),
	abolish_table_pred( TSPred ).
ts_abolish :-
	make_ts_goal(_, TSPred),
	abolish( TSPred ).

/****************************************************************/
/** DSW thread specific stuff

On entry each thread creates facts in global predicates, if not
already there:
ds_cvt_goal(#,GoalVar,TSGoalVar,_$ds_cvt_goal_#(GoalVar,TSGoalVar)).
ds_assert_goal(#,GoalVar,_$ds_assert_goal_#(GoalVar))
ds_table_goal(#,GoalVar,_$ds_table_goal_#(GoalVar))

And it creates the following (empty) thread-specific predicates:
_$ds_cvt_goal_#(Goal,DSGoal)
_$ds_assert_goal_#(Goal)
_$ds_table_goal_#(Goal)

It also initializes the global var my_thread_id to be the thread id of
the current thread.
*****************************************************************/
:- dynamic ds_cvt_goal(_,_,_,_).
:- dynamic ds_assert_goal(_,_,_).
:- dynamic ds_table_goal(_,_,_).

ds_init_thread :-
	xsb_thread_self(TID),
	globalvar(my_thread_id,TID),
	(ds_cvt_goal(TID,_,_,_)
	 ->	true
	 ;	concat_atom(['_$ds_cvt_goal_',TID],CvtGoalName),
		CvtGoal =.. [CvtGoalName,CGoal,DSGoal],
		assert(ds_cvt_goal(TID,CGoal,DSGoal,CvtGoal)),
		dynamic(CvtGoal)
	),
	(ds_assert_goal(TID,_,_)
	 ->	true
	 ;	concat_atom(['_$ds_assert_goal_',TID],AstGoalName),
		AstGoal =.. [AstGoalName,AGoal],
		assert(ds_assert_goal(TID,AGoal,AstGoal)),
		dynamic(AstGoal)
	),
	(ds_table_goal(TID,_,_)
	 ->	true
	 ;	concat_atom(['_$ds_table_goal_',TID],TabGoalName),
		TabGoal =.. [TabGoalName,TGoal],
		assert(ds_table_goal(TID,TGoal,TabGoal)),
		dynamic(TabGoal)
	).

make_ds_goal(Goal,TSGoal) :-
	globalvar(my_thread_id,TID),
	(var(TID)
	 ->	TSGoal = Goal
	 ;	ds_cvt_goal(TID,Goal,TSGoal,CvtGoal),
		(call_c(CvtGoal)
		 ->	true
		 ;	functor(Goal,Pred,Arity),
			concat_atom([Pred,'$ts$',TID],TSGoalName),
			functor(GGoal,Pred,Arity),
			GGoal =.. [Pred|VArgs],
			GTSGoal =.. [TSGoalName|VArgs],
			concat_atom(['_$ds_cvt_goal_',TID],TSCvtGoalName),
			TSCvtGoal =.. [TSCvtGoalName,GGoal,GTSGoal],
			assert(TSCvtGoal),
			call_c(CvtGoal)
		)
	).

ds_call(Goal) :-
	make_ds_goal(Goal,TSGoal),
	call_c(TSGoal).

ds_assert(Goal) :-
	(Goal = (Head:-Body)
	 ->	true
	 ;	Head = Goal,
		Body = true
	),
	make_ds_goal(Head,TSHead),
	globalvar(my_thread_id,TID),
	(var(TID)
	 ->	true
	 ;	ds_assert_goal(TID,TSHead,AssertGoalChk),
		(call_c(AssertGoalChk)
		 ->	true
		 ;	functor(TSHead,Pred,Arity),
			functor(GTSHead,Pred,Arity),
			ds_assert_goal(TID,GTSHead,AssertGoal),
			assert(AssertGoal)
		)
	),
	assert((TSHead:-Body)).

ds_retractall(Goal) :-
	make_ds_goal(Goal,TSGoal),
	globalvar(my_thread_id,TID),
	(var(TID)
	 ->	true
	 ;	ds_assert_goal(TID,TSGoal,AssertGoalChk),
		(call_c(AssertGoalChk)
		 ->	true
		 ;	functor(TSGoal,Pred,Arity),
			functor(GTSGoal,Pred,Arity),
			ds_assert_goal(TID,GTSGoal,AssertGoal),
			assert(AssertGoal)
		)
	),
	retractall(TSGoal).
	

ds_abolish_table_call(G) :-
	make_ds_goal(G, TSG),
	abolish_table_call(TSG).

ds_tnot(G) :-
	make_ds_goal(G,TSG),
	tnot(TSG).

ds_table_ds(PSpec) :-
	ds_table_ds(PSpec,_).

ds_table(PSpec) :-
	ds_table_ds(PSpec,Goal),
	ds_assert((Goal:-Goal)).

ds_table_ds(PSpec,Goal) :-
	(PSpec = Pred/Arity,nonvar(Pred)
	 ->	functor(Goal,Pred,Arity)
	 ;	functor(PSpec,Pred,Arity),
		functor(Goal,Pred,Arity)
	),
	make_ds_goal(Goal,TSGoal),
	globalvar(my_thread_id,TID),
	(var(TID)
	 ->	abolish(TSGoal),
		table(TSGoal),
		dynamic(TSGoal)
	 ;	ds_table_goal(TID,TSGoal,AssertGoal),
%%		writeln(userout,init_table(AssertGoal)),
		(call_c(AssertGoal)
		 ->	true
		 ;	assert(AssertGoal),
			abolish(TSGoal),
			table(TSGoal),
			dynamic(TSGoal)
		)
	).

ds_abolish_tables :-
	globalvar(my_thread_id,TID),
	nonvar(TID),
	ds_table_goal(TID,TabGoal,TabGoalCall),
	retract(TabGoalCall),
	abolish_table_pred(TabGoal),
	fail.
ds_abolish_tables.

ds_abolish :-
	globalvar(my_thread_id,TID),
	nonvar(TID),
	ds_assert_goal(TID,AstGoal,AstGoalCall),
	retract(AstGoalCall),
	abolish(AstGoal),
	fail.
ds_abolish.

/**************************************************************/

/** Higher level stuff **/

par_execute( GoalList ) :-
	par_spawn( GoalList, ThreadList ),
	par_wait( ThreadList ).

n_par_execute( Goal, N ) :-
	n_list( Goal, N, GoalList ),
	par_execute( GoalList ).

n_list( _, 0, [] ) :- !.
n_list( X, N, [X|L] ) :- N1 is N - 1, n_list( X, N1, L ).


par_spawn( [], [] ).
par_spawn( [G|GL], [T|TL] ) :- 
	xsb_thread_create( G, T ), par_spawn( GL, TL ).

par_wait( [] ).
par_wait( [T|L] ) :- xsb_thread_join(T), par_wait(L).

exmut_execute( G, M ) :-
	xsb_user_mutex_lock(M), G, !, xsb_user_mutex_unlock(M).
exmut_execute( _, M ) :- xsb_user_mutex_unlock(M).


console_exmut( G ) :- 
	xsb_user_mutex_lock(MUTEX_CONSOLE), 
	G, !, xsb_user_mutex_unlock(MUTEX_CONSOLE).
console_exmut( _ ) :- 
	xsb_user_mutex_unlock(MUTEX_CONSOLE).
