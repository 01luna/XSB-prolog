/* File:      tables.P
** Author(s): Terry Swift, Prasad Rao, Kostis Sagonas
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: tables.P,v 1.19 1999/10/26 06:47:57 kifer Exp $
** 
*/


/*----------------------------------------------------------------------*/
/* NOTE: This file HAS TO be compiled with the "sysmod" option.         */
/*----------------------------------------------------------------------*/

:- compiler_options([sysmod,xpp_on]).

#include "builtin.h"
#include "flag_defs_xsb.h"

/*----------------------------------------------------------------------*/

/* Change Evaluation Method for Tabled Predicate
   --------------------------------------------- */
variant(PredSpecList) :-
	is_list(PredSpecList),
	( member(PredSpec,PredSpecList),
	  set_tabled_eval_for_pred(PredSpec,VARIANT_EVAL_METHOD),
	  fail;
	  true ).

subsumptive(PredSpecList) :-
	is_list(PredSpecList),
	( member(PredSpec,PredSpecList),
	  set_tabled_eval_for_pred(PredSpec,SUBSUMPTIVE_EVAL_METHOD),
	  fail;
	  true ).

set_tabled_eval_for_pred(P/N,Method) :-
	functor(Term,P,N),
	set_tabled_eval(Term,Method).

set_tabled_eval(_Term,_Method) :- '_$builtin'(SET_TABLED_EVAL).

/*----------------------------------------------------------------------*/

table_state(Call, State) :-
	table_status(Call, Status),
	status_to_state(Status, State).

status_to_state(0, undef).
status_to_state(1, no_call_yet).
status_to_state(2, complete).
status_to_state(3, incomplete).

/*----------------------------------------------------------------------*/

tfindall(T, Call, Result) :-
	table_status(Call, Status),
	( Status =:= 2 -> findall(T,Call,Result)
	; Status =:= 1 -> (call(Call),fail ; tfindall(T,Call,Result))
	; Status =:= 3 ->
	        get_ptcp(PTCP), get_subgoal_ptr(Call, SubgPtr),
		is_incomplete(Call,SubgPtr,PTCP,_), findall(T,Call,Result)
        ; abort(['Illegal (untabled?) subgoal to tfindall/3: ', Call])
	).

tnot(X) :-
	( ground(X) -> 't not'(X)
	; abort(['FLOUNDERING: tnot/1 used with a non-ground subgoal: ', X])
	).

't not'(X) :-
	get_ptcp(PTCP), get_subgoal_ptr(X, SubgPtr),
	( SubgPtr =:= 0, tcall(X), fail
	; is_incomplete(X, SubgPtr, PTCP, Subg), slg_not(Subg)
	).

% skolemized tnot.  Variables temporarily changed to ground and tnot 
% call is made.  Should give prolog's semantics to nonground negative
% calls.

:- table tunnumcall/1.

sk_not(Goal) :-
	copy_term(Goal,Goal1),
	numbervars(Goal1,0,_),  % is now ground, so no check necessary
	't not'(tunnumcall(Goal1)).

tunnumcall(GGoal) :-
	unnumbervars(GGoal,VGoal),
	call(VGoal).


/*----------------------------------------------------------------------*/

abolish_all_tables :- 
	abolish_table_info.

abolish_table_pred(Spec) :-
	( Spec = F/A -> functor(Term,F,A) ; Term = Spec ),
	abolish_table_predicate(Term).

abolish_table_call(_Call) :- 	
	abort('Predicate abolish_table_call/1 is not yet implemented...').

/*----------------------------------------------------------------------*/
/* Predicates to retrieve information out of tables.                    */
/*----------------------------------------------------------------------*/

get_returns_for_call(Call, Return) :-  % Do NOT write (Call,Call) - WRONG !
	get_call(Call, C, R), get_returns(C, R), Return = Call.

get_calls_for_table(Skeleton, Call) :-
	functor(Skeleton,F,A), functor(Call,F,A),
	get_calls(Call, _CallStr, _RetSkel).

get_residual(CallSkel, DelayList) :-
	get_calls(CallSkel, S, R),
	get_returns_and_dls(S, R, DLs),
	( DLs == [] -> DelayList = []
	; DLs = [DL] -> DelayList = DL
	; member(DelayList, DLs)
	).

get_returns_and_dls(CallStr, RetSkel, DLs) :-
	get_returns(CallStr, RetSkel, Leaf),
	get_delay_lists(Leaf, DLs).

/* inline builtin #144 */
get_delay_lists(Leaf, DLs) :- get_delay_lists(Leaf, DLs).

get_call(Call, SubgoalPtr, RetSkel) :-
	get_subgoal_ptr(Call, SubgoalPtr), SubgoalPtr =\= 0,
	construct_ret_for_call(R), RetSkel = R.

get_calls(CallSkel, CallStrPtr, RetSkel) :-
	get_calls(CallSkel),
	get_lastnode_cs_retskel(_, CallStrPtr, RetSkel).

/* inline builtin #152 */
get_lastnode_cs_retskel(LastNode, CallStrPtr, RetSkel) :-
	get_lastnode_cs_retskel(LastNode, CallStrPtr, RetSkel).

/* Given the address of the call structure for a return trie (CallStr)
 * and a return skeleton (RetSkel), both as returned by get_calls/3, it
 * instantiates through backtracking the return skeleton, Retskel, for
 * all the returns in the specified trie.  If RetSkel is partially
 * instantiated, it returns only those answers that unify with it.
 * get_returns/3 returns in addition the leaf node of the return.
 * It can be passed to delete_return/2 (along with the CallStr) to
 * delete the return.
 */

get_returns(CallStr, RetSkel, Rleaf) :-
	get_returns(CallStr, RetSkel),
	get_lastnode_cs_retskel(Rleaf, _, _).

/*----------------------------------------------------------------------*/
/* delete_return(Cs,N) takes a call structure pointer in Cs (returned
 * by get_calls) and the address of a node that is a leaf of the return
 * trie pointed to by the call structure. (Such a node address is
 * returned by get_returns/3.)  It deletes the node and reclaims the
 * space.  There is a potential inefficiency problem in that it deletes
 * it from the chain of returns by running the chain, which may be long.
 *----------------------------------------------------------------------*/

delete_return(CallStr,AnsNode) :- trie_delete_branch_ret(AnsNode,CallStr,1).


/*----------------------------------------------------------------------*/
/* trie assert related predicates - I am not sure they are still needed */
/* probably kept just for backwards compatibility - Kostis.             */
/*----------------------------------------------------------------------*/

trie_dynamic(X) :- dynamic(X), add_trie_index(X).
trie_assert(Term) :- t_assert(Term, _Flag).
trie_assert(Term,Flag) :- t_assert(Term,Flag).
trie_retract(X) :- retract(X).
trie_retract_nr(X) :- retract_nr(X).
trie_retract_all(X) :- retractall(X).


/*======================================================================*/
/* builtins to get (and change) trie nodes - they belong somewhere else */
/*======================================================================*/

table_status(_Call,_Status) :- '_$builtin'(TABLE_STATUS).
abolish_table_predicate(_Term) :- '_$builtin'(ABOLISH_TABLE_PREDICATE).
trie_delete_branch_ret(_LeafNode,_Hook,_BranchOrRet) :-
	'_$builtin'(TRIE_DELETE_TERM).
get_returns(_CallStr,_RetSkel) :- '_$builtin'(TRIE_GET_RETURN).
get_calls(_CallSkel)  :- '_$builtin'(TRIE_GET_CALL).
construct_ret_for_call(_RetSkel) :- '_$builtin'(CONSTRUCT_RET_FOR_CALL).
force_truth_value(_AnsLeafNode, _TruthValue) :- '_$builtin'(FORCE_TRUTH_VALUE).

/* ------------------- end of file trie_tables.P ---------------------- */

