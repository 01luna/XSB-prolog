/* File:      tables.P
** Author(s): Swift, Rao, Sagonas
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: tables.P,v 1.9 1999/02/16 17:03:04 kostis Exp $
** 
*/


/*----------------------------------------------------------------------*/

zero_out_profile_table :-
	zero_out_profile.

write_out_profile_table :-
	write_out_profile.

abolish_all_tables :- 
	abolish_table_info.

/*----------------------------------------------------------------------*/

table_state(Call, State) :-
	table_status(Call, Status),
	status_to_state(Status, State).

status_to_state(0, undef).
status_to_state(1, no_call_yet).
status_to_state(2, complete).
status_to_state(3, incomplete).

tfindall(T, Call, Result) :-
	table_status(Call, Status),
	( Status =:= 2 -> findall(T,Call,Result)
	; Status =:= 1 -> (call(Call),fail ; tfindall(T,Call,Result))
	; Status =:= 3 ->
	        get_ptcp(PTCP), get_subgoal_ptr(Call, SubgPtr),
		is_incomplete(Call,SubgPtr,PTCP,_), findall(T,Call,Result)
        ; abort(('Illegal (untabled?) subgoal to tfindall/3: ', Call))
	).

tnot(X) :-
	( ground(X) -> 't not'(X)
	; functor(X,F,A),
	  abort(('FLOUNDERING: tnot/1 used with a non-ground subgoal of predicate ', F/A))
	).

't not'(X) :-
	get_ptcp(PTCP), get_subgoal_ptr(X, SubgPtr),
	( SubgPtr =:= 0, tcall(X), fail
	; is_incomplete(X, SubgPtr, PTCP, Subg), slg_not(Subg)
	).

etnot(X) :-
	get_ptcp(PTCP), get_osp_breg(Os, Breg),
	( call(X), cut_if_leader(X, Os, Breg), fail
	; is_incomplete(X, 0, PTCP, Subg), slg_not(Subg)
	).

/*----------------------------------------------------------------------*/

set_prof_on(Level) :-
	stat_set_flag(52,Level,1).

set_prof_off :-
	stat_set_flag(52,0,1).

set_pil_on :-
	stat_set_flag(0,1,1).

set_pil_off :-
	stat_set_flag(0,0,1).

/*----------------------------------------------------------------------*/

abolish_table_call(Call) :- 	
	call_psc_tip(Call,_Psc,Tip),
	get_subgoal_ptr(Call,SubgPtr),
        ( SubgPtr =:= 0 ->
            	true
        ; call_struct_disp(call_leaf_ptr,LeafDisp),
	  buff_word(SubgPtr,LeafDisp,CallLeafNode),
	  trie_node_element(CallLeafNode,Child),
	  new_node(NewNode),
	  trie_node_disp(child,ChildDisp),
	  buff_set_word(NewNode,ChildDisp,Child),
	  trie_node_disp(atom,AtomDisp),
	  get_emu_dependent_const(escape,Escape),
	  buff_set_word(NewNode,AtomDisp,Escape),
	  delete_predicate_table(NewNode), % Using the routine in a diff way
	  tip_struct_disp(call_trie_root,CallRootDisp),
	  CallRootPtr is Tip + CallRootDisp,
	  trie_delete_branch(CallLeafNode,CallRootPtr)
	).

abolish_table_pred(Spec) :-
	(Spec = F/A
	 ->	functor(Term,F,A)
	 ;	Term = Spec
	),
	conpsc(Term,Psc),
	psc_tabled(Psc,Tip),
	(Tip =:= 0
	 ->	abort('Error: Cannot abolish table of predicate not tabled')
	 ;	tip_struct_disp(call_trie_root,Rootd),
		buff_word(Tip,Rootd,CallRoot),
		tip_prop(Tip,1,1,0),		% 1(tab_entry),1(set), to 0
		(CallRoot =:= 0
		 ->	true
		 ;	delete_predicate_table(CallRoot)
		)
	).


get_returns_for_call(Call,Return) :-  % Do NOT write (Call,Call) !
	get_call(Call,C,R), get_returns(C,R), Return = Call.

/* OLD get_returns_for_call/2
   should actually be called get_returns_for_subsumed_call/2.

:- import copy_term/2 from basics.
:- import arg/3 from standard.
:- import variant/2 from subsumes.

get_returns_for_call(Call,Return) :-
	copy_term(Call,Ocall),
	get_calls(Call,CallStr,RetSkel),
	variant(Call,Ocall),	% subsuming call
	\+ not_most_general(RetSkel),	% subsumed call, so variant
	Call = Return,		% bind vars to use in retrieval
	get_returns(CallStr,RetSkel).

not_most_general(Term) :-
	functor(Term,_,Arity),
	not_most_gen(Term,1,Arity).

not_most_gen(Term,I,Arity) :-
	I =< Arity,
	arg(I,Term,Arg),
	(nonvar(Arg)
	 ->	true
	 ;	Arg = ground,
		I1 is I+1,
		not_most_gen(Term,I1,Arity)
	).

*/

get_calls_for_table(Skeleton,Call) :-
	functor(Skeleton,F,A), functor(Call,F,A),
	get_calls(Call,_CallStr,_RetSkel).

call_psc_tip(Call,Psc,Tip) :-
	conpsc(Call,Psc),
	psc_tabled(Psc,Tip),
	(Tip =\= 0 -> true; writeln(Call),writeln(':is not tabled'),fail).

/*----------------------------------------------------------------------*/
/* Predicates to retrieve information out of tables.                    */
/*----------------------------------------------------------------------*/

get_residual(CallSkel, DelayList) :-
	get_calls(CallSkel, S, R),
	get_returns_and_dls(S, R, DLs),
	( DLs == [] -> DelayList = []
	; DLs = [DL] -> DelayList = DL
	; member(DelayList, DLs)
	).

get_returns_and_dls(CallStr, RetSkel, DLs) :-
	get_returns(CallStr, RetSkel, Leaf),
	get_delay_lists(Leaf, DLs).

/* inline builtin #144 */
get_delay_lists(Leaf, DLs) :- get_delay_lists(Leaf, DLs).

get_call(Call,SubgoalPtr,RetSkel) :-
	get_subgoal_ptr(Call,SubgoalPtr), SubgoalPtr =\= 0,
	construct_ret_for_call(R), RetSkel = R.

get_calls(CallSkel,CallStrPtr,RetSkel) :-
	get_calls(CallSkel),
	get_lastnode_cs_retskel(_, CallStrPtr, RetSkel).

/* inline builtin #152 */
get_lastnode_cs_retskel(LastNode, CallStrPtr, RetSkel) :-
	get_lastnode_cs_retskel(LastNode, CallStrPtr, RetSkel).

/* Given the address of the call structure for a return trie (CallStr)
 * and a return skeleton (RetSkel), both as returned by get_calls/3, it
 * instantiates through backtracking the return skeleton, Retskel, for
 * all the returns in the specified trie.  If RetSkel is partially
 * instantiated, it returns only those answers that unify with it.
 * get_returns/3 returns in addition the leaf node of the return.
 * It can be passed to delete_return/2 (along with the CallStr) to
 * delete the return.
 */

get_returns(CallStr,RetSkel,Rleaf) :-
	get_returns(CallStr,RetSkel),
	get_lastnode_cs_retskel(Rleaf, _, _).

/* delete_return(Cs,N) takes a call structure pointer in Cs (returned
 * by get_calls) and the address of a node that is a leaf of the return
 * trie pointed to by the call structure. (Such a node address is
 * returned by get_returns/3.)  It deletes the node and reclaims the
 * space.  There is a potential inefficiency problem in that it deletes
 * it from the chain of returns by running the chain, which may be long.
 *
 * trie_delete_branch/2 brutally deletes a term from the trie...
 */

trie_delete_branch(A,B) :- trie_delete_branch_ret(A,B,0).

delete_return(CallStr,AnsNode) :- trie_delete_branch_ret(AnsNode,CallStr,1).


/*----------------------------------------------------------------------*/
/* trie assert related predicates                                       */
/*----------------------------------------------------------------------*/

is_trie_asserted(Term) :- trie_asserted_fact(Term,_Psc,_Ep,_Rn).
trie_dynamic(X) :- dynamic(X), add_trie_index(X).
trie_assert(Term) :- t_assert(Term, _Flag).
trie_assert(Term,Flag) :- t_assert(Term,Flag).
trie_retract(X) :- retract(X).
trie_retract_nr(X) :- retract_nr(X).
trie_retract_all(X) :- retractall(X).

abolish_trie_asserted(Functor/Arity) :-
	functor(Term,Functor,Arity),
	trie_asserted_fact(Term,Psc,_Ep,Rn),
	psc_struct_disp(ep,Epdisp),
	buff_set_word(Psc,Epdisp,0), 
	psc_struct_disp(entry_type,Typedisp),
	buff_set_byte(Psc,Typedisp,0),
	delete_predicate_table(Rn).

trie_asserted_fact(Term,Psc,Eptr,RootNode) :-
	conpsc(Term,Psc),
	Psc =\= 0,
	psc_struct_disp(ep,Epdisp),
	buff_word(Psc,Epdisp,Eptr),
	Eptr =\= 0,
	buff_byte(Eptr,0,Instr),
	wam_opcode(trie_assert,TrInstr),
	Instr = TrInstr,
	trie_node_disp(child,ChildDisp),
	buff_word(Eptr,ChildDisp,RootNode).

/*----------------------------------------------------------------------*/
/* aggregate stuff                                                      */
/*----------------------------------------------------------------------*/

breg_retskel(_BregOffset,_Arity,_RetTerm,_SubgoalPtr) :- '_$builtin'(154).

/*======================================================================*/
/* builtins to get (and change) trie nodes - they belong somewhere else */
/*======================================================================*/

trie_node_element(_N,_Child) :- '_$builtin'(140).
new_node(_N) :- '_$builtin'(141).
table_status(_Call,_Status) :- '_$builtin'(143).
delete_predicate_table(_N) :- '_$builtin'(145).
trie_delete_branch_ret(_LeafNode,_Hook,_BranchOrRet) :- '_$builtin'(149).
get_returns(_CallStr,_RetSkel) :- '_$builtin'(150).
get_calls(_CallSkel)  :- '_$builtin'(151).
construct_ret_for_call(_RetSkel) :- '_$builtin'(153).
force_truth_value(_AnsLeafNode, _TruthValue) :- '_$builtin'(254).

/*======================================================================*/
/*  Emulator-dependent constants (make sure they are kept up-to-date).	*/
/*======================================================================*/

% C structure definitions:
% call structure
%-------------------------
call_struct_disp(next_subgoal,0).
call_struct_disp(ans_root_ptr,4).
call_struct_disp(asf_list_ptr,8).
call_struct_disp(tip_ptr,12).
call_struct_disp(compl_stack_ptr,16).
call_struct_disp(compl_susp_ptr,20).
call_struct_disp(ans_list_ptr,24).
call_struct_disp(prev_subg_ptr,28).
call_struct_disp(call_leaf_ptr,32).
call_struct_disp(cp_ptr,36).
call_struct_disp(ans_list_tail,40).
call_struct_disp(compl_flag,44).
call_struct_disp(nide,48).

% table information structure
%----------------------------
tip_struct_disp(next_tip,0).
tip_struct_disp(call_trie_root,4).

% Trie node structure
%--------------------
trie_node_disp(sibling,4).
trie_node_disp(child,8).
trie_node_disp(parent,12).
trie_node_disp(atom,16).

% Psc structure 
%--------------
psc_struct_disp(entry_type,1).
psc_struct_disp(ep,8).

% WAM opcodes
%------------
wam_opcode(trie_assert,124).

/* ------------------- end of file trie_tables.P ---------------------- */

