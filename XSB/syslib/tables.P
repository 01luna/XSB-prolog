/* File:      tables.P
** Author(s): Terry Swift, Prasad Rao, Kostis Sagonas
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1993-1998
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: tables.P,v 1.25 2000/06/05 00:54:12 kifer Exp $
** 
*/


/*----------------------------------------------------------------------*/
/* NOTE: This file HAS TO be compiled with the "sysmod" option.         */
/*----------------------------------------------------------------------*/

:- compiler_options([sysmod,xpp_on]).

#include "builtin.h"
#include "table_status_defs.h"

/*----------------------------------------------------------------------*/

/* Change Evaluation Method for Tabled Predicate
   --------------------------------------------- */
use_variant_tabling(CommaList) :-
	set_eval_method_for_comma(CommaList,VARIANT_EVAL_METHOD).

use_subsumptive_tabling(CommaList) :-
	set_eval_method_for_comma(CommaList,SUBSUMPTIVE_EVAL_METHOD).

set_eval_method_for_comma((PS1,PS2),EvalMethod) :-
	!, set_eval_method_for_comma(PS1,EvalMethod),
	set_eval_method_for_comma(PS2,EvalMethod).
set_eval_method_for_comma(PredSpec,EvalMethod) :-
	set_tabled_eval_for_pred(PredSpec,EvalMethod).

/*
 * Setting of the evaluation method will fail if calls exist in the
 * Call Trie.
 */
set_tabled_eval_for_pred(PredSpec,Method) :-
	( PredSpec = P/N -> functor(Term,P,N); Term = PredSpec ),
	( set_tabled_eval(Term,Method), fail; true ).

set_tabled_eval(_Term,_Method) :- '_$builtin'(SET_TABLED_EVAL).

/*----------------------------------------------------------------------*/

/*
 * To obtain info about both subsumptive and variant predicates.
 * See the file ../emu/builtin.c for a description of the valid
 * combinations of values for PredType, CallType, and AnsSetStatus.
 */

table_state(Call, PredType, CallType, AnsSetStatus) :-
	table_status(Call,PredTypeCode,CallTypeCode,AnsSetStatusCode),
	predicate_type_code(PredTypeCode,PredType),
	call_type_code(CallTypeCode,CallType),
	answer_set_status_code(AnsSetStatusCode,AnsSetStatus).


table_status(Call,PredType,CallType,AnsSetStatus) :-
	table_status(Call,PredType,CallType,AnsSetStatus).

predicate_type_code(UNTABLED_PREDICATE,      undefined).
predicate_type_code(VARIANT_EVAL_METHOD,     variant).
predicate_type_code(SUBSUMPTIVE_EVAL_METHOD, subsumptive).

call_type_code(UNDEFINED_CALL, undefined).
call_type_code(PRODUCER_CALL,  producer).
call_type_code(SUBSUMED_CALL,  subsumed).
call_type_code(NO_CALL_ENTRY,  no_entry).

answer_set_status_code(UNDEFINED_ANSWER_SET,  undefined).
answer_set_status_code(COMPLETED_ANSWER_SET,  complete).
answer_set_status_code(INCOMPLETE_ANSWER_SET, incomplete).


/*
 * For [temporary] backward compatibility, redefine table_state/2 in
 * terms of the newer table_state/4.
 */

table_state(Call, State) :-
	table_state(Call, PredType, _CallType, AnsSetStatus),
	( PredType == variant ->
	  ( AnsSetStatus == undefined
	    -> State = no_call_yet
	    ;  State = AnsSetStatus
	  )
	; PredType == undefined -> State = undef
	).

/*----------------------------------------------------------------------*/

/*
 * Temporarily abort computations on subsumptive predicates by
 * standard predicates that utilize, or provide, negation.
 */

:- import warning/1 from standard.

tfindall(T, Call, Result) :-
	table_state(Call,PredType,_CallType,AnsSetStatus),
	( PredType == variant ->
	  ( AnsSetStatus == complete -> findall(T,Call,Result)
	  ; AnsSetStatus == undefined ->
		(call(Call), fail ; tfindall(T,Call,Result))
	  ; AnsSetStatus == incomplete ->
	        get_ptcp(PTCP), get_subgoal_ptr(Call, SubgPtr),
		is_incomplete(Call,SubgPtr,PTCP,_), findall(T,Call,Result)
	  )
        ; PredType == subsumptive ->
	  ( warning(('tfindall/3 does not yet fully support subsumptive',
	             ' predicates.')),
	    ( AnsSetStatus == complete ->
		warning((Call, ' answer set is complete; continuing...')),
		findall(T,Call,Result)
	    ; abort([' ', Call,
	             'answer set is not complete; cannot continue.'])
	    )
	  )
        ; abort(['Illegal (untabled?) subgoal to tfindall/3: ', Call])
	).


tnot(Goal) :-
	ground(Goal)
	 -> 't not'(Goal)
	;   abort(['FLOUNDERING: tnot/1 used with a non-ground subgoal: ',
		   Goal]).

't not'(Goal) :-
	table_state(Goal,PredType,_CallType,_AnsSetStatus),
	( PredType == subsumptive ->
	  abort(['Negation of subsumptive predicates currently',
	         'not supported.'])
	; get_ptcp(PTCP), get_subgoal_ptr(Goal, SubgPtr),
	  ( SubgPtr =:= 0, tcall(Goal), fail
	  ; is_incomplete(Goal, SubgPtr, PTCP, Subg), slg_not(Subg)
	  )
	).
	
%% skolemized tnot.  Variables temporarily changed to ground and tnot 
%% call is made.  Should give existential semantics to nonground negative
%% calls. That is: ...:- sk_not(p(X)),... is like
%%  ... :- tnot(pp),...
%%  pp :- p(X).
%% where pp is a new proposition.

:- table tunnumcall/1.
:- use_variant_tabling tunnumcall(_).

sk_not(Goal) :-
	copy_term(Goal,Goal1),
	numbervars(Goal1,0,_),  % is now ground, so no check necessary
	't not'(tunnumcall(Goal1)).

tunnumcall(GGoal) :-
	unnumbervars(GGoal,VGoal),
	call(VGoal).


/*----------------------------------------------------------------------*/

abolish_all_tables :- 
	abolish_table_info.

abolish_table_pred(Spec) :-
	( Spec = F/A -> functor(Term,F,A) ; Term = Spec ),
	abolish_table_predicate(Term).

abolish_table_call(_Call) :- 	
	abort('Predicate abolish_table_call/1 is not yet implemented...').

/*----------------------------------------------------------------------*/
/* Predicates to retrieve information out of tables.                    */
/*----------------------------------------------------------------------*/

/*
 * get_call(+Call, -SubgoalPtr, -RetSkel)
 *   Interpretive traversal of a Call Trie looking for call Call.
 *   If Call is present, then SubgoalPtr is returned as a handle to this
 *   table entry, and RetSkel is the Answer Template for retrieving the
 *   answers of Call.
 */

get_call(Call, SubgoalPtr, RetSkel) :- get_call(Call, SubgoalPtr, RetSkel).


/*
 * get_calls(+CallSkel, -SubgoalPtr, -RetSkel)
 *   Trie-code traversal of a Call Trie; selects paths that unify with
 *   CallSkel through backtracking.  Each successful unification returns
 *   a handle to this table entry in SubgoalPtr and the Answer Template,
 *   needed for retrieving the answers of this entry, in RetSkel.
 */

get_calls(CallSkel, SubgoalPtr, RetSkel) :-
	findall(p(CallSkel,SubgoalPtr,RetSkel),
		( get_calls(CallSkel),
		  get_lastnode_cs_retskel(CallSkel, _, SubgoalPtr, RetSkel)
		),
		List),
	member(p(CallSkel,SubgoalPtr,RetSkel),List).


/*
 * get_calls_for_table(+Skeleton, -Call)
 *   Only the predicate information of Skeleton is used to identify the
 *   table from which all calls are enumerated through backtracking and
 *   returned in Call.
 */

get_calls_for_table(Skeleton, Call) :-
	functor(Skeleton,F,A), functor(Call,F,A),
	get_calls(Call, _CallStr, _RetSkel).


/* inline builtin #152 */
get_lastnode_cs_retskel(CallTerm, LastNode, SubgoalPtr, RetSkel) :-
	get_lastnode_cs_retskel(CallTerm, LastNode, SubgoalPtr, RetSkel).


get_returns_for_call(Call, Return) :-  % Do NOT write (Call,Call) - WRONG !
	get_call(Call, C, R), get_returns(C, R), Return = Call.

get_residual(CallSkel, DelayList) :-
	get_calls(CallSkel, S, R),
	get_returns_and_dls(S, R, DLs),
	( DLs == [] -> DelayList = []
	; DLs = [DL] -> DelayList = DL
	; member(DelayList, DLs)
	).

get_returns_and_dls(CallStr, RetSkel, DLs) :-
	findall((CallStr,RetSkel,DLs),
		(
		    get_returns(CallStr,RetSkel),
		    get_lastnode_cs_retskel(_,Leaf,_,_),
		    get_delay_lists(Leaf,DLs)
		),
		L),
	member((CallStr,RetSkel,DLs),L).
%	get_returns(CallStr, RetSkel, Leaf),
%	get_delay_lists(Leaf, DLs).

/* inline builtin #144 */
get_delay_lists(Leaf, DLs) :- get_delay_lists(Leaf, DLs).

/* Given the address of the call structure for a return trie (CallStr)
 * and a return skeleton (RetSkel), both as returned by get_calls/3, it
 * instantiates through backtracking the return skeleton, Retskel, for
 * all the returns in the specified trie.  If RetSkel is partially
 * instantiated, it returns only those answers that unify with it.
 * get_returns/3 returns in addition the leaf node of the return.
 * It can be passed to delete_return/2 (along with the CallStr) to
 * delete the return.
 */

get_returns(CallStr, RetSkel, Rleaf) :-
	findall(p(CallStr,RetSkel,Rleaf), (get_returns(CallStr,RetSkel),
			       get_lastnode_cs_retskel(_,Rleaf,_,_)
			   ),
		List),
	member(p(CallStr,RetSkel,Rleaf),List).

/*----------------------------------------------------------------------*/
/* delete_return(Cs,N) takes a call structure pointer in Cs (returned
 * by get_calls) and the address of a node that is a leaf of the return
 * trie pointed to by the call structure. (Such a node address is
 * returned by get_returns/3.)  It deletes the node and reclaims the
 * space.  There is a potential inefficiency problem in that it deletes
 * it from the chain of returns by running the chain, which may be long.
 *----------------------------------------------------------------------*/

delete_return(CallStr,AnsNode) :- trie_delete_branch_ret(AnsNode,CallStr,1).


/*----------------------------------------------------------------------*/
/* trie assert related predicates - I am not sure they are still needed */
/* probably kept just for backwards compatibility - Kostis.             */
/*----------------------------------------------------------------------*/

trie_dynamic(X) :- dynamic(X), add_trie_index(X).
trie_assert(Term) :- t_assert(Term, _Flag).
trie_assert(Term,Flag) :- t_assert(Term,Flag).
trie_retract(X) :- retract(X).
trie_retract_nr(X) :- retract_nr(X).
trie_retract_all(X) :- retractall(X).


/*======================================================================*/
/* builtins to get (and change) trie nodes - they belong somewhere else */
/*======================================================================*/

abolish_table_predicate(_Term) :- '_$builtin'(ABOLISH_TABLE_PREDICATE).
trie_delete_branch_ret(_LeafNode,_Hook,_BranchOrRet) :-
	'_$builtin'(TRIE_DELETE_TERM).

get_returns(_CallStr,_RetSkel) :- '_$builtin'(TRIE_GET_RETURN).
get_calls(_CallSkel)  :- '_$builtin'(TRIE_UNIFY_CALL).
force_truth_value(_AnsLeafNode, _TruthValue) :- '_$builtin'(FORCE_TRUTH_VALUE).

/* ---------------------- end of file tables.P ------------------------ */


