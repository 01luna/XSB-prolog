% :- compiler_options([ciao_directives]).

% :- export fix_ms_equals/1, csv_process/2.
% :- export in_delimited_file/3, in_delimited_file_codes/3.
% :- export dehyphenate/2.
% :- export ca/2, ca_list/2.
% :- export special_char/1.
% :- export upper_case/2, letter_or_digit/1, whitespace/1.
% :- export upper_case_codes/2, upper_case_atom/2, upper_case_atom_list/2,
% 	upper_case_term/2, upper_case_term_list/2.
% :- export digit/1, letter/1.
% :- export single_letter/1.
% :- export std_field/3.
% :- export inst_positions/3.
% :- export cvt_delimited_file/4.
% :- export cvt_delimited_file_and_number/4.
% :- export cvt_fixed_file/4.
% :- export cvt_csv_file/3.

% :- export card_int_num/3, general_number/3, some_words/3, read_till_pipe/3.
% :- export opt/3, any_words/3.
% :- export parselisp/2.
% :- export scan_lisp/3.
% :- export unfix/2, unfix_term/2.
% :- export if_predicate_defined/1.
% :- export create_counter/1, create_counter/2, increment_counter/1,
% 	increment_counter/2, decrement_counter/1, set_counter/2,
% 	value_of_counter/2.
% :- export count_solutions/2.
% :- export load_predicate_from_file/3.

% :- export cvt_fedlog_ncp_to_delimited_file/3.
% :- export parse_unquoted/2.

% :- export alphanumeric_part_std/2.
% :- export trim_lead_blanks/2, trim_trail_blanks/2, trim_blanks/2,trim_eol/2.

% :- export file_name_split/4.

% :- export apply_lambda_fast/2, apply_lambda_fast/3,
% 	apply_lambda_fast/4, apply_lambda_fast/5, apply_lambda_fast/6.
% :- export apply_lambda/2, apply_lambda/3, apply_lambda/4,
% 	apply_lambda/5, apply_lambda/6.


% :- import file_read_line_list/2, file_open/3, file_close/1 from file_io.
% :- import concat_atom/3 from string.
% :- import super_tokenize/3 from stdsupertok.
% :- import append/3, reverse/2, memberchk/2 from basics.
% :- import warning/1 from standard.
% :- import psc_type/2, term_psc/2, call0/1 from machine.

% % This predicate is useful to read into Prolog files with in Microsoft
% % "CSV" or "comma delimited" format.  This format puts a comma between
% % each field, and if that field contains a comma itself, double-quotes the
% % field. 
% % e.g. the tab delimited line
% % 	Microsoft	sure 	stinks,I believe
% % becomes
% % 	Microsoft,sure,"stinks,I believe"

% csv_process(Functor,File):- 
% 	file_open(File,read,Stream),
% 	csv_process_1(Functor,Stream),
% 	file_close(Stream).


% csv_process_1(Functor,Stream):- 
% 	repeat,
% 	(file_read_line_list(Stream,List) -> 
% 		break_into_code_fields(Stream,CodeFields,List,44),
% 		atom_codes_list(Tokenlist,CodeFields),
% 		Term =.. [Functor|Tokenlist],
% 		writeq(Term),writeln('.'),
% 		Succeeded = true
% 	 ; true,Succeeded = false),
% 	Succeeded = false.

% /*********************
% csv_parse(_,[],[]).
% csv_parse(Stream,Inlist,[Token|Outlist]):- 
% 	csv_parse_1(Stream,Inlist,Token,Midlist),
% 	csv_parse(Stream,Midlist,Outlist).

% csv_parse_1(Stream,[34|Rest],Token,Remaining):-!,
% 	csv_parse_quoted(Stream,Rest,List,Remaining),
% 	atom_codes(Token,List).
% csv_parse_1(_,Rest,Token,Remaining):-!,
% 	csv_parse_unquoted(Rest,List,Remaining),
% 	atom_codes(Token,List).

% csv_parse_quoted(Stream,[13,10],[13,10|TRest],Out):-!,
% 	(file_read_line_list(Stream,NextLine)
% 	 ->	csv_parse_quoted(Stream,NextLine,TRest,Out)
% 	 ;	warning(('Unexpected end-of-file')),
% 		TRest=[],
% 		Out=[]
% 	).

% csv_parse_quoted(Stream,[10],[10|TRest],Out):-!,
% 	(file_read_line_list(Stream,NextLine)
% 	 ->	csv_parse_quoted(Stream,NextLine,TRest,Out)
% 	 ;	warning(('Unexpected end-of-file')),
% 		TRest=[],
% 		Out=[]
% 	).
	
% csv_parse_quoted(_,[34,13,10],[],[]):-!.
% csv_parse_quoted(_,[34,10],[],[]):-!.
% csv_parse_quoted(_,[34,44|Rest],[],Rest):-!.
% csv_parse_quoted(Stream,[34,34|Rest],[34|Trest],Out):-!,
% 	csv_parse_quoted(Stream,Rest,Trest,Out).

% csv_parse_quoted(Stream,[H|Rest],[H|Trest],Out):-
% 	(H=:=34
% 	 ->	warning(('Expecting comma or end-of-line after quote')),
% 		csv_parse_unquoted(Rest,Trest,Out)
% 	 ;	csv_parse_quoted(Stream,Rest,Trest,Out)
% 	).
	
% csv_parse_unquoted([13,10],[],[]):-!.
% csv_parse_unquoted([10],[],[]):-!.
% csv_parse_unquoted([44],[],[]):-!.
% csv_parse_unquoted([44|Rest],[],Rest):-!.
% csv_parse_unquoted([H|Rest],[H|Trest],Out):-
% 	csv_parse_unquoted(Rest,Trest,Out).
% ************************/





% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % This predicate is useful to read into Prolog files with  Microsoft output 
% % format in which lines have a fixed maximal length and line overruns
% % are signalled be making the last character of a line an '=', 
% % e.g. 	          xxxxxx=
% %                 xxx
% %---
% fix_ms_equals(Infile):-
% 	file_open(Infile,read,Istr),
% 	repeat,
% 	(file_read_line_list(Istr,Line)
% 	 -> get_ms_equals_output_line(Istr,Line,Lineout),
% 	    atom_codes(Output,Lineout),
% 	    write(Output),
% 	    Flag = true
% 	    ;  Flag = false),
% 	Flag == false,	
% 	file_close(Istr).

% get_ms_equals_output_line(Istr,Line,Lineout):- 
% 	is_tail(Line,[61,10],Line1),!,
% 	file_read_line_list(Istr,Line2),
% 	get_ms_equals_output_line(Istr,Line2,Linemid),
% 	append(Line1,Linemid,Lineout).
% get_ms_equals_output_line(_Istr,Line,Line).

% is_tail(L,L,[]).
% is_tail([H|T],L,[H|T1]):-
% 	is_tail(T,L,T1).

% %%%%%%%%%%%%%%%%
% % backtrack through a file with delimited fixed number of fields,
% % returning atoms
% % in_delimited_file(+FileName,+DelimCode,-ResultAtomList)
% in_delimited_file(File,Delim,Fields) :-
% 	(atom(Delim)
% 	 ->	atom_codes(Delim,[DelimC])
% 	 ;	DelimC = Delim
% 	),
% 	in_delimited_file_codes1(File,DelimC,CodeFields),
% 	atom_codes_list(Fields,CodeFields).

% atom_codes_list([],[]).
% atom_codes_list([Atom|Atoms],[Code|Codes]) :-
% 	atom_codes(Atom,Code),
% 	atom_codes_list(Atoms,Codes).

% %%%%%%%%%%%%%%%%
% % Used for reading the title line - only the fields of the first line
% %
% :- export read_first_delim_line/3.
% read_first_delim_line(File,Delim,Fields):-
% 	(atom(Delim)
% 	 ->	atom_codes(Delim,[DelimC])
% 	 ;	DelimC = Delim
% 	),
% 	file_open(File,read,Stream),
% 	(file_read_line_list(Stream,Line)
% 	 ->	break_into_code_fields(Stream,CodeFields,Line,DelimC)
% 	 ;	CodeFields=[]
% 	),
% 	file_close(Stream),
% 	atom_codes_list(Fields,CodeFields).

% %%%%%%%%%%%%%%%%
% % backtrack through a file with delimited fixed number of fields,
% % returning lists of codes
% % in_delimited_file_codes1(+FileName,+DelimCode,-ResultCodesList)
% in_delimited_file_codes(File,Delim,CodeFields) :-
% 	(atom(Delim)
% 	 ->	atom_codes(Delim,[DelimC])
% 	 ;	DelimC = Delim
% 	),
% 	in_delimited_file_codes1(File,DelimC,CodeFields).

% in_delimited_file_codes1(File,Delim,CodeFields) :-
% 	file_open(File,read,Stream),
% 	repeat,	
% 	(file_read_line_list(Stream,Line)
% 	 ->	break_into_code_fields(Stream,CodeFields,Line,Delim)
% 	 ;	!,
% 		file_close(Stream),
% 		fail
% 	).	

% break_into_code_fields(_,[],[],_) :- !.
% break_into_code_fields(Stream,[Field|Fields],Line,Delim) :-
% 	next_code_field(Stream,Line,Delim,Field,Rest),
% 	break_into_code_fields(Stream,Fields,Rest,Delim).


% next_code_field(_,[],_,[],[]).
% next_code_field(Stream,[34|Cs],Delim,Field,Rest) :-!,
% 	 delim_parse_quoted(Stream,Cs,Delim,Field,Rest).
% next_code_field(_,Cs,Delim,Field,Rest) :-!,
% 	 delim_parse_unquoted(Cs,Delim,Field,Rest).

% delim_parse_quoted(Stream,[13,10],Delim,[13,10|TRest],Out):-!,
% 	(file_read_line_list(Stream,NextLine)
% 	 ->
% 	 delim_parse_quoted(Stream,NextLine,Delim,TRest,Out)
% 	 ;
% 	 warning(('Unexpected end-of-file')),
% 	 TRest=[],
% 	 Out=[]).
% delim_parse_quoted(Stream,[10],Delim,[10|TRest],Out):-!,
% 	(file_read_line_list(Stream,NextLine)
% 	 ->
% 	 delim_parse_quoted(Stream,NextLine,Delim,TRest,Out)
% 	 ;
% 	 warning(('Unexpected end-of-file')),
% 	 TRest=[],
% 	 Out=[]).
% delim_parse_quoted(_,[34,13,10],_,[],[]):-!.
% delim_parse_quoted(_,[34,10],_,[],[]):-!.
% delim_parse_quoted(_,[34,Delim|Rest],Delim,[],Rest):-!.
% delim_parse_quoted(Stream,[34,34|Rest],Delim,[34|Trest],Out):-!,
% 	delim_parse_quoted(Stream,Rest,Delim,Trest,Out).
% delim_parse_quoted(Stream,[H|Rest],Delim,[H|Trest],Out):-
% 	(H=:=34
% 	 ->	atom_codes(D,[Delim]),
% 		atom_codes(RestAtom,Rest),
% 	        warning(('Expecting ',D,' or end-of-line after quote, found: ',RestAtom)),
% 		delim_parse_unquoted(Rest,Delim,Trest,Out)
% 	 ;	delim_parse_quoted(Stream,Rest,Delim,Trest,Out)
% 	).



% delim_parse_unquoted([],_,[],[]):-!.  %% change
% delim_parse_unquoted([13,10],_,[],[]):-!.
% delim_parse_unquoted([10],_,[],[]):-!.
% %%delim_parse_unquoted([Delim],Delim,[],[]):-!.
% delim_parse_unquoted([Delim|Rest],Delim,[],Rest):-!.
% delim_parse_unquoted([H|Rest],Delim,[H|Trest],Out):-
% 	delim_parse_unquoted(Rest,Delim,Trest,Out).

% /*
% next_code_field([C|Cs],Delim,Field,Rest) :-
% 	(C < 15		% ignore codes under 15, e.g. nl, cr,...
% 	 ->	next_code_field(Cs,Delim,Field,Rest)
% 	 ; C =:= Delim
% 	 ->	Field = [],
% 		Rest = Cs
% 	 ;	Field = [C|Cso],
% 		next_code_field(Cs,Delim,Cso,Rest)
% 	).
% */


% %%%%%%%%%%%%%%%%
% % necessary for compatability of Amersham and Newark.
% dehyphenate(In,Out):- is_list(In) -> dehyphenate1(In,Out) ; In = Out.
% dehyphenate1([],[]).
% dehyphenate1([-|R],R1):-!,
% 	dehyphenate1(R,R1).
% dehyphenate1([H|R],[H|R1]):- 
% 	dehyphenate1(R,R1).

% %%%%%%%%%%%%%%%%
% ca_list([],[]).
% ca_list([H|T],[H1|T1]):-
% 	(ca(H,H1) ; H1 = H),!,
% 	ca_list(T,T1).

% %%%%%%%%%%%%%%%%
% ca(In,Out):-
% 	ca_1(In,Mid),
% 	concat_atom(Mid,' ',Out).

% ca_1([],[]):-!.
% ca_1([''|T],T1):-!,
% 	ca_1(T,T1).
% ca_1([H|T],[H1|T1]):-!,
% 	(functor(H,_,1) -> arg(1,H,H1) ;  H1 = H),
%         ca_1(T,T1).
% ca_1('',[]):- !.
% ca_1(H,[H]):- atom(H).

% % uppercase
% upper_case(Ci,Co) :-
% 	(Ci >= 0'a, Ci =< 122
% 	 ->	Co is Ci - 32
% 	 ;	Co = Ci
% 	).

% upper_case_codes([],[]).
% upper_case_codes([C|Cs],[U|Us]) :-
% 	upper_case(C,U),
% 	upper_case_codes(Cs,Us).

% upper_case_atom(A,U) :-
% 	atom_codes(A,AC),
% 	upper_case_codes(AC,UC),
% 	atom_codes(U,UC).

% upper_case_atom_list([],[]).
% upper_case_atom_list([A|AL],[U|UL]):-
% 	upper_case_atom(A,U),
% 	upper_case_atom_list(AL,UL).

% upper_case_term(A,U) :-
% 	atom(A),(var(U) ; atom(U)),
% 	!,
% 	upper_case_atom(A,U).

% upper_case_term(T,U) :-
% 	compound(T),!,
% 	T=..[F|TL],
% 	upper_case_term_list(TL,UL),
% 	U=..[F|UL].

% upper_case_term(T,T).

% upper_case_term_list([],[]).
% upper_case_term_list([T|TL],[U|UL]):-
% 	upper_case_term(T,U),
% 	upper_case_term_list(TL,UL).


% letter_or_digit(L) :- letter(L).
% letter_or_digit(D) :- digit(D).

%%whitespace(X) :- X >= 127.
whitespace(0).
whitespace(1).
whitespace(2).
whitespace(3).
whitespace(4).
whitespace(5).
whitespace(6).
whitespace(7).
whitespace(8).
whitespace(9).
whitespace(10).
whitespace(11).
whitespace(12).
whitespace(13).
whitespace(14).
whitespace(15).
whitespace(16).
whitespace(17).
whitespace(18).
whitespace(19).
whitespace(20).
whitespace(20).
whitespace(21).
whitespace(22).
whitespace(23).
whitespace(24).
whitespace(25).
whitespace(26).
whitespace(27).
whitespace(28).
whitespace(29).
whitespace(30).
whitespace(31).
whitespace(32).

special_char(34).   % "
special_char(39).   % '
special_char(33).
special_char(35).
special_char(36).
special_char(37).
special_char(38).
special_char(40).
special_char(41).
special_char(42).
special_char(43).
special_char(44).
special_char(45).
special_char(46).
special_char(47).
special_char(58).
special_char(59).
special_char(60).
special_char(61).
special_char(62).
special_char(63).
special_char(64).
special_char(91).
special_char(92).
special_char(93).
special_char(94).
special_char(95).
special_char(96).
special_char(123).
special_char(124).
special_char(125).
special_char(126).
special_char(X) :- X >= 127.

digit(48).
digit(49).
digit(50).
digit(51).
digit(52).
digit(53).
digit(54).
digit(55).
digit(56).
digit(57).

letter(65).	 %A
letter(66).
letter(67).
letter(68).
letter(69).
letter(70).
letter(71).
letter(72).
letter(73).
letter(74).
letter(75).
letter(76).
letter(77).
letter(78).
letter(79).
letter(80).
letter(81).
letter(82).
letter(83).
letter(84).
letter(85).
letter(86).
letter(87).
letter(88).
letter(89).
letter(90).	 %Z
letter(97).  %a
letter(98).
letter(99).
letter(100).
letter(101).
letter(102).
letter(103).
letter(104).
letter(105).
letter(106).
letter(107).
letter(108).
letter(109).
letter(110).
letter(111).
letter(112).
letter(113).
letter(114).
letter(115).
letter(116).
letter(117).
letter(118).
letter(119).
letter(120).
letter(121).
letter(122). 	%z

% single_letter('A').
% single_letter('B').
% single_letter('C').
% single_letter('D').
% single_letter('E').
% single_letter('F').
% single_letter('G').
% single_letter('H').
% single_letter('I').
% single_letter('J').
% single_letter('K').
% single_letter('L').
% single_letter('M').
% single_letter('N').
% single_letter('O').
% single_letter('P').
% single_letter('Q').
% single_letter('R').
% single_letter('S').
% single_letter('T').
% single_letter('U').
% single_letter('V').
% single_letter('W').
% single_letter('X').
% single_letter('Y').
% single_letter('Z').

% opt([X]) --> [X].
% opt([_X]) --> [].

% std_field(InCodes,PreGroup,Routine):-
% 	super_tokenize(InCodes,PreGroup,List),
% %	initialize_tdcg_input(List),
% 	tphrase_set_string(List),
% 	call(Routine).

% inst_positions(elt(_,_,In,Out),In,Out).

% card_int_num(integer(Num)) --> [integer(Num)],!.
% card_int_num(cardinal(Num)) --> [cardinal(Num)],!.

% general_number(integer(Num)) --> [integer(Num)].
% general_number(Let) --> [Let],{single_letter(Let)}.

% any_words(Rest) -->
% 	['|'],!,
% 	any_words(Rest).
% any_words([W|Rest]) -->
% 	[W],
% 	any_words(Rest).
% any_words([]) --> [].	

% some_words([W|Rest]) -->
% 	[W],
% 	any_words(Rest).

% read_till_pipe([]) --> ['|'],!.
% read_till_pipe([W|R]) --> [W], read_till_pipe(R).


% cvt_csv_file(File,PredName,OutFile) :-
% 	tell(OutFile),
% 	csv_process(PredName,File),
% 	told.

% cvt_delimited_file(File,Delim,PredName,OutFile) :-
% 	(atom(Delim)
% 	 ->	atom_codes(Delim,[DelimC])
% 	 ;	DelimC = Delim
% 	),
% 	file_open(File,read,Stream),
% 	tell(OutFile),
% 	repeat,	
% 	(file_read_line_list(Stream,Line)
% 	 ->	break_into_atom_fields(Stream,Line,DelimC,Atoms),
% 		Term =.. [PredName|Atoms],
% 		writeq(Term),writeln('.'),
% 		fail
% 	 ;	!,
% 		file_close(Stream),
% 		told
% 	).

% cvt_delimited_file_and_number(File,Delim,PredName,OutFile) :-
% 	(atom(Delim)
% 	 ->	atom_codes(Delim,[DelimC])
% 	 ;	DelimC = Delim
% 	),
% 	file_open(File,read,Stream),
% 	create_counter(Ctr),
% 	tell(OutFile),
% 	repeat,	
% 	(file_read_line_list(Stream,Line)
% 	 ->	increment_counter(Ctr),
% 		value_of_counter(Ctr,IDNo),
% 		break_into_atom_fields(Stream,Line,DelimC,Atoms),
% 		Term =.. [PredName,IDNo|Atoms],
% 		writeq(Term),writeln('.'),
% 		fail
% 	 ;	!,
% 		file_close(Stream),
% 		told
% 	).

% break_into_atom_fields(_,[],_,[]) :- !.
% break_into_atom_fields(Stream,Line,Delim,[Atom|Atoms]) :-
% 	next_code_field(Stream,Line,Delim,Field,Rest),
% 	atom_codes(Atom,Field),
% 	break_into_atom_fields(Stream,Rest,Delim,Atoms).
	

% /* Format items: atom(N), ignore(N), trimmed_atom(N), integer(N) */
% cvt_fixed_file(FileIn,FormatList,Functor,FileOut) :-
% 	file_open(FileIn,read,Fdi),
% 	tell(FileOut),
% 	repeat,
% 	(file_read_line_list(Fdi,Line)
% 	 ->	trim_eol(Line,Line0,[]),
% 		parse_line(FormatList,Line0,ValList),
% 		OutTerm =.. [Functor|ValList],
% 		writeq(OutTerm),
% 		writeln('.'),
% 		fail
% 	 ;	!,
% 		told,
% 		file_close(Fdi)
% 	).

% append_n([],0,L,L).
% append_n([X|L1],N,L2,[X|L3]) :-
% 	N1 is N-1,
% 	append_n(L1,N1,L2,L3).

% trim_trail_blanks(L0,L) :-
% 	reverse(L0,L1),
% 	trim_lead_blanks(L1,L2),
% 	reverse(L2,L).

% trim_lead_blanks(L0,L) :-
% 	L0 = [C|L1],
% 	(C =:= 0'   %
% 	 ->	trim_lead_blanks(L1,L)
% 	 ;	L = L0
% 	).
% trim_lead_blanks([],[]).

% trim_eol([13,10],X,X) :- !.
% trim_eol([10],X,X) :- !.
% trim_eol([X|L0],[X|L1],L2) :-
% 	trim_eol(L0,L1,L2).

% trim_eol(CharList,TrimmedCharList):-
% 	trim_eol(CharList,TrimmedCharList,[]).
	
% trim_blanks(String0,String1):-
% 	atom_codes(String0,StringC0),
% 	trim_lead_blanks(StringC0,StringC1),
% 	trim_trail_blanks(StringC1,StringC2),
% 	atom_codes(String1,StringC2).

% parse_line([],_,[]).
% parse_line([atom(N)|Items],Line0,[Atom|Terms]) :-
% 	append_n(AtomCs,N,Rest,Line0),
% 	atom_codes(Atom,AtomCs),
% 	parse_line(Items,Rest,Terms).
% parse_line([integer(N)|Items],Line0,[Int|Terms]) :-
% 	append_n(IntCs,N,Rest,Line0),
% 	number_codes(Int,IntCs),
% 	parse_line(Items,Rest,Terms).
% parse_line([trimmed_atom(N)|Items],Line0,[Atom|Terms]) :-
% 	append_n(AtomCs,N,Rest,Line0),
% 	trim_trail_blanks(AtomCs,TAtomCs),
% 	atom_codes(Atom,TAtomCs),
% 	parse_line(Items,Rest,Terms).
% parse_line([ignore(N)|Items],Line0,Terms) :-
% 	append_n(_,N,Rest,Line0),
% 	parse_line(Items,Rest,Terms).

% /* cvt_fedlog_ncp_to_delimited_file  reads fedlog ncp input and writes a
%    delimited ncp output file */

% cvt_fedlog_ncp_to_delimited_file(File,Delim,OutFile):-
% 	(atom(Delim)
% 	 ->	atom_codes(Delim,[DelimC])
% 	 ;	DelimC = Delim
% 	),
% 	file_open(File,read,Stream),
% 	tell(OutFile),
% 	assert(pn('')),
% 	repeat,	
% 	(file_read_line_list(Stream,Line)
% 	 ->	(\+ Line = [_,_,_,_,45,_,_,45,_,_,_,45,_,_,_,_|_]
% 		 ->	retractall(pn(_)),
% 			parse_unquoted(Line,Line1),
% 			atom_codes(N,Line1),
% 			assert(pn(N))
% 		 ;	pn(N1),
% 			parse_unquoted(Line,Line2),
% 			atom_codes(NCP,Line2),
% 			atom_codes(Dl,[DelimC]),
% 			write(N1), write(Dl), writeln(NCP)
% 		),
% 		fail
% 	 ;	!,
% 		file_close(Stream),
% 		told
% 	).

% parse_unquoted([124,13,10],[]):-!.
% parse_unquoted([13,10],[]):-!.
% parse_unquoted([10],[]):-!.
% parse_unquoted([H|Rest],[H|Trest]):-
% 	parse_unquoted(Rest,Trest).

% /* changes ^ to space, and remove escapes as nec */

% unfix([],[]) :- !.
% unfix(L1,[X|L2]) :-
% 	unfix_code(X,L1,L3),
% 	unfix(L3,L2).

% unfix_code(0' ,[0'^|L],L) :- !.
% unfix_code(0'(,[0'{|L],L) :- !.
% unfix_code(0'),[0'}|L],L) :- !.
% unfix_code(X,[92,Y|L],L) :- unfix_escape(X,Y), !.  %%% 92 is \
% unfix_code(X,[X|L],L).

% unfix_escape(0'{,0'{).
% unfix_escape(0'},0'}).
% unfix_escape(0'[,0'[).
% unfix_escape(0'],0']).
% unfix_escape(0'^,0'^).
% unfix_escape(92,92).

% unfix_term(DName,Name) :-
% 	atom(DName),
% 	atom_codes(DName,DNamec),
% 	unfix(DNamec,Namec),
% 	atom_codes(Name,Namec),!.
% unfix_term(DName,Name) :-
% 	var(DName),
% 	atom(Name),
% 	atom_codes(Name,Namec),
% 	unfix(DNamec,Namec),
% 	atom_codes(DName,DNamec),!.
% unfix_term(Name,Name).


% /* parse a lisp term into a prolog term */

% parselisp(File,PTerm) :-
% 	see(File),
% 	read_tokens([],TokenList,[]),
% 	seen,
% 	reset_dcg_mode,
% 	lisp_terms(PTerm,TokenList,[]),
% 	!.

% read_tokens(CarryOver,TokenList0,TokenList) :-
% 	(file_read_line_list(CodeList)
% 	 ->	(CarryOver=[]
% 		 ->	(if_not_comment(CodeList,NCodeList)
% 			 ->	scan_lisp(NCodeList,TokenList0,TokenList1,Rest),
% 				read_tokens(Rest,TokenList1,TokenList)
% 			 ;	read_tokens(CarryOver,TokenList0,TokenList)
% 			)
% 		 ;	append(CarryOver,CodeList,NCodeList),
% 			scan_lisp(NCodeList,TokenList0,TokenList1,Rest),
% 			read_tokens(Rest,TokenList1,TokenList)
% 		)
% 	 ;	TokenList = TokenList0
% 	).


% if_not_comment([0';,0'+|R],R) :- !.
% if_not_comment([0';|_L],_) :- !, fail.
% if_not_comment([0' |L0],L) :- !, if_not_comment(L0,L).
% if_not_comment(L,L).

% lisp(Atom) -->
% 	symbol(Atom), !.
% lisp(PTerms) -->
% 	[spec('(')],
% 	lisp_terms(PTerms),
% 	[spec(')')].

% lisp_terms([PTerm|PTerms]) -->
% 	lisp(PTerm),
% 	lisp_terms(PTerms).
% lisp_terms([]) --> [].

% %%% move the unfix_term down into scanner, to avoid constructing
% %%% double atoms.  Note have to distiguish the two delimited forms
% %%% since sqbrac unfixes and dquote doesn't.
% symbol(FAtom) --> [atom(Atom)],!,{unfix_term(Atom,FAtom)}.
% symbol(Int) -->
% 	[integer(Atom)],!,
% 	{atom_codes(Atom,NumCodes),
% 	 number_codes(Int,NumCodes)}.
% symbol(Atom) -->
% 	[dquote(Atom)],!.
% symbol(FAtom) -->
% 	[sqbrac(Atom)],{unfix_term(Atom,FAtom)}.


% /* Scanner for reading list expressions and turning them into Prolog
% Terms.  */
% %-----------------------------------------------------
% % imports from XSB, Inc libraries

% :- import integer/1 from standard.

% :- import scanned_list/1 from ode_props.

% %-----------------------------------------------------

% :- dynamic set_case_lisp/2.
% :- retractall(set_case_lisp(_,_)), 
% %%	assert((set_case_lisp(Ci,Co) :- upper_case(Ci,Co))).
% 	assert((set_case_lisp(C,C))).
% :- retractall(set_case_lisp_in_lit(_,_)), 
% %%	assert((set_case_lisp_in_lit(Ci,Co) :- upper_case(Ci,Co))).
% 	assert((set_case_lisp_in_lit(C,C))).


% scan_lisp(List,Tokens0,Tokens,Rest) :-
% 	scan_lisp(List,-1,Rest,Tokens0,Tokens).

% % scan_lisp(+CodeList,+SepCode,-Rest,-TokenListIn,TokenListOut)
% % The workhorse, returns a list of tokens to the next Sep
% scan_lisp([],_,[],T,T).
% scan_lisp([C0|Cs],Sep,Rest,Toks0,Toks) :-
% 	set_case_lisp(C0,C),
% 	(C0 =:= Sep
% 	 ->	Rest = [C0|Cs],
% 		Toks = Toks0
% 	 ; whitespace(C)
% 	 ->	scan_lisp_whitespace(Cs,Cso),
% 		scan_lisp(Cso,Sep,Rest,Toks0,Toks)
% 	 ; delim_lisp(C,EndDel,Term)
% 	 ->	(scan_lisp_literal(Cs,EndDel,LitCodes,[],Cso)
% 		 ->	atom_codes(Lit,LitCodes),
% 			arg(1,Term,Lit),
% 			Toks0 = [Term|Tokso],
% 			scan_lisp(Cso,Sep,Rest,Tokso,Toks)
% 		 ;	Rest = [C0|Cs],
% 			Toks = Toks0
% 		)
		
% 	 ; lisp_punc(C)
% 	 ->	atom_codes(CC,[C]),
% 		chk_ws_continue_lisp(Cs,spec(CC),Sep,Rest,Toks0,Toks)
% 	 ;	scan_lisp_stuff(Cs,LetterCodes,[],Cso1),
% 		name(TTok,[C|LetterCodes]),
% 		chk_ws_continue_lisp(Cso1,atom(TTok),Sep,Rest,Toks0,Toks)
% 	).

% chk_ws_continue_lisp(Cso1,Tok,Sep,Rest,Toks0,Toks) :-
% 	(Cso1 = [NC|Cso2]
% 	 ->	(whitespace(NC)
% 		 ->	Toks0 = [Tok|Tokso],
% 			scan_lisp_whitespace(Cso2,Cso3),
% 			scan_lisp(Cso3,Sep,Rest,Tokso,Toks)
% 		 ;	Toks0 = [Tok|Tokso],
% 			scan_lisp(Cso1,Sep,Rest,Tokso,Toks)
% 		)
% 	 ;	Toks0 = [Tok|Toks],
% 		Rest = []
% 	).

% scan_lisp_whitespace(Csi,Cso) :-
% 	(Csi = [C|Cs]
% 	 ->	(whitespace(C)
% 		 ->	scan_lisp_whitespace(Cs,Cso)
% 		 ;	Cso = Csi
% 		)
% 	 ;	Cso = Csi
% 	).

% % if we did not encounter delimiter till end of line - fail, so that this part
% % would be carried over to another line
% %scan_lisp_literal([],EndDel,Lit,Lit,[]) :-
% %	write('End of stream inside literal with terminating delimiter: '),
% %	put(EndDel),
% %	nl.
% scan_lisp_literal([C|Cs],EndDel,Liti,Lito,Cso) :-
% 	(C =:= 92,Cs=[EndDel|Cs1]   %%end delimiter escaped
% 	 ->	Cs = [C1|Cs1],
% 		set_case_lisp_in_lit(C1,Cr),
% 		Liti = [Cr|Lit],
% 		scan_lisp_literal(Cs1,EndDel,Lit,Lito,Cso)
% 	 ; C =:= EndDel
% 	 ->	Lito = Liti,
% 		Cso = Cs
% 	 ;	set_case_lisp_in_lit(C,Cr),
% 		Liti = [Cr|Lit],
% 		scan_lisp_literal(Cs,EndDel,Lit,Lito,Cso)
% 	).

% scan_lisp_stuff(Csi,Letsi,Letso,Cso) :-
% 	(Csi = [C0|Cs]
% 	 ->	set_case_lisp(C0,C),	
% 		(lisp_punc(C)
% 		 ->	Letso = Letsi,
% 			Cso = Csi
% 		 ;	Letsi = [C|Lets],
% 			scan_lisp_stuff(Cs,Lets,Letso,Cso)
% 		)
% 	 ;      Letso = Letsi,
% 		Cso = Csi
% 	).

% lisp_punc(0'().
% lisp_punc(0')).
% lisp_punc(0' ).
% lisp_punc(13).
% lisp_punc(10).

% %%delim_lisp(_,_,_) :- fail.
% delim_lisp(0'",0'",dquote(_)).
% delim_lisp(0'[,0'],sqbrac(_)).

% if_predicate_defined(Skel) :-
% 	term_psc(Skel,Psc),
% 	psc_type(Psc,Type),
% 	Type =\= 0,		%  != T_ORDI
% 	Type =\= 12.		%  != T_UDEF, not loaded

% /*********
% for(I,I,H) :- I =< H.
% for(I,L,H) :- L < H, L1 is L+1, for(I,L1,H).

% pc(L,H) :- for(I,L,H),put(I),tab(1),writeln(I),fail.
% pcv(L,H,T) :- for(I,L,H),write(T),write('('),write(I),writeln(').'),fail.
% **********/

% %------------------------------------------------------------------

% :- comment(alphanumeric_part_std,"This predicate takes file, each line
% in which contains a string with arbitrary characters in it.  It
% produces a file, each line of which contains the original string, a
% pipe symbol, and the string with all but alphanumeric characters
% removed from it.  It is used, for instance, as an alternative to more
% sophisticated part number standardization, when a simpler form is what
% is needed.").

% alphanumeric_part_std(File,Filestd):- 
% 	file_open(File,read,IStream),
% 	open(Filestd,write,Ostream),
% 	alphanumeric_part_std_1(IStream,Ostream),
% 	close(Ostream),
% 	file_close(IStream).

% alphanumeric_part_std_1(Istr,Ostr):- 
% 	repeat,
% 	(file_read_line_list(Istr,List) -> 
% 		to_alphanumeric(List,Out),
% 		strip_cr(List,List1),
% 		atom_codes(In,List1),
% 		write(Ostr,In),write(Ostr,'|'),writeln(Ostr,Out),
% 		Succeeded = true
% 	 ; true,Succeeded = false),
% 	Succeeded = false.

% % This predicate is to be used to transform a string with punctuation
% % characters, spaces, etc to an alpha-numeric.

% strip_cr([13,10],[]):-!.
% strip_cr([10],[]):-!.
% strip_cr([H|T],[H|T1]):-
% 	strip_cr(T,T1).

% to_alphanumeric(Ilist,Out):-
% 	to_alphanumeric_1(Ilist,Outlist),
% 	atom_codes(Out,Outlist).

% to_alphanumeric_1([],[]).
% to_alphanumeric_1([H|T],[H|T1]):- 
% 	(letter(H) ; digit(H)),!,
% 	to_alphanumeric_1(T,T1).
% to_alphanumeric_1([_H|T],T1):- 
% 	to_alphanumeric_1(T,T1).
% %------------------------------------------------------------------

% :- import term_set_arg/4 from machine.
% create_counter(Ctr) :-
% 	Ctr = '$ctr'(0).

% create_counter(Ctr,InitVal) :-
% 	Ctr = '$ctr'(InitVal).

% increment_counter(Ctr) :-
% 	Ctr = '$ctr'(OldCnt),
% 	Cnt is OldCnt + 1,
% 	term_set_arg(Ctr,1,Cnt,1).

% increment_counter(Ctr,Inc) :-
% 	Ctr = '$ctr'(OldCnt),
% 	Cnt is OldCnt + Inc,
% 	term_set_arg(Ctr,1,Cnt,1).

% decrement_counter(Ctr) :-
% 	Ctr = '$ctr'(OldCnt),
% 	Cnt is OldCnt - 1,
% 	term_set_arg(Ctr,1,Cnt,1).

% set_counter(Ctr,Value) :-
% 	term_set_arg(Ctr,1,Value,1).

% value_of_counter(Ctr,Val) :-
% 	Ctr = '$ctr'(Val).

% count_solutions(Goal,Count) :-
% 	create_counter(Ctr),
% 	(call(Goal),
% 	 increment_counter(Ctr),
% 	 fail
% 	 ;
% 	 value_of_counter(Ctr,Count)
% 	).


% /* load_predicate_from_file(FileName,PredTemplate,InPredSkel) reads
% (canonically) from file FileName and for each term that unifies with
% InPredSkel, it asserts PredTemplate.  */

% load_predicate_from_file(FileName,PredTemplate,InPredSkel) :-
% 	cputime(T0),
% 	see(FileName),
% 	retractall(PredTemplate),
% 	repeat,
% 	(read_canonical(Fact),Fact \== end_of_file
% 	 ->	Fact = InPredSkel,
% 		asserta(PredTemplate),
% 		fail
% 	 ;	!,
% 		seen
% 	),
% 	cputime(T1), T is T1-T0,
% 	write('['),write(FileName),
% 	write(' dynamically loaded (with format), cpu time used: '),
% 	write(T),writeln(' seconds]').


% file_name_split(Filename,Directory,FileRoot,Suffix) :-
% 	atom_codes(Filename,FilenameCB),
% 	change_back_to_for(FilenameCB,FilenameC),
% 	(append(DirectoryC,[0'/|RootSuffC],FilenameC),
% 	 \+memberchk(0'/,RootSuffC)
% 	 ->	atom_codes(Directory,DirectoryC)
% 	 ;	Directory = '',
% 		RootSuffC = DirectoryC
% 	),
% 	(append(RootC,[0'.|SuffixC],RootSuffC),
% 	 \+memberchk(0'.,SuffixC)
% 	 ->	atom_codes(Suffix,SuffixC)
% 	 ;	RootC = RootSuffC,
% 		Suffix = ''
% 	),
% 	atom_codes(FileRoot,RootC).	

% change_back_to_for([],[]).
% change_back_to_for([C|Cs],[D|Ds]) :-
% 	(C =:= 92		% \
% 	 ->	D = 0'/
% 	 ;	D = C
% 	),
% 	change_back_to_for(Cs,Ds).

	
% apply_lambda_fast(lambda(X1,P),X1) :- call0(P).
% apply_lambda_fast(lambda(X1,X2,P),X1,X2) :- call0(P).
% apply_lambda_fast(lambda(X1,X2,X3,P),X1,X2,X3) :- call0(P).
% apply_lambda_fast(lambda(X1,X2,X3,X4,P),X1,X2,X3,X4) :- call0(P).
% apply_lambda_fast(lambda(X1,X2,X3,X4,X5,P),X1,X2,X3,X4,X5) :- call0(P).

% apply_lambda(Lambda,X1) :- copy_term(Lambda,lambda(X1,P)),call0(P).
% apply_lambda(Lambda,X1,X2) :-
% 	copy_term(Lambda,lambda(X1,X2,P)),call0(P).
% apply_lambda(Lambda,X1,X2,X3) :-
% 	copy_term(Lambda,lambda(X1,X2,X3,P)),call0(P).
% apply_lambda(Lambda,X1,X2,X3,X4) :-
% 	copy_term(Lambda,lambda(X1,X2,X3,X4,P)),call0(P).
% apply_lambda(Lambda,X1,X2,X3,X4,X5) :-
% 	copy_term(Lambda,lambda(X1,X2,X3,X4,X5,P)),call0(P).

% end_of_file.
% /*******************************************************************/

% end_of_string --> [_],!,{fail}.
% end_of_string --> [].

% read_till_pipe --> ['|'],!.
% read_till_pipe --> [_], read_till_pipe.

% some_words_not_of_class([W|Rest],Class) -->
% 	[W],
% 	{arg(1,Class,W),\+ Class},
% 	any_words(Rest,Class).

% any_words_not_of_class(Rest,Class) -->
% 	['|'],!,
% 	any_words_not_of_class(Rest,Class).
% any_words([W|Rest],Class) -->
% 	[W],
% 	{\+ Class},
% 	any_words(Rest,Class).
% any_words([],_) --> [].	

% make_num(Atom,Num):-
% 	atomic(Atom),
% 	atom_chars(Atom,L),
% 	length(L,Len),Len < 9,
% 	number_chars(Num,L).

% make_atom(Atom,Num):-
% 	name(Atom,L),
% 	atom_chars(Num,L).

% %-----------------------------------------------------------------------
% % uppercaseatom(+S1, -S2) : upcase the string S1 to S2
% %-----------------------------------------------------------------------
% uppercaseatom(S1, S2) :-
%         atom_chars(S1, L1), 
%         upperlist(L1, L2), 
%         atom_chars(S2, L2).

% upperlist([], []).
% upperlist([Low|Ls], [Upper|UpperLs]) :-
%         Low >= 0'a, Low =< 0'z, !, 
%         Upper is Low - 32, 
%         upperlist(Ls, UpperLs).
% upperlist([Upper|Ls], [Upper|UpperLs]) :-
%         upperlist(Ls, UpperLs).


% strict_get_last([],[]).
% strict_get_last([H],[H]):-!.
% strict_get_last([_H|Rest],Out):-
% 	strict_get_last(Rest,Out).

% %-----------------------------------------------------------------------
% % Misc
% %-----------------------------------------------------------------------
% get_one_number(integer(Num)) -->
% 	[integer(Num)].

% get_numbers([Num|Rest]) -->
% 	get_one_number(Num),
% 	get_numbers(Rest).
% get_numbers([]) --> [].

% writename([]).
% writename([W|Ws]) :- 
% 	(W = cardinal(N)
% 	 -> write(N)
% 	 ; W = integer(I)
% 	 -> write(I)
% 	 ; write(W)
% 	),
% 	write(' '), writename(Ws).

% %-----------------------------------------------------------------------
% % atom_num(+Atom, -Num)
% %   Turns an atom to a number
% %-----------------------------------------------------------------------
% atom_num(Atom,Num):-
% 	atom_chars(Atom,C),
% 	number_chars(Num,C).

% all_atomic([]).
% all_atomic([W|Ws]) :-
% 	atomic(W),
% 	all_atomic(Ws).


% ca_null(In,Out):-
% 	ca_1(In,Mid),
% 	concat_atom(Mid,'',Out).
