/* These routines support Prolog "Databases", allowing a Prolog
programmer to construct a set of Prolog clauses into a Prolog
variable, and then call goals to be proved in such a constructed
database.  The interface predicates are:

empty_db(-DB) returns an empty database.

assert_in_db(+Clause,+DB0,-DB) adds the clause Clause to the database
DB0 returning DB.  Clause may also be a list of clauses in which case
all clauses in the list are added to the database.  A Database is a
*set* of clauses, so asserting a clause that is already in the
database returns the same database.  No ordering of clauses is
preserved, so cuts don't make sense and cannot be used in clauses.
The if-then-else should be used instead.

assert_in_db(+Clause,-DB) adds Clause (or clauses if Clause is a list)
to the empty DB, returning the DB containing exactly the clause(s) of
Clause.

retractall_in_db(+ClauseHead,+DB0,-DB) removes all clauses whose heads
unify with ClauseHead from DB0 returning DB.

clause_in_db(?ClauseHead,?ClauseBody,+DB) returns all clauses in DB
whose heads and bodies unify with ClauseHead and ClauseBody.  (Note
that, unlike clause/2 in Prolog, clause_in_db can be called with
ClauseHead as a variable.)  Note also that the order of clauses is not
preserved and is indeterminate.

call_in_db(?Goal,+DB) calls Goal in DB and returns all instances of
Goal provable in DB.  Clauses must not contain cuts (!).  They can
contain most Prolog constructs, including and, or, if-then-else, \+,
calls to standard predicates, and calls explicitly modified by a
module name.

load_in_db(+FileName,+DB0,-DB) reads the clauses from the file named
FileName and asserts them into database DB0 returning DB.

load_in_db(+FileName,-DB) reads the clauses from the file named
FileName and asserts them into an empty database returning DB.

The following implement set operations on Prolog Databases.  They are
efficiently implemented to take advantage of the structure of the trie
representation of databases to share substructure and to avoid looking
at components of databases when it is not required.

union_db(+DB1,+DB2,?DB3) where DB3 contains the union of the sets of
clauses in DB1 and DB2.

intersect_db(+DB1,+DB2,?DB3) where DB3 contains the intersection
of the sets of clauses in DB1 and DB2.

difference_db(+DB1,+DB2,?DB3) where DB3 contains clauses that appear
in DB1 but not in DB2.

subset_db(+DB1,+DB2) is true if every clause in DB1 is in DB2,
i.e. DB1 is a subset of DB2.

disjoint_db(+DB1,+DB2) is true if DB1 and DB2 are disjoint sets.

Notes:

1. A DB is kept as a trie, which is a ground term.  Each level in the
trie is implemented by a hash table, and hash tables are expanded and
contracted as necessary.  A set of clauses is canonically represented,
i.e., no matter what sequence of assert's and retractall's one uses to
construct a particular set of clauses, the resulting tries
(i.e. terms) are identical.

2. A DB represents an unordered set of clauses.  The order in which
clauses are returned from clause_in_db (and thus for call_in_db) is
indeterminate, and may change from one call to the next (due to
possible expansion or contraction of a hash table.)

3. A DB that is obtained from another DB by adding or deleting a
single clause differs from it in only log subterms (unless a hash
table has been resized).  This means that it is efficient to intern
these DB's, and to table them (as intern).

*/

/* The following are commented out, and made explicit in the code, so
that this code can itself be loaded by load_in_db and processed. */

%:- import append/3 from basics.
%:- import member/2 from basics.
%:- import log_ith/3 from basics.
%:- import term_hash/3 from machine.
%:- import standard_symbol/3 from std_xsb.
%:- import call_c/1 from standard.

:- comment(assert_in_db/3, "@pred{assert_in_db(+Clause,+DB0,?DB)} adds
a clause, @var{Clause}, (or a sequence of clauses, if {Clause} is a
list of clauses) to @var{DB0} to generate @var{DB}.").

assert_in_db(Clauses,DB0,DB) :-
    (Clauses == []
     ->	DB0 = DB
     ; Clauses = [Clause|MClauses]
     ->	assert1_in_db(Clause,DB0,DB1),
	assert_in_db(MClauses,DB1,DB)
     ;	assert1_in_db(Clauses,DB0,DB)
    ).

:- comment(assert_in_dbi/3, "@pred{assert_in_dbi(+Clause,+H0,?HB)}
adds a clause, @var{Clause}, (or a sequence of clauses, if {Clause} is
a list of clauses) to an interned DB, @var{H0} to generate interned DB
@var{H}.").

assert_in_dbi(Clauses,H0,H) :-
    intern_termhash(DB0,H0),
    assert_in_db(Clauses,DB0,DB),
    intern_termhash(DB,H).

assert1_in_db(Clause,DB0,DB) :-
    valid_db(DB0,'assert_in_db/3'),
    (Clause = (Head :- Body)
     ->	true
     ;	Head = Clause,
	Body = true
    ),
    add_to_trie(Head,Body,DB0,DB).

assert1_in_dbi(Clause,H0,H) :-
    intern_termhash(DB0,H0),
    assert1_in_db(Clause,DB0,DB),
    intern_termhash(DB,H).

:- comment(assert_in_db/2, "@pred{assert_in_db(+Clause,?DB)} adds
a clause, @var{Clause}, (or a sequence of clauses, if @var{Clause} is
a list) to the empty DB to generate @var{DB}.").

assert_in_db(Clauses,DB) :-
    empty_db(DB0),
    assert_in_db(Clauses,DB0,DB).

:- comment(assert_in_dbi/2, "@pred{assert_in_dbi(+Clause,?H)} adds
a clause, @var{Clause}, (or a sequence of clauses, if @var{Clause} is
a list) to the empty DB to generate interned DB @var{H}.").

assert_in_dbi(Clauses,H) :-
    empty_db(DB0),
    assert_in_db(Clauses,DB0,DB),
    intern_termhash(DB,H).	

:- comment(retractall_in_db/3,"@pred{retractall_in_db(+Goal,+DB0,?DB)}
retracts all clauses whose heads unify with @var{Goal} (or a term in
@var{Goal} if @var{Goal} is a list) from @var{DB0} generating
@var{DB1}.  ").

retractall_in_db(Clauses0,DB0,DB) :-
    (Clauses0 == []
     ->	DB = DB0
     ; Clauses0 = [Clause|Clauses]
     ->	retractall1_in_db(Clause,DB0,DB1),
	retractall_in_db(Clauses,DB1,DB)
     ;	retractall1_in_db(Clauses0,DB0,DB)
    ).

:- comment(retractall_in_dbi/3,"@pred{retractall_in_dbi(+Goal,+H0,?H)}
retracts all clauses whose heads unify with @var{Goal} (or a term in
@var{Goal} if @var{Goal} is a list) from interned DB, @var{H0}, generating
interned DB, @var{H}.  ").

retractall_in_dbi(Clauses,H0,H) :-
    intern_termhash(DB0,H0),
    retractall_in_db(Clauses,DB0,DB),
    intern_termhash(DB,H).

retractall1_in_db(Clause,DB0,DB) :-
    valid_db(DB0,'retractall_in_db/3'),
    (Clause = (Head:-Body)
     ->	true
     ;	Head = Clause
    ),
    remove_from_trie(Head,Body,DB0,_Vars,DB).

:- comment(clause_in_db/3,"@pred{clause_in_db(?Head,?Body,+DB)}
unifies, in turn, @var{Head} and @var{Body} with the head and body of
rules in @var{DB}.").

clause_in_db(Head,Body,DB) :-
    valid_db(DB,'clause_in_db/3'),
    clause_in_db0(Head,Body,DB).

:- comment(clause_in_dbi/3,"@pred{clause_in_db(?Head,?Body,+H)}
unifies, in turn, @var{Head} and @var{Body} with the head and body of
rules in interned DB, @var{H}.  The order or clauses returned is
indeterminate.").

clause_in_dbi(Head,Body,H) :-
    intern_termhash(DB,H),
    clause_in_db(Head,Body,DB).

clause_in_db0(Head,Body,DB) :-
    find_in_trie(Head,Body,DB).

:- comment(fact_in_db/2, "@pred{fact_in_db(?Fact,+DB)} unifies, in
turn, @var{Fact} with each fact in DB, @var{DB}.  The order of
returned facts is indeterminate.").

fact_in_db(Head,DB) :-
    clause_in_db(Head,true,DB).

:- comment(fact_in_dbi/2, "@pred{fact_in_dbi(?Fact,+H)} unifies, in
turn, @var{Fact} with each fact in interned DB, @var{H}.  The order of
returned facts is indeterminate.").

fact_in_dbi(Head,DB) :-
    clause_in_dbi(Head,true,DB).

:- comment(call_in_db/2, "@pred{call_in_db(+Goal,+DB)} calls the goal
@var{Goal} in the database @var{DB}, binding variables in @var{Goal}
for each instance of @var{Goal} that is proved.").

call_in_db(Goal,DB) :-
    valid_db(DB,'call_in_db/2'),
    call_in_db0(Goal,DB).

call_in_db0(true,_DB) :- !.
call_in_db0((A,B),DB) :- !, call_in_db0(A,DB), call_in_db0(B,DB).
call_in_db0(\+(G),DB) :- !, \+ call_in_db0(G,DB).
call_in_db0(tnot(G),DB) :- !, tnot db_table_call(DB,G).
call_in_db0((C->A;B),DB) :- !,
    (call_in_db0(C,DB) -> call_in_db0(A,DB) ; call_in_db0(B,DB)).
call_in_db0((A;B),DB) :- !, (call_in_db0(A,DB) ; call_in_db0(B,DB)).
call_in_db0(table(Goal),DB) :- !, db_table_call(DB,Goal).
call_in_db0(xact(G),DB) :- !, phrase(G,DB,DB).  % for transaction logic, if useful.
call_in_db0(G,_DB) :- functor(G,F,A), std_xsb:standard_symbol(F,A,_), !,
    standard:call_c(G).
call_in_db0(G,DB) :-
    clause_in_db0(G,B,DB),
    call_in_db0(B,DB).

:- table db_table_call/2.
db_table_call(DB,Goal) :-
    call_in_db0(Goal,DB).

:- comment(call_in_dbi/2, "@pred{call_in_dbi(+Goal,+H)} calls the goal
@var{Goal} in the interned database @var{H}, binding variables in
@var{Goal} for each instance of @var{Goal} that is proved.").

call_in_dbi(Goal,H) :-
    intern_termhash(DB,H),
    call_in_db(Goal,DB).


:- comment(dump_db/2,"@var{dump_db(+DB,+Filename)} writes the clauses
in DB, @var{DB}, to the file @var{Filename}.  If @var{Filename} is
'userout', the clauses will be written to userout.").

dump_db(DB,Filename) :-
    valid_db(DB,'dump_db/2'),
    (Filename == userout
     ->	OStr = userout
     ;	open(Filename,write,OStr)
    ),
    (do_all
     clause_in_db0(Head,Body,DB),
     (Body == true
      -> write_canonical(OStr,Head)
      ;	 write_canonical(OStr,(Head:-Body))
     ),
     writeln(OStr,'.')
    ),
    (Filename == userout
     ->	true
     ;	close(OStr)
    ).

:- comment(dump_db/2,"@var{dump_db(+DB,+Filename)} writes the clauses
in interned DB, @var{DB}, to the file @var{Filename}.  If
@var{Filename} is 'userout', the clauses will be written to
userout.").

dump_dbi(H,Filename) :-
    intern_termhash(DB,H),
    dump_db(DB,Filename).


valid_db(DB,Call) :-
    (var(DB)
     ->	throw(error(Call,'DB cannot be a variable'))
     ;	DB @= ht(_,_,_)
     ->	true
     ; DB == []
     ->	true
     ;	throw(error(Call,'Invalid DB structure'))
    ).

:- comment(pure_call_in_db/2,"@pred{pure_call_in_db(+G,+DB)} has the
same functionality as @pred{call_in_db(G,DB)}, but it is implemented
without cuts, so it can be used when this file is loaded into a DB by
@pred{load_in_db/2}.").

pure_call_in_db(G,DB) :-
    (ctrl_str(G)
     ->	pure_ctrl_call_in_db0(G,DB)
     ;	G \== true,functor(G,F,A),std_xsb:standard_symbol(F,A,_)
     ->	standard:call_c(G)
     ;	clause_in_db(G,B,DB),
	pure_call_in_db(B,DB)
    ).

:- comment(pure_call_in_dbi/2,"@pred{pure_call_in_dbi(+G,+H)} has the
same functionality as @pred{call_in_dbi(G,H)}, but it is implemented
without cuts, so it can be used when this file is loaded into an interned DB by
@pred{load_in_dbi/2}.").

pure_call_in_dbi(G,H) :-
    intern_termhash(DB,H),
    pure_call_in_db(G,DB).

ctrl_str(true).
ctrl_str((_,_)).
ctrl_str(\+(_)).
ctrl_str(xact(_)).
ctrl_str((_;_)).

pure_ctrl_call_in_db0(true,_).
pure_ctrl_call_in_db0((A,B),DB) :- pure_call_in_db(A,DB), pure_call_in_db(B,DB).
pure_ctrl_call_in_db0(\+(G),DB) :- \+ pure_call_in_db(G,DB).
pure_ctrl_call_in_db0(xact(G),DB) :- !, phrase(G,DB,DB).  % for transaction logic, if useful.
pure_ctrl_call_in_db0((A;B),DB) :-
    (A = (C->A1)
     ->	(pure_call_in_db(C,DB) -> pure_call_in_db(A1,DB) ; pure_call_in_db(B,DB))
     ;	(pure_call_in_db(A,DB) ; pure_call_in_db(B,DB))
    ).
pure_ctrl_call_in_db0(M:G,_DB) :- call(M:G).

:- comment(empty_db/1, "@pred{empty_db(?DB)} generates (or tests for)
and empty database, @var{DB}.").

empty_db([]).

:- comment(empty_dbi/1, "@pred{empty_db(?H)} generates (or tests for)
and empty interned database, @var{H}.").

empty_dbi([]).

:- comment(is_db/1, "@pred{is_db(+DB)} succeeds if @var{DB} has the
	   form of a valid database term."
	  ).
is_db([]).
is_db(ht(_,_,_)).

:- comment(is_dbi/1,
"@pred{is_db(+H)} succeeds if @var{H} is in the
form of a valid interned database term.").

is_dbi(H) :-
    intern_termhash(DB,H),
    is_db(DB).

:- comment(find_in_trie/3, "find_in_trie(?Head,?Body,+Trie) succeeds
for terms @var{Head} in ht-trie @var{Trie} with body @{Body}.").

find_in_trie(Head,Body,Trie) :-
    find_in_trie_list([Head],Body0,Trie,Vars),
    my_unnumbervars(Body0,Vars,Body).

:- comment(find_in_trie_list/4,
"find_in_trie_list(?HeadTail,?Body,+Trie,?Vars) succeeds for the
trie-path selected by the list of terms @var{HeadTail} (which must be
a proper list) in ht-trie @var{Trie} with clause body @var{Body},
where @vars{Vars} is an open loglist of variables.").

find_in_trie_list([],Body,Bodies,_Vars) :-
    basics:member(Body,Bodies).
find_in_trie_list([HeadTerm|HeadTail],Body,Trie,Vars) :-
    find_in_first_hashtree(HeadTerm,SubTrie,Trie),
    \+ (HeadTerm = '$VAR'(VN),integer(VN)),	%next clause handles this case
    (atomic(HeadTerm)
     ->	find_in_trie_list(HeadTail,Body,SubTrie,Vars)
     ;	HeadTerm =.. [_|SubHeads],
	basics:append(SubHeads,HeadTail,NewHeadTail),
	find_in_trie_list(NewHeadTail,Body,SubTrie,Vars)
    ).
find_in_trie_list([HeadTerm|HeadTail],Body,Trie,Vars) :-
    find_in_first_hashtree('$VAR'(X),SubTrie,Trie),
    basics:log_ith(X,Vars,HeadTerm),
    find_in_trie_list(HeadTail,Body,SubTrie,Vars).

:- comment(add_to_trie/4, "add_to_trie(+Head,+Body,+Trie0,-Trie) adds
the clause with head @var{Head} and body @var{Body} to ht-trie @var{Trie0},
returning the ht-trie @var{Trie}.").

add_to_trie(Head,Body,Trie0,Trie) :-
    (ground(Head)
     ->	add_to_trie_ground_list([Head],Body,Trie0,Trie)
     ;	copy_term([Head|Body],[Head1|Body1]),
	numbervars([Head1|Body1],0,_),
	add_to_trie_ground_list([Head1],Body1,Trie0,Trie)
    ).

:- comment(add_to_trie_ground_list/4,
"add_to_trie_ground_list(+HeadTail,+Body,+Trie0,-Trie) adds the
trie-path for the list of terms, @var{HeadTail}, with body,
@var{Body}, to ht-trie, @var{Trie0}, returning ht-trie, @var{Trie}.").

add_to_trie_ground_list([],Body,List,MList) :-
    add_to_body_list(List,Body,MList).
add_to_trie_ground_list([HeadTerm|HeadTail],Body,Trie0,Trie) :-
    (atomic(HeadTerm)
     ->	NHeadTail = HeadTail
     ;	HeadTerm = '$VAR'(VN),integer(VN)
     ->	NHeadTail = HeadTail
     ;	HeadTerm =.. [_|SubTerms],
	basics:append(SubTerms,HeadTail,NHeadTail)
    ),
    update_hashtree(HeadTerm,NewSubTrie,OldSubTrie,Trie0,Trie1),
    add_to_trie_ground_list(NHeadTail,Body,OldSubTrie,NewSubTrie),
    db_comps(Trie1,HashBits,NumInTab,HashTree),
    (NumInTab < floor(2**HashBits)
     ->	Trie = Trie1
     ;	NHashBits is HashBits*2,
	db_comps(Trie,NHashBits,NumInTab,NHashTree),
	rebuild_hashtree(HashTree,HashBits,NHashBits,NHashTree)
    ).

:- comment(add_to_body_list/3, "add_to_body_list(+List,+Body,-NewList)
adds @var{Body} to the ordered list @var{List}, returning a new
ordered list containing @var{Body} in @var{NewList}.  If @var{Body} is
already in List, List is returned.").

add_to_body_list([],Body,[Body]).
add_to_body_list([Body0|List],Body,MList) :-
    (Body @< Body0
     ->	MList = [Body,Body0|List]
     ;	Body == Body0
     ->	MList = [Body0|List]
     ;	MList = [Body0|MList1],
	add_to_body_list(List,Body,MList1)
    ).

:- comment(find_in_first_hashtree/3,
"@pred{find_in_first_hashtree(?Term,-Val,+Trie)} returns in @var{Val}
the value associated with key, @var{Term}, found in the first
hash-tree in the ht-trie, @var(Trie}.  It traverses through the first
hash-tree, to return either another ht-trie, if it is internal in the
full trie, or the list of bodies, if it is the last hash-tree of a
full ht-trie.").

find_in_first_hashtree(Term,Val,Trie) :-
    db_comps(Trie,HashBits,_NumInTab,HashTree),
    (var(Term)
     ->	bind_from_hash(Term,Val,HashBits,HashTree)
     ;	Size is floor(2**HashBits),
	machine:term_hash(Term,Size,HashCode),
	(atomic(Term)
	 -> Key = Term
	 ;  Term = '$VAR'(_)
	 -> Key = Term
	 ;  functor(Term,Fun,Ari),
	    Key = Fun/Ari
	),
	find_in_subtree(Key,Val,HashCode,HashBits,HashTree)
    ).

:- comment(find_in_subtree/5,
"find_in_subtree(?Key,-Rec,+HashCode,+HashBits,+HashTree) returns in
@var{Rec} the value associates with key, @var{Key}, which has
hashcode, @var{HashCode}, in hash-tree, @var{HashTree}, whose keys have
@var{HashBits} bits.  It recurses through the hash-tree index.").

find_in_subtree(Key,Rec,HashCode,HashBits,HashTree) :-
    (HashBits =< 0
     ->	my_member((Key-Rec),HashTree)
     ;	HashTree = h(HashTree0,HashTree1,HashTree2,HashTree3),
	NHashBits is HashBits - 2,
	HashBit is HashCode /\ 3,
	NHashCode is HashCode >> 2,
	(HashBit < 2
	 -> (HashBit < 1
	     ->	find_in_subtree(Key,Rec,NHashCode,NHashBits,HashTree0)
	     ;	find_in_subtree(Key,Rec,NHashCode,NHashBits,HashTree1)
	    )
	 ;  HashBit < 3
	 -> find_in_subtree(Key,Rec,NHashCode,NHashBits,HashTree2)
	 ;  find_in_subtree(Key,Rec,NHashCode,NHashBits,HashTree3)
	)
    ).

:- comment(bind_from_hash/4,
"bind_from_hash(-Term,-Rec,+HashBits,+HashTree) nondeterministically
binds the variables@var{Term} and @var{Rec} to the key-value pairs in
hash-tree, @var{HashTree}, whose keys have @var{HashBits} bits.").

bind_from_hash(Term,Val,HashBits,HashTree) :-
    (HashBits =< 0
     ->	my_member((Key-Val),HashTree),
	(Key = Fun/Arity
	 -> functor(Term,Fun,Arity)
	 ;  Term = Key
	)
     ;  HashTree = h(HashTree0,HashTree1,HashTree2,HashTree3),
	NHashBits is HashBits - 2,
	(bind_from_hash(Term,Val,NHashBits,HashTree0)
	 ;  
	 bind_from_hash(Term,Val,NHashBits,HashTree1)
	 ;  
	 bind_from_hash(Term,Val,NHashBits,HashTree2)
	 ;  
	 bind_from_hash(Term,Val,NHashBits,HashTree3)
	)
    ).

%% deterministic for common case of length 1 list (list must be +)
:- index my_member/2-0.
my_member(X,[Y|L]) :-
    (L == []
     ->	X = Y
     ;	(X = Y
	 ;  
	 my_member(X,L)
	)
    ).

:- comment(update_hashtree/5,
"update_hashtree(+Term,?NewVal,-OldVal,+HashTree0,-HashTree) adds a new
key-value pair (or finds an existing pair), @var{Term} and
@var{NewVal}, to the hash-tree, @var{HashTree0}, producing the new
hash-tree, @var{HashTree}.  @var{OldVal} is bound to the previous
value for this key in the hash table (or to [] if this is a new
key.)").

update_hashtree(Term,NewVal,OldVal,HT0,HT) :-
    db_comps(HT0,HashBits,NumInTab,HashTree),
    Size is floor(2**HashBits),
    machine:term_hash(Term,Size,HashCode),
    (atomic(Term)
     ->	Key = Term
     ;	Term = '$VAR'(VN),integer(VN)
     ->	Key = Term
     ;	functor(Term,Fun,Ari),
	Key = Fun/Ari
    ),
    update_subtree(Key,NewVal,OldVal,HashCode,HashBits,Added,HashTree,NHashTree),
    NNumInTab is NumInTab+Added,
    db_comps(HT,HashBits,NNumInTab,NHashTree).

:- comment(update_subtree/8,
"update_subtree(+Key,+NewVal,-OldVal,+HashCode,+HashBits,-Added,+HashTree,-NHashTree)
recurses through @var{HashTree} to add a key-value pair, in @var{Key}
and @var{NewVal}, to the hash-tree, @var{HashTree}, generating a new
hash-tree, @var{NHashTree}.  @var{OldVal} is returned and is the value
for this key in @var{HashTree} (or [] if the key is new.)
@var{HashCode} is the hash code for @var{Key}; @var{HashBits} is the
number of bits in the @var{HashCode} (and in keys in @var{HashTree}),
and @var{Added} is returned as 1 if a new key is added, and 0 if the
key already existed.").

update_subtree(Key,NewVal,OldVal,HashCode,HashBits,Added,HashTree,NHashTree) :-
    (HashBits =< 0
     ->	(NewVal == []
	 -> remove_from_ordered_list(HashTree,Key,OldVal,NHashTree),
	    Added = -1 %???????
	 ;  add_to_ordered_list(HashTree,Key,NewVal,OldVal,Added,NHashTree)
	)
     ;	(HashTree == []
	 -> HashTree0 = [], HashTree1 = [], HashTree2 = [], HashTree3 = []
	 ;  HashTree = h(HashTree0,HashTree1,HashTree2,HashTree3)
	),
	NHashBits is HashBits - 2,
	HashBit is HashCode /\ 3,
	NHashCode is HashCode >> 2,
	(HashBit < 2
	 -> (HashBit < 1
	     ->	NHashTree = h(NHashTree0,HashTree1,HashTree2,HashTree3),
		update_subtree(Key,NewVal,OldVal,NHashCode,NHashBits,Added,HashTree0,NHashTree0)
	     ;	NHashTree = h(HashTree0,NHashTree1,HashTree2,HashTree3),
		update_subtree(Key,NewVal,OldVal,NHashCode,NHashBits,Added,HashTree1,NHashTree1)
	    )
	 ;  HashBit < 3
	 -> NHashTree = h(HashTree0,HashTree1,NHashTree2,HashTree3),
	    update_subtree(Key,NewVal,OldVal,NHashCode,NHashBits,Added,HashTree2,NHashTree2)
	 ;  NHashTree = h(HashTree0,HashTree1,HashTree2,NHashTree3),
	    update_subtree(Key,NewVal,OldVal,NHashCode,NHashBits,Added,HashTree3,NHashTree3)
	)
    ).

:- comment(add_to_ordered_list/6,
"add_to_ordered_list(+OValues,+Key,+NewVal,-OldVal,-Added,-NValues)
adds (or replaces) a key-value pair in an ordered list of key-value
pairs (where the key will be an atom, $VAR, or Pred/Arity and the
value will be a ht-trie.)  @var{OValues} is the old list of key-value
pairs (represented as (@var{Key} - @var{Value}).) The new key-value
pair is (@var{Key} - @var{NewVal}). @var{NValues} is the resulting
list of key-value pairs.  @var{OldVal} is the old value for key
@var{Key} in @var{OValues} (or [] if none), and is returned.
@var{Added} is 1 if the key @var{Key} is new, and 0 if it already
exists in a pair in @var{OValues}.").

add_to_ordered_list(OValues,Key,NewVal,OldVal,Added,NValues) :-
    (OValues == []
     ->	OldVal = [], Added = 1, NValues = [(Key-NewVal)]
     ;	OValues = [OValue|Values],
	OValue = (TKey-TVal),
	(TKey @< Key
	 -> NValues = [OValue|NValues1],
	    add_to_ordered_list(Values,Key,NewVal,OldVal,Added,NValues1)
	 ;  TKey == Key
	 -> NValues = [(Key-NewVal)|Values],
	    Added = 0,
	    OldVal = TVal
	 ;  NValues = [(Key-NewVal)|OValues],
	    Added = 1,
	    OldVal = []
	)
    ).

:- comment(remove_from_trie/5,
"remove_from_trie(+Term,+Value,+Trie0,-Vars,-Trie) removes the term,
@var{Term}, with value, @var{Value}, from the trie @var{Trie0}
yielding @var{Trie}, where @var{Vars} is a log-list of variable
bindings.").

remove_from_trie(Term,Value,Trie0,Vars,Trie) :-
    remove_from_trie_list([Term],Value,Trie0,Vars,Trie).

:- comment(remove_from_trie_list/5,
"remove_from_trie_list(+TermList,?Body,+Trie0,-Vars,-Trie) recurses
through the trie to remove the clause, the remainder of its head is
@var{TermList}, whose body is @var{Body}, from the trie, @var{Trie0},
yielding trie, @var{Trie}. @var{Vars} is a log-list of variable
bindings.").

remove_from_trie_list([],Body,OBodies,_Vars,NBodies) :-
    (nonvar(Body)
     ->	remove_from_ordered_list(OBodies,Body,NBodies)
     ;	NBodies = []
    ).
remove_from_trie_list([Term|TermList],Body,Trie0,Vars,Trie) :-
    (is_most_general_term([Body,Term|TermList])
     ->	Trie = []		% delete everything below!
     ;	(nonvar(Term), Term = '$VAR'(VN), integer(VN)
	 -> basics:log_ith(VN,Vars,NTerm)
	 ;  NTerm = Term
	),
	findall([NTerm|TermList],
		(find_in_first_hashtree(NTerm,_,Trie0),
		 \+ (NTerm = '$VAR'(VN0), integer(VN0))
		),
		TermLists),
	remove_from_trie_lists(TermLists,NTerm,Body,Trie0,Vars,Trie1),
	findall(['$VAR'(VN1)|TermList],
		find_in_first_hashtree('$VAR'(VN1),_,Trie0),
		VTermLists),
	remove_from_trie_lists(VTermLists,NTerm,Body,Trie1,Vars,Trie)
    ).

:- comment(remove_from_trie_lists/6,
"@pred{remove_from_trie_list(+TermLists,+Term,?Body,+Trie0,-Vars,-Trie)}
removes each trie-path for each list in the list, @var{TermLists},
each with clause body, @var{Body}, from the trie, @var{Trie0},
yielding trie, @var{Trie}. @var{Term} is the term at this point in the
input term, used to bind a potential variable in the trie.  @var{Vars}
is a log-list of variable bindings.").

remove_from_trie_lists([],_,_,Trie,_Vars,Trie).
remove_from_trie_lists([TL|TLs],Term,Body,Trie0,Vars,Trie) :-
    (TL = ['$VAR'(VN)|_]
     ->	(copy_term(TL-Vars,NTL-NVars),
	 basics:log_ith(VN,NVars,Term) % new vars
	 -> remove_from_trie_list_nv(NTL,Body,Trie0,NVars,Trie1)
	 ;  Trie1 = Trie0
	)
     ;	remove_from_trie_list_nv(TL,Body,Trie0,Vars,Trie1)
    ),
    remove_from_trie_lists(TLs,Term,Body,Trie1,Vars,Trie).

:- comment(remove_from_trie_list_nv/5,
"@pred{remove_from_trie_list_nv(+TermList,+Body,+Trie0,+Vars,-Trie)}
removes an trie-path, corresponding to @var{TermList}, with body
@var{Body}, from ht-trie, @var{Trie0}, yielding ht-trie, @var{Trie}.
@var{Vars} is a log-list of variable bindings to handle ($VAR)
variables in the input ht-trie, @var{Trie0}.").

remove_from_trie_list_nv([Term|TermList],Body,Trie0,Vars,Trie) :-
    (atomic(Term)
     ->	NTermList = TermList
     ; Term = '$VAR'(_)
     ->	NTermList = TermList
     ;	Term =.. [_|SubTerms],
	basics:append(SubTerms,TermList,NTermList)
    ),
    update_hashtree(Term,NewSubTrie,OldSubTrie,Trie0,Trie1),
    remove_from_trie_list(NTermList,Body,OldSubTrie,Vars,NewSubTrie),
    ((NewSubTrie == [] ; NewSubTrie = ht(_,_,[]))
     ->	remove_from_hash_trie(Term,_OldVal,Trie0,Trie)
     ;	Trie = Trie1
    ).
	
:- comment(remove_from_hash_trie/4,
"@pred{remove_from_hash_trie(+Term,?OldVal,+Trie0,-Trie)} removes the
entry for the pair Term and OldVal from the hash table, HashTree0,
yielding the hash table, HashTree.").

remove_from_hash_trie(Term,OldVal,Trie0,Trie) :-
    db_comps(Trie0,HashBits,NumInTab,HashTree),
    Size is floor(2**HashBits),
    machine:term_hash(Term,Size,HashCode),
    (atomic(Term)
     ->	Key = Term
     ; Term = '$VAR'(I), integer(I)
     ->	Key = Term
     ;	functor(Term,Fun,Ari),
	Key = Fun/Ari
    ),
    NNumInTab is NumInTab - 1,
    remove_from_subtree(Key,OldVal,HashCode,HashBits,HashTree,NHashTree0),
    MinSize is floor(2** (HashBits//2)),
    ((NNumInTab >= MinSize ; Size =< 4)
     ->	NHashTree = NHashTree0,
	NHashBits = HashBits
     ;	NHashBits is HashBits // 2,
	rebuild_hashtree(NHashTree0,HashBits,NHashBits,NHashTree)
    ),
    db_comps(Trie,NHashBits,NNumInTab,NHashTree).

:- comment(remove_from_subtree/6,
"@pred{remove_from_subtree(+Key,?OldVal,+HashCode,+HashBits,+HashTree,-NHashTree)}
removes the entry for the pair @var{Term} and @var{OldVal} from the
hash tree, @var{HashTree}, yielding the hash tree,
@var{NHashTree}. @var{HashCode} is the hash code for @var{Key} and
@var{HashBits} is the number of bits in the hash code (and in all hash
codes for entries in @var{HashTree}).").

remove_from_subtree(Key,OldVal,HashCode,HashBits,HashTree,NHashTree) :-
    (HashBits =< 0
     ->	remove_from_ordered_list(HashTree,Key,OldVal,NHashTree)
     ;	(HashTree == []
	 -> HashTree0 = [], HashTree1 = [], HashTree2 = [], HashTree3 = []
	 ;  HashTree = h(HashTree0,HashTree1,HashTree2,HashTree3)
	),
	NHashBits is HashBits - 2,
	HashBit is HashCode /\ 3,
	NHashCode is HashCode >> 2,
	(HashBit < 2
	 -> (HashBit < 1
	     ->	NNHashTree = h(NHashTree0,HashTree1,HashTree2,HashTree3),
		remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree0,NHashTree0)
	     ;	NNHashTree = h(HashTree0,NHashTree1,HashTree2,HashTree3),
		remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree1,NHashTree1)
	    )
	 ;  HashBit < 3
	 -> NNHashTree = h(HashTree0,HashTree1,NHashTree2,HashTree3),
	    remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree2,NHashTree2)
	 ;  NNHashTree = h(HashTree0,HashTree1,HashTree2,NHashTree3),
	    remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree3,NHashTree3)
	),
	(NNHashTree == h([],[],[],[]) % collapse to keep rep canonical
	 -> NHashTree = []
	 ;  NHashTree = NNHashTree
	)
    ).

:- comment(remove_from_ordered_list/4,
"@pred{remove_from_ordered_list(+OValues,+Key,?OldVal,-NValues)}
removes the pair, (@var{Key} - @var{OldVal}), from the ordered list of pairs in
@var{OValues}, returning the resulting ordered list in @var{NValues}.").

remove_from_ordered_list([OValue|OValues],Key,OldVal,NValues) :-
    (OValue = (Key-OldVal)
     ->	NValues = OValues
     ;	NValues = [OValue|NValues1],
	remove_from_ordered_list(OValues,Key,OldVal,NValues1)
    ).

:- comment(remove_from_ordered_list/3,
"@pred{remove_from_ordered_list(+OValues,+Value,-NValues)} removes
@var{Value} from the list of values in @var{OValues} returning the
list @var{NValues}, failing if it is not there.  This is used at the
leaves of a trie, to remove clause bodies.").

remove_from_ordered_list([OVal|Values],Value,NValues) :-
    (OVal == Value
     ->	NValues = Values
     ;	NValues = [OVal|NValues1],
	remove_from_ordered_list(Values,Value,NValues1)
    ).

:- comment(rebuild_hashtree/4,
"@pred{rebuild_hashtree(+HashTree0,+HashBits,+NewBitSize,-HashTree)}
rebuilds an hash-tree with a different hash-bit size (or width).  This
allows either fixing a hash-tree to be of the right 'width', or to
change the width to agree with another hash-tree one wants to compare
with.  @var{HashTree0} is the old hash-tree with hash-bit size of
@var{HashBits}, @var{NewBitSize} is the new hash-bit size, and
@var{HashTree} is the new re-sized hash-tree. ").

rebuild_hashtree(HashTree0,HashBits,NewBitSize,HashTree) :-
    findall((Term-Val),bind_from_hash(Term,Val,HashBits,HashTree0),TermVals),
    add_all_terms(TermVals,NewBitSize,0,_,[],HashTree).

add_all_terms([],_,N,N,HT,HT).
add_all_terms([(Term-Val)|Terms],HashBits,N0,N,HT0,HT) :-
    Size is floor(2**HashBits),
    machine:term_hash(Term,Size,HashCode),
    (atomic(Term)
     ->	Key = Term
     ;	functor(Term,Fun,Arity),
	Key = Fun/Arity
    ),	 
    update_subtree(Key,Val,_,HashCode,HashBits,Added,HT0,HT1),
    N1 is N0+Added,
    add_all_terms(Terms,HashBits,N1,N,HT1,HT).

:- comment(load_in_db/2, "@pred{load_in_db(+FileName,-DB)} reads the
clauses in @file{FileName} and creates the database @var{DB} that
contains them.").

load_in_db(FileName,DB) :-
    empty_db(DB0),
    load_in_db(FileName,DB0,DB).

:- comment(load_in_dbi/2, "@pred{load_in_dbi(+FileName,-DB)} reads the
clauses in @file{FileName} and creates the interned database @var{DB}
that contains them.").

load_in_dbi(FileName,H) :-
    load_in_db(FileName,DB),
    intern_termhash(DB,H).

:- comment(load_in_db/3, "@pred{load_in_db(+FileName,+DB0,-DB)} reads
the clauses in @file{FileName} and adds them to the database
@var{DB0}, creating a new database @var{DB}.").

load_in_db(FileName,DB0,DB) :-
    open(FileName,read,IStr),
    read_terms_to_trie(IStr,DB0,DB),
    close(IStr).

:- comment(load_in_dbi/3, "@pred{load_in_dbi(+FileName,+H0,-H)} reads
the clauses in @file{FileName} and adds them to the interned database
@var{H0}, creating a new interned database @var{H}.").

load_in_dbi(FileName,H0,H) :-
    intern_termhash(DB0,H0),
    load_in_db(FileName,DB0,DB),
    intern_termhash(DB,H).

read_terms_to_trie(IStr,DB0,DB) :-
    read(IStr,Term),
    (Term == end_of_file
     ->	DB = DB0
     ;	assert_in_db(Term,DB0,DB1),
	read_terms_to_trie(IStr,DB1,DB)
    ).


my_unnumbervars(Term,Vars,NTerm) :-
    (var(Vars)			% no vars, so must be ground
     ->	NTerm = Term
     ; var(Term)
     ->	NTerm = Term
     ;	atomic(Term)
     ->	NTerm = Term
     ;	Term = '$VAR'(I),integer(I)
     ->	basics:log_ith(I,Vars,NTerm)
     ;	Term =.. [F|Args],
	my_unnumbervars_list(Args,Vars,NArgs),
	NTerm =.. [F|NArgs]
    ).

my_unnumbervars_list([],_,[]).
my_unnumbervars_list([Term|Terms],Vars,[NTerm|NTerms]) :-
    my_unnumbervars(Term,Vars,NTerm),
    my_unnumbervars_list(Terms,Vars,NTerms).

/**********************************************************/

:- comment(find_hashtable_for_prefix/4,
"@pred{find_hashtable_for_prefix(+HeadTail,+HT,-TailLen,-SHT)}
searches for the ht-trie associated in the ht-trie @var{HT} with the
first subterm of @var{HeadTail} that is a variable.  @var{HeadTail}
must consist (when sequentialized) of a sequence of bound terms
followed by a sequence of distinct variables.  If this condition does
not hold, the predicate fails.  The ht-trie that is found is returned
in @var{SHT}, and the number of variables remaining in the tail is
returned in @var{TailLen}.").

find_hashtable_for_prefix([HeadTerm|HeadTail],HT,TailLen,SHT) :-
    nonvar(HeadTerm),
    find_in_first_hashtree(HeadTerm,SHT0,HT),
    (atomic(HeadTerm)
     ->	NHeadTail = HeadTail
     ;	HeadTerm =.. [_|SubTerms],
	basics:append(SubTerms,HeadTail,NHeadTail)
    ),
    NHeadTail \== [],
    (is_most_general_term(NHeadTail)
     ->	basics:length(NHeadTail,TailLen),
	SHT = SHT0
     ;	find_hashtable_for_prefix(NHeadTail,SHT0,TailLen,SHT)
    ).

:- comment(update_hashtable/4,
"@pred{update_hashtable_for_prefix(+HeadTail,+NSHT,+OSHT,-TailLen,+HT0,-HT)}
replaces the ht-trie that is associated in the ht-trie @var{HT0} with
the first variable subterm of @var{HeadTail} with the ht-trie
@var{NSHT}.  The ht-trie that is replaced is returned in @var{OSHT}.
The new ht-trie with the replaced subterm is returned in @var{HT}.
@var{HeadTail} must consist (when sequentialized) of a sequence of
bound terms followed by a sequence of distinct variables.  If this
condition does not hold, the predicate fails.  ").

%% DSW: can we combine this with assert_ref_with_trie, and have both efficient?
update_hashtree_for_prefix(HeadTail,NSHT,OSHT,TailLen,HT0,HT) :-
    (NSHT == []
     ->	check_prefix_term(HeadTail,TailLen,'*_in_db/5'),
	remove_from_trie_list(HeadTail,_,HT0,_,HT)
     ;	update_hashtree_for_prefix_1(HeadTail,NSHT,OSHT,TailLen,HT0,HT)
    ).

update_hashtree_for_prefix_1([HeadTerm|HeadTail],NSHT,OSHT,TailLen,HT0,HT) :-
    nonvar(HeadTerm),
    NSHT \== [],
    (atomic(HeadTerm)
     ->	NHeadTail = HeadTail
     ;	HeadTerm =.. [_|SubTerms],
	basics:append(SubTerms,HeadTail,NHeadTail)
    ),
    NHeadTail \== [],
    (is_most_general_term(NHeadTail)
     ->	basics:length(NHeadTail,TailLen),
	update_hashtree(HeadTerm,NSHT,OSHT,HT0,HT)
     ;	update_hashtree(HeadTerm,NSHT0,OSHT0,HT0,HT),
	update_hashtree_for_prefix_1(NHeadTail,NSHT,OSHT,TailLen,OSHT0,NSHT0)
    ).


check_taillen(T1,T2,HeadTail,MsgPred) :-
    (T1 = T2
     ->	true
     ;	misc_error(('[',MsgPred,'] Predicate selection pattern: ',HeadTail,
		    ' is inconsistent with other patterns.'))
    ).

check_prefix_term(HeadTail,TailLen,MsgPred) :-
    (is_prefix_term(HeadTail,TailLen0)
     ->	check_taillen(TailLen,TailLen0,HeadTail,MsgPred)
     ;	misc_error(('[',MsgPred,'] Predicate selection pattern: ',HeadTail,' is illegal.'))
    ).

:- comment(is_prefix_term/2,"
@pred{is_prefix_term(+HeadTail,?TailLen)} checks that @var{HeadTail}
is a @tt{prefix-term}.  A @tt{prefix term} is a prolog term that, when
viewed in prefix order, consists of a sequence of constants followed
by a sequence of distinct variables.  Such a term uniquely determines
a position in a term trie (i.e., prolog DB). ").

is_prefix_term(HeadTail,TailLen) :-
    tail_from_prefix_term(HeadTail,Tail),
    basics:length(Tail,TailLen).

tail_from_prefix_term(HeadTail,TailVars) :-
    HeadTail = [Head|Tail],
    (ground(Head)
     ->	tail_from_prefix_term(Tail,TailVars)
     ;	(var(Head)
	 -> is_most_general_term(HeadTail),
	    TailVars = HeadTail
	 ;  Head =.. [_|Args],
	    basics:append(Args,Tail,ArgsTail),
	    tail_from_prefix_term(ArgsTail,TailVars)
	)
    ).


:- comment(apply_op_in_db/6,
"@pred{apply_op_in_db(+OpLambda,+P1,+P2,+P3,+DB0,?DB)} applies a
binary database operation (union, intersect, subtract, etc.) to two
predicates in a database and puts the result into another predicate in
the database.  For example, to union the tuples of p/3 and q/3 and put
the result into r/3, one could do:

@begin{verbatim}
| ?- assert_in_db([p(a,c,d),p(a,d,e),q(a,c,d),q(b,c,d)],DB1),
	   apply_op_in_db(lambda(A,B,C,union_db(A,B,C)),p/3,q/3,r/3,DB1,DB2),
	   dump_db(DB2,userout).
@end{verbatim}

Here we have put tuples for @tt{p/3} and @tt{q/3} into @var{DB1}.
Then we union those two predicates, putting the result into a
predicate @tt{r/3} in the new database @var{DB2}.  And then we print
out the resulting database.

@var{Pref1}, @var{Pref2}, and @var{Pref3} must be prefix terms.  (For
convenience, the form @tt{Pred/Arity} is converted to a prefix term
using @pred{functor/3}.  Clearly, this is the most commonly used form
of prefix terms.)  The operation of @var{OpLambda} is of the form
@tt{lambda(Var1,...,Varn,Goal)}, which is called by binding the
arguments to @var{Var2} through @var{Varn} and then @tt{call}-ing
@var{Goal}.  The operation must take 2 input trie (databases) and
produce an output trie (database.)  The operation will be applied to
the two tries determined in the input database, @var{DB0}, by the two
prefix terms, and the resulting trie will replace the trie determined
by the target prefix term, creating a new database @var{DB}.  (The
target prefix term will be added if it is not in the input database,
@var{DB0}.)  ").

apply_op_in_db(lambda(HT1,HT2,HT3,Op),Pref1,Pref2,Pref3,DB0,DB) :-
    cvt_pa(Pref1,Pref1a),
    cvt_pa(Pref2,Pref2a),
    cvt_pa(Pref3,Pref3a),
    (find_hashtable_for_prefix([Pref1a],DB0,TL,HT1)
     ->	true
     ;	HT1 = [],
	check_prefix_term([Pref1a],TL,'*_in_db/5')
    ),
    (find_hashtable_for_prefix([Pref2a],DB0,TL2,HT2)
     ->	check_taillen(TL,TL2,Pref2a,'*_in_db/5')
     ;	HT2 = [],
	check_prefix_term([Pref2a],TL,'*_in_db/5')
    ),
    call(Op),
    (update_hashtree_for_prefix([Pref3a],HT3,_,TL,DB0,DB)
     ->	true
     ;	misc_error(('[*_in_db/5] Predicate selection pattern: ',Pref3a,
		    ' is inconsistent with other patterns.'))
    ).

:- comment(apply_op_in_dbi/6, "
@pred{apply_op_in_dbi(+Op,+P1,+P2,+P3,+H0,-H)} has the exact
functionality of @pred{apply_op_in_db(Op,P1,P2,P3,DB0,DB)}, but takes
an interned DB trie in @var{H0} (an integer encoding the interned DB
trie) and produces an updated interned DB trie in @var{H}.  ").

apply_op_in_dbi(Op,P1,P2,P3,H0,H) :-
    intern_termhash(DB0,H0),
    apply_op_in_db(Op,P1,P2,P3,DB0,DB),
    intern_termhash(DB,H).

cvt_pa(PA,PSkel) :-
    (PA = P/A
    -> functor(PSkel,P,A)
    ;  PSkel = PA
    ).

:- comment(apply_rel_op_in_db/4, "
@pred{apply_rel_op_in_db(+RelOpLambdaTerm,+Pref1,+Pref2,+DB)} applies
the relational operator specified in @var{RelOpLambdaTerm} to the
subtries determined by @var{Pref1} and @var{Pref2} in @var{DB} and
succeeds or fails accordingly.  @var{RelOpLambdaTerm} is of the form
@tt{lambda(HT1,HT2,Goal)}, where @var{HT1} and @var{HT2} are variables
and @var{Goal} is a binary goal whose arguments are those varaibles.
The goal must define the desired relational operator on subtries.  ").

apply_rel_op_in_db(lambda(HT1,HT2,Op),Pref1,Pref2,DB) :-
    cvt_pa(Pref1,Pref1a),
    cvt_pa(Pref2,Pref2a),
    (find_hashtable_for_prefix([Pref1a],DB,TL,HT1)
     -> true
     ;	HT1 = [],
	check_prefix_term([Pref1a],TL,'*_in_db/3')
    ),
    (find_hashtable_for_prefix([Pref2a],DB,TL,HT2)
     ->	true
     ;	HT2 = [],
	check_prefix_term([Pref2a],TL,'*_in_db/3')
    ),
    call(Op).

:- comment(apply_rel_op_in_dbi/4, "
@pred{apply_rel_op_in_dbi(+Op,+P1,+P2,+H)} has the exact functionality
of @pred{apply_rel_op_in_db(Op,P1,P2,DB)}, but takes an interned DB
trie in @var{H} (an integer encoding the interned DB trie). ").

apply_rel_op_in_dbi(lambda(HT1,HT2,Op),Pref1,Pref2,H) :-
    intern_termhash(DB,H),
    apply_rel_op_in_db(lambda(HT1,HT2,Op),Pref1,Pref2,DB).

/**********************************************************/

/* These operations are just to support testing. */

:- export naive_subset_db/2, naive_union_db/3, naive_intersect_db/3.
:- export naive_difference_db/3.
:- export naive_disjoint_db/2.
:- export naive_sym_diff_db/3.

naive_union_db(DB1,DB2,DB3) :-
    findall((H:-B),find_in_trie(H,B,DB1),Clauses),
    assert_in_db(Clauses,DB2,DB3).

naive_intersect_db(DB1,DB2,DB3) :-
    valid_db(DB1,'intersect_fact_db/3'),
    valid_db(DB2,'intersect_fact_db/3'),
    findall((H:-B),(find_in_trie(H,B,DB1),find_in_trie(H,B,DB2)),Rules),
    empty_db(DB4),
    assert_in_db(Rules,DB4,DB3).

naive_difference_db(DB1,DB2,DB3) :-
    valid_db(DB1,'difference_fact_db/3'),
    valid_db(DB2,'difference_fact_db/3'),
    findall((H:-B),(clause_in_db(H,B,DB1),
		    \+clause_in_db(H,B,DB2)
		   ),
		   Clauses),
    empty_db(DB0),
    assert_in_db(Clauses,DB0,DB3).

naive_sym_diff_db(DB1,DB2,DB3) :-
    valid_db(DB1,'sym_diff_fact_db/3'),
    valid_db(DB2,'sym_diff_fact_db/3'),
    findall((H:-B),
	    (clause_in_db(H,B,DB1),
	     \+ clause_in_db(H,B,DB2)
	     ;	
	     clause_in_db(H,B,DB2),
	     \+ clause_in_db(H,B,DB1)
	    ),
	    Clauses),
    empty_db(DB0),
    assert_in_db(Clauses,DB0,DB3).

naive_subset_db(DB1,DB2) :-
    \+ (clause_in_db(H,B,DB1),
	\+ clause_in_db(H,B,DB2)).

naive_disjoint_db(DB1,DB2) :-
    \+ (clause_in_db(H,B,DB1),
	clause_in_db(H,B,DB2)).

/*** end of testing operations ***/
/**********************************************************/

:- comment(union_db/3, " @pred{union_db(+DB1,+DB2,-DB)} takes two
prolog databases (tries), in @var{DB1} and @var{DB2} and produces a
prolog DB, in @var{DB}, that is the union of the two input databases.
This is done by traversing the two input tries in concert and in the
process generating the output trie.  This allows the output trie to
share subtries with the input tries, and to perhaps avoid traversing
large portions of the input tries.  For example, if the two input
databases contain facts for disjoint predicates, the union just
creates a new trie that points to entire definitions of the predicates
in the input tries, so such a union is done in time proportional to
the number of predicates, and completely independent of the size
(i.e., the number of tuples) of the predicates.  ").

union_db(DB1,DB2,DB) :-
    (DB1 == DB2
     ->	DB = DB1
     ;	db_comps(DB1,HBits1,Num1,HT1),
     	db_comps(DB2,HBits2,Num2,HT2),
	(HBits1 < HBits2
	 -> HBits = HBits2,
	    rebuild_hashtree(HT1,HBits1,HBits,HT1b),
	    union_subtrees(HBits,HT1b,HT2,DNum,NHT)
	 ; HBits2 < HBits1
	 -> HBits = HBits1,
	    rebuild_hashtree(HT2,HBits2,HBits,HT2b),
	    union_subtrees(HBits,HT1,HT2b,DNum,NHT)
	 ;  HBits = HBits1,
	    union_subtrees(HBits,HT1,HT2,DNum,NHT)
	),
	NNum is Num1 + Num2 - DNum,
	fix_ht_size(HBits,NNum,NHT,DB)
    ).

:- comment(union_dbi/3, " @pred{union_dbi(+H1,+H2,-H)} has the same
functionality as @pred{union_db(DB1,DB2,DB)}, but takes and produces
interned terms for the trie arguments. ").

union_dbi(H1,H2,H) :-
    intern_termhash(DB1,H1),
    intern_termhash(DB2,H2),
    union_db(DB1,DB2,DB),
    intern_termhash(DB,H).

:- comment(union_in_db/5, "@pred{union_in_db(+P1,+P2,+P3,+DB0,?DB)}
unions two subtries in @var{DB0} producing a new (or replaced) subtrie
in @var{DB}.  The input tries are determined by the prefix terms of
@var{P1} and @var{P2}, and the place of the resulting trie is
determined by prefix term @var{P3}.  (See @pred{is_prefix_term/2} and
@pred{apply_op_in_db/6} for discussions of prefix terms.)  ").

union_in_db(P1,P2,P3,H0,H) :-
    apply_op_in_db(lambda(A,B,C,union_db(A,B,C)),P1,P2,P3,H0,H).

:- comment(union_in_dbi/5, "@pred{union_in_dbi(+P1,+P2,+P3,+H0,?H)}
performs the same operation as @pred{union_in_db/5} except it expects
(in @var{H0}) and returns (in @var{H}) interned databases.  ").

union_in_dbi(P1,P2,P3,H0,H) :-
    apply_op_in_dbi(lambda(A,B,C,union_db(A,B,C)),P1,P2,P3,H0,H).


union_subtrees(HashBits,HT1,HT2,DNum,HT) :-
    (HashBits =< 0
     ->	union_kvs(HT1,HT2,0,DNum,HT)
     ;	h_comps(HT1,HT10,HT11,HT12,HT13),
	h_comps(HT2,HT20,HT21,HT22,HT23),
	union_subtree(HashBits,HT10,HT20,DNum0,HT30),
	union_subtree(HashBits,HT11,HT21,DNum1,HT31),
	union_subtree(HashBits,HT12,HT22,DNum2,HT32),
	union_subtree(HashBits,HT13,HT23,DNum3,HT33),
	DNum is DNum0+DNum1+DNum2+DNum3,
	h_comps(HT,HT30,HT31,HT32,HT33)
    ).

%% DNum is diff, negative for loss (dupls)
union_subtree(HashBits,SHT1,SHT2,DNum,SHT) :-
    (SHT1 == []
     ->	SHT = SHT2, DNum = 0
     ; SHT2 == []
     ->	SHT = SHT1, DNum = 0
     ; SHT1 == SHT2
     ->	SHT = SHT1, count_keys(SHT,DNum)
     ;	NHashBits is HashBits - 2,
	union_subtrees(NHashBits,SHT1,SHT2,DNum,SHT)
    ).

%% DNum is number in both sets (so will be subtracted from sum to get count.)
union_kvs(HT1,HT2,DNum0,DNum,HT) :- 
    (HT1 == []
     ->	DNum = DNum0,
	HT = HT2
     ; HT2 == []
     ->	DNum = DNum0,
	HT = HT1
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> HT = [K1-V1|HTt],
	    union_kvs(HT1t,HT2,DNum0,DNum,HTt)
	 ;  K1 @> K2
	 -> HT = [K2-V2|HTt],
	    union_kvs(HT1,HT2t,DNum0,DNum,HTt)
	 ;  (V1 @= ht(_,_,_)
	     ->	union_db(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	     ;	union_values(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	    ),
	    DNum1 is DNum0 + Added,
	    union_kvs(HT1t,HT2t,DNum1,DNum,HTt)	
	)
    ).
    
union_values(V1s,V2s,V3s) :-
    (V1s == []
     ->	V3s = V2s
     ; V2s == []
     ->	V3s = V1s
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> V3s = [V1|V3st],
	    union_values(V1st,V2s,V3st)
	 ;  V1 @> V2
	 -> V3s = [V2|V3st],
	    union_values(V1s,V2st,V3st)
	 ;  V3s = [V1|V3st],
	    union_values(V1st,V2st,V3st)
	)
    ).
	
/********************************************************/

:- comment(intersect_db/3, " @pred{intersect_db(+DB1,+DB2,?DB)} takes
two prolog databases (tries), in @var{DB1} and @var{DB2} and produces
a prolog DB, in @var{DB}, that is the intersection of the two input
databases.  This is done by traversing the two input tries in concert
and in the process generating the output trie.  This allows the output
trie to share subtries with the input tries, and to perhaps avoid
traversing large portions of the input tries.  For example, if the two
input databases contain facts for disjoint predicates, the intersect
just creates a new trie that contains none of the predicates, so such
an Intersection is done in time proportional to the number of
predicates, and completely independent of the size (i.e., the number
of tuples) of the predicates.  ").

intersect_db(DB1,DB2,DB) :-
    (DB1 == DB2
     ->	DB = DB1
     ;	db_comps(DB1,HBits1,_Num1,HT1),
     	db_comps(DB2,HBits2,_Num2,HT2),
	(HBits1 < HBits2
	 -> HBits = HBits2,
	    rebuild_hashtree(HT1,HBits1,HBits,HT1b),
	    intersect_subtrees(HBits,HT1b,HT2,INum,NHT)
	 ; HBits2 < HBits1
	 -> HBits = HBits1,
	    rebuild_hashtree(HT2,HBits2,HBits,HT2b),
	    intersect_subtrees(HBits,HT1,HT2b,INum,NHT)
	 ;  HBits = HBits1,
	    intersect_subtrees(HBits,HT1,HT2,INum,NHT)
	),
	fix_ht_size(HBits,INum,NHT,DB)
    ).

:- comment(intersect_dbi/3, " @pred{intersect_dbi(+H1,+H2,-H)} has the same
functionality as @pred{intersect_db(DB1,DB2,DB)}, but takes and produces
interned terms for the trie arguments. ").

intersect_dbi(H1,H2,H) :-
    intern_termhash(DB1,H1),
    intern_termhash(DB2,H2),
    intersect_db(DB1,DB2,DB),
    intern_termhash(DB,H).

:- comment(intersect_in_db/5,
"@pred{intersect_in_db(+P1,+P2,+P3,+DB0,?DB)} intersects two subtries
in @var{DB0} producing a new (or replaced) subtrie in @var{DB}.  The
input tries are determined by the prefix terms of @var{P1} and
@var{P2}, and the place of the resulting trie is determined by prefix
term @var{P3}.  (See @pred{is_prefix_term/2} and
@pred{apply_op_in_db/6} for discussions of prefix terms.)  ").

intersect_in_db(P1,P2,P3,DB0,DB) :-
    apply_op_in_db(lambda(A,B,C,intersect_db(A,B,C)),P1,P2,P3,DB0,DB).

:- comment(intersect_in_dbi/5,
"@pred{intersect_in_dbi(+P1,+P2,+P3,+H0,?H)} performs the same
operation as @pred{intersect_in_db/5} except it expects (in @var{H0})
and returns (in @var{H}) interned databases.  ").

intersect_in_dbi(P1,P2,P3,DB0,DB) :-
    apply_op_in_dbi(lambda(A,B,C,intersect_db(A,B,C)),P1,P2,P3,DB0,DB).

intersect_subtrees(HashBits,HT1,HT2,INum,HT) :-
    (HashBits =< 0
    ->	intersect_kvs(HT1,HT2,0,INum,HT)
     ;	h_comps(HT1,HT10,HT11,HT12,HT13),
	h_comps(HT2,HT20,HT21,HT22,HT23),
	intersect_subtree(HashBits,HT10,HT20,INum0,HT30),
	intersect_subtree(HashBits,HT11,HT21,INum1,HT31),
	intersect_subtree(HashBits,HT12,HT22,INum2,HT32),
	intersect_subtree(HashBits,HT13,HT23,INum3,HT33),
	INum is INum0+INum1+INum2+INum3,
	h_comps(HT,HT30,HT31,HT32,HT33)
    ).

intersect_subtree(HashBits,SHT1,SHT2,INum,SHT) :-
    (SHT1 == []
     ->	SHT = [], INum = 0
     ; SHT2 == []
     ->	SHT = [], INum = 0
     ; SHT1 == SHT2
     ->	SHT = SHT1, count_keys(SHT,INum)
     ;	NHashBits is HashBits - 2,
	intersect_subtrees(NHashBits,SHT1,SHT2,INum,SHT)
    ).

intersect_kvs(HT1,HT2,INum0,INum,HT) :-
    (HT1 == []
     ->	INum = INum0, HT = []
     ; HT2 == []
     ->	INum = INum0, HT = []
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> intersect_kvs(HT1t,HT2,INum0,INum,HT)
	 ;  K1 @> K2
	 -> intersect_kvs(HT1,HT2t,INum0,INum,HT)
	 ;  (V1 @= ht(_,_,_)
	     ->	intersect_db(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	     ;	intersect_values(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	    ),
	    INum1 is INum0 + Added,
	    intersect_kvs(HT1t,HT2t,INum1,INum,HTt)
	)
    ).
    
intersect_values(V1s,V2s,V3s) :-
    (V1s == []
     ->	V3s = []
     ; V2s == []
     ->	V3s = []
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> intersect_values(V1st,V2s,V3s)
	 ;  V1 @> V2
	 -> intersect_values(V1s,V2st,V3s)
	 ;  V3s = [V1|V3st],
	    intersect_values(V1st,V2st,V3st)
	)
    ).

/********************************************************/

:- comment(difference_db/3, " @var{difference_db(+DB1,+DB2,?DB)} takes
two prolog databases (tries), in @var{DB1} and @var{DB2} and produces
a prolog DB, in @var{DB}, that is set difference of the two input
databases, i.e., all tuples in @var{DB1} that are not in @var{DB2}.
This is done by traversing the two input tries in concert and in the
process generating the output trie.  This allows the output trie to
share subtries with the input tries, and to perhaps avoid traversing
large portions of the input tries.  For example, if the two input
databases contain the same sets of tuples, the difference immediately
detects that and returns the empty database.  ").

difference_db(DB1,DB2,DB) :-
    (DB1 == DB2
     ->	DB = []
     ;	db_comps(DB1,HBits1,Num1,HT1),
     	db_comps(DB2,HBits2,_Num2,HT2),
	(HBits1 < HBits2
	 -> HBits = HBits2,
	    rebuild_hashtree(HT1,HBits1,HBits,HT1b),
	    difference_subtrees(HBits,HT1b,HT2,RNum,NHT)
	 ; HBits2 < HBits1
	 -> HBits = HBits1,
	    rebuild_hashtree(HT2,HBits2,HBits,HT2b),
	    difference_subtrees(HBits,HT1,HT2b,RNum,NHT)
	 ;  HBits = HBits1,
	    difference_subtrees(HBits,HT1,HT2,RNum,NHT)
	),
	NNum is Num1-RNum,
	fix_ht_size(HBits,NNum,NHT,DB)
    ).

:- comment(difference_dbi/3, " @pred{difference_dbi(+H1,+H2,-H)} has the same
functionality as @pred{difference_db(DB1,DB2,DB)}, but takes and produces
interned terms for the trie arguments. ").

difference_dbi(H1,H2,H) :-
    intern_termhash(DB1,H1),
    intern_termhash(DB2,H2),
    difference_db(DB1,DB2,DB),
    intern_termhash(DB,H).

:- comment(difference_in_db/5,
"@pred{difference_in_db(+P1,+P2,+P3,+DB0,?DB)} computes the set
difference of two subtries in @var{DB0} producing a new (or replaced)
subtrie in @var{DB}.  The input tries are determined by the prefix
terms of @var{P1} and @var{P2}, and the place of the resulting trie is
determined by prefix term @var{P3}.  (See @pred{is_prefix_term/2} and
@pred{apply_op_in_db/6} for discussions of prefix terms.)  ").

difference_in_db(P1,P2,P3,DB0,DB) :-
    apply_op_in_db(lambda(A,B,C,difference_db(A,B,C)),P1,P2,P3,DB0,DB).

:- comment(difference_in_dbi/5, "@pred{difference_in_dbi(+P1,+P2,+P3,+H0,?H)}
performs the same operation as @pred{difference_in_db/5} except it expects
(in @var{H0}) and returns (in @var{H}) interned databases.  ").

difference_in_dbi(P1,P2,P3,H0,H) :-
    apply_op_in_dbi(lambda(A,B,C,difference_db(A,B,C)),P1,P2,P3,H0,H).

difference_subtrees(HashBits,HT1,HT2,RNum,HT) :-
    (HashBits =< 0
    ->	difference_kvs(HT1,HT2,0,RNum,HT)
     ;	h_comps(HT1,HT10,HT11,HT12,HT13),
	h_comps(HT2,HT20,HT21,HT22,HT23),
	difference_subtree(HashBits,HT10,HT20,RNum0,HT30),
	difference_subtree(HashBits,HT11,HT21,RNum1,HT31),
	difference_subtree(HashBits,HT12,HT22,RNum2,HT32),
	difference_subtree(HashBits,HT13,HT23,RNum3,HT33),
	RNum is RNum0+RNum1+RNum2+RNum3,
	h_comps(HT,HT30,HT31,HT32,HT33)
    ).

difference_subtree(HashBits,SHT1,SHT2,RNum,SHT) :-
    (SHT1 == []
     ->	SHT = [], RNum = 0
     ; SHT2 == []
     ->	SHT = SHT1, RNum = 0
     ; SHT1 == SHT2
     ->	SHT = [], count_keys(SHT1,RNum)
     ;	NHashBits is HashBits - 2,
	difference_subtrees(NHashBits,SHT1,SHT2,RNum,SHT)
    ).

%% RNum is number removed from list, *not* in list.
difference_kvs(HT1,HT2,RNum0,RNum,HT) :-
    (HT1 == []
     ->	RNum = RNum0, HT = []
     ; HT2 = []
     ->	RNum = RNum0, 
	HT = HT1
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> HT = [K1-V1|HTt],
	    difference_kvs(HT1t,HT2,RNum0,RNum,HTt)
	 ;  K1 @> K2
	 -> difference_kvs(HT1,HT2t,RNum0,RNum,HT)
	 ;  (V1 @= ht(_,_,_)
	     ->	difference_db(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	     ;	difference_values(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	    ),
	    RNum1 is RNum0 + 1 - Added,
	    difference_kvs(HT1t,HT2t,RNum1,RNum,HTt)
	)
    ).
    
%%difference_values(_,_,_) :- writeln(userout,difference_values),fail.
difference_values(V1s,V2s,V3s) :-
    (V1s == []
     ->	V3s = []
     ; V2s == []
     ->	V3s = V1s
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> V3s = [V1|V3st],
	    difference_values(V1st,V2s,V3st)
	 ;  V1 @> V2
	 -> difference_values(V1s,V2st,V3s)
	 ;  difference_values(V1st,V2st,V3s)
	)
    ).

/********************************************************/

:- comment(sym_diff_db/3, " @var{sym_diff_db(+DB1,+DB2,?DB)} takes two
prolog databases (tries), in @var{DB1} and @var{DB2} and produces a
prolog DB, in @var{DB}, that is symmetric difference of the two input
databases, i.e., all tuples in one but not both of @var{DB1} and
@var{DB2}.  This is done by traversing the two input tries in concert
and in the process generating the output trie.  This allows the output
trie to share subtries with the input tries, and to perhaps avoid
traversing large portions of the input tries.  ").

sym_diff_db(DB1,DB2,DB) :-
    (DB1 == DB2
     ->	DB = []
     ;	db_comps(DB1,HBits1,_Num1,HT1),
     	db_comps(DB2,HBits2,_Num2,HT2),
	(HBits1 < HBits2
	 -> HBits = HBits2,
	    rebuild_hashtree(HT1,HBits1,HBits,HT1b),
	    sym_diff_subtrees(HBits,HT1b,HT2,RNum,NHT)
	 ; HBits2 < HBits1
	 -> HBits = HBits1,
	    rebuild_hashtree(HT2,HBits2,HBits,HT2b),
	    sym_diff_subtrees(HBits,HT1,HT2b,RNum,NHT)
	 ;  HBits = HBits1,
	    sym_diff_subtrees(HBits,HT1,HT2,RNum,NHT)
	),
	fix_ht_size(HBits,RNum,NHT,DB)
    ).

:- comment(sym_diff_dbi/3, " @pred{sym_diff_dbi(+H1,+H2,-H)} has the
same functionality as @pred{sym_diff_db(DB1,DB2,DB)}, but takes and
produces interned terms for the trie arguments. ").

sym_diff_dbi(H1,H2,H) :-
    intern_termhash(DB1,H1),
    intern_termhash(DB2,H2),
    sym_diff_db(DB1,DB2,DB),
    intern_termhash(DB,H).

:- comment(sym_diff_in_db/5,
"@pred{sym_diff_in_db(+P1,+P2,+P3,+DB0,?DB)} computes the symmetric
difference of two subtries in @var{DB0} producing a new (or replaced)
subtrie in @var{DB}.  The input tries are determined by the prefix
terms of @var{P1} and @var{P2}, and the place of the resulting trie is
determined by prefix term @var{P3}.  (See @pred{is_prefix_term/2} and
@pred{apply_op_in_db/6} for discussions of prefix terms.)  ").

sym_diff_in_db(P1,P2,P3,DB0,DB) :-
    apply_op_in_db(lambda(A,B,C,sym_diff_db(A,B,C)),P1,P2,P3,DB0,DB).

:- comment(sym_diff_in_dbi/5,
"@pred{sym_diff_in_dbi(+P1,+P2,+P3,+H0,?H)} performs the same
operation as @pred{sym_diff_in_db/5} except it expects (in @var{H0})
and returns (in @var{H}) interned databases.  ").

sym_diff_in_dbi(P1,P2,P3,DB0,DB) :-
    apply_op_in_dbi(lambda(A,B,C,sym_diff_db(A,B,C)),P1,P2,P3,DB0,DB).

% RNum is number in result.
sym_diff_subtrees(HashBits,HT1,HT2,RNum,HT) :-
    (HashBits =< 0
    ->	sym_diff_kvs(HT1,HT2,0,RNum,HT)
     ;	h_comps(HT1,HT10,HT11,HT12,HT13),
	h_comps(HT2,HT20,HT21,HT22,HT23),
	sym_diff_subtree(HashBits,HT10,HT20,RNum0,HT30),
	sym_diff_subtree(HashBits,HT11,HT21,RNum1,HT31),
	sym_diff_subtree(HashBits,HT12,HT22,RNum2,HT32),
	sym_diff_subtree(HashBits,HT13,HT23,RNum3,HT33),
	RNum is RNum0+RNum1+RNum2+RNum3,
	h_comps(HT,HT30,HT31,HT32,HT33)
    ).

sym_diff_subtree(HashBits,SHT1,SHT2,RNum,SHT) :-
    (SHT1 == []
     ->	SHT = SHT2, count_keys(SHT,RNum)
     ; SHT2 == []
     ->	SHT = SHT1, count_keys(SHT,RNum)
     ; SHT1 == SHT2
     ->	SHT = [], RNum = 0
     ;	NHashBits is HashBits - 2,
	sym_diff_subtrees(NHashBits,SHT1,SHT2,RNum,SHT)
    ).

sym_diff_kvs(HT1,HT2,RNum0,RNum,HT) :-
    (HT1 == []
     ->	basics:length(HT2,Len),
	RNum is RNum0 + Len,
	HT = HT2
     ; HT2 = []
     ->	basics:length(HT1,Len),
	RNum is RNum0 + Len,
	HT = HT1
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> HT = [K1-V1|HTt],
	    RNum1 is RNum0 + 1,
	    sym_diff_kvs(HT1t,HT2,RNum1,RNum,HTt)
	 ;  K1 @> K2
	 -> HT = [K2-V2|HTt],
	    RNum1 is RNum0 + 1,
	    sym_diff_kvs(HT1,HT2t,RNum1,RNum,HTt)
	 ;  (V1 @= ht(_,_,_)
	     ->	sym_diff_db(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	     ;	sym_diff_values(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	    ),
	    RNum1 is RNum0 + Added,
	    sym_diff_kvs(HT1t,HT2t,RNum1,RNum,HTt)
	)
    ).
    
sym_diff_values(V1s,V2s,V3s) :-
    (V1s == []
     ->	V3s = V2s
     ; V2s == []
     ->	V3s = V1s
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> V3s = [V1|V3st],
	    sym_diff_values(V1st,V2s,V3st)
	 ;  V1 @> V2
	 -> V3s = [V2|V3st],
	    sym_diff_values(V1s,V2st,V3st)
	 ;  sym_diff_values(V1st,V2st,V3s)
	)
    ).

/********************************************************/

:- comment(xprod_in_db/5,"
@pred{xprod_in_db(+Pref1,+Pref2,+Pref3,+DB0,?DB)} computes the cross
product of the tries determined by @var{Pref1} and @var{Pref2} and
puts the result at the position determined by @var{Pref3}.  The number
of variables in @var{Pref3} must be the sum of the numbers of
variables in @var{Pref1} and @var{Pref2}.  For example, assuming the
call to build_db constructs a prolog database, @var{DB0}, the query:
@begin{verbatim}	   
| ?- build_db(DB),xprod_in_db(p(_,_),q(_,_,_),r(_,_,_,_,_),DB0,DB).
@end{verbatim}	   
would compute the cross product of relations p/2 and q/3 in @var{DB0}
putting the result in r/5 (with r tuples having the p values preceding
the q values). The predicate r/5 is added or replaced and the new DB
@var{DB} is generated. (Note that, since the form p/2 is converted to
prefix term p(_,_), p/2, q/3 and r/5 could be used in place of the
explicit prefix terms in this query.)

The tuples of r/5 would be as though it were defined by the following
Prolog rule:
@begin{verbatim}
r(P1,P2,Q1,Q2,Q3) :- r(P1,P2), q(Q1,Q2,Q3).
@end{verbatim}

The @var{Pref1} values must be facts (i.e., clauses without (non-true)
bodies.)  The complexity of this operation is the size of the
@var{Pref1} trie, since every leaf of the @var{Pref1} trie is
essentially extended with a pointer to the @var{Pref2} trie.  ").

xprod_in_db(Pref1,Pref2,Pref3,DB0,DB) :-
    cvt_pa(Pref1,Pref1a),
    cvt_pa(Pref2,Pref2a),
    cvt_pa(Pref3,Pref3a),
    (find_hashtable_for_prefix([Pref2a],DB0,TLen2,HT2),
     find_hashtable_for_prefix([Pref1a],DB0,TLen1,HT1)
     ->	check_prefix_term([Pref3a],TLen3,'xprod_in_db/5'),
	(TLen3 =\= TLen1+TLen2
	 -> misc_error(('[prolog_db:xprod_in_db] ',Pref1,', ',Pref2,', and ',
			Pref3,' are inconsistent for cross product.'))
	 ;  update_hashtree_for_prefix([Pref3a],NSHT,_OSHT,TLen3,DB0,DB),
	    xprod_ht(HT1,HT2,NSHT)
	)
     ;  retractall_in_db(Pref3a,DB0,DB) % one or other component is empty
    ).
     
:- comment(xprod_in_dbi/5, "@pred{xprod_in_dbi(+P1,+P2,+P3,+H0,?H)}
performs the same operation as @pred{xprod_in_db/5} except it expects
(in @var{H0}) and returns (in @var{H}) interned databases.  ").

xprod_in_dbi(Pref1,Pref2,Pref3,H0,H) :-
    intern_termhash(DB0,H0),
    xprod_in_db(Pref1,Pref2,Pref3,DB0,DB),
    intern_termhash(DB,H).

xprod_ht(HT1,HT2,NSHT) :-
    db_comps(HT1,HashBits,Num,HTree),
    db_comps(NSHT,HashBits,Num,NHTree),
    xprod_htrees(HashBits,HTree,HT2,NHTree).

xprod_htrees(HashBits,HTree,HT2,NHTree) :-
    (HashBits =< 0
     ->	xprod_kvs(HTree,HT2,NHTree)
     ;	h_comps(HTree,H1,H2,H3,H4),
	xprod_htree(HashBits,H1,HT2,NH1),
	xprod_htree(HashBits,H2,HT2,NH2),
	xprod_htree(HashBits,H3,HT2,NH3),
	xprod_htree(HashBits,H4,HT2,NH4),
	h_comps(NHTree,NH1,NH2,NH3,NH4)
    ).

xprod_htree(HashBits,H,HT2,NH) :-
    (H == []
     ->	NH = []
     ;	NHashBits is HashBits - 2,
	xprod_htrees(NHashBits,H,HT2,NH)
    ).

xprod_kvs([],_HT2,[]).
xprod_kvs([K-V|KVs],HT2,[K-NV|NKVs]) :-
    (V @= ht(_,_,_)
     ->	xprod_ht(V,HT2,NV)
     ;	(V == [true]
	 -> NV = HT2
	 ;  misc_error(('[prolog_db:xprod_in_db]: left argument not facts'))
	)
    ),
    xprod_kvs(KVs,HT2,NKVs).

/********************************************************/

:- comment(join_in_db/6, 
"@pred{join_in_db(+Pref1,+Pref2,+NJoin,+Pref3,+DB0,?DB)} performs an
equi-join of tuples of terms specified by @var{Pref1} and @var{Pref2}
producing a new set of terms as specified in @var{Pref3}.  @var{NJoin}
is the number of join variables.  The join arguments are the first
@var{NJoin} fields of the tuples specified by @var{Pref1} and
@var{Pref2}.  The number of variables in @var{Pref3} must be the sum
of the numbers of variables in @var{Pref1} and @var{Pref2} minus
@var{NJoin}.  Assuming the the call to @pred{build_db/1} builds a
prolog DB in @var{DB0}, an example query might be:
@begin{verbatim}
| ?- build_db(DB0),join_in_db(p/3,q/4,1,r/6,DB0,DB).
@end{verbatim}

This query would materialize the predicate r/6 in to @var{DB}, where r/6
definition in Prolog would be:
@begin{verbatim}
r(J,P2,P3,Q2,Q3,Q4) :- p(J,P2,P3), q(J,Q2,Q3,Q4).
@end{verbatim}

The p/3 clauses must be facts. (q/4 could have rules with non-empty
bodies, but I don't see any application for this.)  ").

join_in_db(Pref1,Pref2,NJoin,Pref3,DB0,DB) :-
    cvt_pa(Pref1,Pref1a),
    cvt_pa(Pref2,Pref2a),
    cvt_pa(Pref3,Pref3a),
    find_hashtable_for_prefix([Pref1a],DB0,TLen1,HT1),
    find_hashtable_for_prefix([Pref2a],DB0,TLen2,HT2),
    OutLen is TLen1+TLen2-NJoin,
    check_prefix_term([Pref3a],OutLen,'join_in_db/6'),
    join_ht(HT1,HT2,NJoin,HT3),
    (HT3 == []
     ->	retractall_in_db(Pref3a,DB0,DB)
     ;	update_hashtree_for_prefix([Pref3a],HT3,_,_,DB0,DB)
    ).

:- comment(join_in_dbi/6, "@pred{join_in_dbi(+P1,+P2,+N,+P3,+H0,?H)}
performs the same operation as @pred{join_in_db/6} except it expects
(in @var{H0}) and returns (in @var{H}) interned databases.  ").

join_in_dbi(Pref1,Pref2,NJoin,Pref3,H0,H) :-
    intern_termhash(DB0,H0),
    join_in_db(Pref1,Pref2,NJoin,Pref3,DB0,DB),
    intern_termhash(DB,H).

join_ht([],_DB2,_N,[]) :- !.
join_ht(_DB1,[],_N,[]) :- !.
join_ht(DB1,DB2,NJoin,DB) :-
    db_comps(DB1,HBits1,_Num1,HT1),
    db_comps(DB2,HBits2,_Num2,HT2),
    (HBits1 < HBits2
     ->	HBits = HBits2,
	rebuild_hashtree(HT1,HBits1,HBits,HT1b),
	join_subtrees(HBits,HT1b,HT2,NJoin,INum,NHT)
     ;	HBits2 < HBits1
     ->	HBits = HBits1,
	rebuild_hashtree(HT2,HBits2,HBits,HT2b),
	join_subtrees(HBits,HT1,HT2b,NJoin,INum,NHT)
     ;	HBits = HBits1,
	join_subtrees(HBits,HT1,HT2,NJoin,INum,NHT)
    ),
    fix_ht_size(HBits,INum,NHT,DB).

join_subtrees(HashBits,HT1,HT2,NJoin,INum,HT) :-
    (HashBits =< 0
     ->	join_kvs(HT1,HT2,NJoin,0,INum,HT)
     ;	h_comps(HT1,HT10,HT11,HT12,HT13),
	h_comps(HT2,HT20,HT21,HT22,HT23),
	join_subtree(HashBits,HT10,HT20,NJoin,INum0,HT30),
	join_subtree(HashBits,HT11,HT21,NJoin,INum1,HT31),
	join_subtree(HashBits,HT12,HT22,NJoin,INum2,HT32),
	join_subtree(HashBits,HT13,HT23,NJoin,INum3,HT33),
	INum is INum0+INum1+INum2+INum3,
	h_comps(HT,HT30,HT31,HT32,HT33)
    ).

join_subtree(HashBits,HT1,HT2,NJoin,INum,HT) :-
    (HT1 == []
     ->	HT = [], INum = 0
     ; HT2 == []
     ->	HT = [], INum = 0
     ;	NHashBits is HashBits - 2,
	join_subtrees(NHashBits,HT1,HT2,NJoin,INum,HT)
    ).

join_kvs(KVs1,KVs2,NJoin,INum0,INum,KVs) :-
    (KVs1 == []
     ->	INum = INum0,
	KVs = []
     ; KVs2 == []
     ->	INum = INum0,
	KVs = []
     ;	KVs1 = [K1-V1|KVs1r],
     	KVs2 = [K2-V2|KVs2r],
	(K1 @< K2
	 -> join_kvs(KVs1r,KVs2,NJoin,INum0,INum,KVs)
	 ;  K1 @> K2
	 -> join_kvs(KVs1,KVs2r,NJoin,INum0,INum,KVs)
	 ;  (K1 = _P/Arity
	     ->	NJoin1 is NJoin - 1 + Arity
	     ;	NJoin1 is NJoin - 1
	    ),
	    (NJoin1 =:= 0
	     ->	xprod_ht(V1,V2,NV)
	     ;	join_ht(V1,V2,NJoin1,NV)
	    ),
	    add_kv(NV,K1,Added,KVs,KVsR),
	    INum1 is INum0 + Added,
	    join_kvs(KVs1r,KVs2r,NJoin,INum1,INum,KVsR)
	)
    ).

/********************************************************/

:- comment(reindex_in_db/4,
"@pred{reindex_in_db(+PrefI,+PrefO,+DB0,DB)} generates a new version
of the set of tuples determined by the @var{PrefI} prefix term by
re-ordering its arguments and puts it in the predicate determined by
@var{PrefO}.  Note one can understand this a changing the index on
@var{Pref1} since tuples are indexed in left-to-right order.  The
variables in @var{PrefO} must be a permutation of the variables in
@var{PrefI}, which defines the reordering of the arguments.  Note that
the tries corresponding to an unchanged final sequence of variables in
the two prefix terms will not be traversed in the reindexing.

An following example interchanges the first two arguments of @tt{p/4}
in @var{DB0} to create @tt{q/4} in @var{DB}:
@begin{verbatim}	   
| ?- build_db(DB0),reindex_in_db(p(A,B,C,D),q(B,A,C,D),DB0,DB).
@end{verbatim}	   

Note that reindexing can bring a later argument to the beginning so it
would be available for use in a call to @pred{join_in_db/6}.  ").

reindex_in_db(PrefI,PrefO,DB0,DB) :-
    cvt_pa(PrefI,PrefIa),
    cvt_pa(PrefO,PrefOa),
    find_hashtable_for_prefix([PrefIa],DB0,TLen,IHT),
    tail_from_prefix_term([PrefIa],IVars),
    is_most_general_term(IVars),
    tail_from_prefix_term([PrefOa],OVars),
    is_most_general_term(OVars),
    num_common_tail_vars(IVars,OVars,NCom),
    NArgs is TLen - NCom,
    basics:length(IArgs,NArgs),
    basics:append(IArgs,_,IVars),
    copy_term(PrefO,OPrefO),
    check_prefix_term([PrefOa],TLen,'reindex_in_db/4'),
    reindex_ht(IHT,IArgs,NArgs,OPrefO,PrefOa,DB0,DB).

:- comment(reindex_in_dbi/4, "@pred{reindex_in_dbi(+P1,+P2,+H0,?H)}
performs the same operation as @pred{reindex_in_db/4} except it
expects (in @var{H0}) and returns (in @var{H}) interned databases.
").

reindex_in_dbi(PrefI,PrefO,H0,H) :-
    intern_termhash(DB0,H0),
    reindex_in_db(PrefI,PrefO,DB0,DB),
    intern_termhash(DB,H).

num_common_tail_vars(IV,OV,NCom) :-
    (IV == OV
     ->	basics:length(IV,NCom)
     ;	IV = [_|IVt],
	OV = [_|OVt],
	num_common_tail_vars(IVt,OVt,NCom)
    ).

reindex_ht([],_CArgs,_NArgs,_OPrefO,_PrefO,DB,DB) :- !.
reindex_ht(IHT,CArgs,NArgs,OPrefO,PrefO,DB0,DB) :-
    db_comps(IHT,HBits,_Num,HTree),
    reindex_subtrees(HBits,HTree,CArgs,NArgs,OPrefO,PrefO,DB0,DB).

reindex_subtrees(HashBits,HTree,CArgs,NArgs,OPrefO,PrefO,DB0,DB) :-
    (HashBits =< 0
     ->	reindex_kvs(HTree,CArgs,NArgs,OPrefO,PrefO,DB0,DB)
     ;	h_comps(HTree,HTree1,HTree2,HTree3,HTree4),
	reindex_subtree(HashBits,HTree1,CArgs,NArgs,OPrefO,PrefO,DB0,DB1),
	reindex_subtree(HashBits,HTree2,CArgs,NArgs,OPrefO,PrefO,DB1,DB2),
	reindex_subtree(HashBits,HTree3,CArgs,NArgs,OPrefO,PrefO,DB2,DB3),
	reindex_subtree(HashBits,HTree4,CArgs,NArgs,OPrefO,PrefO,DB3,DB)
    ).

reindex_subtree(HashBits,HTree,CArgs,NArgs,OPrefO,PrefO,DB0,DB) :-
    (HTree == []
     ->	DB = DB0
     ;	NHashBits is HashBits - 2,
	reindex_subtrees(NHashBits,HTree,CArgs,NArgs,OPrefO,PrefO,DB0,DB)
    ).

reindex_kvs([],_CArgs,_NArgs,_OPrefO,_PrefO,DB,DB).
reindex_kvs(KVs,CArgs,NArgs,OPrefO,PrefO,DB0,DB) :-
    KVs = [K-V|KVsr],
    copy_term(CArgs-PrefO,CArgsT-PrefOT),
    CArgsT = [CArgT|RemArgs],
    (K = Pred/Arity
     ->	functor(CArgT,Pred,Arity),
	CArgT =.. [Pred|Args],
	basics:append(Args,RemArgs,NCArgs)
     ;	CArgT = K,
	NCArgs = RemArgs
    ),
    (NCArgs == []
     ->	assert_pref_with_trie([PrefOT],[OPrefO],NArgs,V,DB0,DB1)
     ;	reindex_ht(V,NCArgs,NArgs,OPrefO,PrefOT,DB0,DB1)
    ),
    reindex_kvs(KVsr,CArgs,NArgs,OPrefO,PrefO,DB1,DB).

assert_pref_with_trie([HeadTerm|HeadTail],OPref,NArgs,HT,DB0,DB) :-
    (atomic(HeadTerm)
     ->	NHeadTail = HeadTail,
	(is_most_general_term(OPref)
	 -> NArgs1 is NArgs - 1,
	    OPrefTail = constant % is simpler most general term
	 ;  OPref = [HeadTerm|OPrefTail],
	    NArgs1 = NArgs
	)
     ; HeadTerm = '$VAR'(VN),integer(VN)
     ->	NHeadTail = HeadTail,
	(is_most_general_term(OPref)
	 -> NArgs1 is NArgs - 1,
	    OPrefTail = constant
	 ;  OPref = [_|OPrefTail],
	    NArgs1 = NArgs
	)
     ;  HeadTerm =.. [_|SubTerms],
	basics:length(SubTerms,K),
	basics:append(SubTerms,HeadTail,NHeadTail),
	(is_most_general_term(OPref)
	 -> NArgs1 is NArgs - 1 + K,
	    OPrefT = constant
	 ;  OPref = [OPrefH|OPrefT],
	    OPrefH =.. [_|PrefSubTerms],
	    basics:append(PrefSubTerms,OPrefT,OPrefTail),
	    NArgs1 = NArgs
	)
    ),
    (NArgs1 =:= 0
     ->	update_hashtree(HeadTerm,HT,_,DB0,DB1) % add SubTrie HT
     ;	update_hashtree(HeadTerm,NewSubTrie,OldSubTrie,DB0,DB1),
	assert_pref_with_trie(NHeadTail,OPrefTail,NArgs1,HT,OldSubTrie,NewSubTrie)
    ),
    db_comps(DB1,HashBits,NumInTab,HashTree),
    (NumInTab < floor(2**HashBits)
     ->	DB = DB1
     ;	NHashBits is HashBits*2,
	db_comps(DB,NHashBits,NumInTab,NHashTree),
	rebuild_hashtree(HashTree,HashBits,NHashBits,NHashTree)
    ).


/********************************************************/

:- comment(project_in_db/5,
"@pred{project_in_db(+PrefI,+NArgs,+PrefO,+DB0,?DB)} creates a new
relation that projects away the first @var{NArgs} of the tuples of
@var{PrefI} in @var{DB0}, adding the result according to @var{PrefO}
in @var{DB}.  The number of variables in @var{PrefI} minus @var{NArgs}
must equal the number of variables in @var{PrefO}.  An example of its
use is:
	   
@begin{verbatim}	   
| ?- build_db(DB0),project_in_db(p(_,_,_,_),2,q(_,_),DB0,DB).
@end{verbatim}

which projects away the first two arguments of the @tt{p/4} relation
in @var{DB0} to generate the @tt{q/2} relation in @var{DB}.
").

project_in_db(PrefI,NArgs,PrefO,DB0,DB) :-
    cvt_pa(PrefI,PrefIa),
    cvt_pa(PrefO,PrefOa),
    find_hashtable_for_prefix([PrefIa],DB0,TLen,IHT),
    TLenO is TLen - NArgs,
    check_prefix_term([PrefOa],TLenO,'project_in_db/5'),
    project_ht(IHT,NArgs,OHT),
    (OHT == []
     ->	remove_from_trie(PrefOa,_,DB0,_,DB)
     ;	update_hashtree_for_prefix([PrefOa],OHT,_,_,DB0,DB)
    ).

:- comment(project_in_dbi/5,
"@pred{project_in_dbi(+P1,NArgs,+P2,+H0,?H)} performs the same
operation as @pred{project_in_db/5} except it expects (in @var{H0})
and returns (in @var{H}) interned databases.  ").

project_in_dbi(PrefI,NArgs,PrefO,H0,H) :-
    intern_termhash(DB0,H0),
    project_in_db(PrefI,NArgs,PrefO,DB0,DB),
    intern_termhash(DB,H).

project_ht([],_,[]).
project_ht(IHT,NArgs,OHT) :-
    db_comps(IHT,HBits,_Num,HTree),
    project_subtrees(HBits,HTree,NArgs,[],OHT).

project_subtrees(HashBits,HTree,NArgs,DB0,DB) :-
    (HashBits =< 0
     ->	project_kvs(HTree,NArgs,DB0,DB)
     ;	h_comps(HTree,HTree1,HTree2,HTree3,HTree4),
	project_subtree(HashBits,HTree1,NArgs,DB0,DB1),
	project_subtree(HashBits,HTree2,NArgs,DB1,DB2),
	project_subtree(HashBits,HTree3,NArgs,DB2,DB3),
	project_subtree(HashBits,HTree4,NArgs,DB3,DB)
    ).

project_subtree(HashBits,HTree,NArgs,DB0,DB) :-
    (HTree == []
     ->	DB = DB0
     ;	NHashBits is HashBits - 2,
	project_subtrees(NHashBits,HTree,NArgs,DB0,DB)
    ).

project_kvs([],_NArgs,DB,DB).
project_kvs(KVs,NArgs,DB0,DB) :-
    KVs = [K-V|KVsr],
    (K = Pred/Arity
     ->	functor(CArgT,Pred,Arity),
	CArgT =.. [Pred|Args],
	basics:append(Args,RemArgs,NCArgs),
	basics:length(Args,NNew),
	NArgs1 is NArgs - 1 + NNew
     ;	CArgT = K,
	NCArgs = RemArgs,
	NArgs1 is NArgs - 1
    ),
    (NArgs1 =:= 0
     ->	union_db(V,DB0,DB1)
     ;	project_ht(V,NArgs1,DB2),
	union_db(DB2,DB0,DB1)
    ),
    project_kvs(KVsr,NArgs,DB1,DB).


/********************************************************/

:- comment(copy_in_db/4, "@pred{copy_in_db(+PrefI,+PrefO,+DB0,?DB)}
makes a copy of @var{PrefI} into @var{Pref0} generating @var{DB} from
@var{DB0}.  @var{PrefI} and @var{PrefO} must have the same number of
variables.  This is a very fast operation since it simple copies the
pointer to the appropriate subtrie. ").

copy_in_db(PrefI,PrefO,DB0,DB) :-
    cvt_pa(PrefI,PrefIa),
    cvt_pa(PrefO,PrefOa),
    (find_hashtable_for_prefix([PrefIa],DB0,TL,HT1)
     ->	true
     ;	HT1 = [],
	check_prefix_term([PrefIa],TL,'copy_in_db/4')
    ),
    (update_hashtree_for_prefix([PrefOa],HT1,_,TL,DB0,DB)
     ->	true
     ;	misc_error(('[prolog_in_db:copy_in_db/4] Predicate selection pattern: ',PrefOa,
		    ' is illegal or inconsistent with other patterns.'))
    ).

:- comment(copy_in_dbi/4, "@pred{copy_in_dbi(+P1,+P2,+H0,?H)} performs
the same operation as @pred{copy_in_db/4} except it expects (in
@var{H0}) and returns (in @var{H}) interned databases.  ").

copy_in_dbi(PrefI,PrefO,H0,H) :-
    intern_termhash(DB0,H0),
    copy_in_db(PrefI,PrefO,DB0,DB),
    intern_termhash(DB,H).

:- comment(materialize_in_db/4,
"@pred{materialize_in_db(+PrefI,+PrefO,+DB0,?DB)} calls the query
@var{PrefI} in @var{DB0} and asserts the term @var{Pref0} into
@var{DB} for every answer.  Normally every variable in @var{Pref0}
will be in the goal @var{PrefI}.  ").

materialize_in_db(PrefI,PrefO,DB0,DB) :-
    cvt_pa(PrefI,PrefIa),
    cvt_pa(PrefO,PrefOa),
    tail_from_prefix_term([PrefIa],Tail),
    tail_from_prefix_term([PrefOa],Tail),
    findall(PrefOa,call_in_db(PrefIa,DB0),Facts),
    retractall_in_db(PrefOa,DB0,DB1),
    assert_in_db(Facts,DB1,DB).

:- comment(materialize_in_dbi/4,
"@pred{materialize_in_dbi(+P1,+P2,+H0,?H)} performs the same operation
as @pred{materialize_in_db/4} except it expects (in @var{H0}) and
returns (in @var{H}) interned databases.  ").

materialize_in_dbi(PrefI,PrefO,H0,H) :-
    intern_termhash(DB0,H0),
    materialize_in_db(PrefI,PrefO,DB0,DB),
    intern_termhash(DB,H).

/******************************************************/

:- comment(subset_db/2, "@pred{subset_db(+DB1,+DB2)} succeeds if the
terms in prolog DB @var{DB1} are a subset of the terms in prolog DB
@pred{DB2}, and fails otherwise. ").

subset_db(DB1,DB2) :-
    (DB1 == DB2
     ->	true
     ;	db_comps(DB1,HBits1,_Num1,HT1),
     	db_comps(DB2,HBits2,_Num2,HT2),
	(HBits1 < HBits2
	 -> rebuild_hashtree(HT1,HBits1,HBits2,HT1b),
	    subset_subtrees(HBits2,HT1b,HT2)
	 ; HBits2 < HBits1
	 -> rebuild_hashtree(HT2,HBits2,HBits1,HT2b),
	    subset_subtrees(HBits1,HT1,HT2b)
	 ;  subset_subtrees(HBits1,HT1,HT2)
	)
    ).

:- comment(subset_dbi/2, " @pred{subset_dbi(+H1,+H2)} has the same
functionality as @pred{subset_db(DB1,DB2)}, but takes interned terms
for the trie arguments. ").

subset_dbi(H1,H2) :-
    intern_termhash(DB1,H1),
    intern_termhash(DB2,H2),
    subset_db(DB1,DB2).

:- comment(subset_in_db/3, "@pred{subset_in_db(+Pref1,+Pref2,+DB)}
succeeds if the tuples specified by prefix term @var{Pref1} are a
subset of those specified by @var{Pref2} in @var{DB}.  The number of
variables in @var{Pref1} and @var{Pref2} must be the same. ").

subset_in_db(P1,P2,DB) :-
    apply_rel_op_in_db(lambda(A,B,subset_db(A,B)),P1,P2,DB).

:- comment(subset_in_dbi/3, "@pred{subset_in_dbi(+P1,+P2,+H)} performs
the same function as @pred{subset_in_db/3}, but expects the database
argument to be an interned trie. ").

subset_in_dbi(P1,P2,DB) :-
    apply_rel_op_in_dbi(lambda(A,B,subset_db(A,B)),P1,P2,DB).

subset_subtrees(HashBits,HT1,HT2) :-
    (HashBits =< 0
    ->	subset_kvs(HT1,HT2)
     ;	h_comps(HT1,HT10,HT11,HT12,HT13),
	h_comps(HT2,HT20,HT21,HT22,HT23),
	subset_subtree(HashBits,HT10,HT20),
	subset_subtree(HashBits,HT11,HT21),
	subset_subtree(HashBits,HT12,HT22),
	subset_subtree(HashBits,HT13,HT23)
    ).

subset_subtree(HashBits,SHT1,SHT2) :-
    (SHT1 == []
     ->	true
     ; SHT2 == []
     ->	fail
     ; SHT1 == SHT2
     ->	true
     ;	NHashBits is HashBits - 2,
	subset_subtrees(NHashBits,SHT1,SHT2)
    ).

subset_kvs(HT1,HT2) :-
    (HT1 == []
     ->	true
     ; HT2 == []
     ->	fail
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> fail
	 ;  K1 @> K2
	 -> subset_kvs(HT1,HT2t)
	 ;  (V1 @= ht(_,_,_)
	     ->	subset_db(V1,V2)
	     ;	subset_values(V1,V2)
	    ),
	    subset_kvs(HT1t,HT2t)
	)
    ).

subset_values(V1s,V2s) :-
    (V1s == []
     ->	true
     ; V2s == []
     ->	fail
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> fail
	 ;  V1 @> V2
	 -> subset_values(V1s,V2st)
	 ;  subset_values(V1st,V2st)
	)
    ).

/******************************************************/
subsumed_in_db(P1,P2,DB) :-
    apply_rel_op_in_db(lambda(A,B,subsumed_db(A,B)),P1,P2,DB).

subsumed_in_dbi(P1,P2,DB) :-
    apply_rel_op_in_dbi(lambda(A,B,subsumed_db(A,B)),P1,P2,DB).

subsumed_dbi(H1,H2) :-
    intern_termhash(DB1,H1),
    intern_termhash(DB2,H2),
    subsumed_db(DB1,DB2).

subsumed_db(DB1,DB2) :-
    difference_db(DB1,DB2,DDB),
    findall((H:-B),clause_in_db(H,B,DDB),Clauses),
    all_subsumed(Clauses,DB2).


all_subsumed([],_).
all_subsumed([(Head:-Body)|Clauses],DB) :-
    (Body = true
     ->	subsumed_in_db(Head,DB)
     ;	subsumed_rule_in_db(Head,Body,DB)
    ),
    all_subsumed(Clauses,DB).

subsumed_in_db(G,DB) :-
    term_variables(G,Vars),
    call_in_db(G,DB),
    is_most_general_term(Vars).

%% Hack for rules; must exist another single rule with eq-shorter body
%% with all subgoals subsuming this body
subsumed_rule_in_db(Head,Body,DB) :-
    term_variables(Head,Vars),
    clause_in_db(Head,GBody,DB),
    is_most_general_term(Vars),
    subsumes_goal_lists(GBody,Body).

subsumes_goal_lists(GBody,Body) :-
    (GBody = (G1,Gs)
     ->	subsumes_some(G1,Body),
	subsumes_goal_lists(Gs,Body)
     ;	subsumes_some(GBody,Body)
    ).

subsumes_some(G,Body) :-
    (Body = (B1,Bs)
     ->	(subsumes_chk(G,B1)
	 -> true
	 ;  subsumes_some(G,Bs)
	)
     ;	subsumes_chk(G,Body)
    ).


/******************************************************/
disjoint_in_db(P1,P2,DB) :-
    apply_rel_op_in_db(lambda(A,B,disjoint_db(A,B)),P1,P2,DB).

disjoint_in_dbi(P1,P2,DB) :-
    apply_rel_op_in_dbi(lambda(A,B,disjoint_db(A,B)),P1,P2,DB).

disjoint_db(DB1,DB2) :-
    (DB1 == DB2
     ->	empty_db(DB1)
     ;	db_comps(DB1,HBits1,_Num1,HT1),
     	db_comps(DB2,HBits2,_Num2,HT2),
	(HBits1 < HBits2
	 -> rebuild_hashtree(HT1,HBits1,HBits2,HT1b),
	    disjoint_subtrees(HBits2,HT1b,HT2)
	 ; HBits2 < HBits1
	 -> rebuild_hashtree(HT2,HBits2,HBits1,HT2b),
	    disjoint_subtrees(HBits1,HT1,HT2b)
	 ;  disjoint_subtrees(HBits1,HT1,HT2)
	)
    ).

disjoint_dbi(H1,H2) :-
    intern_termhash(DB1,H1),
    intern_termhash(DB2,H2),
    disjoint_db(DB1,DB2).

disjoint_subtrees(HashBits,HT1,HT2) :-
    (HashBits =< 0
    ->	disjoint_kvs(HT1,HT2)
     ;	h_comps(HT1,HT10,HT11,HT12,HT13),
	h_comps(HT2,HT20,HT21,HT22,HT23),
	disjoint_subtree(HashBits,HT10,HT20),
	disjoint_subtree(HashBits,HT11,HT21),
	disjoint_subtree(HashBits,HT12,HT22),
	disjoint_subtree(HashBits,HT13,HT23)
    ).

disjoint_subtree(HashBits,SHT1,SHT2) :-
    (SHT1 == []
     ->	true
     ; SHT2 == []
     ->	true
     ; SHT1 == SHT2
     ->	fail
     ;	NHashBits is HashBits - 2,
	disjoint_subtrees(NHashBits,SHT1,SHT2)
    ).

disjoint_kvs(HT1,HT2) :-
    (HT1 == []
     ->	true
     ; HT2 == []
     ->	true
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> disjoint_kvs(HT1t,HT2)
	 ;  K1 @> K2
	 -> disjoint_kvs(HT1,HT2t)
	 ;  (V1 @= ht(_,_,_)
	     ->	disjoint_db(V1,V2)
	     ;	disjoint_values(V1,V2)
	    ),
	    disjoint_kvs(HT1t,HT2t)
	)
    ).
    
disjoint_values(V1s,V2s) :-
    (V1s == []
     ->	true
     ; V2s == []
     ->	true
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> disjoint_values(V1st,V2s)
	 ;  V1 @> V2
	 -> disjoint_values(V1s,V2st)
	 ;  fail
	)
    ).

/**********************************************************/

equal_in_db(P1,P2,DB) :-
    apply_rel_op_in_db(lambda(A,B,(A==B)),P1,P2,DB).

equal_in_dbi(P1,P2,DB) :-
    apply_rel_op_in_dbi(lambda(A,B,(A==B)),P1,P2,DB).


/**********************************************************/
/* Add op to make a copy of a predicate, or maybe a subpart of a trie.
I.e., give a new name (initial sequence) and add the initial sequence
and point to same subtrie for the copy.  E.g.,
trie_copy(p(a,q(_,_),_,_), p(a,r(_,_),_,_), DB0, DB).  Then for every
p(a,q(A,B),C,D) in trie, it adds p(a,r(A,B),C,D).  If no r term is
there, it does copy, just adding r/2 node and pointing to other trie.
If r-terms are already there, then it does a union and replacing that
r-term subtrie with the unioned one.
*/
/**********************************************************/

db_comps(DB,B,N,H) :-
    (DB=[], B=2, N=0, H=[]
     ->	true
     ;	DB = ht(B,N,H)
    ).

h_comps(H,H1,H2,H3,H4) :-
    (H=[], H1=[], H2=[], H3=[], H4=[]
     ->	true
     ;	H = h(H1,H2,H3,H4)
    ).

add_kv(V,K,A,HT0,HT) :-
    (V = []
     ->	HT0 = HT,
	A = 0
     ;	HT0 = [K-V|HT],
	A = 1
    ).

count_keys([],0).
count_keys([_|R],N) :-
    (R == []
     ->	N = 1
     ;	length(R,N1),
	N is N1+1
    ).
count_keys(h(HT1,HT2,HT3,HT4),N) :-
    count_keys(HT1,N1),
    count_keys(HT2,N2),
    count_keys(HT3,N3),
    count_keys(HT4,N4),
    N is N1+N2+N3+N4.

fix_ht_size(_HBits,0,HT,[]) :- !,
    (HT == []
     ->	true
     ;	standard:writeln(userout,'ERROR in ht num, internal bug!! ')
    ).
fix_ht_size(HBits,NNum,HT,DB) :-
    (NNum =< 1
     ->	GHBits = 2
     ;	GHBits is 2**ceiling(log(log(NNum+1)/log(2))/log(2))
    ),
    (GHBits =:= HBits
     ->	db_comps(DB,HBits,NNum,HT)
     ;	rebuild_hashtree(HT,HBits,GHBits,NHT),
	db_comps(DB,GHBits,NNum,NHT)
    ).


%% test:
/*
   empty_db(_DB0),
   assert_in_db((app([_X|_L1],_L2,[_X|_L3]):-app(_L1,_L2,_L3)),_DB1,_DB2),
   call_in_db(app(XX,YY,[a,b,c]),_DB2).
**/

% load_in_db('prolog_db.P',_DB),call_in_db((empty_db(_DB0),assert_in_db(app([],_L,_L),_DB0,_DB1),assert_in_db((app([_X|_L1],_L2,[_X|_L3]):-app(_L1,_L2,_L3)),_DB1,_DB2),pure_call_in_db(app(RES1,RES2,[a,b,c,d,e]),_DB2)),_DB).

/* 
   [prolog_db],
   empty_db(_DB0),
   assert_in_db(app([],_L,_L),_DB0,_DB1),
   assert_in_db((app([_X|_L1],_L2,[_X|_L3]):-app(_L1,_L2,_L3)),_DB1,_DB2),
   assert_in_db(nrev([],[]),_DB2,_DB3),
   assert_in_db((nrev([_X|_LL],_RR) :- nrev(_LL,_RR1),app(_RR1,[_X],_RR)),_DB3,_DB4),
   pure_call_in_db((cputime(_T0),
                    (nrev([a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z],REV),writeln(userout,REV),fail ; true),
		     cputime(_T1),Time is _T1-_T0
		   ),
		   _DB4).
*/
	      

/*
   load_in_db('prolog_db.P',_DB),
   call_in_db((empty_db(_DB0),
               assert_in_db(app([],_L,_L),_DB0,_DB1),
	       assert_in_db((app([_X|_L1],_L2,[_X|_L3]):-app(_L1,_L2,_L3)),_DB1,_DB2),
	       assert_in_db(nrev([],[]),_DB2,_DB3),
	       assert_in_db((nrev([_X|_LL],_RR) :- nrev(_LL,_RR1),app(_RR1,[_X],_RR)),_DB3,_DB4),
	       pure_call_in_db((cputime(_T0),
	                        (nrev([a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z],REV),writeln(userout,REV),fail ; true),
				cputime(_T1),Time is _T1-_T0
			      ),_DB4)
	       ),_DB).
*/


% load_in_db('prolog_db.P',_DB),call_in_db((cputime(T0),empty_db(DB0),assert_in_db(app([],L,L),DB0,DB1),assert_in_db((app([X|L1],L2,[X|L3]):-app(L1,L2,L3)),DB1,DB2),(pure_call_in_db(app(RES1,RES2,[a,b,c,d,e]),DB2),fail;true),cputime(T1),Time is T1-T0),_DB).

/*
empty_db(D0),assert_in_db(t(a),D0,D1),assert_in_db(t(b),D1,D2),assert_in_db(t(c),D2,D3),assert_in_db(t(d),D3,D4),assert_in_db(t(e),D4,D5),assert_in_db(t(f),D5,D6),assert_in_db(t(g),D6,D7),assert_in_db(t(h),D7,D8),assert_in_db(t(i),D8,D9),assert_in_db(t(j),D9,D10),assert_in_db(t(k),D10,D11),assert_in_db(t(l),D11,D12),assert_in_db(t(m),D12,D13),assert_in_db(t(n),D13,D14),assert_in_db(t(o),D14,D15),assert_in_db(t(p),D15,D16),assert_in_db(t(q),D16,D17),retractall_in_db(t(q),D17,D18), D18 = D16, retractall_in_db(t(p),D18,D19),D19==D15,retractall_in_db(t(o),D19,D20),D20==D14, retractall_in_db(t(_),D20,D0).
*/

