:- comment(title,"Trie Terms for Sets and Prolog Databases").
:- comment(subtitle,"Efficient Representation of Sets of Clauses and Terms").
:- comment(author,"David S. Warren").

:- comment(summary, " The predicates of the @tt{prolog_db} module
support an abstract datatype for sets of Prolog terms.  The underlying
implementation uses a @em{ground} Prolog term that encodes an indexed
``trie.''  The trie is built using the pre-order traversals of the
terms of the set and thus provides complete indexing for terms that
are bound on an initial sequence of symbols in their pre-order
traversal.  The representation is @em{canonical} in that the same set
of terms is always represented by the same trie term, no matter how it
is constructed.

Trie terms can be used to represent a set of Prolog clauses (a.k.a., a
Prolog Database.)  We call a set of clauses a ``trie-term database.''
Operations are provided to assert clauses to and retract clauses from
a given trie-term database to generate a new one reflecting the
change.  Also there is an operation to evaluate a goal using the
clauses of a given trie-term database.  Trie-terms do not support
duplicates or clause order, so cuts (and duplicate clauses) cannot be
used in trie-term databases.  Trie-term databases can support Prolog
meta-programming in a pure way, since trie-terms are simply Prolog
terms and so earlier trie-term database states are automatically
recovered on backtracking (unlike with Prolog's basic assert and
retract operations.)
	   
Trie terms can be used to represent sets of ground Prolog terms, or
sets of relations over Prolog terms.  Operations are provided for
adding elements to sets/relations generating new sets/relations, and
for deleting and lookup.  Also several set operations, e.g. union,
intersection, and difference, are provided.  These operations take
advantage of the trie structure of a trie-term to sometimes provide
much better performance than more naive tuple-at-a-time
implementations.  This module also provides several restricted
relational operators that can take advantage of the trie data
structure.

The complexity of adding, deleting, and looking up single elements in
a trie-term is log of the the number of symbols in the trie-term (with
minor caveats.)
	   
Since trie terms are ground, they can be interned (a.k.a.
hash-cons-ed) in which case they are copied to a global space and all
subterms are represented only once.  In this case the interned trie
terms are represented in Prolog as integers, which are in fact
pointers to the global term representations.  For every predicate that
manipulates these trie terms, there is a corresponding predicate that
manipulates the interned form of the trie terms.  Most applications
will want to use these interned versions.  The interned trie terms can
be efficiently tabled since only the integer representing a trie term
will be copied to a table.  Also since these trie terms are canonical,
two trie-term integers (pointers) are equal if and only if the sets
are equal.  Also using answer subsumption with the subset operation on
interned trie terms may prove useful for some applications.

In the implementation, every trie term is wrapped with a functor
symbol that indicates whether the representation is a regular trie
term or an interned trie term.  All predicates take either form and
produce a result in the same form.  The predicate @pred{new_db/1}
returns an empty database in regular Prolog term form;
@pred{new_dbi/1} returns an empty database in interned form.  One of
the predicates must be used to create an initial empty database.  ").

:- comment(module," (dsw: too redundant, figure out how to summarize
	   an intro with too much obvious repetition...)

This module provides an abstract data type for
sets of Prolog terms.  Operations allow the construction,
modification, and combination of sets.  Sets of Prolog clauses are
supported and one can evaluate a goal with respect to a set of
clauses.  The representation uses an indexed trie using the sequence
of symbols obtained by a preorder traversal of a term.

A database state is a ground Prolog term that uses a trie data
structure.  (Variables are represented as ground '(dollar-sign)VAR'(i)
terms and interpreted as variables by the access predicates.)  The
trie provides effective indexed access to clauses.  Duplicate clauses
and clause order are not supported, so interpreted clauses may not
contain the cut operator.  The trie representation is also canonical
in that two tries represent the same set, regardless of the sequence
of operations that create the set, if and only if they are identical
terms.  So set identity is term identity.

By restricting the use of the data type to maintain sets of Prolog
ground facts, a user can effectively manipulate a set of relations.
This data type provides efficient set operations and several efficient
restricted forms of relational operations, such as join and project.
Forms are restricted to those for which the structure of the trie term
can be used to provide more efficient algorithms.

Also describe how Prolog database of a set of ground terms can be seen
as a relational database, and we have operations to manipulate those
sets of tuples.  And how prefix specifications work.
	   
@section{Using Trie Terms for Prolog Databases}
Example of 'transaction Logic'-like program.

@section{Using Trie Terms for Sets of Terms (and Relations)}

Examples: tries of boolean vectors and BDDs.

@section{Using Interned (hash-cons-ed) Trie Terms}

@section{Using Interned Trie Terms in Term-Sets}

Example of parsing and term-sets with trie-terms representing sets.
Justification, maybe Fibonacci.  Term-sets with interned trie terms
handle both combinatorial explosion due to nondeterminism (and cross
product) using term-sets, and that due to copied subterms by
interning.  Parses for grammar of A-->AA has both?  Doubly recursive
Fibonacci is deterministic but parses would be exponential due to lack
of subterm sharing.

@section{Representation Details}

Prefix terms?  Prefix term determines a (sub)trie of a trie.

").    


/* The following are commented out, and made explicit in the code, so
that this code can itself be loaded by load_in_db and processed. */

%:- import append/3 from basics.
%:- import member/2 from basics.
%:- import log_ith/3 from basics.
%:- import term_hash/3 from machine.
%:- import standard_symbol/3 from std_xsb.
%:- import call_c/1 from standard.
%:- import intern_termhash/2 from machine.

:- comment(assert_in_db/3, "@pred{assert_in_db(+Clause,+DB0,?DB)} adds
a clause, @var{Clause}, (or a sequence of clauses, if {Clause} is a
list of clauses) to @var{DB0} to generate @var{DB}. @var(DB) will be
of the same form as @var{DB0}, regular or interned. ").

:- index assert_in_db/3-2.
assert_in_db(Clauses,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    assert_in_db_b(Clauses,DB0,DB).
assert_in_db(Clauses,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    assert_in_db_b(Clauses,DB0,DB),
    machine:intern_termhash(DB,H).

assert_in_db_b(Clauses,DB0,DB) :-
    (Clauses == []
     ->	DB0 = DB
     ; Clauses = [Clause|MClauses]
     ->	assert1_in_db_b(Clause,DB0,DB1),
	assert_in_db_b(MClauses,DB1,DB)
     ;	assert1_in_db_b(Clauses,DB0,DB)
    ).

:- comment(assert1_in_db/3, "@pred{assert1_in_db(+Clause,+DB0,?DB)}
asserts a single clause, @var{Clause}, into @var{DB0}, generating
@var{DB}.  Normally @pred{assert_in_db/3} should be used.  This
predicate in needed only in cases in which the ``clause'' to be
asserted is a list. The form of @var{DB} will be the same as the form
of @var{DB0}. ").

:- index assert1_in_db/3-2.
assert1_in_db(Clause,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    assert1_in_db_b(Clause,DB0,DB).
assert1_in_db(Clause,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    assert1_in_db_b(Clause,DB0,DB),
    machine:intern_termhash(DB,H).

assert1_in_db_b(Clause,DB0,DB) :-
    (Clause = (Head :- Body)
     ->	true
     ;	Head = Clause,
	Body = true
    ),
    add_to_trie(Head,Body,DB0,DB).

:- comment(assert_in_db/2, "@pred{assert_in_db(+Clause,?DB)} adds a
clause, @var{Clause}, (or a sequence of clauses, if @var{Clause} is a
list) to the empty DB to generate @var{DB}. @var{DB} will be a regular
DB trie term.").

assert_in_db(Clauses,DB) :-
    new_db(DB0),
    assert_in_db(Clauses,DB0,DB).

:- comment(assert_in_dbi/2, "@pred{assert_in_dbi(+Clause,?DB)} adds a
clause, @var{Clause}, (or a sequence of clauses, if @var{Clause} is a
list) to the empty DB to generate @var{DB}.  @var{DB} will be an
interned DB trie term.").

assert_in_dbi(Clauses,DB) :-
    new_dbi(DB0),
    assert_in_db(Clauses,DB0,DB).

:- comment(retractall_in_db/3,"@pred{retractall_in_db(+Goal,+DB0,?DB)}
retracts all clauses whose heads unify with @var{Goal} (or a term in
@var{Goal} if @var{Goal} is a list) from @var{DB0} generating
@var{DB1}.  The form of @var{DB} will be the same as the form
of @var{DB0}. ").

:- index retractall_in_db/3-2.
retractall_in_db(Clauses,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    retractall_in_db_b(Clauses,DB0,DB).
retractall_in_db(Clauses,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    retractall_in_db_b(Clauses,DB0,DB),
    machine:intern_termhash(DB,H).

retractall_in_db_b(Clauses0,DB0,DB) :-
    (Clauses0 == []
     ->	DB = DB0
     ; Clauses0 = [Clause|Clauses]
     ->	retractall1_in_db(Clause,DB0,DB1),
	retractall_in_db_b(Clauses,DB1,DB)
     ;	retractall1_in_db(Clauses0,DB0,DB)
    ).

retractall1_in_db(Clause,DB0,DB) :-
    (Clause = (Head:-Body)
     ->	true
     ;	Head = Clause
    ),
    remove_from_trie(Head,Body,DB0,_Vars,DB).

:- comment(clause_in_db/3,"@pred{clause_in_db(?Head,?Body,+DB)}
unifies, in turn, @var{Head} and @var{Body} with the head and body of
rules in @var{DB}.  @var{DB} may be either regular or interned.").

:- index clause_in_db/3-3.
clause_in_db(Head,Body,'$TRIETERM'(DB)) :-
    clause_in_db_b(Head,Body,DB).
clause_in_db(Head,Body,'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB,H),
    clause_in_db_b(Head,Body,DB).

clause_in_db_b(Head,Body,DB) :-
    find_in_trie(Head,Body,DB).

:- comment(fact_in_db/2, "@pred{fact_in_db(?Fact,+DB)} unifies, in
turn, @var{Fact} with each fact in DB, @var{DB}.  The order of
returned facts is indeterminate.  @var{DB} may be either regular or
interned.").

fact_in_db(Head,DB) :-
    clause_in_db(Head,true,DB).

:- comment(call_in_db/2, "@pred{call_in_db(+Goal,+DB)} calls the goal
@var{Goal} in the database @var{DB}, binding variables in @var{Goal}
for each instance of @var{Goal} that is proved.  @var{DB} may be
either regular or interned.").

:- index call_in_db/2-2.
call_in_db(Goal,'$TRIETERM'(DB)) :-
    call_in_db_b(Goal,DB).
call_in_db(Goal,'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB,H),
    call_in_db_b(Goal,DB).

call_in_db_b(true,_DB) :- !.
call_in_db_b((A,B),DB) :- !, call_in_db_b(A,DB), call_in_db_b(B,DB).
call_in_db_b(\+(G),DB) :- !, \+ call_in_db_b(G,DB).
call_in_db_b(tnot(G),DB) :- !, tnot db_table_call(DB,G).
call_in_db_b(findall(T,G,L),DB) :- !, findall(T,call_in_db_b(G,DB),L).
call_in_db_b((do_all G),DB) :- !, (do_all call_in_db_b(G,DB)).
call_in_db_b((C->A;B),DB) :- !,
    (call_in_db_b(C,DB) -> call_in_db_b(A,DB) ; call_in_db_b(B,DB)).
call_in_db_b((A;B),DB) :- !, (call_in_db_b(A,DB) ; call_in_db_b(B,DB)).
call_in_db_b(table(Goal),DB) :- !, db_table_call(DB,Goal).
call_in_db_b(xact(G),DB) :- !, phrase(G,DB,DB).  % for transaction logic, if useful.
call_in_db_b(G,_DB) :- functor(G,F,A), std_xsb:standard_symbol(F,A,_), !,
    standard:call_c(G).
call_in_db_b(G,DB) :-
    clause_in_db_b(G,B,DB),
    call_in_db_b(B,DB).

:- table db_table_call/2.
db_table_call(DB,Goal) :-
    call_in_db_b(Goal,DB).

:- comment(dump_db/2,"@var{dump_db(+DB,+Filename)} writes the clauses
in DB, @var{DB}, to the file @var{Filename}.  If @var{Filename} is
'userout', the clauses will be written to userout.  @var{DB} may be
either regular or interned.").

dump_db('$TRIETERM'(DB),FileName) :-
    dump_db_b(DB,FileName).
dump_db('$TRIETERMI'(H),FileName) :-
    machine:intern_termhash(DB,H),
    dump_db_b(DB,FileName).

dump_db_b(DB,Filename) :-
    (Filename == userout
     ->	OStr = userout
     ;	open(Filename,write,OStr)
    ),
    (do_all
     clause_in_db_b(Head,Body,DB),
     (Body == true
      -> write_canonical(OStr,Head)
      ;	 write_canonical(OStr,(Head:-Body))
     ),
     writeln(OStr,'.')
    ),
    (Filename == userout
     ->	true
     ;	close(OStr)
    ).

:- comment(pure_call_in_db/2,"@pred{pure_call_in_db(+G,+DB)} has the
same functionality as @pred{call_in_db(G,DB)}, but it is implemented
without cuts, so it can be used when this file is loaded into a DB by
@pred{load_in_db/2}.  @var{DB} may be either regular or interned.").

:- index pure_call_in_db/2-2.
pure_call_in_db(G,'$TRIETERM'(DB)) :-
    pure_call_in_db_b(G,DB).
pure_call_in_db(G,'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB,H),
    pure_call_in_db_b(G,DB).

pure_call_in_db_b(G,DB) :-
    (ctrl_str(G)
     ->	pure_ctrl_call_in_db_b(G,DB)
     ;	G \== true,functor(G,F,A),std_xsb:standard_symbol(F,A,_)
     ->	standard:call_c(G)
     ;	clause_in_db_b(G,B,DB),
	pure_call_in_db_b(B,DB)
    ).

ctrl_str(true).
ctrl_str((_,_)).
ctrl_str(\+(_)).
ctrl_str(xact(_)).
ctrl_str((_;_)).

pure_ctrl_call_in_db_b(true,_).
pure_ctrl_call_in_db_b((A,B),DB) :- pure_call_in_db_b(A,DB), pure_call_in_db_b(B,DB).
pure_ctrl_call_in_db_b(\+(G),DB) :- \+ pure_call_in_db_b(G,DB).
pure_ctrl_call_in_db_b(xact(G),DB) :- !, phrase(G,DB,DB).  % for transaction logic, if useful.
pure_ctrl_call_in_db_b((A;B),DB) :-
    (A = (C->A1)
     ->	(pure_call_in_db_b(C,DB) -> pure_call_in_db_b(A1,DB) ; pure_call_in_db_b(B,DB))
     ;	(pure_call_in_db_b(A,DB) ; pure_call_in_db_b(B,DB))
    ).
pure_ctrl_call_in_db_b(M:G,_DB) :- call(M:G).

:- comment(new_db/1, "@pred{new_db(?DB)} generates (or tests for) and
empty trie-term database, @var{DB}, represented as a Prolog trie
term.").

new_db('$TRIETERM'([])).

:- comment(new_dbi/1, "@pred{new_db(?DB)} generates (or tests for) and
empty interned trie-term database, @var{DB}, represented in interned
form.").

new_dbi('$TRIETERMI'([])).

:- comment(new_db_like/2, "@pred{new_db_like(+DB0,-DB)} generates an
empty database in @var{DB} in the same form as the input database
@var{DB0}. ").

new_db_like('$TRIETERM'(_),'$TRIETERM'([])).
new_db_like('$TRIETERMI'(_),'$TRIETERMI'([])).

:- comment(is_empty_db/1, "@pred{is_empty_db(+DB)} is true if @var{DB}
represents an empty database (of either form.) ").

is_empty_db('$TRIETERM'([])).
is_empty_db('$TRIETERMI'([])).

:- comment(cvt_db_to_i/2, "@pred{cvt_db_to_i(+DB,-H)} converts a
regular database @var(DB) to an interned database @var{H}. ").

cvt_db_to_i('$TRIETERM'(DB),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB,H).

:- comment(cvt_db_from_i/2, "@pred{cvt_db_to_i(+H,-DB)} converts an
interned database @var(H) to a regular term database @var{H}. ").

cvt_db_from_i('$TRIETERMI'(H),'$TRIETERM'(DB)) :-
    machine:intern_termhash(DB,H).

:- comment(is_db/1, "@pred{is_db(+DB)} succeeds if @var{DB} has the
form of a valid database term, of either form."  ).

is_db('$TRIETERM'(_)).
is_db('$TRIETERMI'(_)).

:- comment(find_in_trie/3, "find_in_trie(?Head,?Body,+Trie) succeeds
for terms @var{Head} in ht-trie @var{Trie} with body @var{Body}.
@var{Trie} is an unwrapped trie term.").

find_in_trie(Head,Body,Trie) :-
    find_in_trie_list([Head],Body0,Trie,Vars),
    my_unnumbervars(Body0,Vars,Body).

:- comment(find_in_trie_list/4,
"find_in_trie_list(?HeadTail,?Body,+Trie,?Vars) succeeds for the
trie-path selected by the list of terms @var{HeadTail} (which must be
a proper list) in ht-trie @var{Trie} with clause body @var{Body},
where @vars{Vars} is an open loglist of variables.").

find_in_trie_list([],Body,Bodies,_Vars) :-
    basics:member(Body,Bodies).
find_in_trie_list([HeadTerm|HeadTail],Body,Trie,Vars) :-
    find_in_first_hashtree(HeadTerm,SubTrie,Trie),
    \+ (HeadTerm = '$VAR'(VN),integer(VN)),	%next clause handles this case
    (atomic(HeadTerm)
     ->	find_in_trie_list(HeadTail,Body,SubTrie,Vars)
     ;	HeadTerm =.. [_|SubHeads],
	basics:append(SubHeads,HeadTail,NewHeadTail),
	find_in_trie_list(NewHeadTail,Body,SubTrie,Vars)
    ).
find_in_trie_list([HeadTerm|HeadTail],Body,Trie,Vars) :-
    find_in_first_hashtree('$VAR'(X),SubTrie,Trie),
    basics:log_ith(X,Vars,HeadTerm),
    find_in_trie_list(HeadTail,Body,SubTrie,Vars).

:- comment(add_to_trie/4, "add_to_trie(+Head,+Body,+Trie0,-Trie) adds
the clause with head @var{Head} and body @var{Body} to ht-trie @var{Trie0},
returning the ht-trie @var{Trie}.").

add_to_trie(Head,Body,Trie0,Trie) :-
    (ground(Head-Body)
     ->	add_to_trie_ground_list([Head],Body,Trie0,Trie)
     ;	copy_term([Head|Body],[Head1|Body1]),
	numbervars([Head1|Body1],0,_),
	add_to_trie_ground_list([Head1],Body1,Trie0,Trie)
    ).

:- comment(add_to_trie_ground_list/4,
"add_to_trie_ground_list(+HeadTail,+Body,+Trie0,-Trie) adds the
trie-path for the list of terms, @var{HeadTail}, with body,
@var{Body}, to ht-trie, @var{Trie0}, returning ht-trie, @var{Trie}.").

add_to_trie_ground_list([],Body,List,MList) :-
    add_to_body_list(List,Body,MList).
add_to_trie_ground_list([HeadTerm|HeadTail],Body,Trie0,Trie) :-
    (atomic(HeadTerm)
     ->	NHeadTail = HeadTail
     ;	HeadTerm = '$VAR'(VN),integer(VN)
     ->	NHeadTail = HeadTail
     ;	HeadTerm =.. [_|SubTerms],
	basics:append(SubTerms,HeadTail,NHeadTail)
    ),
    update_hashtree(HeadTerm,NewSubTrie,OldSubTrie,Trie0,Trie1),
    add_to_trie_ground_list(NHeadTail,Body,OldSubTrie,NewSubTrie),
    db_comps_d(Trie1,HashBits,NumInTab,HashTree),
    (NumInTab < floor(2**HashBits)
     ->	Trie = Trie1
     ;	NHashBits is HashBits*2,
	db_comps_c(Trie,NHashBits,NumInTab,NHashTree),
	rebuild_hashtree(HashTree,HashBits,NHashBits,NHashTree)
    ).

:- comment(add_to_body_list/3, "add_to_body_list(+List,+Body,-NewList)
adds @var{Body} to the ordered list @var{List}, returning a new
ordered list containing @var{Body} in @var{NewList}.  If @var{Body} is
already in List, List is returned.").

add_to_body_list([],Body,[Body]).
add_to_body_list([Body0|List],Body,MList) :-
    (Body @< Body0
     ->	MList = [Body,Body0|List]
     ;	Body == Body0
     ->	MList = [Body0|List]
     ;	MList = [Body0|MList1],
	add_to_body_list(List,Body,MList1)
    ).

:- comment(find_in_first_hashtree/3,
"@pred{find_in_first_hashtree(?Term,-Val,+Trie)} returns in @var{Val}
the value associated with key, @var{Term}, found in the first
hash-tree in the ht-trie, @var(Trie}.  It traverses through the first
hash-tree, to return either another ht-trie, if it is internal in the
full trie, or the list of bodies, if it is the last hash-tree of a
full ht-trie.").

find_in_first_hashtree(Term,Val,Trie) :-
    db_comps_d(Trie,HashBits,_NumInTab,HashTree),
    (var(Term)
     ->	bind_from_hash(Term,Val,HashBits,HashTree)
     ;	Size is floor(2**HashBits),
	machine:term_hash(Term,Size,HashCode),
	(atomic(Term)
	 -> Key = Term
	 ; Term = '$VAR'(_)
	 -> Key = Term
	 ;  functor(Term,Fun,Ari),
	    Key = Fun/Ari
	),
	find_in_subtree(Key,Val,HashCode,HashBits,HashTree)
    ).

:- comment(find_in_subtree/5,
"find_in_subtree(?Key,-Rec,+HashCode,+HashBits,+HashTree) returns in
@var{Rec} the value associates with key, @var{Key}, which has
hashcode, @var{HashCode}, in hash-tree, @var{HashTree}, whose keys have
@var{HashBits} bits.  It recurses through the hash-tree index.").

find_in_subtree(Key,Rec,HashCode,HashBits,HashTree) :-
    (HashBits =< 0
     ->	my_member((Key-Rec),HashTree)
     ;	HashTree = h(HashTree0,HashTree1,HashTree2,HashTree3),
	NHashBits is HashBits - 2,
	HashBit is HashCode /\ 3,
	NHashCode is HashCode >> 2,
	(HashBit < 2
	 -> (HashBit < 1
	     ->	find_in_subtree(Key,Rec,NHashCode,NHashBits,HashTree0)
	     ;	find_in_subtree(Key,Rec,NHashCode,NHashBits,HashTree1)
	    )
	 ;  HashBit < 3
	 -> find_in_subtree(Key,Rec,NHashCode,NHashBits,HashTree2)
	 ;  find_in_subtree(Key,Rec,NHashCode,NHashBits,HashTree3)
	)
    ).

:- comment(bind_from_hash/4,
"bind_from_hash(-Term,-Rec,+HashBits,+HashTree) nondeterministically
binds the variables, @var{Term} and @var{Rec}, to the key-value pairs in
hash-tree, @var{HashTree}, whose keys have @var{HashBits} bits.").

bind_from_hash(Term,Val,HashBits,HashTree) :-
    HashTree \== [],
    (HashBits =< 0
     ->	my_member((Key-Val),HashTree),
	(Key = Fun/Arity
	 -> functor(Term,Fun,Arity)
	 ;  Term = Key
	)
     ;  HashTree = h(HashTree0,HashTree1,HashTree2,HashTree3),
	NHashBits is HashBits - 2,
	(bind_from_hash(Term,Val,NHashBits,HashTree0)
	 ;  
	 bind_from_hash(Term,Val,NHashBits,HashTree1)
	 ;  
	 bind_from_hash(Term,Val,NHashBits,HashTree2)
	 ;  
	 bind_from_hash(Term,Val,NHashBits,HashTree3)
	)
    ).

%% deterministic for common case of length 1 list (list must be +)
my_member(X,[Y|L]) :-
    (L == []
     ->	X = Y
     ;	(X = Y
	 ;  
	 my_member(X,L)
	)
    ).

:- comment(update_hashtree/5,
"update_hashtree(+Term,?NewVal,-OldVal,+HashTree0,-HashTree) adds a new
key-value pair (or finds an existing pair), @var{Term} and
@var{NewVal}, to the hash-tree, @var{HashTree0}, producing the new
hash-tree, @var{HashTree}.  @var{OldVal} is bound to the previous
value for this key in the hash table (or to [] if this is a new
key.)").

update_hashtree(Term,NewVal,OldVal,HT0,HT) :-
    db_comps_d(HT0,HashBits,NumInTab,HashTree),
    Size is floor(2**HashBits),
    machine:term_hash(Term,Size,HashCode),
    (atomic(Term)
     ->	Key = Term
     ;	Term = '$VAR'(VN),integer(VN)
     ->	Key = Term
     ;	functor(Term,Fun,Ari),
	Key = Fun/Ari
    ),
    update_subtree(Key,NewVal,OldVal,HashCode,HashBits,Added,HashTree,NHashTree),
    NNumInTab is NumInTab+Added,
    db_comps_c(HT,HashBits,NNumInTab,NHashTree).

:- comment(update_subtree/8,
"update_subtree(+Key,+NewVal,-OldVal,+HashCode,+HashBits,-Added,+HashTree,-NHashTree)
recurses through @var{HashTree} to add a key-value pair, in @var{Key}
and @var{NewVal}, to the hash-tree, @var{HashTree}, generating a new
hash-tree, @var{NHashTree}.  @var{OldVal} is returned and is the value
for this key in @var{HashTree} (or [] if the key is new.)
@var{HashCode} is the hash code for @var{Key}; @var{HashBits} is the
number of bits in the @var{HashCode} (and in keys in @var{HashTree}),
and @var{Added} is returned as 1 if a new key is added, and 0 if the
key already existed.").

update_subtree(Key,NewVal,OldVal,HashCode,HashBits,Added,HashTree,NHashTree) :-
    (HashBits =< 0
     ->	(NewVal == []
	 -> remove_from_ordered_list(HashTree,Key,OldVal,NHashTree),
	    Added = -1
	 ;  add_to_ordered_list(HashTree,Key-NewVal,OldVal,Added,NHashTree)
	)
     ;	h_comps_d(HashTree,HashTree0,HashTree1,HashTree2,HashTree3),
	NHashBits is HashBits - 2,
	HashBit is HashCode /\ 3,
	NHashCode is HashCode >> 2,
	(HashBit < 2
	 -> (HashBit < 1
	     ->	NHashTree = h(NHashTree0,HashTree1,HashTree2,HashTree3),
		update_subtree(Key,NewVal,OldVal,NHashCode,NHashBits,Added,HashTree0,NHashTree0)
	     ;	NHashTree = h(HashTree0,NHashTree1,HashTree2,HashTree3),
		update_subtree(Key,NewVal,OldVal,NHashCode,NHashBits,Added,HashTree1,NHashTree1)
	    )
	 ;  HashBit < 3
	 -> NHashTree = h(HashTree0,HashTree1,NHashTree2,HashTree3),
	    update_subtree(Key,NewVal,OldVal,NHashCode,NHashBits,Added,HashTree2,NHashTree2)
	 ;  NHashTree = h(HashTree0,HashTree1,HashTree2,NHashTree3),
	    update_subtree(Key,NewVal,OldVal,NHashCode,NHashBits,Added,HashTree3,NHashTree3)
	)
    ).

:- comment(add_to_ordered_list/5,
"add_to_ordered_list(+OValues,+Key-NewVal,-OldVal,-Added,-NValues)
adds (or replaces) a key-value pair in an ordered list of key-value
pairs (where the key will be an atom, $VAR, or Pred/Arity and the
value will be a ht-trie.)  @var{OValues} is the old list of key-value
pairs (represented as (@var{Key} - @var{Value}).) The new key-value
pair is (@var{Key} - @var{NewVal}). @var{NValues} is the resulting
list of key-value pairs.  @var{OldVal} is the old value for key
@var{Key} in @var{OValues} (or [] if none), and is returned.
@var{Added} is 1 if the key @var{Key} is new, and 0 if it already
exists in a pair in @var{OValues}.").

add_to_ordered_list([],KeyNVal,[],1,[KeyNVal]).
add_to_ordered_list([OValue|Values],KeyNVal,OldVal,Added,NValues) :-
    OValue = (TKey-TVal),
    KeyNVal = (Key-_NewVal),
    (TKey @< Key
     ->	NValues = [OValue|NValues1],
	add_to_ordered_list(Values,KeyNVal,OldVal,Added,NValues1)
     ;	TKey == Key
     ->	NValues = [KeyNVal|Values],
	Added = 0,
	OldVal = TVal
     ;	NValues = [KeyNVal,OValue|Values],
	Added = 1,
	OldVal = []
    ).

:- comment(remove_from_trie/5,
"remove_from_trie(+Term,+Value,+Trie0,-Vars,-Trie) removes the term,
@var{Term}, with value, @var{Value}, from the trie @var{Trie0}
yielding @var{Trie}, where @var{Vars} is a log-list of variable
bindings.").

remove_from_trie(Term,Value,Trie0,Vars,Trie) :-
    remove_from_trie_list([Term],Value,Trie0,Vars,Trie).

:- comment(remove_from_trie_list/5,
"remove_from_trie_list(+TermList,?Body,+Trie0,-Vars,-Trie) recurses
through the trie to remove the clause, the remainder of its head is
@var{TermList}, whose body is @var{Body}, from the trie, @var{Trie0},
yielding trie, @var{Trie}. @var{Vars} is a log-list of variable
bindings.").

remove_from_trie_list([],Body,OBodies,_Vars,NBodies) :-
    (nonvar(Body)
     ->	remove_from_ordered_list(OBodies,Body,NBodies)
     ;	NBodies = []
    ).
remove_from_trie_list([Term|TermList],Body,Trie0,Vars,Trie) :-
    (is_most_general_term([Body,Term|TermList])
     ->	Trie = []		% delete everything below!
     ;	(nonvar(Term), Term = '$VAR'(VN), integer(VN)
	 -> basics:log_ith(VN,Vars,NTerm)
	 ;  NTerm = Term
	),
	findall([NTerm|TermList],
		(find_in_first_hashtree(NTerm,_,Trie0),
		 \+ (NTerm = '$VAR'(VN0), integer(VN0))
		),
		TermLists),
	remove_from_trie_lists(TermLists,NTerm,Body,Trie0,Vars,Trie1),
	findall(['$VAR'(VN1)|TermList],
		find_in_first_hashtree('$VAR'(VN1),_,Trie0),
		VTermLists),
	remove_from_trie_lists(VTermLists,NTerm,Body,Trie1,Vars,Trie)
    ).

:- comment(remove_from_trie_lists/6,
"@pred{remove_from_trie_list(+TermLists,+Term,?Body,+Trie0,-Vars,-Trie)}
removes each trie-path for each list in the list, @var{TermLists},
each with clause body, @var{Body}, from the trie, @var{Trie0},
yielding trie, @var{Trie}. @var{Term} is the term at this point in the
input term, used to bind a potential variable in the trie.  @var{Vars}
is a log-list of variable bindings.").

remove_from_trie_lists([],_,_,Trie,_Vars,Trie).
remove_from_trie_lists([TL|TLs],Term,Body,Trie0,Vars,Trie) :-
    (TL = ['$VAR'(VN)|_]
     ->	(copy_term(TL-Vars,NTL-NVars),
	 basics:log_ith(VN,NVars,Term) % new vars
	 -> remove_from_trie_list_nv(NTL,Body,Trie0,NVars,Trie1)
	 ;  Trie1 = Trie0
	)
     ;	remove_from_trie_list_nv(TL,Body,Trie0,Vars,Trie1)
    ),
    remove_from_trie_lists(TLs,Term,Body,Trie1,Vars,Trie).

:- comment(remove_from_trie_list_nv/5,
"@pred{remove_from_trie_list_nv(+TermList,+Body,+Trie0,+Vars,-Trie)}
removes an trie-path, corresponding to @var{TermList}, with body
@var{Body}, from ht-trie, @var{Trie0}, yielding ht-trie, @var{Trie}.
@var{Vars} is a log-list of variable bindings to handle ($VAR)
variables in the input ht-trie, @var{Trie0}.").

remove_from_trie_list_nv([Term|TermList],Body,Trie0,Vars,Trie) :-
    (atomic(Term)
     ->	NTermList = TermList
     ; Term = '$VAR'(_)
     ->	NTermList = TermList
     ;	Term =.. [_|SubTerms],
	basics:append(SubTerms,TermList,NTermList)
    ),
    update_hashtree(Term,NewSubTrie,OldSubTrie,Trie0,Trie1),
    remove_from_trie_list(NTermList,Body,OldSubTrie,Vars,NewSubTrie),
    ((NewSubTrie == [] ; NewSubTrie = ht(_,_,[]))
     ->	remove_from_hash_trie(Term,_OldVal,Trie0,Trie)
     ;	Trie = Trie1
    ).
	
:- comment(remove_from_hash_trie/4,
"@pred{remove_from_hash_trie(+Term,?OldVal,+Trie0,-Trie)} removes the
entry for the pair Term and OldVal from the hash table, HashTree0,
yielding the hash table, HashTree.").

remove_from_hash_trie(Term,OldVal,Trie0,Trie) :-
    db_comps_d(Trie0,HashBits,NumInTab,HashTree),
    Size is floor(2**HashBits),
    machine:term_hash(Term,Size,HashCode),
    (atomic(Term)
     ->	Key = Term
     ; Term = '$VAR'(I), integer(I)
     ->	Key = Term
     ;	functor(Term,Fun,Ari),
	Key = Fun/Ari
    ),
    NNumInTab is NumInTab - 1,
    remove_from_subtree(Key,OldVal,HashCode,HashBits,HashTree,NHashTree0),
    MinSize is floor(2** (HashBits//2)),
    ((NNumInTab >= MinSize ; Size =< 4)
     ->	NHashTree = NHashTree0,
	NHashBits = HashBits
     ;	NHashBits is HashBits // 2,
	rebuild_hashtree(NHashTree0,HashBits,NHashBits,NHashTree)
    ),
    db_comps_c(Trie,NHashBits,NNumInTab,NHashTree).

:- comment(remove_from_subtree/6,
"@pred{remove_from_subtree(+Key,?OldVal,+HashCode,+HashBits,+HashTree,-NHashTree)}
removes the entry for the pair @var{Term} and @var{OldVal} from the
hash tree, @var{HashTree}, yielding the hash tree,
@var{NHashTree}. @var{HashCode} is the hash code for @var{Key} and
@var{HashBits} is the number of bits in the hash code (and in all hash
codes for entries in @var{HashTree}).").

remove_from_subtree(Key,OldVal,HashCode,HashBits,HashTree,NHashTree) :-
    (HashBits =< 0
     ->	remove_from_ordered_list(HashTree,Key,OldVal,NHashTree)
     ;	h_comps_d(HashTree,HashTree0,HashTree1,HashTree2,HashTree3),
	NHashBits is HashBits - 2,
	HashBit is HashCode /\ 3,
	NHashCode is HashCode >> 2,
	(HashBit < 2
	 -> (HashBit < 1
	     ->	remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree0,NHashTree0),
		h_comps_c(NHashTree,NHashTree0,HashTree1,HashTree2,HashTree3)
	     ;	remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree1,NHashTree1),
		h_comps_c(NHashTree,HashTree0,NHashTree1,HashTree2,HashTree3)
	    )
	 ;  HashBit < 3
	 -> remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree2,NHashTree2),
	    h_comps_c(NHashTree,HashTree0,HashTree1,NHashTree2,HashTree3)
	 ;  remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree3,NHashTree3),
	    h_comps_c(NHashTree,HashTree0,HashTree1,HashTree2,NHashTree3)
	)
    ).
/**
remove_from_subtree(Key,OldVal,HashCode,HashBits,HashTree,NHashTree) :-
    (HashBits =< 0
     ->	remove_from_ordered_list(HashTree,Key,OldVal,NHashTree)
     ;	h_comps_d(HashTree,HashTree0,HashTree1,HashTree2,HashTree3),
	NHashBits is HashBits - 2,
	HashBit is HashCode /\ 3,
	NHashCode is HashCode >> 2,
	(HashBit < 2
	 -> (HashBit < 1
	     ->	NNHashTree = h(NHashTree0,HashTree1,HashTree2,HashTree3),
		remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree0,NHashTree0)
	     ;	NNHashTree = h(HashTree0,NHashTree1,HashTree2,HashTree3),
		remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree1,NHashTree1)
	    )
	 ;  HashBit < 3
	 -> NNHashTree = h(HashTree0,HashTree1,NHashTree2,HashTree3),
	    remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree2,NHashTree2)
	 ;  NNHashTree = h(HashTree0,HashTree1,HashTree2,NHashTree3),
	    remove_from_subtree(Key,OldVal,NHashCode,NHashBits,HashTree3,NHashTree3)
	),
	(NNHashTree == h([],[],[],[]) % collapse to keep rep canonical
	 -> NHashTree = []
	 ;  NHashTree = NNHashTree
	)
    ).
***/
:- comment(remove_from_ordered_list/4,
"@pred{remove_from_ordered_list(+OValues,+Key,?OldVal,-NValues)}
removes the pair, (@var{Key} - @var{OldVal}), from the ordered list of
pairs in @var{OValues}, returning the resulting ordered list in
@var{NValues}.  It fails if the pair is not in the original list.").

remove_from_ordered_list([OValue|OValues],Key,OldVal,NValues) :-
    (OValue = (Key-OldVal)
     ->	NValues = OValues
     ;	NValues = [OValue|NValues1],
	remove_from_ordered_list(OValues,Key,OldVal,NValues1)
    ).

:- comment(remove_from_ordered_list/3,
"@pred{remove_from_ordered_list(+OValues,+Value,-NValues)} removes
@var{Value} from the list of values in @var{OValues} returning the
list @var{NValues}, failing if it is not there.  This is used at the
leaves of a trie, to remove clause bodies.").

remove_from_ordered_list([OVal|Values],Value,NValues) :-
    (OVal == Value
     ->	NValues = Values
     ;	NValues = [OVal|NValues1],
	remove_from_ordered_list(Values,Value,NValues1)
    ).

:- comment(rebuild_hashtree/4,
"@pred{rebuild_hashtree(+HashTree0,+HashBits,+NewBitSize,-HashTree)}
rebuilds an hash-tree with a different hash-bit size (or width).  This
allows either fixing a hash-tree to be of the right 'width', or to
change the width to agree with another hash-tree one wants to compare
with.  @var{HashTree0} is the old hash-tree with hash-bit size of
@var{HashBits}, @var{NewBitSize} is the new hash-bit size, and
@var{HashTree} is the new re-sized hash-tree. ").

rebuild_hashtree(HashTree0,HashBits,NewBitSize,HashTree) :-
    findall((Term-Val),bind_from_hash(Term,Val,HashBits,HashTree0),TermVals),
    add_all_terms(TermVals,NewBitSize,0,_,[],HashTree).

add_all_terms([],_,N,N,HT,HT).
add_all_terms([(Term-Val)|Terms],HashBits,N0,N,HT0,HT) :-
    Size is floor(2**HashBits),
    machine:term_hash(Term,Size,HashCode),
    (atomic(Term)
     ->	Key = Term
     ;	functor(Term,Fun,Arity),
	Key = Fun/Arity
    ),	 
    update_subtree(Key,Val,_,HashCode,HashBits,Added,HT0,HT1),
    N1 is N0+Added,
    add_all_terms(Terms,HashBits,N1,N,HT1,HT).

:- comment(load_in_db/2, "@pred{load_in_db(+FileName,-DB)} reads the
clauses in @file{FileName} and creates the database @var{DB} that
contains them.  @var{DB} will be of regular term form.").

load_in_db(FileName,DB) :-
    new_db(DB0),
    load_in_db(FileName,DB0,DB).

:- comment(load_in_dbi/2, "@pred{load_in_dbi(+FileName,-DB)} reads the
clauses in @file{FileName} and creates the database @var{DB} that
contains them.  @var{DB} will be of interned term form.").

load_in_dbi(FileName,H) :-
    new_dbi(H0),
    load_in_db(FileName,H0,H).

:- comment(load_in_db/3, "@pred{load_in_db(+FileName,+DB0,-DB)} reads
the clauses in @file{FileName} and adds them to the database
@var{DB0}, creating a new database @var{DB}.  @var{DB} will be of the
same form as @var{DB0}.  ").

load_in_db(FileName,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    load_in_db_b(FileName,DB0,DB).
load_in_db(FileName,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    load_in_db_b(FileName,DB0,DB),
    machine:intern_termhash(DB,H).

load_in_db_b(FileName,DB0,DB) :-
    open(FileName,read,IStr),
    read_terms_to_trie(IStr,DB0,DB),
    close(IStr).

read_terms_to_trie(IStr,DB0,DB) :-
    read(IStr,Term),
    (Term == end_of_file
     ->	DB = DB0
     ;	assert_in_db_b(Term,DB0,DB1),
	read_terms_to_trie(IStr,DB1,DB)
    ).

my_unnumbervars(Term,Vars,NTerm) :-
    (var(Vars)			% no vars, so must be ground
     ->	NTerm = Term
     ; var(Term)
     ->	NTerm = Term
     ;	atomic(Term)
     ->	NTerm = Term
     ;	Term = '$VAR'(I),integer(I)
     ->	basics:log_ith(I,Vars,NTerm)
     ;	Term =.. [F|Args],
	my_unnumbervars_list(Args,Vars,NArgs),
	NTerm =.. [F|NArgs]
    ).

my_unnumbervars_list([],_,[]).
my_unnumbervars_list([Term|Terms],Vars,[NTerm|NTerms]) :-
    my_unnumbervars(Term,Vars,NTerm),
    my_unnumbervars_list(Terms,Vars,NTerms).

/**********************************************************/

:- comment(find_hashtable_for_prefix/4,
"@pred{find_hashtable_for_prefix(+HeadTail,+HT,-TailLen,-SHT)}
searches for the ht-trie associated in the ht-trie @var{HT} with the
first subterm of @var{HeadTail} that is a variable.  @var{HeadTail}
must consist (when sequentialized) of a sequence of bound terms
followed by a sequence of distinct variables.  If this condition does
not hold, the predicate fails.  The ht-trie that is found is returned
in @var{SHT}, and the number of variables remaining in the tail is
returned in @var{TailLen}.").

find_hashtable_for_prefix([HeadTerm|HeadTail],HT,TailLen,SHT) :-
    nonvar(HeadTerm),
    find_in_first_hashtree(HeadTerm,SHT0,HT),
    (atomic(HeadTerm)
     ->	NHeadTail = HeadTail
     ;	HeadTerm =.. [_|SubTerms],
	basics:append(SubTerms,HeadTail,NHeadTail)
    ),
%    NHeadTail \== [],
    (is_most_general_term(NHeadTail)
     ->	basics:length(NHeadTail,TailLen),
	SHT = SHT0
     ;	find_hashtable_for_prefix(NHeadTail,SHT0,TailLen,SHT)
    ).

:- comment(update_hashtable/4,
"@pred{update_hashtable_for_prefix(+HeadTail,+NSHT,+OSHT,-TailLen,+HT0,-HT)}
replaces the ht-trie that is associated in the ht-trie @var{HT0} with
the first variable subterm of @var{HeadTail} with the ht-trie
@var{NSHT}.  The ht-trie that is replaced is returned in @var{OSHT}.
The new ht-trie with the replaced subterm is returned in @var{HT}.
@var{HeadTail} must consist (when sequentialized) of a sequence of
bound terms followed by a sequence of distinct variables.  If this
condition does not hold, the predicate fails.  ").

%% DSW: can we combine this with assert_ref_with_trie, and have both efficient?
update_hashtree_for_prefix(HeadTail,NSHT,OSHT,TailLen,HT0,HT) :-
    (NSHT == []
     ->	check_prefix_term(HeadTail,TailLen,'*_in_db/5'),
	remove_from_trie_list(HeadTail,_,HT0,_,HT)
     ;	update_hashtree_for_prefix_1(HeadTail,NSHT,OSHT,TailLen,HT0,HT)
    ).

update_hashtree_for_prefix_1([HeadTerm|HeadTail],NSHT,OSHT,TailLen,HT0,HT) :-
    nonvar(HeadTerm),
    NSHT \== [],
    (atomic(HeadTerm)
     ->	NHeadTail = HeadTail
     ;	HeadTerm =.. [_|SubTerms],
	basics:append(SubTerms,HeadTail,NHeadTail)
    ),
    NHeadTail \== [],
    (is_most_general_term(NHeadTail)
     ->	basics:length(NHeadTail,TailLen),
	update_hashtree(HeadTerm,NSHT,OSHT,HT0,HT)
     ;	update_hashtree(HeadTerm,NSHT0,OSHT0,HT0,HT),
	update_hashtree_for_prefix_1(NHeadTail,NSHT,OSHT,TailLen,OSHT0,NSHT0)
    ).


check_taillen(T1,T2,HeadTail,MsgPred) :-
    (T1 = T2
     ->	true
     ;	misc_error(('[',MsgPred,'] Predicate selection pattern: ',HeadTail,
		    ' is inconsistent with other patterns.'))
    ).

check_prefix_term(HeadTail,TailLen,MsgPred) :-
    (is_prefix_term(HeadTail,TailLen0)
     ->	check_taillen(TailLen,TailLen0,HeadTail,MsgPred)
     ;	misc_error(('[',MsgPred,'] Predicate selection pattern: ',HeadTail,' is illegal.'))
    ).

:- comment(is_prefix_term/2,"
@pred{is_prefix_term(+HeadTail,?TailLen)} checks that @var{HeadTail}
is a @tt{prefix-term}.  A @tt{prefix term} is a prolog term that, when
viewed in prefix order, consists of a sequence of constants followed
by a sequence of distinct variables.  Such a term uniquely determines
a position in a term trie (i.e., prolog DB). ").

is_prefix_term(HeadTail,TailLen) :-
    prefix_term(HeadTail,_Pre,Tail),
    basics:length(Tail,TailLen).

prefix_term(PT,Prefix,TailVars) :-
    PT = [Head|Tail],
    (var(Head)
     ->	is_most_general_term(PT),
	TailVars = PT,
	Prefix = []
     ; atomic(Head)
     ->	Prefix = [Head|PrefixT],
	prefix_term(Tail,PrefixT,TailVars)
     ;	Head =.. [Functor|Args],
	functor(Head,Functor,Arity),
	basics:append(Args,Tail,ArgsTail),
	Prefix = [Functor/Arity|PrefixT],
	prefix_term(ArgsTail,PrefixT,TailVars)
    ).


:- comment(apply_op_in_db/6,
"@pred{apply_op_in_db(+OpLambda,+P1,+P2,+P3,+DB0,?DB)} applies a
binary database operation (union, intersect, subtract, etc.) to two
predicates in a database and puts the result into another predicate in
the database.  This is an internal predicate.  For example, to union
the tuples of p/3 and q/3 and put the result into r/3, one could do:

@begin{verbatim}
| ?- assert_in_db([p(a,c,d),p(a,d,e),q(a,c,d),q(b,c,d)],DB1),
	   apply_op_in_db(lambda(A,B,C,union_db_b(A,B,C)),p/3,q/3,r/3,DB1,DB2),
	   dump_db(DB2,userout).
@end{verbatim}

Here we have put tuples for @tt{p/3} and @tt{q/3} into @var{DB1}.
Then we union those two predicates, putting the result into a
predicate @tt{r/3} in the new database @var{DB2}.  And then we print
out the resulting database.  We must use the *_b form for union, since
it takes an unwrapped trie-term as required.

@var{Pref1}, @var{Pref2}, and @var{Pref3} must be prefix terms.  (For
convenience, the form @tt{Pred/Arity} is converted to a prefix term
using @pred{functor/3}.  Clearly, this is the most commonly used form
of prefix terms.)  The operation of @var{OpLambda} is of the form
@tt{lambda(Var1,...,Varn,Goal)}, which is called by binding the
arguments to @var{Var2} through @var{Varn} and then @tt{call}-ing
@var{Goal}.  The operation must take 2 input trie (databases) and
produce an output trie (database.)  The operation will be applied to
the two tries determined in the input database, @var{DB0}, by the two
prefix terms, and the resulting trie will replace the trie determined
by the target prefix term, creating a new database @var{DB}.  (The
target prefix term will be added if it is not in the input database,
@var{DB0}.)  ").

:- index apply_op_in_db/6-5.
apply_op_in_db(Lambda,Pref1,Pref2,Pref3,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    apply_op_in_db_b(Lambda,Pref1,Pref2,Pref3,DB0,DB).
apply_op_in_db(Lambda,Pref1,Pref2,Pref3,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    apply_op_in_db_b(Lambda,Pref1,Pref2,Pref3,DB0,DB),
    machine:intern_termhash(DB,H).

apply_op_in_db_b(lambda(HT1,HT2,HT3,Op),Pref1,Pref2,Pref3,DB0,DB) :-
    cvt_pa(Pref1,Pref1a),
    cvt_pa(Pref2,Pref2a),
    cvt_pa(Pref3,Pref3a),
    (find_hashtable_for_prefix([Pref1a],DB0,TL,HT1)
     ->	true
     ;	HT1 = [],
	check_prefix_term([Pref1a],TL,'*_in_db/5')
    ),
    (find_hashtable_for_prefix([Pref2a],DB0,TL2,HT2)
     ->	check_taillen(TL,TL2,Pref2a,'*_in_db/5')
     ;	HT2 = [],
	check_prefix_term([Pref2a],TL,'*_in_db/5')
    ),
    call(Op),
    (update_hashtree_for_prefix([Pref3a],HT3,_,TL,DB0,DB)
     ->	true
     ;	misc_error(('[*_in_db/5] Predicate selection pattern: ',Pref3a,
		    ' is inconsistent with other patterns.'))
    ).

cvt_pa(PA,PSkel) :-
    (PA = P/A
    -> functor(PSkel,P,A)
    ;  PSkel = PA
    ).

:- comment(apply_rel_op_in_db/4, "
@pred{apply_rel_op_in_db(+RelOpLambdaTerm,+Pref1,+Pref2,+DB)} applies
the relational operator specified in @var{RelOpLambdaTerm} to the
subtries determined by @var{Pref1} and @var{Pref2} in @var{DB} and
succeeds or fails accordingly.  This is an internal predicate.
@var{RelOpLambdaTerm} is of the form @tt{lambda(HT1,HT2,Goal)}, where
@var{HT1} and @var{HT2} are variables and @var{Goal} is a binary goal
whose arguments are those varaibles.  The goal must define the desired
relational operator on subtries.  ").

apply_rel_op_in_db(Lambda,Pref1,Pref2,'$TRIETERM'(DB)) :-
    apply_rel_op_in_db_b(Lambda,Pref1,Pref2,DB).
apply_rel_op_in_db(Lambda,Pref1,Pref2,'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB,H),
    apply_rel_op_in_db_b(Lambda,Pref1,Pref2,DB).

apply_rel_op_in_db_b(lambda(HT1,HT2,Op),Pref1,Pref2,DB) :-
    cvt_pa(Pref1,Pref1a),
    cvt_pa(Pref2,Pref2a),
    (find_hashtable_for_prefix([Pref1a],DB,TL,HT1)
     -> true
     ;	HT1 = [],
	check_prefix_term([Pref1a],TL,'*_in_db/3')
    ),
    (find_hashtable_for_prefix([Pref2a],DB,TL,HT2)
     ->	true
     ;	HT2 = [],
	check_prefix_term([Pref2a],TL,'*_in_db/3')
    ),
    call(Op).

/**********************************************************/

/* These operations are just to support testing. */


naive_union_db(DB1,DB2,DB3) :-
    findall((H:-B),find_in_trie(H,B,DB1),Clauses),
    assert_in_db(Clauses,DB2,DB3).

naive_intersect_db(DB1,DB2,DB3) :-
    findall((H:-B),(find_in_trie(H,B,DB1),find_in_trie(H,B,DB2)),Rules),
    (DB4 = '$TRIETERM'(_) -> DB4 = '$TRIETERM'([]) ; DB4 = '$TRIETERMI'([])),
    assert_in_db(Rules,DB4,DB3).

naive_difference_db(DB1,DB2,DB3) :-
    findall((H:-B),(clause_in_db(H,B,DB1),
		    \+clause_in_db(H,B,DB2)
		   ),
		   Clauses),
    (DB1 = '$TRIETERM'(_) -> DB0 = '$TRIETERM'([]) ; DB0 = '$TRIETERMI'([])),
    assert_in_db(Clauses,DB0,DB3).

naive_sym_diff_db(DB1,DB2,DB3) :-
    findall((H:-B),
	    (clause_in_db(H,B,DB1),
	     \+ clause_in_db(H,B,DB2)
	     ;	
	     clause_in_db(H,B,DB2),
	     \+ clause_in_db(H,B,DB1)
	    ),
	    Clauses),
    (DB1 = '$TRIETERM'(_) -> DB0 = '$TRIETERM'([]) ; DB0 = '$TRIETERMI'([])),
    assert_in_db(Clauses,DB0,DB3).

naive_subset_db(DB1,DB2) :-
    \+ (clause_in_db(H,B,DB1),
	\+ clause_in_db(H,B,DB2)).

naive_disjoint_db(DB1,DB2) :-
    \+ (clause_in_db(H,B,DB1),
	clause_in_db(H,B,DB2)).

/*** end of testing operations ***/
/**********************************************************/

:- comment(union_db/3, " @pred{union_db(+DB1,+DB2,-DB)} takes two
prolog databases, in @var{DB1} and @var{DB2} and produces a prolog DB,
in @var{DB}, that is the union of the two input databases.  This is
done by traversing the two input tries in concert and in the process
generating the output trie.  This allows the output trie to share
subtries with the input tries, and to perhaps avoid traversing large
portions of the input tries.  For example, if the two input databases
contain facts for disjoint predicates, the union just creates a new
trie that points to entire definitions of the predicates in the input
tries, so such a union is done in time proportional to the number of
predicates, and completely independent of the size (i.e., the number
of tuples) of the predicates.  The form of all the DBs must be the
same. ").

union_db('$TRIETERM'(DB1),'$TRIETERM'(DB2),'$TRIETERM'(DB)) :-
    union_db_b(DB1,DB2,DB).
union_db('$TRIETERMI'(H1),'$TRIETERMI'(H2),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB1,H1),
    machine:intern_termhash(DB2,H2),
    union_db_b(DB1,DB2,DB),
    machine:intern_termhash(DB,H).

union_db_b(DB1,DB2,DB) :-
    (DB1 == DB2
     ->	DB = DB1
     ;	db_comps_d(DB1,HBits1,Num1,HT1),
     	db_comps_d(DB2,HBits2,Num2,HT2),
	(HBits1 < HBits2
	 -> HBits = HBits2,
	    rebuild_hashtree(HT1,HBits1,HBits,HT1b),
	    union_subtrees(HBits,HT1b,HT2,DNum,NHT)
	 ; HBits2 < HBits1
	 -> HBits = HBits1,
	    rebuild_hashtree(HT2,HBits2,HBits,HT2b),
	    union_subtrees(HBits,HT1,HT2b,DNum,NHT)
	 ;  HBits = HBits1,
	    union_subtrees(HBits,HT1,HT2,DNum,NHT)
	),
	NNum is Num1 + Num2 - DNum,
	fix_ht_size(HBits,NNum,NHT,DB)
    ).

:- comment(union_in_db/5, "@pred{union_in_db(+P1,+P2,+P3,+DB0,?DB)}
unions two subtries in @var{DB0} producing a new (or replaced) subtrie
in @var{DB}.  The input tries are determined by the prefix terms of
@var{P1} and @var{P2}, and the place of the resulting trie is
determined by prefix term @var{P3}.  (See @pred{is_prefix_term/2} and
@pred{apply_op_in_db/6} for discussions of prefix terms.)  The form of
@var{DB} will be the same as that of @var{DB0}. ").

union_in_db(P1,P2,P3,H0,H) :-
    apply_op_in_db(lambda(A,B,C,union_db_b(A,B,C)),P1,P2,P3,H0,H).

union_subtrees(HashBits,HT1,HT2,DNum,HT) :-
    (HashBits =< 0
     ->	union_kvs(HT1,HT2,0,DNum,HT)
     ;	h_comps_d(HT1,HT10,HT11,HT12,HT13),
	h_comps_d(HT2,HT20,HT21,HT22,HT23),
	union_subtree(HashBits,HT10,HT20,DNum0,HT30),
	union_subtree(HashBits,HT11,HT21,DNum1,HT31),
	union_subtree(HashBits,HT12,HT22,DNum2,HT32),
	union_subtree(HashBits,HT13,HT23,DNum3,HT33),
	DNum is DNum0+DNum1+DNum2+DNum3,
	h_comps_c(HT,HT30,HT31,HT32,HT33)
    ).

%% DNum is diff, negative for loss (dupls)
union_subtree(HashBits,SHT1,SHT2,DNum,SHT) :-
    (SHT1 == []
     ->	SHT = SHT2, DNum = 0
     ; SHT2 == []
     ->	SHT = SHT1, DNum = 0
     ; SHT1 == SHT2
     ->	SHT = SHT1, count_keys(SHT,DNum)
     ;	NHashBits is HashBits - 2,
	union_subtrees(NHashBits,SHT1,SHT2,DNum,SHT)
    ).

%% DNum is number in both sets (so will be subtracted from sum to get count.)
union_kvs(HT1,HT2,DNum0,DNum,HT) :- 
    (HT1 == []
     ->	DNum = DNum0,
	HT = HT2
     ; HT2 == []
     ->	DNum = DNum0,
	HT = HT1
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> HT = [K1-V1|HTt],
	    union_kvs(HT1t,HT2,DNum0,DNum,HTt)
	 ;  K1 @> K2
	 -> HT = [K2-V2|HTt],
	    union_kvs(HT1,HT2t,DNum0,DNum,HTt)
	 ;  (V1 @= ht(_,_,_)
	     ->	union_db_b(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	     ;	union_values(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	    ),
	    DNum1 is DNum0 + Added,
	    union_kvs(HT1t,HT2t,DNum1,DNum,HTt)	
	)
    ).
    
union_values(V1s,V2s,V3s) :-
    (V1s == []
     ->	V3s = V2s
     ; V2s == []
     ->	V3s = V1s
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> V3s = [V1|V3st],
	    union_values(V1st,V2s,V3st)
	 ;  V1 @> V2
	 -> V3s = [V2|V3st],
	    union_values(V1s,V2st,V3st)
	 ;  V3s = [V1|V3st],
	    union_values(V1st,V2st,V3st)
	)
    ).
	
/********************************************************/

:- comment(intersect_db/3, " @pred{intersect_db(+DB1,+DB2,?DB)} takes
two prolog databases (tries), in @var{DB1} and @var{DB2} and produces
a prolog DB, in @var{DB}, that is the intersection of the two input
databases.  This is done by traversing the two input tries in concert
and in the process generating the output trie.  This allows the output
trie to share subtries with the input tries, and to perhaps avoid
traversing large portions of the input tries.  For example, if the two
input databases contain facts for disjoint predicates, the intersect
just creates a new trie that contains none of the predicates, so such
an Intersection is done in time proportional to the number of
predicates, and completely independent of the size (i.e., the number
of tuples) of the predicates.  The form of all the DBs must be the
same. ").

intersect_db('$TRIETERM'(DB1),'$TRIETERM'(DB2),'$TRIETERM'(DB)) :-
    intersect_db_b(DB1,DB2,DB).
intersect_db('$TRIETERMI'(H1),'$TRIETERMI'(H2),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB1,H1),
    machine:intern_termhash(DB2,H2),
    intersect_db_b(DB1,DB2,DB),
    machine:intern_termhash(DB,H).

intersect_db_b(DB1,DB2,DB) :-
    (DB1 == DB2
     ->	DB = DB1
     ;	db_comps_d(DB1,HBits1,_Num1,HT1),
     	db_comps_d(DB2,HBits2,_Num2,HT2),
	(HBits1 < HBits2
	 -> HBits = HBits2,
	    rebuild_hashtree(HT1,HBits1,HBits,HT1b),
	    intersect_subtrees(HBits,HT1b,HT2,INum,NHT)
	 ; HBits2 < HBits1
	 -> HBits = HBits1,
	    rebuild_hashtree(HT2,HBits2,HBits,HT2b),
	    intersect_subtrees(HBits,HT1,HT2b,INum,NHT)
	 ;  HBits = HBits1,
	    intersect_subtrees(HBits,HT1,HT2,INum,NHT)
	),
	fix_ht_size(HBits,INum,NHT,DB)
    ).

:- comment(intersect_in_db/5,
"@pred{intersect_in_db(+P1,+P2,+P3,+DB0,?DB)} intersects two subtries
in @var{DB0} producing a new (or replaced) subtrie in @var{DB}.  The
input tries are determined by the prefix terms of @var{P1} and
@var{P2}, and the place of the resulting trie is determined by prefix
term @var{P3}.  (See @pred{is_prefix_term/2} and
@pred{apply_op_in_db/6} for discussions of prefix terms.)  The form of
@var{DB} will be the same as that of @var{DB0}. ").

intersect_in_db(P1,P2,P3,DB0,DB) :-
    apply_op_in_db(lambda(A,B,C,intersect_db_b(A,B,C)),P1,P2,P3,DB0,DB).

intersect_subtrees(HashBits,HT1,HT2,INum,HT) :-
    (HashBits =< 0
    ->	intersect_kvs(HT1,HT2,0,INum,HT)
     ;	h_comps_d(HT1,HT10,HT11,HT12,HT13),
	h_comps_d(HT2,HT20,HT21,HT22,HT23),
	intersect_subtree(HashBits,HT10,HT20,INum0,HT30),
	intersect_subtree(HashBits,HT11,HT21,INum1,HT31),
	intersect_subtree(HashBits,HT12,HT22,INum2,HT32),
	intersect_subtree(HashBits,HT13,HT23,INum3,HT33),
	INum is INum0+INum1+INum2+INum3,
	h_comps_c(HT,HT30,HT31,HT32,HT33)
    ).

intersect_subtree(HashBits,SHT1,SHT2,INum,SHT) :-
    (SHT1 == []
     ->	SHT = [], INum = 0
     ; SHT2 == []
     ->	SHT = [], INum = 0
     ; SHT1 == SHT2
     ->	SHT = SHT1, count_keys(SHT,INum)
     ;	NHashBits is HashBits - 2,
	intersect_subtrees(NHashBits,SHT1,SHT2,INum,SHT)
    ).

intersect_kvs(HT1,HT2,INum0,INum,HT) :-
    (HT1 == []
     ->	INum = INum0, HT = []
     ; HT2 == []
     ->	INum = INum0, HT = []
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> intersect_kvs(HT1t,HT2,INum0,INum,HT)
	 ;  K1 @> K2
	 -> intersect_kvs(HT1,HT2t,INum0,INum,HT)
	 ;  (V1 @= ht(_,_,_)
	     ->	intersect_db_b(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	     ;	intersect_values(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	    ),
	    INum1 is INum0 + Added,
	    intersect_kvs(HT1t,HT2t,INum1,INum,HTt)
	)
    ).
    
intersect_values(V1s,V2s,V3s) :-
    (V1s == []
     ->	V3s = []
     ; V2s == []
     ->	V3s = []
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> intersect_values(V1st,V2s,V3s)
	 ;  V1 @> V2
	 -> intersect_values(V1s,V2st,V3s)
	 ;  V3s = [V1|V3st],
	    intersect_values(V1st,V2st,V3st)
	)
    ).

/********************************************************/

:- comment(difference_db/3, " @var{difference_db(+DB1,+DB2,?DB)} takes
two prolog databases (tries), in @var{DB1} and @var{DB2} and produces
a prolog DB, in @var{DB}, that is set difference of the two input
databases, i.e., all tuples in @var{DB1} that are not in @var{DB2}.
This is done by traversing the two input tries in concert and in the
process generating the output trie.  This allows the output trie to
share subtries with the input tries, and to perhaps avoid traversing
large portions of the input tries.  For example, if the two input
databases contain the same sets of tuples, the difference immediately
detects that and returns the empty database.  The form of all the DBs
must be the same. ").

difference_db('$TRIETERM'(DB1),'$TRIETERM'(DB2),'$TRIETERM'(DB)) :-
    difference_db_b(DB1,DB2,DB).
difference_db('$TRIETERMI'(H1),'$TRIETERMI'(H2),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB1,H1),
    machine:intern_termhash(DB2,H2),
    difference_db_b(DB1,DB2,DB),
    machine:intern_termhash(DB,H).

difference_db_b(DB1,DB2,DB) :-
    (DB1 == DB2
     ->	DB = []
     ;	db_comps_d(DB1,HBits1,Num1,HT1),
     	db_comps_d(DB2,HBits2,_Num2,HT2),
	(HBits1 < HBits2
	 -> HBits = HBits2,
	    rebuild_hashtree(HT1,HBits1,HBits,HT1b),
	    difference_subtrees(HBits,HT1b,HT2,RNum,NHT)
	 ; HBits2 < HBits1
	 -> HBits = HBits1,
	    rebuild_hashtree(HT2,HBits2,HBits,HT2b),
	    difference_subtrees(HBits,HT1,HT2b,RNum,NHT)
	 ;  HBits = HBits1,
	    difference_subtrees(HBits,HT1,HT2,RNum,NHT)
	),
	NNum is Num1-RNum,
	fix_ht_size(HBits,NNum,NHT,DB)
    ).

:- comment(difference_in_db/5,
"@pred{difference_in_db(+P1,+P2,+P3,+DB0,?DB)} computes the set
difference of two subtries in @var{DB0} producing a new (or replaced)
subtrie in @var{DB}.  The input tries are determined by the prefix
terms of @var{P1} and @var{P2}, and the place of the resulting trie is
determined by prefix term @var{P3}.  (See @pred{is_prefix_term/2} and
@pred{apply_op_in_db/6} for discussions of prefix terms.)  The form of
@var{DB} will be the same as that of @var{DB0}. ").

difference_in_db(P1,P2,P3,DB0,DB) :-
    apply_op_in_db(lambda(A,B,C,difference_db_b(A,B,C)),P1,P2,P3,DB0,DB).

difference_subtrees(HashBits,HT1,HT2,RNum,HT) :-
    (HashBits =< 0
    ->	difference_kvs(HT1,HT2,0,RNum,HT)
     ;	h_comps_d(HT1,HT10,HT11,HT12,HT13),
	h_comps_d(HT2,HT20,HT21,HT22,HT23),
	difference_subtree(HashBits,HT10,HT20,RNum0,HT30),
	difference_subtree(HashBits,HT11,HT21,RNum1,HT31),
	difference_subtree(HashBits,HT12,HT22,RNum2,HT32),
	difference_subtree(HashBits,HT13,HT23,RNum3,HT33),
	RNum is RNum0+RNum1+RNum2+RNum3,
	h_comps_c(HT,HT30,HT31,HT32,HT33)
    ).

difference_subtree(HashBits,SHT1,SHT2,RNum,SHT) :-
    (SHT1 == []
     ->	SHT = [], RNum = 0
     ; SHT2 == []
     ->	SHT = SHT1, RNum = 0
     ; SHT1 == SHT2
     ->	SHT = [], count_keys(SHT1,RNum)
     ;	NHashBits is HashBits - 2,
	difference_subtrees(NHashBits,SHT1,SHT2,RNum,SHT)
    ).

%% RNum is number removed from list, *not* in list.
difference_kvs(HT1,HT2,RNum0,RNum,HT) :-
    (HT1 == []
     ->	RNum = RNum0, HT = []
     ; HT2 = []
     ->	RNum = RNum0, 
	HT = HT1
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> HT = [K1-V1|HTt],
	    difference_kvs(HT1t,HT2,RNum0,RNum,HTt)
	 ;  K1 @> K2
	 -> difference_kvs(HT1,HT2t,RNum0,RNum,HT)
	 ;  (V1 @= ht(_,_,_)
	     ->	difference_db_b(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	     ;	difference_values(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	    ),
	    RNum1 is RNum0 + 1 - Added,
	    difference_kvs(HT1t,HT2t,RNum1,RNum,HTt)
	)
    ).
    
%%difference_values(_,_,_) :- writeln(userout,difference_values),fail.
difference_values(V1s,V2s,V3s) :-
    (V1s == []
     ->	V3s = []
     ; V2s == []
     ->	V3s = V1s
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> V3s = [V1|V3st],
	    difference_values(V1st,V2s,V3st)
	 ;  V1 @> V2
	 -> difference_values(V1s,V2st,V3s)
	 ;  difference_values(V1st,V2st,V3s)
	)
    ).

/********************************************************/

:- comment(sym_diff_db/3, " @var{sym_diff_db(+DB1,+DB2,?DB)} takes two
prolog databases (tries), in @var{DB1} and @var{DB2} and produces a
prolog DB, in @var{DB}, that is symmetric difference of the two input
databases, i.e., all tuples in one but not both of @var{DB1} and
@var{DB2}.  This is done by traversing the two input tries in concert
and in the process generating the output trie.  This allows the output
trie to share subtries with the input tries, and to perhaps avoid
traversing large portions of the input tries.  The form of all the DBs
must be the same. ").

sym_diff_db('$TRIETERM'(DB1),'$TRIETERM'(DB2),'$TRIETERM'(DB)) :-
    sym_diff_db_b(DB1,DB2,DB).
sym_diff_db('$TRIETERMI'(H1),'$TRIETERMI'(H2),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB1,H1),
    machine:intern_termhash(DB2,H2),
    sym_diff_db_b(DB1,DB2,DB),
    machine:intern_termhash(DB,H).

sym_diff_db_b(DB1,DB2,DB) :-
    (DB1 == DB2
     ->	DB = []
     ;	db_comps_d(DB1,HBits1,_Num1,HT1),
     	db_comps_d(DB2,HBits2,_Num2,HT2),
	(HBits1 < HBits2
	 -> HBits = HBits2,
	    rebuild_hashtree(HT1,HBits1,HBits,HT1b),
	    sym_diff_subtrees(HBits,HT1b,HT2,RNum,NHT)
	 ; HBits2 < HBits1
	 -> HBits = HBits1,
	    rebuild_hashtree(HT2,HBits2,HBits,HT2b),
	    sym_diff_subtrees(HBits,HT1,HT2b,RNum,NHT)
	 ;  HBits = HBits1,
	    sym_diff_subtrees(HBits,HT1,HT2,RNum,NHT)
	),
	fix_ht_size(HBits,RNum,NHT,DB)
    ).

:- comment(sym_diff_in_db/5,
"@pred{sym_diff_in_db(+P1,+P2,+P3,+DB0,?DB)} computes the symmetric
difference of two subtries in @var{DB0} producing a new (or replaced)
subtrie in @var{DB}.  The input tries are determined by the prefix
terms of @var{P1} and @var{P2}, and the place of the resulting trie is
determined by prefix term @var{P3}.  (See @pred{is_prefix_term/2} and
@pred{apply_op_in_db/6} for discussions of prefix terms.)  The form of
@var{DB} will be the same as that of @var{DB0}. ").

sym_diff_in_db(P1,P2,P3,DB0,DB) :-
    apply_op_in_db(lambda(A,B,C,sym_diff_db_b(A,B,C)),P1,P2,P3,DB0,DB).

% RNum is number in result.
sym_diff_subtrees(HashBits,HT1,HT2,RNum,HT) :-
    (HashBits =< 0
    ->	sym_diff_kvs(HT1,HT2,0,RNum,HT)
     ;	h_comps_d(HT1,HT10,HT11,HT12,HT13),
	h_comps_d(HT2,HT20,HT21,HT22,HT23),
	sym_diff_subtree(HashBits,HT10,HT20,RNum0,HT30),
	sym_diff_subtree(HashBits,HT11,HT21,RNum1,HT31),
	sym_diff_subtree(HashBits,HT12,HT22,RNum2,HT32),
	sym_diff_subtree(HashBits,HT13,HT23,RNum3,HT33),
	RNum is RNum0+RNum1+RNum2+RNum3,
	h_comps_c(HT,HT30,HT31,HT32,HT33)
    ).

sym_diff_subtree(HashBits,SHT1,SHT2,RNum,SHT) :-
    (SHT1 == []
     ->	SHT = SHT2, count_keys(SHT,RNum)
     ; SHT2 == []
     ->	SHT = SHT1, count_keys(SHT,RNum)
     ; SHT1 == SHT2
     ->	SHT = [], RNum = 0
     ;	NHashBits is HashBits - 2,
	sym_diff_subtrees(NHashBits,SHT1,SHT2,RNum,SHT)
    ).

sym_diff_kvs(HT1,HT2,RNum0,RNum,HT) :-
    (HT1 == []
     ->	basics:length(HT2,Len),
	RNum is RNum0 + Len,
	HT = HT2
     ; HT2 = []
     ->	basics:length(HT1,Len),
	RNum is RNum0 + Len,
	HT = HT1
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> HT = [K1-V1|HTt],
	    RNum1 is RNum0 + 1,
	    sym_diff_kvs(HT1t,HT2,RNum1,RNum,HTt)
	 ;  K1 @> K2
	 -> HT = [K2-V2|HTt],
	    RNum1 is RNum0 + 1,
	    sym_diff_kvs(HT1,HT2t,RNum1,RNum,HTt)
	 ;  (V1 @= ht(_,_,_)
	     ->	sym_diff_db_b(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	     ;	sym_diff_values(V1,V2,V3),
		add_kv(V3,K1,Added,HT,HTt)
	    ),
	    RNum1 is RNum0 + Added,
	    sym_diff_kvs(HT1t,HT2t,RNum1,RNum,HTt)
	)
    ).
    
sym_diff_values(V1s,V2s,V3s) :-
    (V1s == []
     ->	V3s = V2s
     ; V2s == []
     ->	V3s = V1s
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> V3s = [V1|V3st],
	    sym_diff_values(V1st,V2s,V3st)
	 ;  V1 @> V2
	 -> V3s = [V2|V3st],
	    sym_diff_values(V1s,V2st,V3st)
	 ;  sym_diff_values(V1st,V2st,V3s)
	)
    ).

/********************************************************/

:- comment(xprod_in_db/5,"
@pred{xprod_in_db(+Pref1,+Pref2,+Pref3,+DB0,?DB)} computes the cross
product of the tries determined by @var{Pref1} and @var{Pref2} and
puts the result at the position determined by @var{Pref3}.  The number
of variables in @var{Pref3} must be the sum of the numbers of
variables in @var{Pref1} and @var{Pref2}.  For example, assuming the
call to build_db constructs a prolog database, @var{DB0}, the query:
@begin{verbatim}	   
| ?- build_db(DB),xprod_in_db(p(_,_),q(_,_,_),r(_,_,_,_,_),DB0,DB).
@end{verbatim}	   
would compute the cross product of relations p/2 and q/3 in @var{DB0}
putting the result in r/5 (with r tuples having the p values preceding
the q values). The predicate r/5 is added or replaced and the new DB
@var{DB} is generated. (Note that, since the form p/2 is converted to
prefix term p(_,_), p/2, q/3 and r/5 could be used in place of the
explicit prefix terms in this query.)

The tuples of r/5 would be as though it were defined by the following
Prolog rule:
@begin{verbatim}
r(P1,P2,Q1,Q2,Q3) :- r(P1,P2), q(Q1,Q2,Q3).
@end{verbatim}

The @var{Pref1} values must be facts (i.e., clauses without (non-true)
bodies.)  The complexity of this operation is the size of the
@var{Pref1} trie, since every leaf of the @var{Pref1} trie is
essentially extended with a pointer to the @var{Pref2} trie.  The form of
@var{DB} will be the same as that of @var{DB0}. ").

xprod_in_db(Pref1,Pref2,Pref3,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    xprod_in_db_b(Pref1,Pref2,Pref3,DB0,DB).
xprod_in_db(Pref1,Pref2,Pref3,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    xprod_in_db_b(Pref1,Pref2,Pref3,DB0,DB),
    machine:intern_termhash(DB,H).

xprod_in_db_b(Pref1,Pref2,Pref3,DB0,DB) :-
    cvt_pa(Pref1,Pref1a),
    cvt_pa(Pref2,Pref2a),
    cvt_pa(Pref3,Pref3a),
    (find_hashtable_for_prefix([Pref2a],DB0,TLen2,HT2),
     find_hashtable_for_prefix([Pref1a],DB0,TLen1,HT1)
     ->	check_prefix_term([Pref3a],TLen3,'xprod_in_db/5'),
	(TLen3 =\= TLen1+TLen2
	 -> misc_error(('[prolog_db:xprod_in_db] ',Pref1,', ',Pref2,', and ',
			Pref3,' are inconsistent for cross product.'))
	 ;  update_hashtree_for_prefix([Pref3a],NSHT,_OSHT,TLen3,DB0,DB),
	    xprod_ht(HT1,HT2,NSHT)
	)
     ;  retractall_in_db_b(Pref3a,DB0,DB) % one or other component is empty
    ).
     
xprod_ht(HT1,HT2,NSHT) :-
    (HT1 == [true]
     ->	NSHT = HT2
     ;	db_comps_d(HT1,HashBits,Num,HTree),
	db_comps_d(NSHT,HashBits,Num,NHTree),
	xprod_htrees(HashBits,HTree,HT2,NHTree)
    ).

xprod_htrees(HashBits,HTree,HT2,NHTree) :-
    (HashBits =< 0
     ->	xprod_kvs(HTree,HT2,NHTree)
     ;	h_comps_d(HTree,H1,H2,H3,H4),
	xprod_htree(HashBits,H1,HT2,NH1),
	xprod_htree(HashBits,H2,HT2,NH2),
	xprod_htree(HashBits,H3,HT2,NH3),
	xprod_htree(HashBits,H4,HT2,NH4),
	h_comps_c(NHTree,NH1,NH2,NH3,NH4)
    ).

xprod_htree(HashBits,H,HT2,NH) :-
    (H == []
     ->	NH = []
     ;	NHashBits is HashBits - 2,
	xprod_htrees(NHashBits,H,HT2,NH)
    ).

xprod_kvs([],_HT2,[]).
xprod_kvs([K-V|KVs],HT2,[K-NV|NKVs]) :-
    (V @= ht(_,_,_)
     ->	xprod_ht(V,HT2,NV)
     ;	(V == [true]
	 -> NV = HT2
	 ;  misc_error(('[prolog_db:xprod_in_db]: left argument not facts'))
	)
    ),
    xprod_kvs(KVs,HT2,NKVs).

/********************************************************/

:- comment(join_in_db/6,
"@pred{join_in_db(+Pref1,+Pref2,+NJoin,+Pref3,+DB0,?DB)} performs an
equi-join of tuples of terms specified by @var{Pref1} and @var{Pref2}
producing a new set of terms as specified in @var{Pref3}.  @var{NJoin}
is the number of join variables.  The join arguments are the first
@var{NJoin} fields of the tuples specified by @var{Pref1} and
@var{Pref2}.  The number of variables in @var{Pref3} must be the sum
of the numbers of variables in @var{Pref1} and @var{Pref2} minus
@var{NJoin}.  Assuming the call to @pred{build_db/1} builds a prolog
DB in @var{DB0}, an example query might be:
@begin{verbatim}
| ?- build_db(DB0),join_in_db(p/3,q/4,1,r/6,DB0,DB).
@end{verbatim}

This query would materialize the predicate r/6 in to @var{DB}, where r/6
definition in Prolog would be:
@begin{verbatim}
r(J,P2,P3,Q2,Q3,Q4) :- p(J,P2,P3), q(J,Q2,Q3,Q4).
@end{verbatim}

The p/3 clauses must be facts. (q/4 could have rules with non-empty
bodies, but I don't see any application for this.)  The form of
@var{DB} will be the same as that of @var{DB0}. ").

:- index join_in_db/6-5.
join_in_db(Pref1,Pref2,NJoin,Pref3,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    join_in_db_b(Pref1,Pref2,NJoin,Pref3,DB0,DB).
join_in_db(Pref1,Pref2,NJoin,Pref3,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    join_in_db_b(Pref1,Pref2,NJoin,Pref3,DB0,DB),
    machine:intern_termhash(DB,H).

join_in_db_b(Pref1,Pref2,NJoin,Pref3,DB0,DB) :-
    cvt_pa(Pref1,Pref1a),
    cvt_pa(Pref2,Pref2a),
    cvt_pa(Pref3,Pref3a),
    find_hashtable_for_prefix([Pref1a],DB0,TLen1,HT1),
    find_hashtable_for_prefix([Pref2a],DB0,TLen2,HT2),
    OutLen is TLen1+TLen2-NJoin,
    check_prefix_term([Pref3a],OutLen,'join_in_db/6'),
    join_ht(HT1,HT2,NJoin,HT3),
    (HT3 == []
     ->	retractall_in_db_b(Pref3a,DB0,DB)
     ;	update_hashtree_for_prefix([Pref3a],HT3,_,_,DB0,DB)
    ).

join_ht([],_DB2,_N,[]) :- !.
join_ht(_DB1,[],_N,[]) :- !.
join_ht(DB1,DB2,NJoin,DB) :-
    db_comps_d(DB1,HBits1,_Num1,HT1),
    db_comps_d(DB2,HBits2,_Num2,HT2),
    (HBits1 < HBits2
     ->	HBits = HBits2,
	rebuild_hashtree(HT1,HBits1,HBits,HT1b),
	join_subtrees(HBits,HT1b,HT2,NJoin,INum,NHT)
     ;	HBits2 < HBits1
     ->	HBits = HBits1,
	rebuild_hashtree(HT2,HBits2,HBits,HT2b),
	join_subtrees(HBits,HT1,HT2b,NJoin,INum,NHT)
     ;	HBits = HBits1,
	join_subtrees(HBits,HT1,HT2,NJoin,INum,NHT)
    ),
    fix_ht_size(HBits,INum,NHT,DB).

join_subtrees(HashBits,HT1,HT2,NJoin,INum,HT) :-
    (HashBits =< 0
     ->	join_kvs(HT1,HT2,NJoin,0,INum,HT)
     ;	h_comps_d(HT1,HT10,HT11,HT12,HT13),
	h_comps_d(HT2,HT20,HT21,HT22,HT23),
	join_subtree(HashBits,HT10,HT20,NJoin,INum0,HT30),
	join_subtree(HashBits,HT11,HT21,NJoin,INum1,HT31),
	join_subtree(HashBits,HT12,HT22,NJoin,INum2,HT32),
	join_subtree(HashBits,HT13,HT23,NJoin,INum3,HT33),
	INum is INum0+INum1+INum2+INum3,
	h_comps_c(HT,HT30,HT31,HT32,HT33)
    ).

join_subtree(HashBits,HT1,HT2,NJoin,INum,HT) :-
    (HT1 == []
     ->	HT = [], INum = 0
     ; HT2 == []
     ->	HT = [], INum = 0
     ;	NHashBits is HashBits - 2,
	join_subtrees(NHashBits,HT1,HT2,NJoin,INum,HT)
    ).

join_kvs(KVs1,KVs2,NJoin,INum0,INum,KVs) :-
    (KVs1 == []
     ->	INum = INum0,
	KVs = []
     ; KVs2 == []
     ->	INum = INum0,
	KVs = []
     ;	KVs1 = [K1-V1|KVs1r],
     	KVs2 = [K2-V2|KVs2r],
	(K1 @< K2
	 -> join_kvs(KVs1r,KVs2,NJoin,INum0,INum,KVs)
	 ;  K1 @> K2
	 -> join_kvs(KVs1,KVs2r,NJoin,INum0,INum,KVs)
	 ;  (K1 = _P/Arity
	     ->	NJoin1 is NJoin - 1 + Arity
	     ;	NJoin1 is NJoin - 1
	    ),
	    (NJoin1 =:= 0
	     ->	xprod_ht(V1,V2,NV)
	     ;	join_ht(V1,V2,NJoin1,NV)
	    ),
	    add_kv(NV,K1,Added,KVs,KVsR),
	    INum1 is INum0 + Added,
	    join_kvs(KVs1r,KVs2r,NJoin,INum1,INum,KVsR)
	)
    ).

/********************************************************/

:- comment(reorder_in_db/4,
"@pred{reorder_in_db(+PrefI,+PrefO,+DB0,DB)} generates a new version
of the set of tuples determined by the @var{PrefI} prefix term by
re-ordering its arguments and puts it in the predicate determined by
@var{PrefO}.  Note one can understand this a changing the index on
@var{Pref1} since tuples are indexed in left-to-right order.  The
variables in @var{PrefO} must be a permutation of the variables in
@var{PrefI}, which defines the reordering of the arguments.  Note that
the tries corresponding to an unchanged final sequence of variables in
the two prefix terms will not be traversed in the reordering.

An following example interchanges the first two arguments of @tt{p/4}
in @var{DB0} to create @tt{q/4} in @var{DB}:
@begin{verbatim}	   
| ?- build_db(DB0),reorder_in_db(p(A,B,C,D),q(B,A,C,D),DB0,DB).
@end{verbatim}	   

Note that reordering can bring a later argument to the beginning so it
would be available for use in a call to @pred{join_in_db/6}.  The form
of @var{DB} will be the same as that of @var{DB0}. ").

reorder_in_db(PrefI,PrefO,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    reorder_in_db_b(PrefI,PrefO,DB0,DB).
reorder_in_db(PrefI,PrefO,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    reorder_in_db_b(PrefI,PrefO,DB0,DB),
    machine:intern_termhash(DB,H).

reorder_in_db_b(PrefI,PrefO,DB0,DB) :-
    cvt_pa(PrefI,PrefIa),
    cvt_pa(PrefO,PrefOa),
    prefix_term([PrefIa],IPr,IVars),
    is_most_general_term(IVars),
    prefix_term([PrefOa],OPr,OVars),
    (OPr == IPr
     ->	misc_error(('[prolog_in_db:reorder_in_db] Output must be different from input: ',OPr))     ;	true
    ),
    is_most_general_term(OVars),
    num_common_tail_vars(IVars,OVars,NCom),
    (NCom =:= 0
     ->	findall(PrefO,clause_in_db_b(PrefI,true,DB0),Clauses),
	retractall_in_db_b(PrefO,DB0,DB1),
	assert_in_db_b(Clauses,DB1,DB)
     ;	find_hashtable_for_prefix([PrefIa],DB0,TLen,IHT),
	(NCom =:= TLen
	 -> copy_in_db_b(PrefIa,PrefOa,DB0,DB)
	 ;  NArgs is TLen - NCom,
	    basics:length(IArgs,NArgs),
	    basics:append(IArgs,_,IVars),
	    copy_term(PrefO,OPrefO),
	    check_prefix_term([PrefOa],TLen,'reorder_in_db/4'),
	    reorder_ht(IHT,IArgs,NArgs,OPrefO,PrefOa,DB0,DB)
	)
    ).

num_common_tail_vars(IV,OV,NCom) :-
    (IV == OV
     ->	basics:length(IV,NCom)
     ;	IV = [_|IVt],
	OV = [_|OVt],
	num_common_tail_vars(IVt,OVt,NCom)
    ).

reorder_ht([],_CArgs,_NArgs,_OPrefO,_PrefO,DB,DB) :- !.
reorder_ht(IHT,CArgs,NArgs,OPrefO,PrefO,DB0,DB) :-
    db_comps_d(IHT,HBits,_Num,HTree),
    reorder_subtrees(HBits,HTree,CArgs,NArgs,OPrefO,PrefO,DB0,DB).

reorder_subtrees(HashBits,HTree,CArgs,NArgs,OPrefO,PrefO,DB0,DB) :-
    (HashBits =< 0
     ->	reorder_kvs(HTree,CArgs,NArgs,OPrefO,PrefO,DB0,DB)
     ;	h_comps_d(HTree,HTree1,HTree2,HTree3,HTree4),
	reorder_subtree(HashBits,HTree1,CArgs,NArgs,OPrefO,PrefO,DB0,DB1),
	reorder_subtree(HashBits,HTree2,CArgs,NArgs,OPrefO,PrefO,DB1,DB2),
	reorder_subtree(HashBits,HTree3,CArgs,NArgs,OPrefO,PrefO,DB2,DB3),
	reorder_subtree(HashBits,HTree4,CArgs,NArgs,OPrefO,PrefO,DB3,DB)
    ).

reorder_subtree(HashBits,HTree,CArgs,NArgs,OPrefO,PrefO,DB0,DB) :-
    (HTree == []
     ->	DB = DB0
     ;	NHashBits is HashBits - 2,
	reorder_subtrees(NHashBits,HTree,CArgs,NArgs,OPrefO,PrefO,DB0,DB)
    ).

reorder_kvs([],_CArgs,_NArgs,_OPrefO,_PrefO,DB,DB).
reorder_kvs(KVs,CArgs,NArgs,OPrefO,PrefO,DB0,DB) :-
    KVs = [K-V|KVsr],
    copy_term(CArgs-PrefO,CArgsT-PrefOT),
    CArgsT = [CArgT|RemArgs],
    (K = Pred/Arity
     ->	functor(CArgT,Pred,Arity),
	CArgT =.. [Pred|Args],
	basics:append(Args,RemArgs,NCArgs)
     ;	CArgT = K,
	NCArgs = RemArgs
    ),
    (NCArgs == []
     ->	assert_pref_with_trie([PrefOT],[OPrefO],NArgs,V,DB0,DB1)
     ;	reorder_ht(V,NCArgs,NArgs,OPrefO,PrefOT,DB0,DB1)
    ),
    reorder_kvs(KVsr,CArgs,NArgs,OPrefO,PrefO,DB1,DB).

assert_pref_with_trie([HeadTerm|HeadTail],OPref,NArgs,HT,DB0,DB) :-
    (atomic(HeadTerm)
     ->	NHeadTail = HeadTail,
	(is_most_general_term(OPref)
	 -> NArgs1 is NArgs - 1,
	    OPrefTail = constant % is simpler most general term
	 ;  OPref = [HeadTerm|OPrefTail],
	    NArgs1 = NArgs
	)
     ; HeadTerm = '$VAR'(VN),integer(VN)
     ->	NHeadTail = HeadTail,
	(is_most_general_term(OPref)
	 -> NArgs1 is NArgs - 1,
	    OPrefTail = constant
	 ;  OPref = [_|OPrefTail],
	    NArgs1 = NArgs
	)
     ;  HeadTerm =.. [_|SubTerms],
	basics:length(SubTerms,K),
	basics:append(SubTerms,HeadTail,NHeadTail),
	(is_most_general_term(OPref)
	 -> NArgs1 is NArgs - 1 + K,
	    OPrefT = constant
	 ;  OPref = [OPrefH|OPrefT],
	    OPrefH =.. [_|PrefSubTerms],
	    basics:append(PrefSubTerms,OPrefT,OPrefTail),
	    NArgs1 = NArgs
	)
    ),
    (NArgs1 =:= 0
     ->	update_hashtree(HeadTerm,HT,_,DB0,DB1) % add SubTrie HT
     ;	update_hashtree(HeadTerm,NewSubTrie,OldSubTrie,DB0,DB1),
	assert_pref_with_trie(NHeadTail,OPrefTail,NArgs1,HT,OldSubTrie,NewSubTrie)
    ),
    db_comps_d(DB1,HashBits,NumInTab,HashTree),
    (NumInTab < floor(2**HashBits)
     ->	DB = DB1
     ;	NHashBits is HashBits*2,
	db_comps_c(DB,NHashBits,NumInTab,NHashTree),
	rebuild_hashtree(HashTree,HashBits,NHashBits,NHashTree)
    ).


/********************************************************/

:- comment(project_in_db/5,
"@pred{project_in_db(+PrefI,+NArgs,+PrefO,+DB0,?DB)} creates a new
relation that projects away the first @var{NArgs} of the tuples of
@var{PrefI} in @var{DB0}, adding the result according to @var{PrefO}
in @var{DB}.  The number of variables in @var{PrefI} minus @var{NArgs}
must equal the number of variables in @var{PrefO}.  An example of its
use is:
	   
@begin{verbatim}	   
| ?- build_db(DB0),project_in_db(p(_,_,_,_),2,q(_,_),DB0,DB).
@end{verbatim}

which projects away the first two arguments of the @tt{p/4} relation
in @var{DB0} to generate the @tt{q/2} relation in @var{DB}.  The form
of @var{DB} will be the same as that of @var{DB0}.  ").

project_in_db(PrefI,NArgs,PrefO,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    project_in_db_b(PrefI,NArgs,PrefO,DB0,DB).
project_in_db(PrefI,NArgs,PrefO,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    project_in_db_b(PrefI,NArgs,PrefO,DB0,DB),
    machine:intern_termhash(DB,H).

project_in_db_b(PrefI,NArgs,PrefO,DB0,DB) :-
    cvt_pa(PrefI,PrefIa),
    cvt_pa(PrefO,PrefOa),
    (find_hashtable_for_prefix([PrefIa],DB0,TLen,IHT)
     ->	TLenO is TLen - NArgs,
	check_prefix_term([PrefOa],TLenO,'project_in_db/5'),
	project_ht(IHT,NArgs,OHT),
	(OHT == []
	 -> remove_from_trie(PrefOa,_,DB0,_,DB)
	 ;  update_hashtree_for_prefix([PrefOa],OHT,_,_,DB0,DB)
	)
     ;  DB = DB0
    ).

project_ht(IHT,NArgs,OHT) :-
    (IHT == []
     ->	OHT = []
     ;	db_comps_d(IHT,HBits,_Num,HTree),
	project_subtrees(HBits,HTree,NArgs,[],OHT)
    ).

project_subtrees(HashBits,HTree,NArgs,DB0,DB) :-
    (HashBits =< 0
     ->	project_kvs(HTree,NArgs,DB0,DB)
     ;	h_comps_d(HTree,HTree1,HTree2,HTree3,HTree4),
	project_subtree(HashBits,HTree1,NArgs,DB0,DB1),
	project_subtree(HashBits,HTree2,NArgs,DB1,DB2),
	project_subtree(HashBits,HTree3,NArgs,DB2,DB3),
	project_subtree(HashBits,HTree4,NArgs,DB3,DB)
    ).

project_subtree(HashBits,HTree,NArgs,DB0,DB) :-
    (HTree == []
     ->	DB = DB0
     ;	NHashBits is HashBits - 2,
	project_subtrees(NHashBits,HTree,NArgs,DB0,DB)
    ).

project_kvs([],_NArgs,DB,DB).
project_kvs([K-V|KVsr],NArgs,DB0,DB) :-
    (K = _Pred/Arity
     ->	NArgs1 is NArgs - 1 + Arity
     ;	NArgs1 is NArgs - 1
    ),
    (NArgs1 =:= 0
     ->	union_db_b(V,DB0,DB1)
     ;	project_ht(V,NArgs1,DB2),
	union_db_b(DB0,DB2,DB1)
    ),
    project_kvs(KVsr,NArgs,DB1,DB).

/********************************************************/

:- comment(copy_in_db/4, "@pred{copy_in_db(+PrefI,+PrefO,+DB0,?DB)}
makes a copy of @var{PrefI} into @var{Pref0} generating @var{DB} from
@var{DB0}.  @var{PrefI} and @var{PrefO} must have the same number of
variables.  This is a very fast operation since it simple copies the
pointer to the appropriate subtrie.  The form of
@var{DB} will be the same as that of @var{DB0}. ").

copy_in_db(PrefI,PrefO,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    copy_in_db_b(PrefI,PrefO,DB0,DB).
copy_in_db(PrefI,PrefO,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    copy_in_db_b(PrefI,PrefO,DB0,DB),
    machine:intern_termhash(DB,H).

copy_in_db_b(PrefI,PrefO,DB0,DB) :-
    cvt_pa(PrefI,PrefIa),
    cvt_pa(PrefO,PrefOa),
    (find_hashtable_for_prefix([PrefIa],DB0,TL,HT1)
     ->	true
     ;	HT1 = [],
	check_prefix_term([PrefIa],TL,'copy_in_db/4')
    ),
    (update_hashtree_for_prefix([PrefOa],HT1,_,TL,DB0,DB)
     ->	true
     ;	misc_error(('[prolog_in_db:copy_in_db/4] Predicate selection pattern: ',PrefOa,
		    ' is illegal or inconsistent with other patterns.'))
    ).

:- comment(materialize_in_db/4,
"@pred{materialize_in_db(+PrefI,+PrefO,+DB0,?DB)} calls the query
@var{PrefI} in @var{DB0} and asserts the term @var{Pref0} into
@var{DB} for every answer.  Normally every variable in @var{Pref0}
will be in the goal @var{PrefI}.  The form of @var{DB} will be the
same as that of @var{DB0}. ").

:- index materialize_in_db/4-3.
materialize_in_db(PrefI,PrefO,'$TRIETERM'(DB0),'$TRIETERM'(DB)) :-
    materialize_in_db_b(PrefI,PrefO,DB0,DB).
materialize_in_db(PrefI,PrefO,'$TRIETERMI'(H0),'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB0,H0),
    materialize_in_db_b(PrefI,PrefO,DB0,DB),
    machine:intern_termhash(DB,H).

materialize_in_db_b(PrefI,PrefO,DB0,DB) :-
    cvt_pa(PrefI,PrefIa),
    cvt_pa(PrefO,PrefOa),
    prefix_term([PrefIa],_,Tail),
    prefix_term([PrefOa],_,Tail),
    findall(PrefOa,call_in_db(PrefIa,DB0),Facts),
    retractall_in_db_b(PrefOa,DB0,DB1),
    assert_in_db_b(Facts,DB1,DB).

/******************************************************/

:- comment(subset_db/2, "@pred{subset_db(+DB1,+DB2)} succeeds if the
terms in prolog DB @var{DB1} are a subset of the terms in prolog DB
@pred{DB2}, and fails otherwise. The form of both DBs must be the
same. ").

subset_db('$TRIETERM'(DB1),'$TRIETERM'(DB2)) :-
    subset_db_b(DB1,DB2).
subset_db('$TRIETERMI'(H1),'$TRIETERMI'(H2)) :-
    machine:intern_termhash(DB1,H1),
    machine:intern_termhash(DB2,H2),
    subset_db_b(DB1,DB2).

subset_db_b(DB1,DB2) :-
    (DB1 == DB2
     ->	true
     ;	db_comps_d(DB1,HBits1,_Num1,HT1),
     	db_comps_d(DB2,HBits2,_Num2,HT2),
	(HBits1 < HBits2
	 -> rebuild_hashtree(HT1,HBits1,HBits2,HT1b),
	    subset_subtrees(HBits2,HT1b,HT2)
	 ; HBits2 < HBits1
	 -> rebuild_hashtree(HT2,HBits2,HBits1,HT2b),
	    subset_subtrees(HBits1,HT1,HT2b)
	 ;  subset_subtrees(HBits1,HT1,HT2)
	)
    ).

:- comment(subset_in_db/3, "@pred{subset_in_db(+Pref1,+Pref2,+DB)}
succeeds if the tuples specified by prefix term @var{Pref1} are a
subset of those specified by @var{Pref2} in @var{DB}.  The number of
variables in @var{Pref1} and @var{Pref2} must be the same. @var{DB}
may be of either form. ").

subset_in_db(P1,P2,DB) :-
    apply_rel_op_in_db(lambda(A,B,subset_db_b(A,B)),P1,P2,DB).

subset_subtrees(HashBits,HT1,HT2) :-
    (HashBits =< 0
    ->	subset_kvs(HT1,HT2)
     ;	h_comps_d(HT1,HT10,HT11,HT12,HT13),
	h_comps_d(HT2,HT20,HT21,HT22,HT23),
	subset_subtree(HashBits,HT10,HT20),
	subset_subtree(HashBits,HT11,HT21),
	subset_subtree(HashBits,HT12,HT22),
	subset_subtree(HashBits,HT13,HT23)
    ).

subset_subtree(HashBits,SHT1,SHT2) :-
    (SHT1 == []
     ->	true
     ; SHT2 == []
     ->	fail
     ; SHT1 == SHT2
     ->	true
     ;	NHashBits is HashBits - 2,
	subset_subtrees(NHashBits,SHT1,SHT2)
    ).

subset_kvs(HT1,HT2) :-
    (HT1 == []
     ->	true
     ; HT2 == []
     ->	fail
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> fail
	 ;  K1 @> K2
	 -> subset_kvs(HT1,HT2t)
	 ;  (V1 @= ht(_,_,_)
	     ->	subset_db_b(V1,V2)
	     ;	subset_values(V1,V2)
	    ),
	    subset_kvs(HT1t,HT2t)
	)
    ).

subset_values(V1s,V2s) :-
    (V1s == []
     ->	true
     ; V2s == []
     ->	fail
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> fail
	 ;  V1 @> V2
	 -> subset_values(V1s,V2st)
	 ;  subset_values(V1st,V2st)
	)
    ).


is_empty_in_db(Pref,'$TRIETERM'(DB)) :-
    is_empty_in_db_b(Pref,DB).
is_empty_in_db(Pref,'$TRIETERMI'(H)) :-
    machine:intern_termhash(DB,H),
    is_empty_in_db_b(Pref,DB).

is_empty_in_db_b(Pref,DB) :-
    cvt_pa(Pref,Prefa),
    \+ find_hashtable_for_prefix([Prefa],DB,_TL,_HT).


move_in_db(Pref1,Pref2,DB0,DB) :-
    copy_in_db(Pref1,Pref2,DB0,DB1),
    retractall_in_db(Pref1,DB1,DB).

%% this is simple way...
%% should be faster if done by traversing the DB trie.
count_in_db(Pref,DB,Count) :-
    cvt_pa(Pref,Prefa),
    gensym(ctr,Ctr),
    conset(Ctr,0),
    (do_all
     call_in_db(Prefa,DB),
     coninc(Ctr)
    ),
    conget(Ctr,Count).


/******************************************************/ :-
comment(subsumed_db/2," @pred{subsumed_db(+DB1,+DB2)} succeeds if
database @var{DB1} is subsumed by database @var{DB2}.  If the
databases contain only facts, then this succeeds if the set of ground
instances of @var{DB1} is a subset of the set of ground instances of
@var{DB2}. (check... variables in DB1.)  If the databases contain
rules, then an approximation is attempted by comparing individual
rules.  The databases must be of the same form.  ").

subsumed_db('$TRIETERM'(DB1),'$TRIETERM'(DB2)) :-
    subsumed_db_b(DB1,DB2).
subsumed_db('$TRIETERMI'(H1),'$TRIETERMI'(H2)) :-
    machine:intern_termhash(DB1,H1),
    machine:intern_termhash(DB2,H2),
    subsumed_db_b(DB1,DB2).

:- comment(subsumed_in_db/3," @pred{subsumed_in_db(+Pref1,+Pref2,+DB)}
succeeds if the set of tuples specified by prefix term @var{Pref1} is
subsumed by the set of tuples specified by prefix term @var{Pref2} in
database @var{DB}.  If the tuple sets contain only facts, then this
succeeds if the set of ground instances of tuples in @var{DB}
determined by @var{Pref1} is a subset of the set of ground instances
of those determined by @var{Pref2}. (check... variables in DB1.)  If
tuple sets contain rules (?), then an approximation is attempted by
comparing individual rules.  ").

    subsumed_in_db(P1,P2,DB) :-
    apply_rel_op_in_db(lambda(A,B,subsumed_db_b(A,B)),P1,P2,DB).

subsumed_db_b(DB1,DB2) :-
    difference_db_b(DB1,DB2,DDB),
    findall((H:-B),clause_in_db_b(H,B,DDB),Clauses),
    all_subsumed(Clauses,DB2).

all_subsumed([],_).
all_subsumed([(Head:-Body)|Clauses],DB) :-
    (Body = true
     ->	subsumed_fact_in_db(Head,DB)
     ;	subsumed_rule_in_db(Head,Body,DB)
    ),
    all_subsumed(Clauses,DB).

subsumed_fact_in_db(G,DB) :-
    term_variables(G,Vars),
    call_in_db_b(G,DB),
    is_most_general_term(Vars).

%% Hack for rules; must exist another single rule with eq-shorter body
%% with all subgoals subsuming this body
subsumed_rule_in_db(Head,Body,DB) :-
    term_variables(Head,Vars),
    clause_in_db_b(Head,GBody,DB),
    is_most_general_term(Vars),
    subsumes_goal_lists(GBody,Body).

subsumes_goal_lists(GBody,Body) :-
    (GBody = (G1,Gs)
     ->	subsumes_some(G1,Body),
	subsumes_goal_lists(Gs,Body)
     ;	subsumes_some(GBody,Body)
    ).

subsumes_some(G,Body) :-
    (Body = (B1,Bs)
     ->	(subsumes_chk(G,B1)
	 -> true
	 ;  subsumes_some(G,Bs)
	)
     ;	subsumes_chk(G,Body)
    ).


/******************************************************/

:- comment(disjoint_db/2, "@pred{disjoint_db(+DB1,+DB2)} succeeds if
the prolog databases @var{DB1} and @var{DB2} are disjoint.  @var{DB1}
and @var{DB2} must be of the same form.  ").

disjoint_db('$TRIETERM'(DB1),'$TRIETERM'(DB2)) :-
    disjoint_db_b(DB1,DB2).
disjoint_db('$TRIETERMI'(H1),'$TRIETERMI'(H2)) :-
    machine:intern_termhash(DB1,H1),
    machine:intern_termhash(DB2,H2),
    disjoint_db_b(DB1,DB2).

:- comment(disjoint_in_db/3, "@pred{disjoint_in_db(+Pref1,+Pref2,+DB)}
succeeds if the tuples specified by prefix term @var{Pref1} are
disjoint from those specified by @var{Pref2} in @var{DB}.  The number
of variables in @var{Pref1} and @var{Pref2} must be the same. @var{DB}
may be of either form.  ").

disjoint_in_db(P1,P2,DB) :-
    apply_rel_op_in_db(lambda(A,B,disjoint_db_b(A,B)),P1,P2,DB).

disjoint_db_b(DB1,DB2) :-
    (DB1 == DB2
     ->	is_empty_db(DB1)
     ;	db_comps_d(DB1,HBits1,_Num1,HT1),
     	db_comps_d(DB2,HBits2,_Num2,HT2),
	(HBits1 < HBits2
	 -> rebuild_hashtree(HT1,HBits1,HBits2,HT1b),
	    disjoint_subtrees(HBits2,HT1b,HT2)
	 ; HBits2 < HBits1
	 -> rebuild_hashtree(HT2,HBits2,HBits1,HT2b),
	    disjoint_subtrees(HBits1,HT1,HT2b)
	 ;  disjoint_subtrees(HBits1,HT1,HT2)
	)
    ).

disjoint_subtrees(HashBits,HT1,HT2) :-
    (HashBits =< 0
    ->	disjoint_kvs(HT1,HT2)
     ;	h_comps_d(HT1,HT10,HT11,HT12,HT13),
	h_comps_d(HT2,HT20,HT21,HT22,HT23),
	disjoint_subtree(HashBits,HT10,HT20),
	disjoint_subtree(HashBits,HT11,HT21),
	disjoint_subtree(HashBits,HT12,HT22),
	disjoint_subtree(HashBits,HT13,HT23)
    ).

disjoint_subtree(HashBits,SHT1,SHT2) :-
    (SHT1 == []
     ->	true
     ; SHT2 == []
     ->	true
     ; SHT1 == SHT2
     ->	fail
     ;	NHashBits is HashBits - 2,
	disjoint_subtrees(NHashBits,SHT1,SHT2)
    ).

disjoint_kvs(HT1,HT2) :-
    (HT1 == []
     ->	true
     ; HT2 == []
     ->	true
     ;	HT1 = [K1-V1|HT1t],
	HT2 = [K2-V2|HT2t],
	(K1 @< K2
	 -> disjoint_kvs(HT1t,HT2)
	 ;  K1 @> K2
	 -> disjoint_kvs(HT1,HT2t)
	 ;  (V1 @= ht(_,_,_)
	     ->	disjoint_db_b(V1,V2)
	     ;	disjoint_values(V1,V2)
	    ),
	    disjoint_kvs(HT1t,HT2t)
	)
    ).
    
disjoint_values(V1s,V2s) :-
    (V1s == []
     ->	true
     ; V2s == []
     ->	true
     ;	V1s = [V1|V1st],
	V2s = [V2|V2st],
	(V1 @< V2
	 -> disjoint_values(V1st,V2s)
	 ;  V1 @> V2
	 -> disjoint_values(V1s,V2st)
	 ;  fail
	)
    ).

/**********************************************************/

:- comment(equal_in_db/3, "@pred{equal_in_db(P1,P2,DB)} succeeds if
the set of tuples specified by prefix term @var{Pref1} is equal to the
set of tuples specified by prefix term @var{Pref2}.  @var{DB} may be
of either form.  ").

equal_in_db(P1,P2,DB) :-
    apply_rel_op_in_db(lambda(A,B,(A==B)),P1,P2,DB).


/**********************************************************/

/**db_comps(DB,B,N,H) :-
    (DB == []
     ->	B = 2, N = 0, H = []
     ; H == []
     ->	DB = []
     ;	DB = ht(B,N,H)
    ).
***/

db_comps_d(DB,B,N,H) :-
    (DB == []
     ->	B = 2, N = 0, H = []
     ;	DB = ht(B,N,H)
    ).

db_comps_c(DB,B,N,H) :- 
    (H == []
     ->	DB = H
     ;	DB = ht(B,N,H)
    ).

/* directional versions are more efficient. No CPs
h_comps(H,H1,H2,H3,H4) :-
    (H=[], H1=[], H2=[], H3=[], H4=[]
     ->	true
     ;	H = h(H1,H2,H3,H4)
    ).
*/

h_comps_d(H,H1,H2,H3,H4) :-
    (H == []
     ->	H1 = [], H2 = [], H3 = [], H4 = []
     ;	H = h(H1,H2,H3,H4)
    ).

h_comps_c(H,H1,H2,H3,H4) :-
    (H1 == [], H2 == [], H3 == [], H4 == []
     ->	H = []
     ;	H = h(H1,H2,H3,H4)
    ).

add_kv(V,K,A,HT0,HT) :-
    (V = []
     ->	HT0 = HT,
	A = 0
     ;	HT0 = [K-V|HT],
	A = 1
    ).

count_keys([],0).
count_keys([_|R],N) :-
    (R == []
     ->	N = 1
     ;	length(R,N1),
	N is N1+1
    ).
count_keys(h(HT1,HT2,HT3,HT4),N) :-
    count_keys(HT1,N1),
    count_keys(HT2,N2),
    count_keys(HT3,N3),
    count_keys(HT4,N4),
    N is N1+N2+N3+N4.

fix_ht_size(_HBits,0,HT,[]) :- !,
    (HT == []
     ->	true
     ;	standard:writeln(userout,'ERROR in ht num, internal bug!! ')
    ).
fix_ht_size(HBits,NNum,HT,DB) :-
    (NNum =< 1
     ->	GHBits = 2
     ;	GHBits is 2**ceiling(log(log(NNum+1)/log(2))/log(2))
    ),
    (GHBits =:= HBits
     ->	db_comps_c(DB,HBits,NNum,HT)
     ;	rebuild_hashtree(HT,HBits,GHBits,NHT),
	db_comps_c(DB,GHBits,NNum,NHT)
    ).

