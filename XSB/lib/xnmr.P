/* File:      xnmr.P
** Author(s): David Warren
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 1986, 1993-1999
** Copyright (C) ECRC, Germany, 1990
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: xnmr.P,v 1.2 1999-08-26 13:30:47 warren Exp $
** 
*/


:- compiler_options([cpp_on]).

#include "sig.h"
#include "flag_defs.h"
#include "standard.h"
#include "char_defs.h"

:- nmr.

nmr :-
        set_inthandler('_$keyboard_int'(_), MYSIG_KEYB),
        version_message,
        prompt('nmr| ?- ',[]),
        prompt(' ? ',[],'_$more_prompt'(_)),
        prompt(' ? ',[],'_$debug_prompt'(_)),
        fail.
nmr :-
	push_abort_cutpoint,
	repeat,
	pop_abort_cutpoint,
	push_abort_cutpoint, % reset abort cutpoint
	nmr1,	% Protect varible state, so fail to this point
		% doesnt require untrailing (when aborting or
		% segfault handling)
	pop_abort_cutpoint.  % reset for caller

nmr1 :-
	repeat,
	trimcore,
	stat_set_flag(HIDE_STATE, 1), %% hide call interceptions.
	stat_set_flag(INVOKE_NUM, 0),
	conset('_$break_level', 0),
	print_debug_state,
	prompt(Prompt,Prompt),
	file_write(STDFDBK, Prompt),
	file_flush(STDFDBK, _),

	file_read(STDIN, X, Vars),
	(nonvar(X), read_in_stop(X), !	% end of top loop; halt
	; 
	abolish_all_tables,
	compute_query(X,Q1),
	process_nmr_query(Q1, Vars)
	).

read_in_stop(halt) :- halt.     % quit entire system, regardless of break level
read_in_stop(end_of_file).	% pop a break level, out if at top


process_nmr_query(X, Vars) :- 
	prompt(MorePrompt,MorePrompt,'_$more_prompt'(_)),
	stat_flag(LETTER_VARS, LetterVars),
	nmr_get_residual(X,Vars,Res),
	(var(Vars),Res == []
         ->     !,
	        file_nl(STDFDBK), file_write(STDFDBK, yes), file_nl(STDFDBK),
		fail
	 ;      true
        ),
	(LetterVars =:= 0
         ->     print_answer(Vars),
	        print_delay_lists(Res)
	 ;      (numbervars([Vars,Res]), 
	         print_answer(Vars), 
		 print_delay_lists(Res),
		 fail
	         ; 
		 true
	        )
	),
	file_write(STDFDBK, MorePrompt),
	file_flush(STDFDBK, _),
	no_more(C),
	(C =:= 10
         ->	!,
	        file_nl(STDFDBK), file_write(STDFDBK, yes), file_nl(STDFDBK)
         ; C =:= 0's   % 'print stable models
         ->     (Res \== []
	         ->     process_stable_models(X)
	         ;      true
	        )
	 ; C =:= 0'a   % 'answer set semantics
         ->     (Res \== []
	         ->     process_answerset_semantics(X)
	         ;      true
	        )
	 ;      true
        ),
	fail.
process_nmr_query(_,_) :- 
	file_nl(STDFDBK), file_write(STDFDBK, no), file_nl(STDFDBK),
	fail.

print_delay_lists([]) :- !.
print_delay_lists([DL|DLs]) :-
	file_nl(STDFDBK),
	file_write(STDFDBK,'DELAY LIST = '),
	file_write(STDFDBK,DL),
	print_delay_lists(DLs).

no_more(X) :- 
	file_get(0, C), 
	(C =:= -1 /* end_of_file */
         ->     X = 10
         ; C =:= 10
         ->     X = 10
         ;      X = C,
	        scan_to_nl
         ).

scan_to_nl :-
	file_get(0, X), 
	(X =:= -1 /* end_of_file */
         ->     true
         ; X =:= 10
         ->     true
         ;      scan_to_nl
         ).
	

compute_query(Q,Q1) :-
	(Q == [] -> State = undef 
         ; Q = [_|_] -> State = undef
         ;	table_state(Q,State)
        ),
	(State == undef
	 ->    Q1 = {Q},
	       ('{}'(Q),fail ; true)
	 ;     Q1 = Q,
	       (untable_call(Q),fail ; true)
	).


:- table '{}'/1.
'{}'(Q) :- 
	'_$savecp'(C), 
	goal_cut_trans(Q,X,C),
	( stat_set_flag(HIDE_STATE, 0)         %% expose tracing
	; stat_set_flag(HIDE_STATE, 1), fail   %% hide again when backtrack
	),
	call_expose(X).

untable_call(Q) :- 
	'_$savecp'(C), 
	goal_cut_trans(Q,X,C),
	( stat_set_flag(HIDE_STATE, 0)         %% expose tracing
	; stat_set_flag(HIDE_STATE, 1), fail   %% hide again when backtrack
	),
	call_expose(X).

nmr_get_residual(CallSkel, Vars, DelayList) :-
	get_calls(CallSkel, S, R),
	is_most_general_term(R),
	all_distinct_vars(Vars),
	get_returns(S,R,Leaf),
	get_delay_lists(Leaf, DLs),
	DelayList = DLs.

% inline builtin
get_delay_lists(Leaf, DLs) :- get_delay_lists(Leaf, DLs).

print_answer([]) :- !.
print_answer([vv(Name, Val)|Tail]) :-
	file_nl(STDFDBK), file_write(STDFDBK, Name), 
	file_write(STDFDBK, ' = '), file_write(STDFDBK, Val),
	print_answer(Tail).

conset(Con, Val) :- conpsc(Con, PSC), psc_set_prop(PSC, Val).

all_distinct_vars(Vars) :-
	\+ \+ all_distinct1(Vars).
all_distinct1([]).
all_distinct1([vv(_Name,Var)|Rest]) :-
	var(Var),
	Var=[],
	all_distinct1(Rest).

process_stable_models(Query) :-
	prompt(MorePrompt,MorePrompt,'_$more_prompt'(_)),
	(Query = {tnot(Q)}
         ->     true
         ;      Q = Query
        ),
	init_smodels(Q,0),
	file_nl(STDFDBK),
	file_write(STDFDBK,'Stable Models: '), 
	a_stable_model,
	file_nl(STDFDBK),
	file_write(STDFDBK,'  '),
	print_current_stable_model,
	file_write(STDFDBK, MorePrompt),
	file_flush(STDFDBK, _),
	no_more(Cmd),
	(Cmd =:= 10
         ->     !,
	        file_write(STDFDBK, '  yes'), 
		file_nl(STDFDBK)
	 ; true
        ),
	fail.
process_stable_models(_).

process_answerset_semantics(Query) :-
	(Query = {tnot(Q)}
         ->     Neg = 1
         ;      Q = Query, Neg = 0
        ),
	init_smodels(Q,0),
	(in_all_stable_models(1,Neg)
	 ->     file_write(STDFDBK,'  yes')
	 ;      file_write(STDFDBK,'  no')
	),
	file_nl(STDFDBK).

prompt(New,Old) :- prompt(New,Old,'_$nmr_main_prompt'(_)).

prompt(New,Old,Pstore) :- 
	(Old == []
	 ->	true
	 ;	get_prompt(Pstore,Old)
	),
	(Old \== New
	 ->	set_prompt(Pstore,New)
	 ;	true
	).

get_prompt(Pstore,Prompt) :-
	term_psc(Pstore, Psc),
	psc_prop(Psc, Buff),	
	intern_string(Buff, String),	%% temp solution, since ALIAS not work
	Prompt = String.		%% for double word.

set_prompt(Pstore,Prompt) :-
	term_psc(Pstore, Psc),
	psc_set_type(Psc, 8),			%% T_CSET
	conname(Prompt, String),
	psc_set_prop(Psc, String).

print_debug_state :-
	stat_flag(TRACE,Trace),
	stat_flag(DEBUG_ON,Debug),
	stat_flag(QUASI_SKIPPING,QuasiSkip),
	( (Trace > 0, QuasiSkip =:= 0)
	  ->	file_write(STDDBG,[trace]), file_nl(STDDBG)
	  ; (Debug > 0; (Trace > 0, QuasiSkip > 0))
	  ->	file_write(STDDBG,[debug]), file_nl(STDDBG)
	; true
	).

version_message :-
	file_nl(STDMSG),
	slash(Slash),
	%% xsb_configuration(etcdir, EtcDir),
	%% fmt_write_string(CopyingMsg, '%s%scopying.msg', f(EtcDir,Slash)),
	%% print_file_contents(CopyingMsg, STDMSG),
	%% file_nl(STDMSG),
	xsb_configuration(config_dir, ConfigDir),
	fmt_write_string(ConfMsg, '%s%sbanner.msg', f(ConfigDir,Slash)),
	print_file_contents(ConfMsg, STDMSG).

