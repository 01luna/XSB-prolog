%:- compiler_options([sysmod]).

:- export table_dump/0,table_dump/1,table_dump/2, table_dump/3.
% table_dump_file/0, table_dump_file/1.

:- import domain_error/4,check_nonvar_list/3 from error_handler.
:- import numbervars/1 from num_vars.
:- import member/2,length/2 from basics.
:- import get_calls_for_table/2 from tables.
:- import subsumes_chk/2 from subsumes.
:- import parsort/4 from machine.
:- import sort/2 from setof.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% table_dump/0 shows summary and details of #subgoals and #returns for
% all tabled predicates.
%
% table_dump(Pred,Options) writes to current_output depending on what
% is in the list of Options: info(summary) shows summary and details
% of #subgoals and #returns for all subgoals that are subsumed by
% Pred.  info(details) shows details of #subgoals and #returns for all
% subgoals that are subsumed by Pred.  results(Results) does not write
% output, instead it binds Results to a list of the results that would
% have otherwise been output. 
%
% table_dump(Stream, Pred, Options) performs like table_dump/2, except
% it writes output to stream, even if results(Results) is in the
% Options list.  
%
% These following utilities are also available but are not exported
% table_dump_f/0 writes to generated filename the summary and details
% for all tabled predicates.  table_dump_f(File) appends to File the
% summary and details for all tabled predicates.  The contents of the
% file can be read by prolog or parsed by tools such as Perl or Awk
% format_table_dump_file(File) will format the contents of a
% table_dump file and write it to current_output.
% format_table_dump_file(InFile,OutFile) will format the contents of a
% table dump file InFile and write it to OutFile.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% table_dump/3 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

table_dump(Stream,Pred,Options) :- 
	check_options(Options,Details,Summary,ResultsIn,Output), 
	(ResultsIn = results(Results) -> true ; ResultsIn = Results),
	(Summary == y -> table_dump_summary(Pred,Stream,Results,Results1,Output) ; Results = Results1),
	(Details == y -> 
	    table_dump_details(Pred,Stream,Results1,Output) 
         ;  (var(Results1) -> Results1 = [] ; true)).

table_dump_summary(Pred,Stream,ResultsIn,ResultsOut,Output):-
	all_call_returns_for_atom_list(Pred,NumCalls, List), 
	sumreturns(List,NumReturns),
	(var(ResultsIn) ->
	      ResultsIn = [summary =  Pred - subgoals(NumCalls) - returns(NumReturns)|ResultsOut]
	    ; ResultsOut = n),
	(Output = y -> 
	    writeit_prolog(Stream,summary =  Pred - subgoals(NumCalls) - returns(NumReturns)),nl
	 ;  true).

table_dump_details(Pred,Stream,ResultsIn,Output):-
	all_call_returns_for_atom_list(Pred,NumCalls, List), 
	(var(ResultsIn) ->
	    ResultsIn = [details- Pred - subgoals(NumCalls) - answers_for_subgoals(List)]
          ; true),
        (Output = y -> 
	    writeit_prolog(Stream,details- Pred - subgoals(NumCalls) - answers_for_subgoals(List))
	  ; true).

%all_call_returns_for_atom_list(+Pred,?NumCalls,?List) is true when
%NumCalls is the number of calls for tabled predicate Pred that are
%subsumed by Pred, and List is the list of list of answers for those
%calls.
all_call_returns_for_atom_list(Pred,NumCalls, Slist) :-
	findall(Pred,predicate_property(Pred,tabled),PredList_1),
	sort(PredList_1,PredList),
	(PredList = [] -> 
	    (NumCalls=0,Slist=[]) 
	 ;  member(Pred,PredList),
  	    findall(C-NR-RSs,all_call_returns_for_atom(Pred,C,NR,RSs),List),
	    parsort(List,[desc(2),asc(1)],0, Slist),
	    length(List,NumCalls)
	).

all_call_returns_for_atom(Pred,C,NR,RSs) :-
	 get_calls_for_table(Pred,C),
	 get_call(C,TH,RS),
	 subsumes_chk(Pred,C),
	 findall(Atom,(get_returns(TH,RS),bindreturn(C,RS,Atom)),RSs),
	 length(RSs,NR).

bindreturn(Pred,Ret,Pred):- ground(Ret),ground(Pred).
bindreturn(Pred,Ret,Pred):-
	getvarsig(Pred,Sig-[]),
        bindtosig(Sig,Ret).

getvarsig(Term,[Sig|End]-End) :- var(Term),!,Term=Sig.
getvarsig(Term,End-End):- ground(Term),!.
getvarsig([Term|Terms],Sig-End) :- !,getvarsig(Term,Sig-Sigs), getvarsig(Terms,Sigs-End).
getvarsig(Term,Sig) :- compound(Term),!,Term =.. Terms, getvarsig(Terms,Sig).

bindtosig(Sig,Ret) :- Ret=..[ret|Sig]. %must have same number of vars   (?? if not variant)

sumreturns([],0).
sumreturns([_-N-_L|Rs],NumReturns) :- sumreturns(Rs,NR), NumReturns is N + NR.

writeit_prolog(Stream,Term) :- numbervars(Term), 
	writeq(Stream,Term), 
	write(Stream,'.'),nl(Stream),fail. %fail to remove effect of numbervars
writeit_prolog(_,_).

%--------

check_options(Options,Details,Summary,ResultList,Output):-
	check_nonvar_list(Options,'table_dump/[2,3]','[2,3]'),
	(Options == [] -> 
	    Details = n,Summary = y,ResultList = n,Output = y
	 ;  check_options_1(Options,Details,Summary,ResultList,Output)).

check_options_1([],D,S,R,O):-
	(var(D) -> D = n ; true),
	(var(S) -> S = y ; true),  % summary true by default
	(var(R) -> R = n ; true),
	(var(O) -> O = y ; true).
check_options_1([details(Bool)|T],D,S,R,O):-!,
	(Bool == true -> 
	    D = y 
	 ;  (Bool == false -> 
	        D = n
	    ; 	domain_error('[summary(<true/False>),details(<true/false>),results(Var),output(<true/false>)]',
	             Bool,'table_dump/[2,3]','[2,3]') ) ),
	check_options_1(T,D,S,R,O).
check_options_1([summary(Bool)|T],D,S,R,O):-!,
	(Bool == true -> 
	    S = y 
	 ;  (Bool == false -> 
	        S = n
	    ; 	domain_error('[summary(<true/False>),details(<true/false>),results(<var>),output(<true/false>)]',
	             Bool,'table_dump/[2,3]','[2,3]') ) ),
	check_options_1(T,D,S,R,O).
check_options_1([results(X)|T],D,S,results(X),O):-!,
	(var(X) -> 
	    true
	 ;  domain_error('[summary(<true/False>),details(<true/false>),results(<var>),output(<true/false>)]',
	             X,'table_dump/[2,3]','[2,3]') ),
	check_options_1(T,D,S,results(X),O).
check_options_1([output(Bool)|T],D,S,R,O):-!,
	(Bool == true -> 
	    S = y 
	 ;  (Bool == false -> 
	        S = n
	    ; 	domain_error('[summary(<true/False>),details(<true/false>),results(<var>),output(<true/false>)]',
	             Bool,'table_dump/[2,3]','[2,3]') ) ),
	check_options_1(T,D,S,R,O).
check_options_1([Culprit|_],_D,_S,_,_):-
	domain_error('[summary(<true/False>),details(<true/false>),results(<var>),output(<true/false>)]',
	             Culprit,'table_dump/[2,3]','[2,3]').

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Convenience
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% table_dump/0   table dump all tabled predicates.

table_dump(Pred,Options):- table_dump(userout,Pred,Options).

table_dump(Pred) :- table_dump(userout,Pred,[summary(true)]).

table_dump :- findall(Pred,predicate_property(Pred,tabled),Preds),
	      sort(Preds,PredList),member(P,PredList),nl,
	      table_dump(P,[details(true)]),fail.
table_dump.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
end_of_file.

% details for Pred Pattern- number of subcalls, #answers for each subcalls
% all_call_returns_for_atomlw calls all_call_returns_for_atoml/3 and writes out pattern(Pred,called(NumCalls),answers_for_calls(List of each call and how many answers it has))). 
all_call_returns_for_atomlw(Pred) :-
	all_call_returns_for_atoml(Pred,NumCalls, List),
	writeit( details- Pred - subgoals(NumCalls) - answers_for_subgoals(List)). 

:- dynamic tdformat/1.
:- dynamic tdformatterm/1.

writeit(Term) :- assert(tdformatterm(Term)),fail.
writeit(_) :- nowriteit(_),(\+ writetostream(_)),!.
% commenting out the flora stuff for now.
%writeit(Term) :- tdformat(prolog) -> writeit_prolog(Term) ; writeit_flora(Term).
writeit(Term) :- writeit_prolog(Term).

%writeit_flora(Term) :- 
%		    convert_to_flora(Term,FloraTerm), 
%		    writeq(FloraTerm), write('.'),nl,fail. %fail to remove effect of numbervars
%writeit_flora(_).
%
%convert_to_flora(_Term,_FloraTerm) :- 
%	write(' Sorry, FLORA syntax for table_dump not yet implemented. '),nl,fail.

gathertdformatterms(Options) :- member(results(Terms),Options), !, (findall(Term, tdformatterm(Term), Terms) -> true;Terms=[]), retractall(tdformatterm(_)).
gathertdformatterms(_). %facts not requested

gentdfile(File) :- 
	shell_to_list(date,DateLL,_),DateLL = [DateL],
	concat_atom([table_dump|DateL],'-',File).

/*	
These predicates are not used by any of the exported predicates.

format_table_dump_file(In,Out) :- tell(Out),format_table_dump_file(In),told.
format_table_dump_file(File) :- open(File,read,Stream), formatfile(Stream),close(Stream).

:- dynamic formatTableDumpTerm/1.
formatfile(Stream) :- repeat,read(Stream,Term), numbervars(Term), formatTableDumpTerm(Term),Term=end_of_file.
formatfile(_).

formatTableDumpTerm(eof) :- !,fail.
formatTableDumpTerm(td(details-Pred-NumCalls-answers_for_subgoals([]))) :-!, writeit(td(details-Pred-NumCalls-answers_for_subgoals([]))).

formatTableDumpTerm(td(details-Pred-NumCalls-answers_for_subgoals(NumReturns))) :-!,
    write('td(details-'),write(Pred),write('-'),write(NumCalls),nl,write('   - answers_for_subgoals(['),nl, writereturns(NumReturns),write('    ])).'),nl.

formatTableDumpTerm(Term) :-writeq(Term),write('.'),nl.

writereturns([H,H1|T]) :- !,write('    '),writeq(H),write(','),nl,writereturns([H1|T]).
writereturns([H|T]) :- write('    '),writeq(H),writereturns(T).
writereturns([]):- nl.

all_returns_for_atom_write(Pred) :- 
	all_returns_for_atom(Pred,NumReturns), writeit(Pred - returns(NumReturns)).

all_returns_for_atom(Pred,NumReturns) :- 
	findall(Cr, get_returns_for_call(Pred,Cr), Callsr), 
	length(Callsr,NumReturns).

gentdstamp(table_dump-DateAtom) :- 
	shell_to_list(date,DateLL,_),DateLL = [DateL],
	concat_atom([DateL],'-',DateAtom).
writeit_flora(_,_).

*/



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% options: 
%info(summary), info(details), info(allreturns),   -- info(summary) is default
%format(flora), format(prolog)   -- format(prolog) is default 
%results(R) - if present R is bound to the output instead of writing to stdout. If a stream is given as arg1 of table_dump/3, output is also written to that stream. 

table_dump_file :- gentdfile(File), table_dump_f(File).
table_dump_file(File) :- open(File,append,Stream), 
	reset_current_output(Stream,Old),table_dump,reset_current_output(Old,_),close(Stream).


/* Right now, experimental for aggregs.P */
	
:- export get_unifiable_returns/3.

:- import t_assert_2/2 from assert.
:- import (index)/2 from standard.
:- dynamic '_$return'/1.
:- index('_$return'/1,trie).
:- import system_retract_fact/1 from assert.


get_unifiable_returns(TableEntry,Skel, Leaf) :-
	\+ \+ (get_unifiable_returns_1(TableEntry, Skel, ReturnList),
	       ReturnList \== [],
	       t_assert_2('_$return'(ReturnList),_)),
	system_retract_fact('_$return'(ReturnList)),
%	    change_attv_to_var(ReturnTemplate),
	member('_$get_returns'(TableEntry,Leaf),ReturnList).
	
get_unifiable_returns_1(TableEntry, Skel, ReturnsList):- 
	findall('_$get_returns'(TableEntry,RetLeaf),
		'_$$get_returns'(TableEntry,Skel,RetLeaf),
		ReturnsList).



/*
 * For [temporary] backward compatibility, redefine table_state/2 in
 * terms of the newer table_state/4.
 */

table_state(Call, State) :-
	table_state(Call, PredType, _CallType, AnsSetStatus),
	(PredType == variant
         -> ( AnsSetStatus == undefined
             -> State = no_call_yet
	     ;  State = AnsSetStatus )
	 ; PredType == undefined -> State = undef
        ).




