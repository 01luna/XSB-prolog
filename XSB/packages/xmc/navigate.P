/* File:      navigate.P
** Author(s): Abhik Roychoudhury
** Contact:   lmc@cs.sunysb.edu
** 
** Copyright (C) SUNY at Stony Brook, 1998-2000
** 
** XMC is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XMC is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XMC; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: navigate.P,v 1.3 2001-07-03 22:32:16 gmkp Exp $
** 
*/
:- dynamic node/3.
:- dynamic edge/2.

% justification_root(+Q, -RootNode)
% ---- Evaluates query Q and returns the rootnode of the tree.

justification_root(Q, node(RootNodeId, Q, TV)) :-
	justify(Q, TV, RootNodeId), close_open_tables, !.
%	node(RootNodeId, Q, TV),
%	RootNode = node(RootNodeId, Q, TV).


%get_child((G, TV, tabled, _), Child) :- !, 
%	'$justifier_trie'(T),
%	NodeId = num(_),
%	nb_asserted(seen(NodeId, G, (_, _, R, _)), T),
%	get_child1(R, Child).

get_child(NodeId, Child) :- 
	'$justifier_trie'(T),
	nb_asserted(seen(NodeId, PG, R), T),
	get_child1(R, Child).

get_child1(L, Child) :- arc(L, L1), get_child2(L1, Child).

get_child2((G, TV, loop1, _), Child) :- !,
	G =.. [rec_models, IState, FName],
	intern(State, IState),
	(trie_interned(state(State,Number),_,_) ->
	    Child = node(loop, loop(G), TV)
	 ;  '$justifier_trie'(T),
	    nb_asserted(seen(num(CId), G, _), T),
	    Child = node(num(CId), G, TV)
	).

get_child2((G, TV, L, _), Child) :-
	(show(G) -> '$justifier_trie'(T),
		    nb_asserted(seen(num(CId), G, _), T),
		    Child = node(num(CId), G, TV)
%		    (L = ancestor 
%			-> Child = node(ancestor, ancestor(G), TV)
%			; Child = node(num(CId), G, TV)
%		    )
		 ; ((allowed(G), \+ single_child((G, TV, L, _))) 
			-> Child = node((G, TV, L, nil), G, TV)
			; \+ builtin(G)
				-> get_child1(L, Child)
		   )
	).

get_children(NodeId, Children) :- 
	setof(C, get_child(NodeId, C), Children).

single_child(NId) :- get_children(NId, [_1child]).

arc((leaf(A), B, C, D), S) :- !, arc((A, B, C, D), S).
arc((A, B, C, D), (A, B, C, D)).
arc((_, _, _, S), S1) :- arc(S, S1). 

%-------------------------------------------------------------------------

