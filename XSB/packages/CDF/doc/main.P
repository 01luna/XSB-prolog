:- compiler_options([ciao_directives]).

:- comment(title,"CDF: Cold Dead Fish").
:- comment(subtitle,"An Ontology Management System (OMS)").

:- comment(author,"Terrance Swift, David S. Warren").
:- comment(author,"with help from Joseph Gartner, Tanya Vidrevich").

:- comment(copyright,"Copyright XSB, Inc; Medicine Rules, Inc, 2001.
This document produced via the XSBDOC system.").

:- comment(module,"

The goal of the @em{Ontology Management System} (OMS) is to store,
manage, and provide a basis for visualizing ontology-based knowledge
for systems implemented in XSB @footnote{Historically, the OMS was
first called the @em{Taxonomy Management System (TMS)}.}.  The OMS
provides facilities to represent knowledge in a way useful to XSB, to
translate that knowledge to and from a relational database format; and
to translate that knowledge into a format visualizable through Protege
(and eventually XJ2).

@section{A Quick Tour of the OMS}

In this section, we briefly introduce terminology and ideas that will
be discussed more thoroughly in the succeeding sections.  At a high
level, the OMS stores @concept{objects}, their @concept{attributes},
@concept{classes}, their @concept{relations}, and schema information
about all.  Storage can be in different formats according to the needs
of an application.  Different formats are explained below; for this
introduction we present all facts in an @em{external} format
(discussed more in @ref{OMS: External Format}).  Reasoning about objects
is supported in part by the @pred{class_ext/3} relation which denote
sets of objects (or equivalently types or classes of objects).  As an
example, the fact @begin{verbatim} class_ext('Sutures','A2390',dla)
@end{verbatim} @noindent indicates that @tt{Sutures} is a class in the
@tt{dla} ontology and that within this ontology, it has the native id
@tt{A2390}.  Since native ids may not be unique across organizations
or ontologies, the external form uses the native id together with the
source ontology as a keys in its various data facts.

Classes and sets are interchangible in the OMS, and reasoning about
classes and their inheritance mechanisms can generally be done using
intuitions about naive set theory.  Accordingly, the OMS distinguishes
the subset relation among classes via the @pred{subclass_ext/4}
predicate.  This relation is similar to that used in many
object-oriented systems -- the relation can be seen as defining a
reflexive, transitive and weakly asymetric partial order, with a
single node, denoted as the @index{OMS Root} that is maximal in the
partial order.  As an example, the fragment

@begin{verbatim}
class_ext('FIIG','FIIG',dla) 
subclass_ext('A2390',dla,'FIIG',dla)
@end{verbatim} 
@noindent indicates that the class @tt{Sutures}, from the @tt{dla}
ontology, whose native id is @tt{'A2390'} is a subclass of the class
@tt{FIIG} which is also found in the @tt{dla} ontology.  Another way
to say this is that the set of parts 
that are sutures is a subset of the set of parts classified in all
FIIGs.  Note that while it may be meaningful to distinguish native ids
from names, as with @tt{Sutures}, this is not necessary.  The
@pred{class_ext/4} predicate for @tt{FIIG} defines the native id to be
the same as the name, and then uses this native id in the
@pred{subclass_ext/4} predicate.

Given classes and their subclass relations, denoted via the predicate
@pred{subclass_ext/4}, simple but useful @concept{taxonomies} can be
developed.  However, not all interesting information about the world
can be represented via a fixed subclass relation.  Hence, there are
other predicates that can indicate arbitrary relations between
classes.

The first type of relation between classes simply states that the
relationship holds for all elements of the class.  This is done using
the @pred{relationship_ext/6} predicate.  For example, in the database
fragment 
@begin{verbatim} 
class_ext( needle_type, needle_type,my_ont)
class_ext( needle_type_domain, needle_type_domain,my_ont)
relationship_ext(Sutures,dla, needle_type,my_ont,needle_type_domain,my_ont).  
@end{verbatim} 

@noindent @tt{Sutures}, @tt{ needle_type}, and @tt{
needle_type_domain} are all classes, and the @tt{ needle_type}
relationship is inheritable.  This fragment indicates that any object
in the @tt{sutures class} has a @tt{ needle_type} relation to an
element (or elements) in the class @tt{needle_type_domain}.  It also
implies that any class @em{C} that is defined as a subclass of
@tt{Sutures} will inherit the @tt{ needle_type} relationship.  To see
this, note that the elements of @em{C} are a subset of the objets of
@tt{Sutures} so that if each element of @tt{Sutures} has a
needle_type, then every element of @em{C} must also.
@pred{relationship_ext/6} thus provides a simple but powerful
mechanism for inheritance in the OMS.  In addition, the above fragment
also indicates that @tt{relationship_ext/6} facts (as well as
@tt{subclass_ext/4} facts) can relate classes from different
ontologies.

Naive set theory distinguishes between sets and primitive elements.
In the OMS, elements of sets are called @em{objects}, which are
denoted via the @pred{object_ext/3} relation.  Objects are linked to
classes via the @pred{memberof_ext/4} relation, and in the OMS each
object must be linked to at least one class.  Thus a particular suture
may be denoted as 

@begin{verbatim} 
object_ext('SUTURE SET,NONABSORBABLE,SURGICAL',007689768,dla)
memberof_ext(0087689768,dla,Sutures,dla) 
@end{verbatim}

@noindent We say that an object @em{O} is of type or class @em{C1} if
there is a fact @em{memberof(O,C)} and @em{C} is a subclass of @em{C1}
(remember that a class is a subclass of itself, so that @em{O} will be
a subclass of @em{C}).  Also note in the example above, the name of
the object is given as the DLA item name code, so that many different
objects with different native ids may share the same name.

Analogously to @tt{relationship_ext/6}, each object can be linked to a
class via the @pred{attribute/3} relation 
@begin{verbatim} 
attribute_ext(87689768,dla,needle_type,my_ont,curved,my_ont)
@end{verbatim} 

@noindent or to another object via the @pred{attribute_object/3}
relation.  We will return to the effects of inheritance on these
predicates shortly, after describing two other types of relations.

Sets may have relations that do not hold for their members.  For
instance, a finite set may have a given cardinality, but its subsets
will have a different cardinality.  From a practical point of view,
such relations on sets are @em{non-inheritable}.  A practical example
of a non-inheritable relation comes from part matching.
@begin{verbatim}
strel(Sutures,dla,needle_type_weight,dla,integer(5),OMS).
@end{verbatim} 

@noindent This fragment indicates that the matching weight for the
@tt{needle_type} attribute for parts classified to @tt{Sutures} should
be @tt{5} (actually @tt{integeger(X)} is an OMS primitive type see
@ref{oms_init_oms (library)} for a further discussion).  Matching
weights are non-inheritable because a given classification of a part
may increase or decrease the weight.  For instance if a part were
classified as a non-absorbable cuticle suture, needle type might weigh
less (or more) for matching.  This practical example can be linked
back to set theory.  The @tt{needle_type_weight} is a relation on the
set @tt{Sutures}, and is irrelevant to the proper subset
@tt{Absorbable Sutures} of @tt{Sutures} @footnote{For this example, we
assume that @tt{Absorbable Sutures} is a proper subset of
@tt{Sutures}.}.

Finally, it is often very useful to be able to state @em{schema
relations} between sets.  To take a simple example, the class
@em{person} has a relation @em{brother} to the class of
@em{male_person}.  This doesn't mean that every person @em{has} a
brother, only that @em{if} a person has a brother, the brother is a
@em{male_person}.  The following fragment provides an
application-oriented example: 
@begin{verbatim}
schema_ext(dla_part,dla,newark_match,dla,newark_part,newark).
@end{verbatim} @noindent
This indiates that a given @em{dla_part} may have a @tt{newark_match}
to a given @tt{newark_part} -- but not necessarily.

With this discussion of relations in mind, we can turn back to a
fuller description of 
@tt{attribute/6} and @tt{attribute_object_ext/6}.  The fragment
@begin{verbatim} 
attribute_ext(87689768,dla, needle_type,my_ont,curved,my_ont),
@end{verbatim}  @noindent
mentioned above indicates that part @tt{87689768} has a
@tt{needle_type} that is in the class @tt{curved}.  There are several
points to observe about this.  First, @tt{curved} is a class, rather
than an object.  In the case of many types of attributes, such as
needle types, colors and so on, relating an object to a class is
sufficient as there is no need to distinguish objects within the
class.  It would be equally correct to state
@begin{verbatim} 
attribute_object_ext(87689768,dla,needle_type,my_ont,curved_object,my_ont),
@end{verbatim}  @noindent
if an object @tt{curved_object} were defined as an object and as a
member of the class @tt{curved}.  However, we believe that the use of
@pred{attribute_ext/6} is more intuitive in cases such as this where
the actual objects within a class do not matter.

Consider the effects of inheritance on @tt{attribute_ext/6} and
@tt{attribute_object_ext/6}.  In the case of @tt{needle_type}, the
definition of @tt{needle_type} on the class of @tt{Sutures} via a
@tt{relatioship_ext/6} predicate indicates that each object in this class
is related to @tt{needle_type_domain}.  Thus, if no stronger 
information were provided for, say, part @tt{0092424}, then the fact
@begin{verbatim} 
attribute_ext(0092424,dla, needle_type,my_ont,needle_type_domain,my_ont),
@end{verbatim}  @noindent
would be true in the OMS, and this can be seen as a primitive form of
``default'' reasoning that is provided by the OMS.  Indeed, the fact 
@begin{verbatim} 
attribute_ext(87689768,dla,needle_type,my_ont,needle_type_domain,my_ont), 
@end{verbatim}  @noindent
would also be true, but would be of less interest, since there is
specific information that @tt{87689768} is related to a subclass of
@tt{needle_type_domain}, namely @tt{curved}.

In contrast to the relation @tt{needle_type} the relation
@tt{newark_match} was defined via the @tt{schema_ext/6} predicate.  So
in this case no @tt{attribute_ext/6}, will be inferred, as accords
with intuition.  

All relations defined by the 3rd and 4th arguments of
@pred{relationship_ext/6}, @pred{strel_ext/6}, @pred{schrel_ext/6},
@pred{attribute_ext/6}, and @pred{attribute_object_ext/6} are classes
(e.g. @tt{needle_type}, @tt{needle_type_weight}, and
@tt{newark_match}.  Relations can be defined on these classes in
exactly the same manner as other classes.  For instance, an
@tt{AQL_level} could be defined for the class @tt{newark_match}
indicating the number of errors per hundred found in random samples.
Similarly, a relation @tt{unique} might be defined on @tt{needle_type}
indicating that any part could be related to one most specific
subclass of @tt{needle_type_domain}.  This last case suggests a
mechanism for extending the semantics of the OMS.  While the OMS would
not enforce the constraint of @tt{unique} itself, a type-checker would
be written in XSB to ensure that needle types were unique or for other
application-specific semantic constaints.

The above relation predicates allow the definition of named binary
relations between classes.  However, binary definitions can sometimes
be inconvenient to use.  For instance, in the matching weight example,
two parts may have a given match with a given weight that indicates
the strength of the match.  This could be defined by a series of
definitions 
@begin{verbatim}
schema_ext(dla_part,dla,newark_match_1,dla,newark_part,newark).  
:
schema_ext(dla_part,dla,newark_match_n,dla,newark_part,newark).
@end{verbatim} 
@noindent 
indicting that a given part has a newark
match of weight @em{1} through @em{n}.  However, defining matches in
this way is time-consuming and prone to errors.  To address this, the
OMS provides @em{parameterized classes}, as in the following fact
@begin{verbatim}
schema_ext(dla_part,dla,newark_match(integer(_)),dla,newark_part,newark).
@end{verbatim} @noindent which indicates that a @tt{dla_part} can have
a @tt{newark_match} with an integer weight to a @tt{newark_part}.  An
example of attribute information for this relation is:
@begin{verbatim}
attribute_object_ext(87689768,dla,newark_match(integer(9)),dla,58f1j,newark).
@end{verbatim} @noindent

There are other aspects to the OMS, including features that allow the
combination of ontologies, the efficient storage of ontologies in
databases, and further aspects of inheritance all of which are
discussed below.  In addition, we discuss in Section @ref{Builtin
Classes and Relationships} conventions that may be useful for default
reasoning.

@subsection{Comparisons with Other Systems}

The OMS has similarities to other systems for managing object-oriented
knowledge such as @em{Flora} (@uref{http://xsb.sourceforge.net}), RDF
(@uref{http://www.w3c.org/RDF/}), and Protege
(@uref{http://www.smi.stanford.edu/projects/protege}).  Indeed, the
connections between these systems are sometimes strong. There exists
translations between OMS and Protege (documented below) as well as
between OMS and RDF via Protege.  However the OMS differs from these
systems in its easy convertability between Prolog and database syntax.
In addition, the various semantic axioms of the OMS that have been
developed to allow it to handle partial information (@ref{Semantic
Axioms}) distinguishes it both from RDF and Protege.

While many of the ideas of the OMS were inspired by F-logic
@cite{KLW93} and FLORA, the OMS is simpler than FLORA in several
respects.  First, it does not allow information about taxonomies or
relations to be defined dynamically by rules.  Second, the OMS does
not provide for a constraint that a given attribute is unique or
functional.  And third, the OMS does not provide for non-monotonic
inheritance, but substitutes a the monotonic inheritance of @tt{
relationship_ext} facts for default reasoning.  These differences are
the results of design decisions intended to make the OMS more
efficient, and easier to use in commercial systems.

@section{Views and Formats of the OMS}

There are several views and formats of the OMS -- a Programmer's View,
a Query View, an Internal Format, an External Format, and an External
Intensional Format.  The @index{Programmer's View} should be used by
application programs that interface tightly with the OMS.  This view
uses generated keys for classes and objects; it supports inheritance
of relations among subclasses and objects; and defines
@pred{subclass/2} and @pred{memberof/2} relations as reflexive and
transitive.  More loosely coupled systems, and human users can use a
Query View for the OMS which has the same semantics as the
Programmer's View in terms of inheritance and transitivity of the
hierarchical predicates but classes and objects are queried via pairs
of native ids and sources along the lines of the examples of @ref{A
Quick Tour of the OMS}.

Underlying both of these views are different formats in which OMS
information can be kept.  The @index{Internal Format} is an
extensional database of OMS facts that use generate keys of objects
and classes.  The @index{External Format} of the OMS, does not make
use of generated keys is also defined.  The external format provides a
means of representing the extensional database of OMS facts in
human-readable format, using native ids and sources.  It was this
format that was represented in the examples of @ref{A Quick Tour of
the OMS}.  Finally, the @index{External Intensional Format} provides a
mechanism for the OMS to dynamically access and intern ontology data
that is not in an OMS format -- for example, data that is kept in an
extenal database.  These views and formats are discussed below with
the exception of the Query View, which is discussed in
@ref{oms_queries (library)}.

@subsection{OMS: External Format}

The External Format is used when creating an ontology by hand and can
be a means of porting another ontology into the OMS Internal Format.
As a simple example, let us consider some classes taken from the file
@tt{oms/test/ext4.P} @footnote{currently this test file is uses
abstract classes.  In a future version of the documentation, I'll
create more meaningful names.}.  @tt{ext4.P} contains class
definitions that include the following classes.

@begin{verbatim}
class_ext('OMS Root','OMS Root','OMS').
class_ext('OMS Inheritable Relationships',
          'OMS Inheritable Relationships','OMS').
class_ext('OMS Set-Valued Relations','OMS Set-Valued Relations','OMS').
class_ext('OMS Schema Relations','OMS Schema Relations','OMS').
class_ext('OMS Relations','OMS Relations','OMS').
class_ext('Descriptions','Descriptions','OMS').

class_ext(myownname,c1,test).
class_ext(c2,c2,test).
class_ext(c3,c3,test).
class_ext(c11,c11,test).
class_ext(c12,c12,test).
class_ext(c13,c13,test).

class_ext(r3,r3,test).

class_ext(myf,f(c2,test,g(integer(1),'OMS',c12,test),test),test).
@end{verbatim}

@noindent These class definitions state that @tt{myownname}, say, is
the name of a class, whose native id is @tt{c1} and whose source
ontology is @tt{test}.  Classes with the source @tt{OMS} are built
into the OMS and are present for every ontology -- see
@ref{oms_init_oms (library)} for the descriptions of such classes.
They need not be defined in a file in External Format, however we
include them in this example for expository purposes.

The final term defines a parameterized class.  The native od of this
class has an @em{outer functor} of @tt{f}, and two @em{arguments}, the
first of which has native id @tt{c2} and source ontology @tt{test},
and the second of which is another parameterized class whose outer
functor is @tt{g} whose source ontology is also @tt{test}.  The
parameterized class @tt{f} is thus a combination of two classes each
of which are identified by a native id and a source ontology.  Because
it is a combination of two classes and will appear that way once the
external form is loaded into the OMS, this parameterized class is
referred to as @tt{f/2}, rather than as @tt{f/4} as it appears in the
external form.  Similarly, the parametrized class @tt{g} is referred
to as @tt{g/2} Note that the first argument of @tt{g/2} is
@tt{integer(1)}, whose source is @tt{OMS}.  While this class has the
syntax of a parameterized class, it is in fact an @em{OMS primitive
class}.  OMS primitive classes allow the user to use useful
programming types --- integers, floats, atoms, and so on --- without
having to explicitly define a separate class for each integer, say.
OMS primitive types are further discussed in @ref{???}.  As with
@tt{integer(1)}, all OMS primitive types have @tt{OMS} as their source
ontology.  The class hierarchy is defined as:

@begin{verbatim}
subclass_ext('OMS Inheritable Relationships','OMS','OMS Relations',OMS).
subclass_ext('OMS Set-Valued Relations','OMS','OMS Relations',OMS).
subclass_ext('OMS Schema Relations','OMS','OMS Relations',OMS).
subclass_ext('OMS Relations','OMS','OMS Root','OMS').
subclass_ext('Descriptions','OMS','OMS Set-Valued Relations','OMS').

subclass_ext(c1,test,c2,test).
subclass_ext(c2,test,c3,test).
subclass_ext(c3,test,'OMS Root','OMS').

subclass_ext(c11,test,c12,test).
subclass_ext(c12,test,c13,test).
subclass_ext(c13,test,'OMS Root','OMS').

subclass_ext(r1,test,r2,test).
subclass_ext(r2,test,'OMS Inheritable Relationships','OMS').
subclass_ext(r3,test,'OMS Schema Relations','OMS').

subclass_ext(f(c2,test,g(integer(1),'OMS',c11,test),test),test,c2,test).
@end{verbatim}

@noindent These subclass definitions denote the hierarchy of the
ontology.  Note that in the External Format, classes are @em{always}
referenced by the native id and the source ontology.  Also note that
@tt{r2}, while being a perfectly good class, can also be used to
define inheritable relationships, since it is a subclass of @tt{OMS
Inheritable Relationships}.  Similarly, @tt{r3} can be used to define
schema relations @footnote{For historical purposes, the term
'relationship' is used to denote relations that are inheritable, while
'relations' is used to denote relations that may or may not be
inheritable.}.

The final term defines
@tt{f(c2,test,g(integer(1),'OMS',c12,test),test)} with source ontology
@tt{test} as a subclass of @tt{c2} with source ontology @tt{test}.
For implementation reasons, parameterized classes can only be defined
as leaves of the hierarchy via explicit @pred{subclass_ext/4} (or
@pred{subclass/2} definitions).  However, parameterized classes have a
rich @em{implicit} hierarchy.  A parameterized class @em{C1} is a
subclass of a parameternized class @em{C2} if @em{C1} and @em{C2} both
have the same outer functor and each of the arguments of @em{C1} is a
subclass of each of the arguments of @em{C2}.  As an example

@begin{verbatim}
@tt{f(c1,test,g(integer(1),'OMS',c22,test),test)} + test
@end{verbatim}
is a subclass of 
@begin{verbatim}
@tt{f(c2,test,g(integer(1),'OMS',c22,test),test)} + test
@end{verbatim}

@noindent since @tt{c1} is a subclass @tt{c2}, but not of 

@begin{verbatim}
@tt{f(c2,test,g(integer(1),'OMS',c22,test),test)} + test
@end{verbatim}

@noindent since @tt{c12} is a subclass @tt{c22} @footnote{In a precise
sense, a parameterized class can be seen as a @em{product} of its
arguments, and behaves that way in terms of inheritance.}.  Thus the
hierarchy of atomic classes reflects through parameterized classes,
and the inheritance structure for any ontology can roughly be seen as
consisting of a DAG, whose leaves may or may not be parameterized
classes, but whose internal nodes are atomic.

The next conceptual part of the ontology are the relations, which include

@begin{verbatim}
relationship_ext(c2,test,r2,test,c12,test).
relationship_ext(f(c2,test,g(integer(1),'OMS',c11,test),test),test,
                 r1,test,c1,test).
@end{verbatim}

@noindent The first simply defines an @tt{r2} relationship in which
@tt{c2} is the source and @tt{c12} the target.  In the second @tt{r1}
is a specialization of the @tt{r2} relation since @tt{r1} is a
subclass of @tt{r2}.  There is a further subtle point illustrated in
the use of the parameterized class in the relation definition.
@tt{f(c2,test,g(integer(1),'OMS',c11,test),test) + test} is
(implicitly) a subclass of
@tt{f(c2,test,g(integer(1),'OMS',c12,test),test) + test}.  This means
that a subclass of @tt{f(c2,test,g(integer(1),'OMS',c12,test),test) +
test} relations have an @tt{r1} relation defined for them, but all do
not.  While this is somewhat abstract given this example, it is
important in that once parameterized classes are put into a class
hierarchy, the subclasses implicit in the parameterized class can be
used freely throughout the rest of the ontology definition.

Set-valued and schema relations are defined anagously:

@begin{verbatim}
strel_ext(c1,test,'Descriptions','OMS',atom('a description'),'OMS').

schrel_ext(c1,test,r2,test,c12,test).
@end{verbatim}
Note the use of the primitive type @pred{atom/1} in the set-valued
relation.

The above predicates, @pred{class_ext/3}, @pred{subclass_ext/4},
@pred{relationship_ext/6}, @pred{strel_ext/6}, @pred{schrel_ext/6},
are collectively termed the @em{schema} for an ontology (in external
form).  Analagous to the schema of an ontology is the data, consisting
of predicates @pred{object_ext/3}, @pred{memberof_ext/4},
@pred{attribute_ext/6}, and @pred{attribute_object_ext/6}.  Let us
begin with definitions of objects.

@begin{verbatim}
object_ext(o1,o1,test).
object_ext(o2,o2,test).
object_ext(o3,o3,test).
object_ext(o11,o11,test).
object_ext(of,of,test).
@end{verbatim}

@noindent Definitions of objects are analgous to those for classes, in
that objects have a name, a native id and a source ontology, and the
native id plus source uniquely determines the object.  However at
present all native ids for classes must have atomic names, unlike
those for classes which specify a parameterized class (or subclass).
Each object must be defined to be a member of at least one class, as
in the following statements.

@begin{verbatim}
memberof_ext(o1,test,c1,test).
memberof_ext(o2,test,c2,test).
memberof_ext(o3,test,c3,test).
memberof_ext(o11,test,c11,test).

memberof_ext(of,test,f(c2,test,g(integer(1),'OMS',c11,test),test),test).
@end{verbatim}

@noindent The first two arguments of @pred{memberof_ext/4} are the
native id of an object and its source; the second two are the native
id of a class and its source.  The final term shows that it is allowed
for an object to be member of a parameterized class.  

Finally, the external form defines some attributes for objects.

@begin{verbatim}
attribute_ext(o2,test,r2,test,c12,test).

attribute_object_ext(o2,test,r2,test,o12,test).
@end{verbatim}

The predicates @pred{attribute_ext/6} and
@pred{attribute_object_ext/6} are similar except that the target of
@pred{attribute_object_ext/6} must be an object, rather than a class
as with @pred{attribute_ext/6}.

@noindent Routines for loading data in External Format into an OMS and
dumping an OMS to a file in External Format are described in
@ref{oms_io (library)}.  The schema for the External Format is
summarized below.  All relations in the External Format are
extensional -- inheritance and transitivity is executed only after
they are translated back to the Internal Format by routines in
@ref{oms_io (library)}.

In the external form, class names, object names, object native ids,
and all sources must be atomic.

@begin{itemize} 

@item @tt{class_ext(Name,NativeId,Source)} (@pred{class_ext/3}):
@tt{Name} is the name of a class, @tt{Nativeid} its (possibly
parameterized) native id, and @tt{Source} its source.

@item @tt{subclass_ext(SubNId,SubSrc,SupNId,SupSrc)}
(@pred{subclass_ext/4}) denotes that one class is a subclass of
another.  @tt{SubNId} and @tt{SubSrc} are the native id and source of
the subclass; and @tt{SupNId} and @tt{SupSrc} are the native id and
source of the superclass.

@item
@tt{relationship_ext(NId_from,Src_from,NId_rel,Src_rel,NId_to,Src_to)}
(@pred{relationship_ext/6}) is the external form of an inheritable
relationship.  Native ids and sources are used in the usual manner.

@item
@tt{strel_ext(NId_from,Src_from,NId_rel,Src_rel,NId_to,Src_to)}
(@pred{strel_ext/6}) is the external form of a (non-inheritable)
set-valued relation.

@item
@tt{schrel_ext(NId_from,Src_from,NId_rel,Src_rel,NId_to,Src_to)}
(@pred{schrel_ext/6}) is the external form of an schema relationship.

@item @tt{object_ext(Name,Native_id,Src)} (@pred{object_ext/3})
denotes an object with given name, native id, and source.

@item @tt{memberof_ext(ObjNid,ObjSrc,ClassNid,ClassSrc)}
(@pred{memberof_ext/4}) declares the object specified by @tt{ObjNid +
ObjSrc} to be a member of the class specified by @tt{ClassNid +
ClassSrc}.

@item
@tt{attribute_ext(ObjNid,ObjSrc,RelNid,RelSrc,ClassNid,ClassSrc)}
(@pred{attribute_ext/6}) defines an attribute of an object, using
object and class native ids and sources.

@item
@tt{attribute_object_ext(ObjNid,ObjSrc,RelNid,RelSrc,Obj2Nid,Obj2Src)}
(@pred{attribute_object_ext/6}) defines an attribute of an object,
when the target of the object is another object, rather than a class
as in @pred{attribute_ext/6}.

@end{itemize}

@subsection{Programmer's View of the OMS}

The Programmer's View of the OMS is the one that tightly coupled
applications actually use.  To create a Programmer's View of the
previously-discussed ontology in @tt{ext4.P}, the OMS may be consulted
into XSB and the external form loaded by a predicate such as
@pred{load_mergeomsext/1}.  For expository purposes we discuss aspects
of the Programmer's View of the OMS by means of the XSB command
prompt.  Various applications of the OMS may communicate through the
Java interface to XSB, through an ontology editor, or in a number of
other ways.  If we make the query:

@begin{verbatim}
| ?- class(Cid,myownname,Nid,Src).

Cid = 17
Nid = c1
Src = test

yes
@end{verbatim}

We see that a class defined in our External Format has in fact been
loaded into the OMS.  However rather than having three arguments as
with @pred{class_ext/3}, the predicate @pred{class/4} has four
arguments: the original three plus @tt{17}, which unified with the
variable @tt{Cid}.  This new argument is a @em{class id}, and is
uniquely generated for each class that is loaded into the OMS.
Similarly, if we make the query

@begin{verbatim}
| ?- object(Oid,OName,ONid,OSrc).
@end{verbatim}

@noindent we get back the bindings

@begin{verbatim}
Oid = 1
OName = o1
ONid = o1
OSrc = test
@end{verbatim}

and infact, can backtrack through all other bindings for the goal
object, if we wish.  In a similar manner to class, there is a new
@em{Object Id} argument that is uniquely generated for each object
loaded into the OMS.  Now, what happens if we use the object
identifier @tt{1} where a class should be?  

@begin{verbatim}
| ?- class(1,Name,Nid,Src).
@end{verbatim}

@noindent gives back the bindings

@begin{verbatim}
Name = OMS Root
ONid = OMS Root
OSrc = OMS
@end{verbatim}

Illustrating the point that class ids and object ids are generated
separately.  Class ids are generated for parameterized classes based
on class ids for atomic classes.

@begin{verbatim}
| ?- class(Id,myf,Nid,Src).

Id = f(18,g(integer(1),21))
Nid = f(c2,test,g(integer(1),OMS,c12,test),test)
Src = test
@end{verbatim}

In loading this class, the class @tt{c2 + test} is translated to its
class id, @tt{18}, and a similar translation is done for @tt{c12 +
test}.  Hoever, note that no translation is done for outer functors of
parameterized classes or for primitive classes: @tt{integer(1)} has
the same form in the class id as in the native id.  At this point it
is easier to see why the OMS maintains clothes all integers in the
form @tt{integer/1}: without this clothing the integer @tt{1} would be
seen as the class id for @tt{OMS Root}!

In the Programmer's View, native ids and sources are not found in OMS
predicates other than @pred{class/4} and @pred{object/4}.  For
instance, if we make the following query to @pred{subclass/2}

@begin{verbatim}
| ?- subclass(f(18,g(integer(1),21)),Cid),class(Cid,Name,Nid,Src).
@end{verbatim}

@noindent we get back a series of bindings to all classes to which
this parameterized class belongs.  The first set of bindings is 

@begin{verbatim}
Cid = f(18,g(integer(1),21))
Name = myf
Nid = f(c2,test,g(integer(1),OMS,c12,test),test)
Src = test;
@end{verbatim}

@noindent reflecting the fact that the @pred{subclass/2} is
reflexive.  Further backtracking gives 

@begin{verbatim}
Cid = 18
Name = c2
Nid = c2
Src = test;
@end{verbatim}

@noindent as well as other subclasses to which
@tt{f(18,g(integer(1),21))} transtively belongs, up to @tt{OMS Root}
@footnote{Because @pred{subclass/2} does not use tabling, superclasses
or subclasses may be repeated when backtracking through a query to
@pred{subclass/2}.}.

In addition to providing transitivity for @pred{subclass/2}, the
Programmer's View also supports inheritance for relationships and
schrels.  Recall that the external form contained the fact

@begin{verbatim}
relationship_ext(c2,test,r2,test,c12,test).
@end{verbatim}

This relationship is, of course, supported in the Programmer's View,
and can be accessed by translating into the appropriate class ids.  In
addition, since @tt{c1 + test} is a subclass of @tt{c2 + test} calling
making a call to @tt{relationship/3} shows that there is also an
@tt{r2 + test} relation from @tt{c1 + test} to @tt{c12 + test},
indicating that relational inheritance is transparently supported for
the user.

Further examination of the Programmer's View shows that inheritance is
propagated to attribute information.  For instance, it can be seen
that there is an @tt{r2 + test} attribute for @tt{o1 + test}, by
calling @pred{attribute/3} with the appropriate class and object ids.



In the Programmer's View, OMS predicates have the following form
(described further in in @ref{oms_init_oms (library)}).
@begin{itemize}

@item @tt{class(CID,Name,NativeID,Source)} (@pred{class/4}: where
@tt{CID} is a class ID, @tt{Name} is the name of the Class (an atom),
@tt{NativeID} is a user ID for the node, and @tt{Source} is an atom
that identifies the source ontology of this class.

@item @tt{subclass(SubCID,SupCID)} (@pred{subclass/2}): where
@tt{SubCID} is the class id of a class that is a sub-class of the
class @tt{SupCID}.  @em{TLS explain a bit further about how exactly
subclassing works with parameterized classes}.

@item @tt{relationship(SCID,RelCID,TCID)} (@pred{relationship/3}): is
an inheritable relation where @tt{SCID}, @tt{RelCID} and @tt{TCID} are
class ids, indicating a source class, a relation class and a target
class, respectively.  @tt{RelCID} must be a descendent of the @em{OMS
Inheritable Relationships} class (this is ensured OMS routines that
create new relations).  This predicate specifies monotonic
inheritance: that each object that is a subclass of @tt{SCID} must
have a @tt{RelCID} attribute of type (i.e. a subclass of) @tt{TCID}
(the precise semantics is described in @ref{Semantic Axioms}).

@item @tt{strel(SCID,RelCID,TCID)} (@pred{strel/3}): where @tt{SCID},
@tt{RelCID} and @tt{TCID} are class IDs, indicating a source class, a
relation class and a target class, respectively.  This predicate
designates non-inheritable relationships.

@item @tt{schrel(SCID,RelCID,TCID)} (@pred{schrel/3}): where
@tt{SCID}, @tt{RelCID} and @tt{TCID} are class IDs, indicating a
source class, a relation class and a target class, respectively.  This
predicate designates the type of that an attribute must have: i.e. if
an object is of type @tt{SCID} then any attribute of that object whose
relation part is a subclass of @tt{RelCID} must have a target that is
a subclass of @tt{TCID}; and any attribute_object of that object whose
relation part is a subclass of @tt{RelCID} must have a target that is
a memberof @tt{TCID}.  See @ref{Semantic Axioms} for more details.

@item @tt{object(OID,Name,NativeID,Source)} (@pred{object/4}): where
@tt{OID} is an internally-generated integer ID for this Object;
@tt{Name} is the name of this object; @tt{NativeID} is a user ID for
this object; and @tt{Source} is the source ontology.

@item @tt{memberof(OID,CID)} (@pred{memberof/2}): where OID is the
object ID of an object that is an element of the class CID.

@item @tt{attribute(OID,RelCID,TCID)} (@pred{attribute/3}): indicates
that the relational class @tt{RelCID} maps the object @tt{OID} to the
class @tt{TCID}.  For this to be valid, there must be a tuple in
relationship indicating that this is correctly typed.

@item @tt{attribute_object(OID,RelCID,TOID)}
(@pred{attribute_object/3}): indicates that the relational class
@tt{RelCID} maps the object @tt{OID} to the object @tt{TOID}.  For
this to be valid, there must be a tuple in relationship indicating
that this is correctly typed.  @end{itemize}

@subsection{Semantic Axioms}

@em{TLS: certain details of the formzliation for this section need to
be revised and / or simplified.}

There are a number of axioms implicit in the OMS.  Understanding these
constraints can be useful in developing certain applications as well
as in understanding the External Format of the OMS.  Many of these
relate to the typing of the Intensional Format and are straightforward
from the previous section.  For brevity, the term @em{cid(C)} stands
for the open fomula @begin{itemize}

@item @em{(exists Name) (exists N_id) (exists Ont).class(C,Name,N_id,Ont)} @end{itemize} while @em{oid(O)} stands
for the open formula @begin{itemize} @item @em{(exists Name) (exists
N_id) .object(0,Name,N_id)}.  @end{itemize} In addition, the
quantifier @em{exists_one} means @em{there exists a unique}.

@subsection{Axioms}

Every correct instance of the OMS must statisfy the following axioms.

@begin{enumerate}
@item Domain definitions
@begin{enumerate}
@item @em{d1}: Domain defintion for subclass.

(all X)(all Y) (subclass(X,Y) => (cid(X) and cid(Y))

@item @em{d2}: Domain defintion for relationship

(all X)(all Y)(all Z) (relationship(X,Y,Z) => (cid(X) and cid(Y) and cid(Z))

@item @em{d3}: Domain defintion for set_relationship

(all X)(all Y)(all Z) (set_relationship(X,Y,Z) => (cid(X) and cid(Y) and cid(Z))

@item @em{d4}: Domain defintion for schema

(all X)(all Y)(all Z) (schema(X,Y,Z) => (cid(X) and cid(Y) and cid(Z))

@item @em{d5}: Independence of Cids and Oids

(not exists X) cid(X) and oid(X)

@item @em{d6}: Domain definition for memberof

(all X)(all Y) (memberof(X,Y) => (oid(X) and cid(Y))

@item @em{d7}: Domain defintion for attribute

(all X)(all Y)(all Z) (attribute(X,Y,Z) => (oid(X) and cid(Y) and cid(Z))

@item @em{d8}: Domain defintion for attribute_object

(all X)(all Y)(all Z) (attribute_object(X,Y,Z) => (oid(X) and cid(Y) and oid(Z))
@end{enumerate}

@item Subclass axioms

@begin{enumerate}
@item @em{c1}: Existence of a root concept.

(exists X) cid(X) and concept(X,'OMS Root','OMS Root',oms)

@item @em{c2}: Reflexivity of subclass

(all X) subclass(X,X)

@item @em{c3}: Weak anti-symmetry of subclass

(all X)(all Y) (subclass(X,Y) and subclass(Y,X)) => X = Y

@item @em{c4}: Transitivity of subclass

(all X)(all Y)(all Z) (subclass(X,Y) and subclass(Y,Z)) => subclass(X,Z)

@item @em{c5}: Rootedness and connectedness of subclass

(all X) (cid(X) => (subclass(X,Y) and cid(Y) and concept(Y,'OMS
					Root','OMS Root',oms)) 

@item @em{m6}: Existence of memberof for each object

(all X) (oid(X) => ((exists Y) memberof(X,Y)

@item @em{m7}: Propagation of subclass through memberof

(all X)(all Y)(all Z) (memberof(X,Y) and subclass(Y,Z)) => memberof(X,Z)
@end{enumerate}

@item Relationship Axioms
@begin{enumerate}
@item @em{r1}: Existence of a root class for OMS relationships

(exists X) concept(X,'OMS Relationships','OMS Relationships',oms)

@item @em{r2}:  All relations are subclasses of 'OMS Relationships'

(all X)(all Y)(all Z) (relationship(X,Y,Z) or set_relationship(X,Y,Z)
or schema(X,Y,Z)) => (subclass(Y,W) and concept(Y,'OMS Relationships','OMS Relationships',oms))
@end{enumerate}

@item Inheritance Axioms
@begin{enumerate}
@item @em{i1}: Source inheritance propagation to classes for relationship

(all X)(all Y)(all Z) (relationship(X,Y,Z) and subclass(W,X)) =>
relationship(W,Y,Z) 

@item @em{i2}: Source inheritance propagation to classes for schema

(all X)(all Y)(all Z) (schema(X,Y,Z) and subclass(W,X)) => schema(W,Y,Z) 

@item @em{i3}: Relation inheritance propagation to classes for relationship

(all X)(all Y)(all Z) (relationship(X,Y,Z) and subclass(W,Y)) =>
relationship(X,W,Z) 

@item @em{i4}: relation inheritance propagation to classes for schema

(all X)(all Y)(all Z) (schema(X,Y,Z) and subclass(W,Y)) => schema(X,W,Z) 

@item @em{i5}: target inheritance propagation to classes for relationship

(all X)(all Y)(all Z) (relationship(X,Y,Z) and subclass(Z,W)) =>
relationship(X,Y,W)  

@item @em{i6}: source inheritance propagation to objects for relationship

(all X)(all Y)(all Z) (relationship(X,Y,Z) and memberof(O,X)) =>
attribute(O,Y,W)   

@item @em{i7}: source constraint propagation to objects for attribute

(all X)(all Y)(all Z) (schema(X,Y,Z) and memberof(O,X) and
attribute(X,Y',Z')) => subclass(Z,Z') 

@item @em{i8}: source constraint propagation to objects for attribute_object

(all X)(all Y)(all Z) (schema(X,Y,Z) and memberof(O,X) and
attribute_object(X,Y',Z')) => memberof(Z',Z)

@end{enumerate}
@end{enumerate}

We discuss these axioms briefly.  The domain axioms simply state the
when a concept id is expected as an argument of one or another OMS
predicate, and when an object id is expected.  The subclass axioms are
standard for subclass relationships, while @em{m6} and @em{m7} are
standard for object logics that distinguish between objects and
classes.  The relationship axioms simply state that relationship names
form a particular subclass of objects.  Finally, the inheritance
axioms formalize inheritance and show clearly that the difference
between the meaning of @pred{schrel/3} and @pred{relationship/3}
predicates is on how they act on objects.  @pred{relationship/3}
predicates imply the existence of a corresponding attribute for a
objects in a class, while @pred{schrel/3} predicates constrain the
types.  Consider the OMS pseudo-code, where class and object names
stand for their ids:

@begin{itemize} 
@item relationship(part,primary_material,material)
@end{itemize} 
which states that each part must have a primary material that is a
subclass of some ontology node 'material'.  Then this means that the
fact 
@begin{itemize} 
@item attribute(Obj,primary_material,material)
@end{itemize} 
will always hold if memberof(Obj,part) holds.  In traditional
extensional databases, a closed world assumption holds where a fact is
held to be false if it is not contained extensionally within the
database.  In the OMS an attribute value can be inferred for an object
merely via the schema information.

@subsection{OMS: Internal Format} The Internal Format of the OMS
consists of raw facts upon which the Programmer's View is based.  It
does not include relationships or attributes derived via inheritance
or transitive subclass or memberof relations.  Users will rarely have
to work directly with this level.  We include a brief description for
completeness and because the predicates in internal form are are
loaded and dumped to files via the predicates @pred{load_oms/1} and
@pred{dump_oms/1}.

The following predicates comprise the Internal Format.  Some of these
predicates and their initialization are discussed in @ref{oms_init_oms
(library)}.

@begin{itemize}

@item @tt{oms_cn(CID,Name,NativeID,Source)} (@pred{oms_cn/4}).
Internal form of @pred{class/4}, where @tt{CID} is an internally
generated class ID (an integer), @tt{Name} is the name of the Class
(an atom), @tt{NativeID} is a user ID for the node (an atom), and
@tt{Source} is an atom that identifies the source of this class.  

@item @tt{oms_sc(SubCID,SupCID)}: (@pred{oms_sc/2}).  Internal form of
a @pred{subclass/2} where SubCID is the CID of a class that is an
immediate sub-class of the class SupCID.

@item @tt{oms_rln(SCID,RelCID,TCID)}: (@pred{oms_rln/3}).  Internal
form of @pred{relationship/3}, where SCID, RelCID and TCID are class
IDs, indicating a source class, a relation class and a target class,
respectively.  RelCID must be a descendent of the @index{OMS
Inheritable Relationships} class.

@item @tt{oms_strel(SCID,RelCID,TCID)}: (@pred{oms_strel/3}).
Internal form of @pred{strel/3}, where SCID, RelCID and TCID are
class IDs, indicating a source class, a relation class and a target
class, respectively.  RelCID must be a descendent of the @index{OMS
Set-Valued Relations} class.

@item @tt{oms_schrel(SCID,RelCID,TCID)}: (@pred{oms_schrel/3}).
Internal form of @pred{schrel/3}, where SCID, RelCID and TCID are
class IDs, indicating a source class, a relation class and a target
class, respectively.  RelCID must be a descendent of the @index{OMS
Schema Relationships} class.

@item @tt{OMS_obj(OID,Name,NativeID,Source)}: (@pred{oms_obj/4}).
Internal form of @pred{object/4}, where OID is an internally-generated
integer ID for this Object; Name is the name of this object, NativeID
is a native ID for this object, and Source is its source ontology.

@item @tt{OMS_mo(OID,CID)} (@pred{oms_mo/2}).  Internal form of the
@pred{memberof/2} where OID is the object ID of an object that is
contained in the class CID.

@item @tt{OMS_at(OID,RelCID,TCID)}: (@pred{oms_at/3}).  Internal form of
the @pred{attribute/3}, and indicates that (every relation in) the
relational class RelCID maps the object OID to the class TCID.
That is that RelCID maps OID to some object in TCID.  

@item @tt{oms_ao(OID,RelCID,TOID)}: (@pred{oms_ao/3}).  Internal form of
the @pred{attribute_object/3} relation, and indicates that the
relational class RelCID maps the object OID to the object TOID.  
@end{itemize}

@subsection{OMS: External Intensional Format} The final view of the
OMS allows users to define a Programmer's View via predicates.  To see
the advantage of using the External Intensional Format, consider a
concrete example that uses approved item names.  In Prolog, an
approved item name fact consists of an Item Name Code, the FIIG to
which the Item Name Code belongs, the Item Name itself, and a
description:

@begin{verbatim}
item_name('00001','A516K0','ELECTRON TUBE','An inclosure, including
two or more electrodes, in which a flow of electrons may occur through
a vacuum or a contained gas. The electronic conduction takes place
either by means of electrons emitted from a cathode or by ionization
of the contained gas. Includes phototubes (photoemissive type only),
Geiger-Mueller tubes, traveling wave tubes, cathode ray tubes and
microwave tubes (Klystron, magnetron, or the like). Excludes items
whose primary purpose is to produce light energy. Also excludes
PHOTOELECTRIC CELL; and SEMICONDUCTOR DEVICE (as modified).'). 
@end{verbatim}

If we wish to include item name facts in our ontology, we might
translate the above fact as follows.

@begin{verbatim}
class_ext('ELECTRON TUBE','OOOO1',fiig).

subclass_ext('OOOO1',fiig,'A516K0',fiig).

strel('OOOO1',fiig,'Descriptions','OMS',atom(''An inclosure, including
  two or more electrodes, in which a flow of electrons may occur
  through a vacuum or a contained gas. The electronic conduction takes
  place either by means of electrons emitted from a cathode or by
  ionization of the contained gas. Includes phototubes (photoemissive
  type only), Geiger-Mueller tubes, traveling wave tubes, cathode ray
  tubes and microwave tubes (Klystron, magnetron, or the like). Excludes
  items whose primary purpose is to produce light energy. Also excludes
  PHOTOELECTRIC CELL; and SEMICONDUCTOR DEVICE (as modified).')).
@end{verbatim}

To translate all such approved item names into the OMS wouldn't be
hard.  We'd start by mapping the item_name predicate to OMS predicates
as follows.  

@begin{verbatim}
class_ext(Name,Nid,fiig):- item_name(Nid,_,Name,_).

subclass_ext(Nid,fiig,Fiig,fiig):- item_name(Nid,Fiig_,_).

strel_ext(Nid,fiig,'Descriptions','OMS',atom(Descr),'OMS):- 
	item_name(Nid,_,_,Descr).
@end{verbatim}

The programmer might then write scripts so that a file of item_name
facts could then be transformed into OMS external form.  Such an
approach is fairly simple and is often done successfully.  However,
this approach does have disadvantages.  First, if item name
information is maintained outside of the OMS (as it is by DLA) then
whenever information about item names changes, the transformation
scripts must be rerun.  Second, if the item name information is kept
in a database the DBMS resident information must be exported from the
DBMS and transformed into external form @footnote{The DBMS interface
to the OMS has been implemented, but is not yet fully supported}.

The OMS external intensional format allows a user to define views of
the data which are used automatically by the OMS.  For instance a view
of item name information might look like:

@begin{verbatim}
class_int(Name,Nid,fiig):- item_name(Nid,_,Name,_).

subclass_int(Nid,fiig,Fiig,fiig):- item_name(Nid,Fiig_,_).

strel_int(Nid,fiig,'Descriptions','OMS',atom(Descr),'OMS):- 
	item_name(Nid,_,_,Descr).
@end{verbatim}

@noindent If these rules are dynamically loaded into memory, along
with @tt{item_name/4} then a query

@begin{verbatim}
class(Id,Name,Nid,Src)
@end{verbatim}

@noindent will check not only the @pred{oms_cn/4} facts that may have
been created from information external form but also will call
@pred{class_int/3} rules.  Similarly, a query: 

@begin{verbatim}
subclass(ChildCid,ParentCid)
@end{verbatim}

@noindent will check @pred{oms_sc/2} rules, and also will translate
the class ids of the query to native ids and sources and check
@pred{subclass_int/4} rules, and translate the native ids and sources
back to class ids when necessary. 

For each @em{xxx}@tt{_ext/n} predicate, there is a corresponding
@em{xxx}@tt{_int/n} predicate, and all views support a free
intermixture of external intensional and explicitly loaded classes and
/ or objects.  Even parameterized classes can be built using a mixture
of intensional and explicitly loaded classes @footnote{Hopefully I've
gotten all --- or at least most of --- the bugs out by now.}.

As a final point, the OMS does not directly support assertion or
deletion of information in the External Intensional Format.  As a
result if intensional data is to be modified by, say, an XJ-based GUI,
cache-coherency cannot be guarenteed.

@subsection{Views on the Different Views}

To summarize, users may load an OMS from the external form and dump
information in external form to a file.  Alternatively, users may
define external intensional predicates to access dynamically loaded
data in non-OMS format, and eventually to access data from databases.
As another alternative, once an OMS is created the internal form may
be dumped to and loaded from files (say, by the predicates
@pred{load_oms/1} and @pred{dump_oms/1}.  No matter how the
information is loaded it is used by the predicates of the Programmer's
View, either directly in the case of information in Internal Format;
by translation from External Format into Internal Format (by,
e.g. @pred{load_mergeomsext/1}); or by calling intensional rules.

Which format should an application use to load and save OMS data?  The
answer, of course, depends on the needs and size of an application.
Data in Internal Format is fastest to save and load, but the saved
data can be difficult to read, and impossible (or at least really
difficult) to modify outside of the OMS.  Data in External Format is
easier to create and view from an editor, but is slower to load.
Finally, external intensional data may be fast to load, but execution
of user-level queries is somewhat slower than data based on Internal
Format, as translations need to be made form concept and object ids to
native ids and sources and intensional rules need to be executed.

").

main.

