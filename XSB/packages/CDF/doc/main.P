:- compiler_options([ciao_directives]).

:- comment(title,"CDF: Cold Dead Fish").
:- comment(subtitle,"An Ontology Management System (OMS)").

:- comment(author,"Terrance Swift, David S. Warren").
:- comment(author,"with help from Joseph Gartner, Tanya Vidrevich").

:- comment(copyright,"Copyright XSB, Inc; Medicine Rules, Inc, 2001.
This document produced via the XSBDOC system.").

:- comment(summary,"@include{README.cdf}").

:- comment(module,"

Two leading paradigms for formal knowledge representation are
ontologies and logic programming.  Both formalisms have a clear,
logic-based semantics.  Ontologies have advantages in that the
knowledge they represent is easily visualizable.  In addition, if an
ontology is based on a description logic, important problems in
consistency and ontology construction are decidable and can be
performed by deduction engines.  In terms of knowledge representation,
logic programming has advantages in its extensions to incorporate
non-monotonic and constraint-based reasoning.  In addition the
procedurality of logic programming complements an the deduction engine
of an ontology.

@em{Cold Dead Fish (CDF)} provides an experimental platform to combine
logic programming with ontology management @footnote{Historically,
Cold Dead Fish was called the Ontology Management System (OMS) and in
this documentation we use the two terms interchangibly.}.  Development
of CDF is actively underway, and the initial versions of many
important parts of CDF are not yet available.  Nonetheless, the OMS
has already been used heavily in commercial and research products to
represent and manipulate knowledge in a way that is useful to XSB, to
allow the knowledge to persist in a database of file system, and to
visualize that knowledge through Interprolog @cite{Cale01} or other
tools.

@section{A (somewhat) Formal Introduction to CDF}

In this section we motivate design decisions taken by CDF, and
introduce a semantics of CDF based on a translation of an @em{CDF
instance} into a set of first-order logic sentences that constitute an
@em{Ontology Theory} whose models are the models of a CDF instance.
For simplicity of presentation our description of CDF instances omits
features that will be introduced in later sections -- such as
primitive types, extensional facts vs. intensional rules, internal
identifiers vs. identifiers to name a few @footnote{The development of
this section generally follows @cite{SwiW03}.}.

From a semantic point of view, a @em{CDF instance} can be thought of
as a set of ground Prolog facts for the following predicates:
@tt{class/2}, @tt{object/2}, @tt{relation/2}, @tt{subclass/2},
@tt{subrel/2}, @tt{memberof/2}, @tt{irel/3}, @tt{schrel/3},
@tt{strel/3}, @tt{attribute/3}, and @tt{attribute_object/3}.  In
practice, these facts may be defined either @em{extensionally}, or
@em{intensionally} using XSB rules.  Most of the arguments of facts in
a CDF instance are @em{identifiers}.  The actual syntax for
identifiers in CDF will be interoduced in Section @ref{}; for now we
can equate identifiers with logical terms.  For the purposes of this
section (though not of CDF) an @em{atomic identifier} can be thought
of as an atomic term, while a product identifier can be thought of as
a non-atomic term.

Despite the simple syntax of CDF instances, their semantics differs
from the usual semantics assigned to facts in Prolog.  While some
identifiers identify objects of a given structure (as in the semantics
of Prolog), others identify tuples of objects, sets of objects or of
tuples of objects, or relationships.  Furthermore, the facts of a CDF
instance can implicitly denote inheritance of various relationships
among classes and objects or constraints about what relationships are
allowed.

The rest of this section has two aims: first it motivates the
semantics of CDF via various examples -- as it does so, it introduces
the formal semantics for the various predicates that are introduced as
well as axioms for CDF as a whole.

@subsection{Classes and Objects}
Naive set theory provides a natural way to classify objects and to
discuss their relations.  Accordingly, CDF makes a fundamental
distinction between objects and sets.

@bf{Example 1}  We begin to construct a fragment of a CDF instance for
representing medical sutures, which will form a running example
throughout the paper.  In the process of modelling this instance, we
adapt meta-data from the U.S. Defence Logistics Information Service
(@tt{http://www.dlis.mil}), from the Universal Standard Products and
Services Classification @cite{UNSPSC}, as well as from the website of
various commercial medical supply companies.

@begin{verbatim}
  class(medicalEquipment,medicalEquipment)
         class(woundCareProducts,woundCareProducts,) 
  class(suturesAndRelatedProducts,suturesAndRelatedProducts)
         class(sutures,sutures)) 
  class(nonAbsorbableSutures,nonAbsorbableSutures)
         class(absorbableSutures,absorbableSutures) 
  class(sutureNeedles,sutureNeedles) 
@end{verbatim}

In CDF, sets are termed @em{classes} to stress the informality of its
sets from the perspective of set theory.  The first argument in the
@tt{class/2} tuples is the name of the class, and the second is an
identifier.  Each identifier is taken to exclusively identify an
element which may be a class, an object, or a relation, exclusively.
For readibility, we have made the names of the classes equal to the
identifiers, but in practice, identifiers of classes and objects
differ from their names (@ref{}).

Along with classes,
the fragment contains the following objects, whose names and
identifiers are formed from their various part numbers.
 @begin{verbatim}
  object(suture547466,suture547466)
  object(sutureU245H,sutureU245H)
@end{verbatim}

Note that the decision of whether to denote an entity as an object or
as a class depends on the use of a given CDF instance.  Here, a given
part number can specify a number of physical parts, but the physical
parts are taken to be identical for the purposes of this instance.
However, if we were constructing a CDF instance for warehouse
management, the above objects might be better represented as classes,
and the physical objects represented as CDF objects.

In the instance of Example 1, there is no explicit indication that the
objects are members of the class @tt{sutures}, nor is there explicit
indication that the class of @tt{absorbableSutures} is a subclass of
@tt{sutures}.  This information can be added via the predicate:

@begin{itemize}
@item	@tt{memberof(Object_id,Class_id)}
@end{itemize}

@noindent
indicating that a given object is a member of a given class; and via
the predicate: 
@begin{itemize}
@item	@tt{subclass(Class1_id,Class2_id)}
@end{itemize}

@noindent
indicating that @em{Class1_id} is a subclass of @em{Classs2_id}.

@bf{Example 2} 
Continuing from Example 1, we add the facts
@begin{verbatim}
  class('OMS Root','OMS Root')   
  subclass(medicalEquipment,'OMS Root')  
   subclass(woundCareProducts,medicalEquipment) 
    subclass(suturesAndRelatedProducts,woundCareProducts)
        subclass(sutures,suturesandRelatedProducts) 
            subclass(absorbableSutures,sutures)  
            subclass(nonAbsorbableSutures,sutures) 
            subclass(sutureNeedles,suturesAndRelatedProducts)  
@end{verbatim}

@noindent
to denote the hierarchy of classes.  Note that the top class on the
hierarchy is called @tt{'OMS Root'}, a class that is included in every
instance and denotes the maximal element of any @tt{subclass/2}
relation.  Next, we add the facts 
@begin{verbatim}
  memberof(suture547466,absorbableSutures)
  memberof(sutureU245H,suturesAndRelatedProducts)
@end{verbatim} 
@noindent
to denote classes to which the objects belong.  Note that by these
statements, @tt{sutureU245H} belongs to the class
@tt{suturesAndRelatedProducts} which is (potentially)
more general than the class @tt{absorbableSutures}.
@end{example}

At this point, we have introduced four CDF predicates, and can begin
defining the semantics of CDF instances.

@bf{Definition 1} @em{An @em{ontology language} is a first-order
language containing only predicates: @em{isClass/1,
isObj/1,isRel/1,memof/2, rel/3, and crel/3}.  An @em{ontology
structure} is a structure defined over an ontology language.  An
@em{ontology theory} is a set of first-order sentences formed over an
ontology language that includes a set of @em{ core axioms}.  If @em{T}
is an ontology theory formed over an ontology language @em{L}, an
ontology structure @em{S} over @em{L} is a model of @em{T} is every
sentence of @em{T} is satisfied in @em{S}.}

An ontology theory has both core axioms that belong to every ontology
theory, and @em{instance axioms} that are particular to a given theory
and that are used to represent the meaning of a given CDF instance.
Accordingly, in developing our semantics we present both core and
instance axioms.  As a technical point, if @em{I} is an atomic
identifier in a CDF instance, then we assume that @em{I} is a constant
in @em{L} the language underlying the ontology theory to which we
translate.  Similarly, if @em{I} is a @em{n}-ary product identifier,
we assume that @em{I} is an @em{n}-ary function in @em{L}.  We thus
freely use identifiers when refering both to CDF instances and to
ontology theories.

Informally @em{isClass/1} indicates that an identifier @em{I} is a
class name or @em{ class identifier}; @em{isObj/1} that @em{I} is an
object name or @em{object identifier}; and @em{isRel/1} that @em{I} is
a relation name, or @em{relation identifier}.  @em{memof(O,C)}
indicates that object identifier @em{O} is a member of class
identifier @em{C}; @em{rel(O1,R,O2)} indicates that object identifier
@em{O1} has an @em{R} relation to an object identifier @em{O2}; and
@em{crel(C1,R,O2)} indicates that the class identifier @em{C1} has a
@em{R} relation to an object identifier @em{O2}.

Our first core axiom ensures that objects, classes, and relations have
distinct identifiers

@bf{Core Axiom 1} @em{[Distinct Identifiers]}

@noindent
@em{(@bf{not exists} Id).(isClass(Id) @bf{and} isObj(Id)) @bf{and}
    (@bf{not exists} Id).(isClass(Id) @bf{and} isRel(Id)) @bf{and}
    (@bf{not exists} Id).(isObj(Id) @bf{and} isRel(Id))
}

@em{isClass/1}, @em{isObj/1}, and @em{isRel/1} provides a sorting that
extends to all predicates, as the next axiom indicates.

@bf{Core Axiom 2} @em{[Predicate Sorts]}

@em{
    (@bf{forall} X,Y).(memof(X,Y) @bf{=>} (isObj(X) @bf{and} isClass(Y)))
								@bf{and} 
    (@bf{forall} X,Y,Z).(rel(X,Y,Z) @bf{=>} (isObj(X) @bf{and} isRel(Y)
					   @bf{and} isObj(Z))) @bf{and}  
    (@bf{forall} X,Y,Z).(crel(X,Y,Z) @bf{=>} (isClass(X) @bf{and} isRel(Y)
					   @bf{and} isObj(Z))) 
}


We now provide rules to construct instance axioms for the CDF instance
predicates introduced so far.  Note that the names of identifiers play
no role in CDF semantics.

@bf{Instance Axiom} [@tt{class/2}] For each fact
of the form @tt{class(Atom,Id)} in an OMS instance @em{O}, add the
axiom: 
@begin{itemize}
@item @em{isClass(Id)} 
@end{itemize}
@noindent
denoted as @em{Int(@tt{class(Atom,Id)})}.

@bf{Instance Axiom} [@tt{object/2}]
For each fact of the form @tt{object(Atom,Id)} add the instance
axiom: 
@begin{itemize}
@item @em{isObj(Id)} 
@end{itemize}
@noindent
denoted as @em{Int(@tt{object(Atom,Id)})}

@bf{Instance Axiom} [@tt{relation/2}] For each
fact of the form @tt{relation(Atom,Id)} add the instance axiom:
@begin{itemize}
@item @em{isObj(Id)} 
@end{itemize}
@noindent
denoted as @em{Int(@tt{relation(Atom,Id)})}

@bf{Instance Axiom} [@tt{subclass/2}]
For each fact of the form @tt{subclass(Id1,Id2)} add the instance
axiom: 
@begin{itemize}
@item	@em{(@bf{forall} X).(memof(X,Id1) @bf{=>} memof(X,Id2))}
@end{itemize}
@noindent
denoted as @em{Int(@tt{subclass(Id1,Id2)})}.

The CDF instance predicate @tt{subrel/2} is used to indicate that one
relation is a sub-relation of another.

@bf{Instance Axiom} [@tt{subrel/2}]
For each fact of the form @tt{subrel(Id1,Id2)} add the instance
axiom: 
@begin{itemize}
@item	@em{(@bf{forall}) X,Y.(rel(X,Id1,Y) @bf{=>} rel(X,Id2,Y))}
@end{itemize}
@noindent
denoted as @em{Int(@tt{subrel(Id1,Id2)})}.

@bf{Instance Axiom} [@tt{memberof/2}]
For each fact of the form @tt{memberof(Id1,Id2)} add the instance
axiom:
@begin{itemize}
@item @em{memof(Id1,Id2)}
@end{itemize}
@noindent
denoted as @em{Int(@tt{memberof(Id1,Id2)})}.

It is important for the semantics of relations that each class have at
least one member.

@bf{Core Axiom 3} @em{[Non-Null Classes]}
@begin{itemize}
@item @em{(@bf{forall} X).(isClass(X) @bf{=>} (@bf{exists} Y).memof(Y,X))}
@end{itemize}

Our last core axiom for these predicates ensures is that each class is
a subclass of @tt{'OMS Root'}.

@bf{Core Axiom} @em{[Domain Containment]}
@begin{itemize}
@item @em{(@bf{forall} X).(isObj(X) @bf{=>} memof(X,'OMS Root'))}
@end{itemize} 

@subsection{General Relations between Classes}

Given classes, objects and the predicates @tt{subclass/2} and
@tt{memberof/2}, simple but useful @em{taxonomies} can be developed.
However, not all interesting information about the world can be
represented via a fixed subclass relation.  Hence, there are other
predicates that can indicate arbitrary relations among classes.

The first type of relation between classes simply states that the
relationship holds for all elements of the class.  This is done using
the @tt{irel/3} predicate, whose name stands for ``inheritable
relationship''.

@bf{Example 3}
The following fragment adds to the facts in the previous examples.

@begin{verbatim}
class(endType)          class(endTypeDomain)
class(singleArmed)      class(doubleArmed)
class(unarmed)          relation(endType,endType) 

subclass(endTypeDomain,'OMS Root') 
   subclass(singleArmed,endTypeDomain) 
    subclass(doubleArmed,endTypeDomain)  
   subclass(unarmed,endTypeDomain) 

irel(sutures,endType,endTypeDomain)  
@end{verbatim}

@noindent
This fragment indicates that @em{any} object in the @tt{
sutures} class has a @tt{endType} relation to an
object in or subclass of @tt{endTypeDomain}.  This immediately
implies that any class that is defined as a subclass of
@tt{sutures} will inherit the @tt{endType}
relationship.  This knowledge may be relatively definite -- that it
has a relation to the class @tt{unarmed} or less definite that
the subclass just has a relation to @tt{endTypeDomain},
e.g. to @tt{unarmed} or @tt{ singleArmed} or @tt{
doubleArmed}.

@tt{irel/3} thus provides a simple but powerful mechanism for
inheritance in CDF, as can be seen from the following translation
rule:

@bf{Instance Axiom} [irel/3]
For each fact of the form @tt{irel(Cid1,Rid,Cid2)} add the instance
axiom: 
@begin{itemize}
@item @em{
(@bf{forall} X). (memof(X,Cid1) @bf{=>} (@bf{exists} Y).(rel(X,Rid,Y) 
					@bf{and} memof(Y,Cid2))))
}
@end{itemize} @noindent
denoted as @em{Int(@tt{irel(Cid1,Rid,Cid2)})}

Alternatively, sets may have relations that do @em{not} hold for their
subclasses or members.  For instance, a finite set may have a given
cardinality, but its proper subsets will have a different cardinality.
From a practical point of view, such relations on sets are
@em{non-inheritable}.

@bf{Example 4} 
A practical example of a non-inheritable relation comes from an
application that may be called part equivalency matching.  In this
application, the possible attributes for a class of parts are given
various weights.  Two parts match if the sum of the weights of their
attributes that match are above a given threshold.  The weighting for
the @tt{endType} of sutures might be given as:

@begin{verbatim}
class(endTypeWeight,match)).  class(highWeight,match))
subclass(endTypeWeight,match),'OMS Root')
strel(sutures,endTypeWeight,match),highWeight,match))
@end{verbatim} 

@noindent 
This fragment indicates that the matching weight for the
@tt{endType} attribute for parts classified to
@tt{sutures} should be @tt{highweight}.  Matching weights are
denoted as non-inheritable using the @tt{strel/3} predicate, which
indicates a @em{set-valued} relation.  The weights are made
non-inheritable because a weight may depend on a given classification
of a part.  For instance if a part were classified as a
@tt{nonAbsorbableSuture}, its @tt{endType} might weigh
less (or more) for determining whether two sutures are equivalent.


@bf{Instance Axiom} [@tt{strel/3}]
For each fact of the form @tt{strel(Id1,Rid,Id2)} add the instance axiom:
@begin{itemize}
@item @em{
(@bf{exists} X).membof(X,Id2) @bf{and} crel(Id1,Rid,X)
}
@end{itemize}
@noindent
denoted as @em{Int(@tt{strel(Cid1,Rid,Cid2)})}.

Finally, it is often useful to indicate typing via @tt{schema
relations} between sets.  To take a simple example, the class
@em{person} may have a relation @em{ brother} to the class of
@em{malePerson}.  This doesn't mean that every person @em{has} a
brother that is a @em{malePerson} (as would be indicated by
@tt{irel/3}), only that @em{if} a person has a brother, the brother
must be a @em{malePerson}.

@bf{Example 5}
The following fragment provides an application-oriented example:
@begin{verbatim}
class(dlaPart)  class(suturesRusPart)  
class(EquivalencyMatch,match)) 

subclass(dlaPart,'OMS Root')  
subclass(suturesRusPart,'OMS Root') 
      subclass(suturesRusMatch,'CDF Relations','CDF')) 
schrel(dlaPart,suturesRusMatch,suturesRusPart) 
@end{verbatim}

@noindent This fragment indiates that a given @tt{dlaPart} may
have a @tt{suturesRusMatch} to a given
@tt{suturesRusPart} -- but not necessarily -- an equivalent
part may not be in the vendor's catalog.  However, the fragment
precludes the case in which a @tt{dlaPart} has a
@tt{suturesRusMatch} to a part in class that is not a
@tt{suturesRusPart}, such as the parts from a competing
vendor.

Not surprisingly, the semantics of @tt{schrel/3} resembles that of
@tt{irel/3}.

@bf{Instance Axiom} [@tt{schrel/3}]
For each fact of the form @tt{schrel(Cid1,Rid,Cid2)} add the instance
axiom: 
@begin{itemize}
@item @em{
(@bf{forall} X.@bf{forall} Y). ((memof(X,Cid1) @bf{and} rel(X,Rid,Y))
					@bf{=>} memof(Y,Cid2))
}
@end{itemize}
@noindent
denoted as @em{Int(@tt{schrel(Cid1,Rid,Cid2)})}.

@subsection{General Relations among Objects and Classes}

Relations between objects and classes, and between objects and other
objects are modelled by CDF predicates @tt{attribute/3} and
@tt{attribute_object/3}.  

@bf{Example 6} @tt{attribute/3} relates an object to a class.  The
fragment
@begin{verbatim}
attribute(suture547466,endType,singleArmed)
@end{verbatim} 

@noindent indicates via its first fact that the @tt{suture547466}
object has an @tt{endType} that is in the class @tt{singleArmed}.  In
the case of many types of attributes, such as needle end types, colors
and so on, relating an object to a class is sufficient as there is no
need to distinguish objects within the target class of colors or end
types.  The second fact indicates that there is a @tt{suturesRusMatch}
between the objects @tt{suture547466} and @tt{sutureU245H}, indicated
by the predicate @tt{attribute_object/3} which is used to relate an
object to an object.

At this stage, we can introduce our last two translation rules.

@bf{Instance Axiom} [@tt{attribute/3}]
For each fact of the form @tt{attribute(Oid1,Rid,Cid2)} add the instance
axiom: 
@begin{itemize}
@item @em{
  (@bf{exists} X).(rel(Oid1,Rid,X) @bf{and} memof(X,Cid2))
}
@end{itemize}
@noindent
denoted as @em{Int(@tt{attribute(Oid1,Rid,Cid2)})}.

@bf{Instance Axiom} [attribute_object/3]
For each fact of the form @tt{attribute_object(Oid1,Rid,Oid2)} add
the instance axiom:
@begin{itemize}
@item @em{rel(Oid1,Rid,Oid2)}
@end{itemize}
@noindent
denoted as @em{Int(@tt{attribute_object(Oid1,Rid,Oid2)})}.

@subsection{Product Classes and Object}

The above predicates allow the definition of various named binary
relations between classes.  However, binary definitions can sometimes
be inconvenient to use.  For instance, in the part equivalency
matching example, (Example 4), it may be desirable to make explicit
the weight of the match as an indication of the strength of the match.
The weight could be made explicit by a series of definitions

@begin{verbatim}
schrel(dlaPart,suturesRusMatch_low,suturesRusPart)
:
schrel(dlaPart,suturesRusMatch_high,suturesRusPart)
@end{verbatim} 
@noindent 
indicting that a given part has a match of weight @em{low} through
@em{high}.  However, for a scale with a large number of values,
defining matches in this way is time-consuming and prone to errors.
To address this, CDF provides @em{product classes}, as in the
following fact

@begin{verbatim}
schrel(dlaPart,suturesRusMatch(matchScale),suturesRusPart)
@end{verbatim} 
@noindent 
which indicates that a @tt{dlaPart} can have
a @tt{suturesRusMatch} relation with some @tt{matchScale}
weight to a @tt{suturesRusPart} part.

@bf{Example 5} 
Anoter aspect of product classes is illustrated by the fragment:
@begin{verbatim}
class(sign,sign)   class('+','+')  class('-','-')  
class(dimension,dimension)  class(length,length)  
class(unit,unit)  class(width,width)  class(height,height) 
class(time,time)  class(minutes,minutes)  class(days,days) 

subclass(sign,omsRoot)  
   subclass('+',sign) 
   subclass('-',sign) 
subclass(unit,omsRoot,oms))  
   subclass(dimensionUnit,unit) 
      subclass(length,dimensionUnit)  
      subclass(width,dimensionUnit) 
       subclass(height,dimensionUnit) 
   subclass(timeUnit,unit) 
      subclass(minutes,timeUnit) 
        subclass(days,timeUnit)

class('measure/3',measure(sign,integer,unit))
@end{verbatim}

@noindent

The class @tt{measure(sign,integer,unit)} can be thought of as the set
of terms with outer functor @tt{measure/3} whose first argument is a
member of the class @tt{sign}, whose second argument is an integer
@tt{integer} indicates the class of all integers @footnote{As a
practical matter, integers are defined as a primitive type, see
@cite{SwiW03}.}, and whose third element is a member of @tt{unit}.  By
this reasoning, the terms @tt{ measure('+',integer(1),length)} and
@tt{measure('-',integer(2),days} are both subclasses of @tt{
measure(sign,integer,unit)}, but neither is a subclass of each other.

We capture the intuition behind product classes through the following
axiom schemas.  The first indicates that product identifiers 
are constructed from @em{constituent identifiers} of the same sort.

@bf{Core Axiom} @em{[Downward Closure]}
For each product identifier @em{f(x1,...,xn)} and for each atomic
identifier @em{c} the following axioms are added,
@begin{itemize}
@item @em{isClass(f(x1,...,xn)) @bf{=>}
	isClass(x1) @bf{and} ... @bf{and} isClass(x_n)}
@item @em{isObj(f(x1,...,xn)) @bf{=>}
	isObj(x1) @bf{and} ... @bf{and} isObj(x_n)}
@item @em{isRel(f(x1,...,xn)) @bf{=>}
	isRel(x1) @bf{and} ... @bf{and} isRel(x_n)}
@end{itemize}

The next axiom associates product classes with the objects they contain.

@bf{Core Axiom} @em{[Implicit Subclassing]}
For each product identifier @em{f(x1,...,xn)} and for each atomic
identifier @em{c} the following axioms are added,
@begin{enumerate}
@item @em{(@bf{forall} O).(memof(O,f(x1,...,xn)) @bf{=>}
	 (O = f(y1,...,yn) @bf{and} 
		memof(y1,x1) @bf{and} ... @bf{and} memof(yn,xn)))}

@item @em{(@bf{forall} C).(memof(f(x1,...,xn),C) @bf{=>}
	(C = f(y1,...,yn) @bf{or} C = c))}
@end{enumerate}

@noindent
Note that together with Axiom @ref{ax:sorts}, Axiom @\ref{ax:implsc}
implies that if @em{memof(f(y1,...,yn),f(x1,...,xn))} holds,
then @em{isObj(f(y1,...,yn))}, and @em{isClass(f(x1,...,xn))} hold
as do @em{isObj(y_i)} and @em{isClass(xi)} for @em{1 =< i =< n}.

@cite{SwiW03} gives conditions that are necessary and sufficient for
an OMS instance to have be consistent.

@subsection{Inheritance}

Consider the effects of inheritance on @tt{attribute/3} and
@tt{attribute_object/3}.  The definition of the @tt{irel/3} relation
in Example 3 on the class of @tt{sutures} indicates that each
object in this class is related to @tt{endTypeDomain}.  Thus,
if no stronger information were provided for, say, part
@tt{suturesU245H}, then 
@begin{itemize}
@item @em{Int(@tt{attribute(suturesU245H,endType,endTypeDomain)})}
@end{itemize}
@noindent would be true in any model of the CDF instance.  This
consequence can be seen as a primitive form of ``default'', or more
precisely indefinite, reasoning that is provided by CDF.  Indeed,
@begin{itemize}
@item @em{Int(@tt{attribute(suture547466,endType,endTypeDomain)})}
@end{itemize}
@noindent 
would also be true, but would be of less interest, since Example 3
indicates there is specific information that @tt{suture547466}
is related to a subclass of @tt{endTypeDomain}, namely
@tt{singleArmed}.

In contrast to the relation @tt{endType} the relation
@tt{suturesRusMatch} was defined via the @tt{schrel/3}
predicate.  So in this case no @tt{attribute/3}, will be inferred, as
accords with intuition.  However the constraint that any
@tt{suturesRusMatch} must be to a @tt{suturesRusPart}
holds for members of the class @tt{sutures}, just as it holds
for subclasses of @tt{sutures}.

The followin formulas summarize inheritance in the first argument of
relations, and can be proved in a straightforward manner.

@bf{Proposition 1.1} @em{[First Argument Inheritance Propagation]}
Let @em{M} be an ontology model.
@begin{itemize}
@item If @em{M |= Int(@tt{irel(Id1,Id2,Id3)}) @bf{and}
	Int(@tt{subclass(Id0,Id1)})} then @em{M |= @tt{irel(Id0,Id2,Id3)})}

@item If @em{M |= Int(@tt{irel(Id1,Id2,Id3)}) @bf{and}
	Int(memberof(Id0,Id1))} then @em{M |= Int(attribute(Id0,Id2,Id3)})}

@item If @em{M |= Int(@tt{irel(Id1,Id2,Id3)}) @bf{and}
	Int(memberof(Id0,Id1))} then @em{M |= Int(attribute(Id0,Id2,Id3)})}

@item If @em{M |= Int(@tt{schrel(Id1,Id2,Id3)}) @bf{and}
    Int(@tt{subclass(Id0,Id1)})} then @em{M |= Int(@tt{schrel(Id0,Id2,Id3)})}

@item If @em{M |= Int(@tt{schrel(Id1,Id2,Id3)}) @bf{and}
		         Int(@tt{memberof(Id0,Id1)}) 
		@bf{and} Int(@tt{attribute(Id0,Id2,Id4)})} then 
	@em{M |= Int(@tt{subclass(Id4,Id3)})}

@item  If @em{M |= Int(@tt{schrel(Id1,Id2,Id3)}) @bf{and}
	        Int(@tt{memberof(Id0,Id1)}) @bf{and} 
		Int(@tt{attribute_object(Id0,Id2,Id4)})}
	then @em{M |= Int(@tt{memberof(Id4,Id3)})}
@end{itemize}

There is inheritance also in the third argument of relations.
Consider again the @tt{irel/3} fact @tt{endType}, defined in
Example 3.  This fact states that any element of @tt{sutures}
is related to a member or subclass of @tt{endTypeDomain}.  By
this definition, it also holds that @tt{endType} relates any
element of @tt{sutures} to a member or subclass of any
@em{superclass} of @tt{endTypeDomain} so that
@begin{itemize}
@item @em{
	Int(irel(sutures,endType,'OMS Root'))}
@end{itemize}
@noindent
should also hold in any model of the CDF instance.  Similiarly, 
@begin{itemize}
@item @em{
  Int(schrel('dlaPart',suturesRusMatch,'OMS Root'))}
@end{itemize} 

@noindent should also hold.  In English, every member or subclass of
@tt{suture} that has a @tt{suturesRusMatch} relation has the same
relation to a member or subclass of @tt{'OMS Root'}.

@bf{Proposition 1.2} @em{[Third-Argument Inheritance Propagation]}
@begin{itemize}
@item If @em{M |= Int(irel(Id1,Id2,Id3)) @bf{and}
	Int(subclass(Id3,Id4))} then @em{M |= Int(irel(Id0,Id2,Id4))}

@item If @em{M |= Int(schrel(Id1,Id2,Id3)) @bf{and}
	Int(subclass(Id3,Id4))} then @em{M |= Int(schrel(Id0,Id2,Id4))}

@item If @em{M |= Int(strel(Id1,Id2,Id3)) @bf{and}
	Int(subclass(Id3,Id4))} then @em{M |= Int(strel(Id0,Id2,Id4))}
@end{itemize}

A final aspect of inheritance arises from the fact that relation names
themselves are classes.  In our framework, inheritance in the second
argument of relations is taken to account for generalization or
specialization of the relations.  For instance, the relation
@tt{parent} can be generalized to @tt{ancestor} or specialized to
@tt{mother}.  Thus, if @tt{Abraham} is the @tt{parent} of @tt{Isaac},
it is true that he is the @tt{ancestor} or @tt{Isaac} but not
necessarily the @tt{mother} of @tt{Isaac}.  This intuition is
reflected in the final inheritance propositions.

@bf{Proposition} @em{[Second-Argument Inheritance Propagation]}

@begin{itemize}
@item If @em{M |= irel(Id1,Id2,Id3)) @bf{and}
	subclass(Id2,Id4))} then @em{M |= irel(Id0,Id4,Id3)}

@item If @em{M |= schrel(Id1,Id2,Id3)) @bf{and}
	subclass(Id2,Id4))} then @em{M |= schrel(Id0,Id4,Id3)}

@item If @em{M |= strel(Id1,Id2,Id3)) @bf{and}
	subclass(Id2,Id4))} then @em{M |= strel(Id0,Id4,Id3)}
@end{itemize}


@section{Views and Formats of the OMS}


where a term @em{T} is an identifier iff:

@begin{enumerate}

@item @em{T} has the form @em{id(A1,A2)} where @em{A1} and @em{A2} are
Prolog atoms (logical constants); or 

@item @em{T} has the form @em{id(T1,A2)} in which @em{T1} has the
form: @em{f(I1,...,In)} where @em{I1,...,In} are identifiers, and
@em{A2} is a Prolog atom.  
@end{enumerate} 
In the first case, an identifier is called @em{atomic}; in the second
it is called a @em{ product identifier}.  For either type of
identifier, the atomic second argument is called the @em{source}.  We
will see in later sections that identifiers can be in either @em{internal}
or @em{external} format.






@section{Views and Formats of the OMS}

There are several views and formats of the OMS -- a Programmer's View,
a Query View, an Internal Format, an External Format, and an External
Intensional Format.  The @index{Programmer's View} should be used by
application programs that interface tightly with the OMS.  This view
uses generated keys for classes and objects; it supports inheritance
of relations among subclasses and objects; and defines
@pred{subclass/2} and @pred{memberof/2} relations as reflexive and
transitive.  More loosely coupled systems, and human users can use a
Query View for the OMS which has the same semantics as the
Programmer's View in terms of inheritance and transitivity of the
hierarchical predicates but classes and objects are queried via pairs
of native ids and sources along the lines of the examples of @ref{A
Quick Tour of the OMS}.

Underlying both of these views are different formats in which OMS
information can be kept.  The @index{Internal Format} is an
extensional database of OMS facts that use generate keys of objects
and classes.  The @index{External Format} of the OMS, does not make
use of generated keys is also defined.  The external format provides a
means of representing the extensional database of OMS facts in
human-readable format, using native ids and sources.  It was this
format that was represented in the examples of @ref{A Quick Tour of
the OMS}.  Finally, the @index{External Intensional Format} provides a
mechanism for the OMS to dynamically access and intern ontology data
that is not in an OMS format -- for example, data that is kept in an
extenal database.  These views and formats are discussed below with
the exception of the Query View, which is discussed in
@ref{omsqueries (library)}.

@subsection{OMS: External Format}

The External Format is used when creating an ontology by hand and can
be a means of porting another ontology into the OMS Internal Format.
As a simple example, let us consider some classes taken from the file
@tt{oms/test/ext4.P} @footnote{currently this test file is uses
abstract classes.  In a future version of the documentation, I'll
create more meaningful names.}.  @tt{ext4.P} contains class
definitions that include the following classes.

@begin{verbatim}
class_ext('OMS Root','OMS Root'.
class_ext('OMS Inheritable Relationships',
          'OMS Inheritable Relationships'.
class_ext('OMS Set-Valued Relations','OMS Set-Valued Relations'.
class_ext('OMS Schema Relations','OMS Schema Relations'.
class_ext('OMS Relations','OMS Relations'.
class_ext('Descriptions','Descriptions'.

class_ext(myownname,c1,test).
class_ext(c2,c2,test).
class_ext(c3,c3,test).
class_ext(c11,c11,test).
class_ext(c12,c12,test).
class_ext(c13,c13,test).

class_ext(r3,r3,test).

class_ext(myf,f(c2,test,g(integer(1),'OMS',c12,test),test),test).
@end{verbatim}

@noindent These class definitions state that @tt{myownname}, say, is
the name of a class, whose native id is @tt{c1} and whose source
ontology is @tt{test}.  Classes with the source @tt{OMS} are built
into the OMS and are present for every ontology -- see
@ref{oms_init_oms (library)} for the descriptions of such classes.
They need not be defined in a file in External Format, however we
include them in this example for expository purposes.

The final term defines a parameterized class.  The native od of this
class has an @em{outer functor} of @tt{f}, and two @em{arguments}, the
first of which has native id @tt{c2} and source ontology @tt{test},
and the second of which is another parameterized class whose outer
functor is @tt{g} whose source ontology is also @tt{test}.  The
parameterized class @tt{f} is thus a combination of two classes each
of which are identified by a native id and a source ontology.  Because
it is a combination of two classes and will appear that way once the
external form is loaded into the OMS, this parameterized class is
referred to as @tt{f/2}, rather than as @tt{f/4} as it appears in the
external form.  Similarly, the parametrized class @tt{g} is referred
to as @tt{g/2} Note that the first argument of @tt{g/2} is
@tt{integer(1)}, whose source is @tt{OMS}.  While this class has the
syntax of a parameterized class, it is in fact an @em{OMS primitive
class}.  OMS primitive classes allow the user to use useful
programming types --- integers, floats, atoms, and so on --- without
having to explicitly define a separate class for each integer, say.
OMS primitive types are further discussed in @ref{???}.  As with
@tt{integer(1)}, all OMS primitive types have @tt{OMS} as their source
ontology.  The class hierarchy is defined as:

@begin{verbatim}
subclass_ext('OMS Inheritable Relationships','OMS','OMS Relations',OMS).
subclass_ext('OMS Set-Valued Relations','OMS','OMS Relations',OMS).
subclass_ext('OMS Schema Relations','OMS','OMS Relations',OMS).
subclass_ext('OMS Relations','OMS','OMS Root'.
subclass_ext('Descriptions','OMS','OMS Set-Valued Relations'.

subclass_ext(c1,test,c2,test).
subclass_ext(c2,test,c3,test).
subclass_ext(c3,test,'OMS Root'.

subclass_ext(c11,test,c12,test).
subclass_ext(c12,test,c13,test).
subclass_ext(c13,test,'OMS Root'.

subclass_ext(r1,test,r2,test).
subclass_ext(r2,test,'OMS Inheritable Relationships'.
subclass_ext(r3,test,'OMS Schema Relations'.

subclass_ext(f(c2,test,g(integer(1),'OMS',c11,test),test),test,c2,test).
@end{verbatim}

@noindent These subclass definitions denote the hierarchy of the
ontology.  Note that in the External Format, classes are @em{always}
referenced by the native id and the source ontology.  Also note that
@tt{r2}, while being a perfectly good class, can also be used to
define inheritable relationships, since it is a subclass of @tt{OMS
Inheritable Relationships}.  Similarly, @tt{r3} can be used to define
schema relations @footnote{For historical purposes, the term
'relationship' is used to denote relations that are inheritable, while
'relations' is used to denote relations that may or may not be
inheritable.}.

The final term defines
@tt{f(c2,test,g(integer(1),'OMS',c12,test),test)} with source ontology
@tt{test} as a subclass of @tt{c2} with source ontology @tt{test}.
For implementation reasons, parameterized classes can only be defined
as leaves of the hierarchy via explicit @pred{subclass_ext/4} (or
@pred{subclass/2} definitions).  However, parameterized classes have a
rich @em{implicit} hierarchy.  A parameterized class @em{C1} is a
subclass of a parameternized class @em{C2} if @em{C1} and @em{C2} both
have the same outer functor and each of the arguments of @em{C1} is a
subclass of each of the arguments of @em{C2}.  As an example

@begin{verbatim}
@tt{f(c1,test,g(integer(1),'OMS',c22,test),test)} + test
@end{verbatim}
is a subclass of 
@begin{verbatim}
@tt{f(c2,test,g(integer(1),'OMS',c22,test),test)} + test
@end{verbatim}

@noindent since @tt{c1} is a subclass @tt{c2}, but not of 

@begin{verbatim}
@tt{f(c2,test,g(integer(1),'OMS',c22,test),test)} + test
@end{verbatim}

@noindent since @tt{c12} is a subclass @tt{c22} @footnote{In a precise
sense, a parameterized class can be seen as a @em{product} of its
arguments, and behaves that way in terms of inheritance.}.  Thus the
hierarchy of atomic classes reflects through parameterized classes,
and the inheritance structure for any ontology can roughly be seen as
consisting of a DAG, whose leaves may or may not be parameterized
classes, but whose internal nodes are atomic.

The next conceptual part of the ontology are the relations, which include

@begin{verbatim}
relationship_ext(c2,test,r2,test,c12,test).
relationship_ext(f(c2,test,g(integer(1),'OMS',c11,test),test),test,
                 r1,test,c1,test).
@end{verbatim}

@noindent The first simply defines an @tt{r2} relationship in which
@tt{c2} is the source and @tt{c12} the target.  In the second @tt{r1}
is a specialization of the @tt{r2} relation since @tt{r1} is a
subclass of @tt{r2}.  There is a further subtle point illustrated in
the use of the parameterized class in the relation definition.
@tt{f(c2,test,g(integer(1),'OMS',c11,test),test) + test} is
(implicitly) a subclass of
@tt{f(c2,test,g(integer(1),'OMS',c12,test),test) + test}.  This means
that a subclass of @tt{f(c2,test,g(integer(1),'OMS',c12,test),test) +
test} relations have an @tt{r1} relation defined for them, but all do
not.  While this is somewhat abstract given this example, it is
important in that once parameterized classes are put into a class
hierarchy, the subclasses implicit in the parameterized class can be
used freely throughout the rest of the ontology definition.

Set-valued and schema relations are defined anagously:

@begin{verbatim}
strel_ext(c1,test,'Descriptions','OMS',atom('a description').

schrel_ext(c1,test,r2,test,c12,test).
@end{verbatim}
Note the use of the primitive type @pred{atom/1} in the set-valued
relation.

The above predicates, @pred{class_ext/3}, @pred{subclass_ext/4},
@pred{relationship_ext/6}, @pred{strel_ext/6}, @pred{schrel_ext/6},
are collectively termed the @em{schema} for an ontology (in external
form).  Analagous to the schema of an ontology is the data, consisting
of predicates @pred{object_ext/3}, @pred{memberof_ext/4},
@pred{attribute_ext/6}, and @pred{attribute_object_ext/6}.  Let us
begin with definitions of objects.

@begin{verbatim}
object_ext(o1,o1,test).
object_ext(o2,o2,test).
object_ext(o3,o3,test).
object_ext(o11,o11,test).
object_ext(of,of,test).
@end{verbatim}

@noindent Definitions of objects are analgous to those for classes, in
that objects have a name, a native id and a source ontology, and the
native id plus source uniquely determines the object.  However at
present all native ids for classes must have atomic names, unlike
those for classes which specify a parameterized class (or subclass).
Each object must be defined to be a member of at least one class, as
in the following statements.

@begin{verbatim}
memberof_ext(o1,test,c1,test).
memberof_ext(o2,test,c2,test).
memberof_ext(o3,test,c3,test).
memberof_ext(o11,test,c11,test).

memberof_ext(of,test,f(c2,test,g(integer(1),'OMS',c11,test),test),test).
@end{verbatim}

@noindent The first two arguments of @pred{memberof_ext/4} are the
native id of an object and its source; the second two are the native
id of a class and its source.  The final term shows that it is allowed
for an object to be member of a parameterized class.  

Finally, the external form defines some attributes for objects.

@begin{verbatim}
attribute_ext(o2,test,r2,test,c12,test).

attribute_object_ext(o2,test,r2,test,o12,test).
@end{verbatim}

The predicates @pred{attribute_ext/6} and
@pred{attribute_object_ext/6} are similar except that the target of
@pred{attribute_object_ext/6} must be an object, rather than a class
as with @pred{attribute_ext/6}.

@noindent Routines for loading data in External Format into an OMS and
dumping an OMS to a file in External Format are described in
@ref{oms_io (library)}.  The schema for the External Format is
summarized below.  All relations in the External Format are
extensional -- inheritance and transitivity is executed only after
they are translated back to the Internal Format by routines in
@ref{oms_io (library)}.

In the external form, class names, object names, object native ids,
and all sources must be atomic.

@begin{itemize} 

@item @tt{class_ext(Name,NativeId,Source)} (@pred{class_ext/3}):
@tt{Name} is the name of a class, @tt{Nativeid} its (possibly
parameterized) native id, and @tt{Source} its source.

@item @tt{subclass_ext(SubNId,SubSrc,SupNId,SupSrc)}
(@pred{subclass_ext/4}) denotes that one class is a subclass of
another.  @tt{SubNId} and @tt{SubSrc} are the native id and source of
the subclass; and @tt{SupNId} and @tt{SupSrc} are the native id and
source of the superclass.

@item
@tt{relationship_ext(NId_from,Src_from,NId_rel,Src_rel,NId_to,Src_to)}
(@pred{relationship_ext/6}) is the external form of an inheritable
relationship.  Native ids and sources are used in the usual manner.

@item
@tt{strel_ext(NId_from,Src_from,NId_rel,Src_rel,NId_to,Src_to)}
(@pred{strel_ext/6}) is the external form of a (non-inheritable)
set-valued relation.

@item
@tt{schrel_ext(NId_from,Src_from,NId_rel,Src_rel,NId_to,Src_to)}
(@pred{schrel_ext/6}) is the external form of an schema relationship.

@item @tt{object_ext(Name,Native_id,Src)} (@pred{object_ext/3})
denotes an object with given name, native id, and source.

@item @tt{memberof_ext(ObjNid,ObjSrc,ClassNid,ClassSrc)}
(@pred{memberof_ext/4}) declares the object specified by @tt{ObjNid +
ObjSrc} to be a member of the class specified by @tt{ClassNid +
ClassSrc}.

@item
@tt{attribute_ext(ObjNid,ObjSrc,RelNid,RelSrc,ClassNid,ClassSrc)}
(@pred{attribute_ext/6}) defines an attribute of an object, using
object and class native ids and sources.

@item
@tt{attribute_object_ext(ObjNid,ObjSrc,RelNid,RelSrc,Obj2Nid,Obj2Src)}
(@pred{attribute_object_ext/6}) defines an attribute of an object,
when the target of the object is another object, rather than a class
as in @pred{attribute_ext/6}.

@end{itemize}

@subsection{Programmer's View of the OMS}

The Programmer's View of the OMS is the one that tightly coupled
applications actually use.  To create a Programmer's View of the
previously-discussed ontology in @tt{ext4.P}, the OMS may be consulted
into XSB and the external form loaded by a predicate such as
@pred{load_mergeomsext/1}.  For expository purposes we discuss aspects
of the Programmer's View of the OMS by means of the XSB command
prompt.  Various applications of the OMS may communicate through the
Java interface to XSB, through an ontology editor, or in a number of
other ways.  If we make the query:

@begin{verbatim}
| ?- class(Cid,myownname,Nid,Src).

Cid = 17
Nid = c1
Src = test

yes
@end{verbatim}

We see that a class defined in our External Format has in fact been
loaded into the OMS.  However rather than having three arguments as
with @pred{class_ext/3}, the predicate @pred{class/4} has four
arguments: the original three plus @tt{17}, which unified with the
variable @tt{Cid}.  This new argument is a @em{class id}, and is
uniquely generated for each class that is loaded into the OMS.
Similarly, if we make the query

@begin{verbatim}
| ?- object(Oid,OName,ONid,OSrc).
@end{verbatim}

@noindent we get back the bindings

@begin{verbatim}
Oid = 1
OName = o1
ONid = o1
OSrc = test
@end{verbatim}

and infact, can backtrack through all other bindings for the goal
object, if we wish.  In a similar manner to class, there is a new
@em{Object Id} argument that is uniquely generated for each object
loaded into the OMS.  Now, what happens if we use the object
identifier @tt{1} where a class should be?  

@begin{verbatim}
| ?- class(1,Name,Nid,Src).
@end{verbatim}

@noindent gives back the bindings

@begin{verbatim}
Name = OMS Root
ONid = OMS Root
OSrc = OMS
@end{verbatim}

Illustrating the point that class ids and object ids are generated
separately.  Class ids are generated for parameterized classes based
on class ids for atomic classes.

@begin{verbatim}
| ?- class(Id,myf,Nid,Src).

Id = f(18,g(integer(1),21))
Nid = f(c2,test,g(integer(1),OMS,c12,test),test)
Src = test
@end{verbatim}

In loading this class, the class @tt{c2 + test} is translated to its
class id, @tt{18}, and a similar translation is done for @tt{c12 +
test}.  Hoever, note that no translation is done for outer functors of
parameterized classes or for primitive classes: @tt{integer(1)} has
the same form in the class id as in the native id.  At this point it
is easier to see why the OMS maintains clothes all integers in the
form @tt{integer/1}: without this clothing the integer @tt{1} would be
seen as the class id for @tt{OMS Root}!

In the Programmer's View, native ids and sources are not found in OMS
predicates other than @pred{class/4} and @pred{object/4}.  For
instance, if we make the following query to @pred{subclass/2}

@begin{verbatim}
| ?- subclass(f(18,g(integer(1),21)),Cid),class(Cid,Name,Nid,Src).
@end{verbatim}

@noindent we get back a series of bindings to all classes to which
this parameterized class belongs.  The first set of bindings is 

@begin{verbatim}
Cid = f(18,g(integer(1),21))
Name = myf
Nid = f(c2,test,g(integer(1),OMS,c12,test),test)
Src = test;
@end{verbatim}

@noindent reflecting the fact that the @pred{subclass/2} is
reflexive.  Further backtracking gives 

@begin{verbatim}
Cid = 18
Name = c2
Nid = c2
Src = test;
@end{verbatim}

@noindent as well as other subclasses to which
@tt{f(18,g(integer(1),21))} transtively belongs, up to @tt{OMS Root}
@footnote{Because @pred{subclass/2} does not use tabling, superclasses
or subclasses may be repeated when backtracking through a query to
@pred{subclass/2}.}.

In addition to providing transitivity for @pred{subclass/2}, the
Programmer's View also supports inheritance for relationships and
schrels.  Recall that the external form contained the fact

@begin{verbatim}
relationship_ext(c2,test,r2,test,c12,test).
@end{verbatim}

This relationship is, of course, supported in the Programmer's View,
and can be accessed by translating into the appropriate class ids.  In
addition, since @tt{c1 + test} is a subclass of @tt{c2 + test} calling
making a call to @tt{relationship/3} shows that there is also an
@tt{r2 + test} relation from @tt{c1 + test} to @tt{c12 + test},
indicating that relational inheritance is transparently supported for
the user.

Further examination of the Programmer's View shows that inheritance is
propagated to attribute information.  For instance, it can be seen
that there is an @tt{r2 + test} attribute for @tt{o1 + test}, by
calling @pred{attribute/3} with the appropriate class and object ids.



In the Programmer's View, OMS predicates have the following form
(described further in in @ref{oms_init_oms (library)}).
@begin{itemize}

@item @tt{class(CID,Name,NativeID,Source)} (@pred{class/4}: where
@tt{CID} is a class ID, @tt{Name} is the name of the Class (an atom),
@tt{NativeID} is a user ID for the node, and @tt{Source} is an atom
that identifies the source ontology of this class.

@item @tt{subclass(SubCID,SupCID)} (@pred{subclass/2}): where
@tt{SubCID} is the class id of a class that is a sub-class of the
class @tt{SupCID}.  @em{TLS explain a bit further about how exactly
subclassing works with parameterized classes}.

@item @tt{relationship(SCID,RelCID,TCID)} (@pred{relationship/3}): is
an inheritable relation where @tt{SCID}, @tt{RelCID} and @tt{TCID} are
class ids, indicating a source class, a relation class and a target
class, respectively.  @tt{RelCID} must be a descendent of the @em{OMS
Inheritable Relationships} class (this is ensured OMS routines that
create new relations).  This predicate specifies monotonic
inheritance: that each object that is a subclass of @tt{SCID} must
have a @tt{RelCID} attribute of type (i.e. a subclass of) @tt{TCID}
(the precise semantics is described in @ref{Semantic Axioms}).

@item @tt{strel(SCID,RelCID,TCID)} (@pred{strel/3}): where @tt{SCID},
@tt{RelCID} and @tt{TCID} are class IDs, indicating a source class, a
relation class and a target class, respectively.  This predicate
designates non-inheritable relationships.

@item @tt{schrel(SCID,RelCID,TCID)} (@pred{schrel/3}): where
@tt{SCID}, @tt{RelCID} and @tt{TCID} are class IDs, indicating a
source class, a relation class and a target class, respectively.  This
predicate designates the type of that an attribute must have: i.e. if
an object is of type @tt{SCID} then any attribute of that object whose
relation part is a subclass of @tt{RelCID} must have a target that is
a subclass of @tt{TCID}; and any attribute_object of that object whose
relation part is a subclass of @tt{RelCID} must have a target that is
a memberof @tt{TCID}.  See @ref{Semantic Axioms} for more details.

@item @tt{object(OID,Name,NativeID,Source)} (@pred{object/4}): where
@tt{OID} is an internally-generated integer ID for this Object;
@tt{Name} is the name of this object; @tt{NativeID} is a user ID for
this object; and @tt{Source} is the source ontology.

@item @tt{memberof(OID,CID)} (@pred{memberof/2}): where OID is the
object ID of an object that is an element of the class CID.

@item @tt{attribute(OID,RelCID,TCID)} (@pred{attribute/3}): indicates
that the relational class @tt{RelCID} maps the object @tt{OID} to the
class @tt{TCID}.  For this to be valid, there must be a tuple in
relationship indicating that this is correctly typed.

@item @tt{attribute_object(OID,RelCID,TOID)}
(@pred{attribute_object/3}): indicates that the relational class
@tt{RelCID} maps the object @tt{OID} to the object @tt{TOID}.  For
this to be valid, there must be a tuple in relationship indicating
that this is correctly typed.  @end{itemize}

@subsection{OMS: Internal Format} The Internal Format of the OMS
consists of raw facts upon which the Programmer's View is based.  It
does not include relationships or attributes derived via inheritance
or transitive subclass or memberof relations.  Users will rarely have
to work directly with this level.  We include a brief description for
completeness and because the predicates in internal form are are
loaded and dumped to files via the predicates @pred{load_oms/1} and
@pred{dump_oms/1}.

The following predicates comprise the Internal Format.  Some of these
predicates and their initialization are discussed in @ref{oms_init_oms
(library)}.

@begin{itemize}

@item @tt{oms_cn(CID,Name,NativeID,Source)} (@pred{oms_cn/4}).
Internal form of @pred{class/4}, where @tt{CID} is an internally
generated class ID (an integer), @tt{Name} is the name of the Class
(an atom), @tt{NativeID} is a user ID for the node (an atom), and
@tt{Source} is an atom that identifies the source of this class.  

@item @tt{oms_sc(SubCID,SupCID)}: (@pred{oms_sc/2}).  Internal form of
a @pred{subclass/2} where SubCID is the CID of a class that is an
immediate sub-class of the class SupCID.

@item @tt{oms_rln(SCID,RelCID,TCID)}: (@pred{oms_rln/3}).  Internal
form of @pred{relationship/3}, where SCID, RelCID and TCID are class
IDs, indicating a source class, a relation class and a target class,
respectively.  RelCID must be a descendent of the @index{OMS
Inheritable Relationships} class.

@item @tt{oms_strel(SCID,RelCID,TCID)}: (@pred{oms_strel/3}).
Internal form of @pred{strel/3}, where SCID, RelCID and TCID are
class IDs, indicating a source class, a relation class and a target
class, respectively.  RelCID must be a descendent of the @index{OMS
Set-Valued Relations} class.

@item @tt{oms_schrel(SCID,RelCID,TCID)}: (@pred{oms_schrel/3}).
Internal form of @pred{schrel/3}, where SCID, RelCID and TCID are
class IDs, indicating a source class, a relation class and a target
class, respectively.  RelCID must be a descendent of the @index{OMS
Schema Relationships} class.

@item @tt{OMS_obj(OID,Name,NativeID,Source)}: (@pred{oms_obj/4}).
Internal form of @pred{object/4}, where OID is an internally-generated
integer ID for this Object; Name is the name of this object, NativeID
is a native ID for this object, and Source is its source ontology.

@item @tt{OMS_mo(OID,CID)} (@pred{oms_mo/2}).  Internal form of the
@pred{memberof/2} where OID is the object ID of an object that is
contained in the class CID.

@item @tt{OMS_at(OID,RelCID,TCID)}: (@pred{oms_at/3}).  Internal form of
the @pred{attribute/3}, and indicates that (every relation in) the
relational class RelCID maps the object OID to the class TCID.
That is that RelCID maps OID to some object in TCID.  

@item @tt{oms_ao(OID,RelCID,TOID)}: (@pred{oms_ao/3}).  Internal form of
the @pred{attribute_object/3} relation, and indicates that the
relational class RelCID maps the object OID to the object TOID.  
@end{itemize}

@subsection{OMS: External Intensional Format} The final view of the
OMS allows users to define a Programmer's View via predicates.  To see
the advantage of using the External Intensional Format, consider a
concrete example that uses approved item names.  In Prolog, an
approved item name fact consists of an Item Name Code, the FIIG to
which the Item Name Code belongs, the Item Name itself, and a
description:

@begin{verbatim}
item_name('00001','A516K0','ELECTRON TUBE','An inclosure, including
two or more electrodes, in which a flow of electrons may occur through
a vacuum or a contained gas. The electronic conduction takes place
either by means of electrons emitted from a cathode or by ionization
of the contained gas. Includes phototubes (photoemissive type only),
Geiger-Mueller tubes, traveling wave tubes, cathode ray tubes and
microwave tubes (Klystron, magnetron, or the like). Excludes items
whose primary purpose is to produce light energy. Also excludes
PHOTOELECTRIC CELL; and SEMICONDUCTOR DEVICE (as modified).'). 
@end{verbatim}

If we wish to include item name facts in our ontology, we might
translate the above fact as follows.

@begin{verbatim}
class_ext('ELECTRON TUBE','OOOO1',fiig).

subclass_ext('OOOO1',fiig,'A516K0',fiig).

strel('OOOO1',fiig,'Descriptions','OMS',atom(''An inclosure, including
  two or more electrodes, in which a flow of electrons may occur
  through a vacuum or a contained gas. The electronic conduction takes
  place either by means of electrons emitted from a cathode or by
  ionization of the contained gas. Includes phototubes (photoemissive
  type only), Geiger-Mueller tubes, traveling wave tubes, cathode ray
  tubes and microwave tubes (Klystron, magnetron, or the like). Excludes
  items whose primary purpose is to produce light energy. Also excludes
  PHOTOELECTRIC CELL; and SEMICONDUCTOR DEVICE (as modified).')).
@end{verbatim}

To translate all such approved item names into the OMS wouldn't be
hard.  We'd start by mapping the item_name predicate to OMS predicates
as follows.  

@begin{verbatim}
class_ext(Name,Nid,fiig):- item_name(Nid,_,Name,_).

subclass_ext(Nid,fiig,Fiig,fiig):- item_name(Nid,Fiig_,_).

strel_ext(Nid,fiig,'Descriptions','OMS',atom(Descr),'OMS):- 
	item_name(Nid,_,_,Descr).
@end{verbatim}

The programmer might then write scripts so that a file of item_name
facts could then be transformed into OMS external form.  Such an
approach is fairly simple and is often done successfully.  However,
this approach does have disadvantages.  First, if item name
information is maintained outside of the OMS (as it is by DLA) then
whenever information about item names changes, the transformation
scripts must be rerun.  Second, if the item name information is kept
in a database the DBMS resident information must be exported from the
DBMS and transformed into external form @footnote{The DBMS interface
to the OMS has been implemented, but is not yet fully supported}.

The OMS external intensional format allows a user to define views of
the data which are used automatically by the OMS.  For instance a view
of item name information might look like:

@begin{verbatim}
class_int(Name,Nid,fiig):- item_name(Nid,_,Name,_).

subclass_int(Nid,fiig,Fiig,fiig):- item_name(Nid,Fiig_,_).

strel_int(Nid,fiig,'Descriptions','OMS',atom(Descr),'OMS):- 
	item_name(Nid,_,_,Descr).
@end{verbatim}

@noindent If these rules are dynamically loaded into memory, along
with @tt{item_name/4} then a query

@begin{verbatim}
class(Id,Name,Nid,Src)
@end{verbatim}

@noindent will check not only the @pred{oms_cn/4} facts that may have
been created from information external form but also will call
@pred{class_int/3} rules.  Similarly, a query: 

@begin{verbatim}
subclass(ChildCid,ParentCid)
@end{verbatim}

@noindent will check @pred{oms_sc/2} rules, and also will translate
the class ids of the query to native ids and sources and check
@pred{subclass_int/4} rules, and translate the native ids and sources
back to class ids when necessary. 

For each @em{xxx}@tt{_ext/n} predicate, there is a corresponding
@em{xxx}@tt{_int/n} predicate, and all views support a free
intermixture of external intensional and explicitly loaded classes and
/ or objects.  Even parameterized classes can be built using a mixture
of intensional and explicitly loaded classes @footnote{Hopefully I've
gotten all --- or at least most of --- the bugs out by now.}.

As a final point, the OMS does not directly support assertion or
deletion of information in the External Intensional Format.  As a
result if intensional data is to be modified by, say, an XJ-based GUI,
cache-coherency cannot be guarenteed.

@subsection{Views on the Different Views}

To summarize, users may load an OMS from the external form and dump
information in external form to a file.  Alternatively, users may
define external intensional predicates to access dynamically loaded
data in non-OMS format, and eventually to access data from databases.
As another alternative, once an OMS is created the internal form may
be dumped to and loaded from files (say, by the predicates
@pred{load_oms/1} and @pred{dump_oms/1}.  No matter how the
information is loaded it is used by the predicates of the Programmer's
View, either directly in the case of information in Internal Format;
by translation from External Format into Internal Format (by,
e.g. @pred{load_mergeomsext/1}); or by calling intensional rules.

Which format should an application use to load and save OMS data?  The
answer, of course, depends on the needs and size of an application.
Data in Internal Format is fastest to save and load, but the saved
data can be difficult to read, and impossible (or at least really
difficult) to modify outside of the OMS.  Data in External Format is
easier to create and view from an editor, but is slower to load.
Finally, external intensional data may be fast to load, but execution
of user-level queries is somewhat slower than data based on Internal
Format, as translations need to be made form concept and object ids to
native ids and sources and intensional rules need to be executed.

").

main.

