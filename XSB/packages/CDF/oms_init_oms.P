:- compiler_options([ciao_directives]).

:- document_export
	class/4, 
	newClass/5, retractallClass/4,
	updateClass/4, updateObject/4,
	subclass/2, proper_subclass/2,
	immediate_subclass/2, % if_subclass/2,
%	assert_subclass/2, 
	newSubclass/2, retractallSubclass/2,
	is_a_relation/1,
	relationship/3, 
	immediate_relationship/3,immediate_irel/3, 
	is_an_inheritable_relationship/1,
%	assert_relationship/3, 
	newRelationship/3, newRelationshipClass/3,
	retractallRelationship/3,
	strel/3,
	is_a_strel/1,	
%	assert_strel/3, 
	newStrel/3, newStrelClass/3, retractallStrel/3,
		schrel/3,
	immediate_schrel/3, is_a_schrel/1,
%	assert_schrel/3, 
	newSchrel/3, 	newSchrelClass/3, retractallSchrel/3,
		object/4, 
%	assert_object/4, newObject/3, 
	newObject/5,retractallObject/4,
	memberof/2,
	immediate_memberof/2, 
%	assert_memberof/2, 
	newMemberof/2,retractallMemberof/2,
	(attribute)/3,
	immediate_attribute/3, 
%	assert_attribute/3, 
	newAttribute/3,retractallAttribute/3,
        updateAttribute/5,
	attribute_object/3,
%	assert_attribute_object/3, 
	newAttribute_object/3, retractallAttribute_object/3,

	new_oms/0,

/*	oms_use_cache/0, oms_dont_use_cache/0,*/

	set_chk_index/0.

:- import conset/2, conget/2 from gensym.
:- import variant/2, subsumes/2 from subsumes.
:- import ground/1, member/2 from basics.
:- import abolish_table_pred/1 from tables.

:- dynamic oms_checking/1.
:- call_assert(oms_checking(partial)).
:- [oms_constraints].
:- [oms_exceptions].
:- [oms_oblivion].
:- [oms_cdf].

:- dynamic class_int/3.
:- dynamic immediate_subclass_int/4.
:- dynamic immediate_relationship_int/6.
:- dynamic strel_int/6.
:- dynamic immediate_schrel_int/6.
:- dynamic immediate_memberof_int/4.
:- dynamic object_int/3.
:- dynamic immediate_attribute_int/6.
:- dynamic attribute_object_int/6.

:- dynamic cn_id_map/4.
:- index(cn_id_map/4,[1,3+4],5001).

:- dynamic ob_id_map/4.
:- index(ob_id_map/4,[1,3+4],5001).

:- dynamic last_checked/1.

:- init_ext_dynamic,
   init_oms_dynamic,
   init_oms_rels,
   init_index_std.

%--------------------------------------------------------------------
/* TLS: these should be used only when checking dead code.  They
include superceded predicate names and "imports" from other files.

:- export assert_attribute/3,assert_attribute_object/3,
	assert_memberof/2,
	assert_object/4, 
	assert_relationship/3,assert_schrel/3,assert_strel/3,
	assert_subclass/2, 

	irel/3, newIrel/3,

	retractall_attribute/3, retractall_attribute_object/3,
	retractall_class/4, retractall_memberof/2,
	retractall_object/4,  retractall_relationship/3,
	retractall_schrel/3, retractall_strel/3,  retractall_subclass/2,

% used by oms_io:
	oms_initialize_ctrs/0.

:- import check_incremental_constraints/1 from oms_constraints.
*/
%--------------------------------------------------------------------

:- comment(module,
"
@section{Using the OMS}

Both the OMS Internal Format (@ref{OMS: Internal Format} and the OMS
Programmer's View (@ref{Programmer's View of the OMS}) are defined in
this file.  Both of these views use generated identifiers, which means
that data in External Format must be transformed into Internal Format
by one of the predicates in @ref{oms_io (library)}.  The user of the
OMS will normally access data in the OMS's Internal Format through
the Programmer's View, which supports a semantics of inheritance (see
@ref{Semantic Axioms for the Programmer's View}) and accesses External
Intensional Data.  Predicates defined at the Programmer's View include
@pred{class/4}, @pred{subclass/2}, @pred{relationship/3}, and others
defined below.  Predicates that support the Internal Format include
@pred{oms_cn/4}, @pred{oms_sc/2}, @pred{oms_rln/3} and others.

@section{Builtin Classes and Relations}

The following classs and relations are defined for @em{every}
instance of the OMS.  In other words, any ontology definable via the
OMS includes these classs and relations.

@begin{itemize}

@item @index{OMS Root}: 
	Class that is the root node of the Ontology.  All classes are
subclasses of @tt{OMS Root}. 

@item @index{OMS Relations}:
	Class that includes all relations --- inheritable or not.
@footnote{For historical purposes, inheritable relations are sometimes
called @em{relationships}.}  
Defined as: 
@begin{verbatim} 
newClass('OMS Relations',RootCid,'OMS',RelCid)
@end{verbatim}

As mentioned in @ref{A Quick Tour of the OMS}, OMS relations can
define inheritable attributes which hold for subclasses and objects,
inheritable schema attributes, and non-inheritable attributes.
Subclasses of @tt{OMS Relations} define inheritable attributes.

@item @index{OMS Inheritable Relationships}:
	Class that includes all inheritable relationships.
Defined as:
@begin{verbatim}
newClass('OMS Inheritable Relationships',RelCid,'OMS',InheritableCid):
@end{verbatim}

@item @index{OMS Set-Valued Relations}:
	Class that includes all non-inheritable set-valued relations.
Defined as:
@begin{verbatim}
newClass('OMS Set-Valued Relations',RelCid,'OMS',_SetValCid):
@end{verbatim}

Inheritable Relations themselves may sometimes be transitive or
symmetric.  If so, the relations are set as subclasses of the
following Classes.

@item  @index{OMS Transitive Relations}:
Defined as:
@begin{verbatim}
newClass('OMS Transitive Relations',InheritableCid,'OMS',_TranCid):
@end{verbatim}

@item  @index{OMS Symmetric Relations}:
Defined as:
@begin{verbatim}
newClass('OMS Symmetric Relations',InheritableCid,'OMS',_SymCid):
@end{verbatim}

@item @index{OMS Primitive Types}: The classes here are implemented as
part of the undelying OMS code and avoids explicit class creation, for
numbers, atoms, etc.  They are represented in XSB by structured terms.
Defined as: 

@begin{verbatim} 
newClass('OMS Primitive Types',RootCid,'OMS',_PTypesCid),
@end{verbatim}

The primitive types supplied by the OMS are: 
@begin{verbatim}
        oms_cn(integer(X),'INTEGER/1',integer(X),'OMS').
  	oms_cn(float(X),'FLOAT/1',float(X),'OMS').
  	oms_cn(atom(X),'ATOM/1',atom(X),'OMS').
  	oms_cn(cardinal(X),'CARDINAL/1',cardinal(X),'OMS').
  	oms_cn(aint(X),'AINT/1',atom(X),'OMS').
  	oms_cn(object(X),'OBJECT/1',object(Y,Z),'OMS').
  	oms_cn(clause(X,Y),'CLAUSE/2',clause(X,Y),'OMS').
@end{verbatim}

@noindent The data structures represented by first three are
self-explanatory; @tt{aint(_)} is used to represent integers that have
the form of Prolog atoms, such as @tt{'01968'}; while @tt{obj(_)} is
used to represent the set of all object IDs.

Each of the primitive types can be seen as constituting a rather flat
hierarchy.  A given integer, say @tt{integer(7)} is a leaf of the
integer hierarchy.  Its immediate parent is @tt{integer(_)}, in which
the underscore signifies an anonymous Prolog variable.
@tt{integer(_)} can be thought of as standing for the expression
@em{(all X).integer(X)}.  Thus, @tt{integer(_)} is the 
parent of each
instanitated integer, so that the usual ordering of integers is not
maintained within the OMS.  Similarly, @tt{atom(_)} is the parent of
each instantiated atom and so on.

@end{itemize}
").

%--------------------------------------------------------------------
/* Basic code that declares and initializes a basic OMS */

% TLS: this predicate may not get used heavily, but I think its useful
% to have all the re-initialization stuff here in one place, to record
% what the state consists of and to make future maintenance easier. 

:- comment(new_oms/0,"Normally, initialization is done automatically
upon loading an OMS.  The routine @pred{new_oms/0} should be called
only when an OMS is to be reinitialized during a session.  This
predicate removes all data in internal, external, and external
intensional format, and reasserts the basic OMS classes and
relations.").

new_oms:- 
	conset('_cid_ctr',0),
	conset('_oid_ctr',0),

	retractall(oms_cn(_,_,_,_)),
	retractall(oms_sc(_,_)),
	retractall(oms_rln(_,_,_)),
	retractall(oms_strel(_,_,_)),
	retractall(oms_schrel(_,_,_)),
	retractall(oms_obj(_,_,_,_)),
	retractall(oms_mo(_,_)),
	retractall(oms_at(_,_,_)),
	retractall(oms_ao(_,_,_)),

	retractall(last_checked(_)),

	retractall(class_int(_,_,_)),
	retractall(immediate_subclass_int(_,_,_,_)),
	retractall(immediate_relationship_int(_,_,_,_,_,_)),
	retractall(strel_int(_,_,_,_,_,_)),
	retractall(immediate_schrel_int(_,_,_,_,_,_)),
	retractall(object_int(_,_,_)),
	retractall(immediate_memberof_int(_,_,_,_)),
	retractall(immediate_attribute_int(_,_,_,_,_,_)),
	retractall(attribute_object_int(_,_,_,_,_,_)),

	retractall(cn_id_map(_,_,_,_)),
	retractall(ob_id_map(_,_,_,_)),

	init_oms_rels.

init_oms_dynamic :-
	dynamic(oms_cn(_,_,_,_)),
	dynamic(oms_sc(_,_)),
	dynamic(oms_rln(_,_,_)),
	dynamic(oms_strel(_,_,_)),
	dynamic(oms_schrel(_,_,_)),
	dynamic(oms_obj(_,_,_,_)),
	dynamic(oms_mo(_,_)),
	dynamic(oms_at(_,_,_)),
	dynamic(oms_ao(_,_,_)).

init_index_std :-
	init_schema_index_std,
	init_data_index_std.

init_schema_index_std :-
	%% oms_cn(Cid,Label,NatCid,Sou)
	index(oms_cn(_,_,_,_),[1,2,3]),
	%% oms_sc(SubCid,SupCid)
	index(oms_sc(_,_),[1,2]),
	%% oms_rln(SCid,RCid,TCid)
	index(oms_rln(_,_,_),[1+2,1,2+3]),
%%	index(oms_rln(_,_,_),[1+2,1,16'0283]),
	%% oms_strel(SCid,RCid,TCid)
	index(oms_strel(_,_,_),[1+2,1]),
	%% oms_schrel(SCid,RCid,TCid)
	index(oms_schrel(_,_,_),[1+2,1]).

init_data_index_std :-
	%% oms_obj(Oid,Name,Native_Id,Src)
	%% TLS, objects will "mostly" be unique w.o. source, so to save
	%% a little space, I'm not changing the index yet.
	index(oms_obj(_,_,_,_),[1,3]),
	%% oms_mo(Oid,Cid)
	index(oms_mo(_,_),[1,2]),
	%% oms_at(Oid,RCid,TCid)
	index(oms_at(_,_,_),[1+2,1,2+3]),
%%	index(oms_at(_,_,_),[1+2,1,16'0283]),
	%% oms_ao(Oid,RCid,TOid)
	index(oms_ao(_,_,_),[1+2]).

init_ext_dynamic :-
	dynamic(class_ext/3), %% class_ext(Label,NatCId,Sou)
	dynamic(subclass_ext/4), 
	%% subclass_ext(SubNatCid,SubSource,SupNatCid,SupSource)
	dynamic(relationship_ext/6), 
	%% relationship_ext(SNCId,SSrc,RNCId,RSrc,TNCId,TSrc)
	dynamic(strel_ext/6), 
	%% strel_ext(SNCId,SSrc,RNCId,RSrc,TNCId,TSrc)
	dynamic(schrel_ext/6), 
	%% schrel_ext(SNCId,SSrc,RNCId,RSrc,TNCId,TSrc)
	dynamic(object_ext/3), %% object_ext(Name,Native_Id,Src)
	dynamic(memberof_ext/4), %% memberof_ext(NOId,NCId,Source)
	dynamic(attribute_ext/6) ,
        %% attribute_ext(OId,Osrc,RNCId,RSrc,TNCId,TSrc)
	dynamic(attribute_object_ext/6). 
        %% attribute_object_ext(OId,Osrc,RNCId,RSrc,TOId,Tsrc)

init_oms_rels :-
	(oms_cn(_,_,_,_) -> true ; conset('_cid_ctr',0)),

	(oms_obj(_,_,_,_) -> true ; conset('_oid_ctr',0)),

	newClass('OMS Root',unk,'OMS',RootCid) ,

	newClass('OMS Relations',RootCid,'OMS',RelCid),

	newClass('OMS Inheritable Relationships',RelCid,'OMS',Inhid),

	newClass('Definition',Inhid,'OMS',_Defid),
	newClass('Necessary Condition',Inhid,'OMS',_Necessid),
	newClass('Sufficient Condition',Inhid,'OMS',_Suffid),

	newClass('OMS Set-Valued Relations',RelCid,'OMS',StrelId),

	/* Now description is just a type of strel */
	newClass('Descriptions',StrelId,'OMS',_Did),

	newClass('OMS Primitive Types',RootCid,'OMS',TypesCid),
	newClass([],TypesCid,'OMS',_Nullid),
	assert_basic_types(TypesCid).

oms_primitive_type(aint(_)).
oms_primitive_type(atom(_)).
oms_primitive_type(cardinal(_)).
oms_primitive_type(float(_)).
oms_primitive_type(integer(_)).
oms_primitive_type(object(_)).
oms_primitive_type(clause(_,_)).

assert_basic_types:- 
 	newClass('OMS Root',unk,'OMS',RootCid),
	newClass('OMS Primitive Types',RootCid,'OMS',TypesCid),
	assert_basic_types(TypesCid).

/* Note: Cid must be unified with Native ID for external dumping to
 work.  Do NOT use newClass for these -- variable handling has been
 taken out of that predicate.  */
assert_basic_types(TypsCid):- 
	newPrimitiveClass('AINT/1',TypsCid,aint(X),'OMS',aint(X)),
	newPrimitiveClass('ATOM/1',TypsCid,atom(X),'OMS',atom(X)),
	newPrimitiveClass('CARDINAL/1',TypsCid,cardinal(X),'OMS',cardinal(X)),
	newPrimitiveClass('FLOAT/1',TypsCid,float(X),'OMS',float(X)),
	newPrimitiveClass('INTEGER/1',TypsCid,integer(X),'OMS',integer(X)),
	newPrimitiveClass('OBJECT/1',TypsCid,object(_),'OMS',object(_,_)),
	newPrimitiveClass('CLAUSE/2',TypsCid,clause(X,Y),'OMS',clause(X,Y)).

newPrimitiveClass(Name,ParentCid,NewCid,Source,NativeID):- 
	(oms_cn(NewCid,Name,NativeID,Source) -> true 
           ; 
	   UpdateList = [asserta(oms_cn(NewCid,Name,NativeID,Source)),
		      asserta(oms_sc(NewCid,ParentCid))],
           oms_update_list(UpdateList)).

oms_primitive_class(aint(X),'AINT/1',aint(X),'OMS').
oms_primitive_class(atom(X),'ATOM/1',atom(X),'OMS').
oms_primitive_class(cardinal(X),'CARDINAL/1',cardinal(X),'OMS').
oms_primitive_class(float(X),'FLOAT/1',float(X),'OMS').
oms_primitive_class(integer(X),'INTEGER/1',integer(X),'OMS').
oms_primitive_class(clause(X,Y),'CLAUSE/2',clause(X,Y),'OMS').
oms_primitive_class(object(X),'OBJECT/1',object(Y,Z),'OMS') :-
	(nonvar(X)
	 ->	object(X,_,Y,Z)
	 ; nonvar(Y),nonvar(Z)
	 ->	object(X,_,Y,Z)
	 ;	true
	).

%% Given a OMS in memory, initialize ID counters to max used.
oms_initialize_ctrs :-
	(conset('_$maxctr',0),
	 (oms_cn(Cid,_,_,_) ; cn_id_map(Cid,_,_,_)),
	 integer(Cid),
	 conget('_$maxctr',Cnt),
	 Cid > Cnt,
	 conset('_$maxctr',Cid),
	 fail
	 ;
	 conget('_$maxctr',CCnt),
	 conset('_cid_ctr',CCnt)
	),
	(conset('_$maxctr',0),
	 (oms_obj(Oid,_,_,_) ; ob_id_map(Oid,_,_,_)),
	 conget('_$maxctr',Cnt),
	 Oid > Cnt,
	 conset('_$maxctr',Oid),
	 fail
	 ;
	 conget('_$maxctr',OCnt),
	 conset('_oid_ctr',OCnt)
	).

newcid(NatCid,Source,Cid):- 
	(atomic(NatCid) -> atomic_newcid(Cid) ; 
	    parameterized_ext_int(NatCid,Cid,Source)).

atomic_newcid(Cid) :-
	conget('_cid_ctr',OCid),
	Cid is OCid+1,
	conset('_cid_ctr',Cid).

%%% CLASS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(class/4,"@tt{class(Cid,Name,NatCid,Source)} retrieves a
class with internal ID of @tt{Cid}, name of @tt{Name}, native ID of
@tt{NatCid}, and source @tt{Source}.

In the case in which @tt{Cid} or @tt{NatCid} are instantiated to
parameterized classes, and they do not unify with a currently loaded
class, a check will be made to see if they are subsumed by a currently
loaded class, returning the name and/or source of the subsuming class.
The @tt{Cid} and @tt{NatCid}, are those of the subsued class -- there
is always a 1-1 relation between the @tt{NatCid} and @tt{Cid} of any
fact in any OMS.

Finally, @tt{class/4} will access either Internal or External
Intensional facts as needed.

@em{Technical Point}.  @pred{class/4} will also intern
@pred{cn_id_map/4} relations as needed for External Intensional facts.
").

/* TLS: check unbound calls to get_class_int to make sure they properly
   handle intensional parameterized classes. Non-deterministic unless
   the first conditional is true.
*/
class(Cid,Label,NatCid,Sou) :-
	nonvar(Cid) ->
	%%	(ground(Cid) ; nonvar(Cid),oms_primitive_type(Cid)) -> %% did not take care of param classes with non-ground primitive classes as arguments or of param classes with some arguments being variables
	        class_cidbound(Cid,Label,NatCid,Sou) 
          ; (nonvar(NatCid) ->
                   class_nidbound(Cid,Label,NatCid,Sou) 
               ;
       (           oms_cn(Cid,Label,NatCid,Sou) ;
                   get_class_int(Cid,Label,NatCid,Sou))).

/* Succeed if you can unify with an internal CID or external
   intensional CID.  Otherwise, if NID is a parametrized class, get
   the skeleton and check subsumption against extensional and
   intensional classes.  Extra unification of non-para terms (first
   w. unification of term and then with skeleton) "optimizes" for
   atomic CIDs.  This predicate is deterministic, as CID is
   instantiated. 

TLS: changed to fix problem in, e.g. class(object(1),X,Y,Z)
*/

class_cidbound(Cid,Label,NatCid,Sou):-
     (oms_primitive_class(Cid,Label,NatCid,Sou) -> true
      ;	(oms_cn(Cid,Label,NatCid,Sou) -> true 
         ; (cn_id_map(Cid,Label,NatCid,Sou)  -> true 
            ; (\+ atomic(Cid),
               skeleton(Cid,Cidskel), 
              ( (oms_cn(Cidskel,Label,_Natid1,Sou),
                 term_subclass(Cid,Cidskel), 
		 parameterized_int_ext(Cid,NatCid,Sou))
	         -> true 
	            ; cn_id_map(Cidskel,Label,_NatCid1,Sou),
                          term_subclass(Cid,Cidskel), 
                          % get NID of orig. CID, not of subsuming CID
	              parameterized_int_ext(Cid,NatCid,Sou)))))).

/* This predicate assumes that CID is not fully instantiated, and that
   source may not be bound: determinism is therefore not enforced.

   If the Native CID is atomic, we check extensional or external
   intensional as usual -- interning the intensional mapping if
   necessary.  Otherwise, things get more complicated.  We first try
   to check oms_cn (a heuristic hack); otherwise we transform the
   Native_id to a CID, interning cn_int_maps as we go.  Finally, we
   check to see whether the transformed CID is subsumed by extensional
   or external intensional.  

   If a call is made along the lines of class(Q,W,h(E,R,T,Y),U) it
   will succeed against whatever it unifies with internaly or
   ext_int-ally.  This is in analogy to our handling of
   the goal class(h(E,R),W,T,U).

*/

/* TLS: the following could be optimized more. */
class_nidbound(Cid,Label,NatCid,Sou):- 	
	oms_primitive_class(Cid,Label,NatCid,Sou).
class_nidbound(Cid,Label,NatCid,Sou):- 
%	atomic(NatCid),!,
	\+ oms_primitive_class(Cid,Label,NatCid,Sou),
        (oms_cn(Cid,Label,NatCid,Sou)
         ; get_class_int(Cid,Label,NatCid,Sou)).
class_nidbound(Cid,Label,NatCid,Sou):- 
	\+ oms_primitive_class(Cid,Label,NatCid,Sou),
	\+ oms_cn(Cid,Label,NatCid,Sou),
	/* TLS: use cn_id_map rather than get_class_int for efficiency  */
            \+ cn_id_map(Cid,Label,NatCid,Sou),
	NatCid =.. [Functor|List],
	class_nidbound_1(List,NewList,NatCid),
	Cid =.. [Functor|NewList],
	skeleton(Cid,CidSkel),
	        (oms_cn(CidSkel,Label,_NatSkel,Sou),
	         term_subclass(Cid,CidSkel)
	         ;
	         term_get_class_int(Cid,Label,NatCid,Sou)).

class_nidbound_1([],[],_).
class_nidbound_1([_H],_,Term):- !,
	oms_error(update,('Cannot intern the class:',Term)).
% TLS: taken out only ground NIDS make it here
%  (see comment for class_nidbound)
%class_nidbound_1([Nid,S|T],[_|T1],Term):- 
%        var(Nid),var(S), !,class_nidbound_1(T,T1,Term).
class_nidbound_1([Nid,S|T],[Cid|T1],Term):- 
	(atomic(Nid) -> class_or_abort(Nid,S,Cid,Term)
	   ; ext_int(Cid,_Label,Nid,S)),
	class_nidbound_1(T,T1,Term).

call_assert(Term):- (call(Term) -> true ; asserta(Term)).

%-------------------------------------------------------------
/* Supporting routines to produce a Cid from External Intensional
 * rules. 
 *
 * TLS: fixed buglet.  Dont know if this one will go away when I rethink
   terms in subclass. */

term_get_class_int(GoalCid,Label,NatCid,Sou) :-
	skeleton(NatCid,NatSkel),
	(cn_id_map(NewCid,Label,NatSkel,Sou),
	 term_subclass(GoalCid,NewCid)
	 ->	true
	 ;	(class_int(Label,NatCid,Sou),
	         %%ext_int(GoalCid,Label,NatCid,Sou)
		 create_new_para_cid_for_int(NatCid,GoalCid,Sou,Label)
		 ->	true
		 ;	class_int(Label,NatSkel,Sou),
			create_new_para_cid_for_int(NatSkel,CidNew,
			                                            Sou,Label),
			%%ext_int(CidNew,Label,NatSkel,Sou),
			term_subclass(GoalCid,CidNew) )
	).	

get_class_int(Cid,Label,NatCid,Sou) :-
	class_int(Label,NatCid,Sou),
	(cn_id_map(Cid,Label,NatCid,Sou)
	 ->	true
	 ;	atomic_newcid(Cid),
		asserta(cn_id_map(Cid,Label,NatCid,Sou))
	).	

ext_int(Cid,Label,NatCid,Sou):- 
	atomic(NatCid),!,
        (oms_cn(Cid,Label,NatCid,Sou) -> true 
         ; get_class_int(Cid,Label,NatCid,Sou)).
ext_int(Cid,Label,NatCid,Sou):- 
	oms_primitive_class(Cid,Label,NatCid,Sou).
ext_int(Cid,Label,NatCid,Sou):- 
	\+ oms_primitive_class(Cid,Label,NatCid,Sou),
	parameterized_ext_int(NatCid,Cid,Sou).

parameterized_ext_int(NatCid,Cid,_Sou):- 
	NatCid =.. [Functor|List],
	parameterized_ext_int_1(List,NewList,NatCid),
	Cid =.. [Functor|NewList].

parameterized_ext_int_1([],[],_).
parameterized_ext_int_1([_H],_,Term):- !,
	oms_error(update,('Cannot intern the class:',Term)).
parameterized_ext_int_1([Nid,Sou|T],[Cid|T1],Term):- 
	(atomic(Nid) -> class_or_abort(Nid,Sou,Cid,Term)
	   ; ext_int(Cid,_,Nid,Sou)),
	parameterized_ext_int_1(T,T1,Term).

class_or_abort(Nid,Source,Cid,_Term):- class(Cid,_,Nid,Source),!.
class_or_abort(H,S,_N,Term):-
	oms_error(update,('Cannot find class for',H,S,'in',Term)).

%-------------------------------------------------------------

/* TLS changing the published inteface for consisetency */
retractall_class(Cid,Name,NatCid,Sou):- 
	retractallClass(Cid,Name,NatCid,Sou).

:- comment(retractallClass/4,

"@tt{retractallClass(Cid,Name,NatCid,Sou)} retracts all classes in
Internal Format that match the arguments.  It will not affect classes
in External Intensional Format.  Note it is the user's responsibility
to remove all references to this class.  (@em{TLS: add documentation
about obliterate_class})").

retractallClass(Cid,Label,NatCid,Sou) :-
	oms_update_list([retractall(oms_cn(Cid,Label,NatCid,Sou))]).

:- comment(newClass/4, "@tt{newClass(Name,ParentCid,Source,NewCid)}
creates a new class and adds it to the ontology.  It calls
@pred{newClass/5} passing Name as the native ID.").

newClass(Name,ParentCid,Source,NewCid) :-
	newClass(Name,ParentCid,Name,Source,NewCid).

:- comment(newClass/5,
"@tt{newClass(Name,ParentCid,NativeId,Source,-NewCid)} creates a new
class and adds it to the ontology.  
@begin{itemize}
@item Name is the name of the new class and must be instantiated to an atom;
@item ParentCid is the class ID of this node's parent, if known and @tt{unk}
if not.  
@item NativeID must be instantiated to a valid NativeId: and must be
either an atom or the native id for a parameterized class.
@item Source is the source ontology, used to disambiguate native ids
when ontologies are merged.  It must be instantiated to an atom.
@item @tt{NewCid} must be a variable; it will be instantiated to the new Cid.
@end{itemize}

If there is already a class (defined via @pred{oms_cn/4} or
@pred{class_int/3} with the given @tt{NatCid} and @tt{Source}, then
that the id of that class is returned in @tt{NewCid}.  If a new class
is added, it is added in Internal Format, as a @pred{oms_cn/4} fact.").

newClass(Name,ParentCid,NativeId,Source,NewCid) :-
	newClass(Name,ParentCid,NativeId,Source,NewCid,UpdateList,[]),
	oms_update_list(UpdateList).

newClass(Name,ParentCid,NativeId,Source,NewCid,UpdateList0,UpdateList) :-
	check_new_name(Name,class(Name,NativeId,Source)),
	check_new_nid(NativeId,class(Name,NativeId,Source)),
	check_new_source(Source,class(Name,NativeId,Source)),
	(var(NewCid)
	 ->	(class(NewCid,Name0,NativeId,Source)  % old class
		 ->	add_parent_if_nec(NewCid,Name,ParentCid,UpdateList0,UpdateList),
			(Name \== Name0
			 ->	oms_warning(update,('newClass called with old NativeId and Source [',
						    NativeId,', ',Source,
						    '] but new Name [',Name,', ',Name0,']'))
			 ;	true
			)
		 ;	check_source_consistency(NativeId,Source),
		        newcid(NativeId,Source,NewCid), % new class
			UpdateList0 = [asserta(oms_cn(NewCid,Name,NativeId,Source))|UpdateList1],
			add_parent_if_nec(NewCid,Name,ParentCid,UpdateList1,UpdateList)
		)
	 ;	oms_warning(update,('newClass needs a variable in CID: ',
                                    NewCid,', ',Name,', ',
                                    NativeId,', ',Source)),
		UpdateList0=UpdateList
	).

/* Code as of 7/24 
newClass(Name,ParentCid,NativeId,Source,NewCid,UpdateList0,UpdateList) :-
	check_new_name(Name,class(Name,NativeId,Source)),
	check_new_nid(NativeId,class(Name,NativeId,Source)),
	check_new_source(Source,class(Name,NativeId,Source)),
	(var(NewCid)
	 ->	(class(NewCid,OldName,NativeId,SourceO) % old class
		 ,(SourceO=='OMS';SourceO==Source)    % dont muck around w OMS!
		 ->	(OldName == Name
			 ->    add_parent_if_nec(NewCid,Name,ParentCid,
                                                 UpdateList0,UpdateList)
			    ;  oms_warning(update,('newClass called with ',
                                      ' old NativeId and Source, but new Name',
				      Name,OldName,NativeId,SourceO)),
			        fail
			)
		 ;	check_source_consistency(NativeId,Source),
		        newcid(NativeId,Source,NewCid), % new class
			UpdateList0 = [asserta(oms_cn(NewCid,Name,NativeId,Source))|UpdateList1],
			add_parent_if_nec(NewCid,Name,ParentCid,UpdateList1,UpdateList)
		)
	 ;	oms_warning(update,('newClass needs a variable in CID: ',
                                    NewCid,Name,NativeId,Source)),
		UpdateList0=UpdateList
	).
*/


/* Note that this predicate should be folded into newClass (which   predicate should also be made more maintainable */
check_source_consistency(Nid,Source):- 
	(atomic(Nid) -> true ; 
	    check_source_consistency_1(Nid,Source)).

check_source_consistency_1(Nid,Source):-
	    skeleton(Nid,Skel),
	    (oms_cn(_,_,Skel,Source1) ; cn_id_map(_,_,Skel,Source1)),
	    Source1 \== Source,!,
	    oms_warning(update,('Cannot create a class for ',Nid,' in ',Source,
  	                    ' since ',Skel,' is already used for ',Source1,
	 	            ' ontology.')).
check_source_consistency_1(_,_).

add_parent_if_nec(_,_,unk,UdL,UdL) :- !.
add_parent_if_nec(NewCid,_,ParentCid,UdL,UdL) :-
	immediate_subclass(NewCid,ParentCid),!.
add_parent_if_nec(NewCid,_,ParentCid,
                               [asserta(oms_sc(NewCid,ParentCid))|UdL],UdL) :-
	class(ParentCid,_,_,_),!.
add_parent_if_nec(NewCid,Name,ParentCid,_,_) :-
	oms_warning(update,('No parent class for ',ParentCid,
                            ' of ',Name:NewCid)),
	fail.

:- comment(updateClass/4,"@tt{updateClass(Cid,Name,NatId,Source)}
updates @tt{Name}, @tt{Native Id}, and/or @tt{Source} information for
the class identified with @tt{CID} -- as long as that class is defined
by an internal fact of the predicate @tt{oms_cn/4}.  Its intended use
is in editors or other GUIs that may manipulate names and identifiers
of classes.").

updateClass(Cid,Label,NatId,Source) :-
	nonvar(Cid),
	class(Cid,_,_,_),
	oms_update_list([retractall(oms_cn(Cid,_,_,_)),
			 asserta(oms_cn(Cid,Label,NatId,Source))]).

%%% SUBCLASS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(subclass/2,"@tt{subclass(SubCid,SupCid)} is true if class
SubCid is semantically a subset of class SupCid.  For non-primitive
classes, @pred{subclass/2} is the reflexive transitive closure of
@pred{immediate_subclass/2} and tuple subsumption.  For an example of
tuple subsumption, f(a,source1,b,source2) may be a subclass of
f(c,source1,b,souce2) if a is a subset of c in source 1 (see @ref{OMS:
External Format}).  For primitive types, term subsumption is used
instead of tuple subsumption -- for example integer(5) is a subclass
of integer(_).  Only terms appearing in explicit class definitions are
generated (not all their instances), but for testing (i.e. a
bound/bound call), subsumed terms are handled.  ").

%%%:- table subclass/2.

subclass(One,Two):- 
	nonvar(One),var(Two),!,
	subclass_bf(One,Two).
subclass(One,Two):- 
	nonvar(One),nonvar(Two),!,
	subclass_bb(One,Two).
subclass(One,Two):- 
	var(One),nonvar(Two),!,
	subclass_fb(One,Two).
subclass(One,Two):- 
	inner_subclass_ff(One,Two).

/* Primitive types are handled separately in 3rd clause
 * because variables must be handled */
subclass_bb(One,Two):- 
	integer(One),!,
	inner_subclass_bb(One,Two).
subclass_bb(One,Two):- 	/* One is a term */
	integer(Two),!,
	subclass_bb_1(One,Two).
subclass_bb(One,Two):- /* One is a term, Two is a term */
	oms_primitive_type(One),
	!,subsumes(Two,One).  
subclass_bb(One,Two):- /* One is a non-primitive term, Two is a term */
	term_subclass(One,Two).

/* One is a Term, Two is an integer */
subclass_bb_1(One,Two):- 
	oms_primitive_type(One),!,
	inner_subclass_bb(One,Two).
/* One is a non-primitive term, Two is an integer.
 * Thus, we need not check the immediate subclass, Mid, 
 * which must be a term */
subclass_bb_1(One,Two):- 
	skeleton(One,Oneskel),
	inner_immediate_subclass(Oneskel,Mid),
	term_subclass(One,Oneskel),
	inner_subclass_bb(Mid,Two).

/* On second clause, want integer(5) to be a subclass of itself and of
integer(X), but want integer(X) only to be a sc of itself. */

subclass_bf(One,Two):- integer(One),!, 
	inner_subclass_bf(One,Two).
subclass_bf(One,Two):- 
	oms_primitive_type(One),!, 
	(One = Two ;
	 (ground(One) -> 
	     skeleton(One,Oneskel),
	     inner_immediate_subclass(Oneskel,Mid),
	     inner_subclass_bf(Oneskel,Two) 
	 ;   
	     inner_immediate_subclass(One,Mid),
	     inner_subclass_bf(Mid,Two))).  
subclass_bf(One,Two):- 
	One = Two 
    ;   skeleton(One,Oneskel), 
	inner_immediate_subclass(Oneskel,Mid),
	prim_or_not_term_subclass(One,Oneskel), 
	(Oneskel == One -> 
	    inner_subclass_bf(Mid,Two) 
	  ; inner_subclass_bf(Oneskel,Two)).

subclass_fb(One,Two):- 
	integer(Two),!,
	inner_subclass_fb(One,Two).  
subclass_fb(One,One):-
	skeleton(One,Oneskel), class(Oneskel,_,_,_),
	prim_or_not_term_subclass(One,Oneskel).

%%% subclass(-,-).
inner_subclass_ff(Sub,Sub).
inner_subclass_ff(Sub,Sup) :-
	inner_immediate_subclass(Sub,Par),
	inner_subclass_bf(Par,Sup).

%%% subclass(+,+).
inner_subclass_bb(Sub,Sub).
inner_subclass_bb(Sub,Sup) :-
	inner_immediate_subclass(Sub,Par),
	inner_subclass_bf(Par,Sup).

%%% subclass(+,-).
inner_subclass_bf(Sub,Sub).
inner_subclass_bf(Sub,Sup) :-
	inner_immediate_subclass(Sub,Par),
	inner_subclass_bf(Par,Sup).

%%% subclass(-,+).
inner_subclass_fb(Sup,Sup).
inner_subclass_fb(Sub,Sup) :-
	inner_immediate_subclass(Child,Sup),
	inner_subclass_fb(Sub,Child).

skeleton(Term,Term1):- 
	functor(Term,T,A),
	functor(Term1,T,A).

prim_or_not_term_subclass(One,Oneskel):- 
	(oms_primitive_type(Oneskel) -> true ; term_subclass(One,Oneskel)).

/* assumes Term1 and Term2 both have the same outer functor */
term_subclass(Term1,Term2):- 
	Term1 =.. [F|R1],
	Term2 =.. [F|R2],
	term_subclass_list(R1,R2).

term_subclass_list([],[]).
term_subclass_list([H|T],[H1|T1]):- 
	once(subclass(H,H1)),
	term_subclass_list(T,T1).

:- comment(proper_subclass/2, "@tt{proper_subclass(SubCid,SupCid)} is
true if SubCid is a subclass of SupCid but is not the same class").

proper_subclass(SubCid,SupCid) :-
	subclass(SubCid,SupCid),
	SubCid \== SupCid.

:- comment(immediate_subclass/2,
"@tt{immediate_subclass(SubCid,SupCid)} is true if there is a
corresponding fact in @pred{oms_sc/2} or in the intensional rules.  In
other words, it succeeds if @tt{SubCid} is an immediate subclass of
@tt{SupCid} in the Taxonomy.").

inner_immediate_subclass(SubCid,SupCid) :- 
	oms_sc(SubCid,SupCid).
inner_immediate_subclass(CCid,PCid) :-
	immediate_subclass_int(CCid,PCid).

immediate_subclass(SubCid,SupCid) :- 
	nonvar(SubCid),
        skeleton(SubCid,SubSkel), 
	oms_cn(SubSkel,_Label,_Natid1,_Sou),
	term_subclass(SubCid,SubSkel),
	SubCid \== SubSkel,
	SupCid = SubSkel.
immediate_subclass(SubCid,SupCid) :- 
	oms_sc(SubCid,SupCid).
immediate_subclass(CCid,PCid) :-
	immediate_subclass_int(CCid,PCid).

immediate_subclass_int(CCid,PCid) :-
	(nonvar(CCid)
	 ->	class(CCid,_,CNatId,CSou),
		immediate_subclass_int(CNatId,CSou,PNatId,PSou),
		class(PCid,_,PNatId,PSou)
	 ; nonvar(PCid)
	 ->	class(PCid,_,PNatId,PSou),
		immediate_subclass_int(CNatId,CSou,PNatId,PSou),
		class(CCid,_,CNatId,CSou)
	 ;	immediate_subclass_int(CNatId,CSou,PNatId,PSou),
		class(CCid,_,CNatId,CSou),
		class(PCid,_,PNatId,PSou)
	).

:- comment(assert_subclass/2, "@tt{assert_subclass(SubCid,SupCid)}
adds a new subclass-superclass pair to the taxonomy, if it's not
already there.").
assert_subclass(SubCid,SupCid) :- newSubclass(SubCid,SupCid).

:- comment(retractallSubclass/2,
"@tt{retractallSubclass(SubCid,SupCid)} deletes all unifying
@pred{oms_sc/2} facts from the Internal Format of the ontology.  It
does not affect facts defined via @pred{immediate_subclass_int/4}.").

retractallSubclass(SubCid,SupCid) :-
	oms_update_list([retractall(oms_sc(SubCid,SupCid))]).

/* TLS for consistency */
retractall_subclass(SubCid,SupCid) :-
	retractallSubclass(SubCid,SupCid).

:- comment(newSubclass/2,"@tt{NewSubclass(SubCid,SupCid)} adds a new
@pred{oms_sc/2} fact (Internal Format) to the ontology, if it is not
already present in the Programmer's View (i.e. the transitive closure
of @pred{oms_sc/2}, @pred{immediate_subclass_int/4} and term subsumption for
parameterized classes).  ").

newSubclass(CCid,PCid) :-
	check_incremental_constraints(subclass(CCid,PCid)),
	newSubclass(CCid,PCid,Updates,[]),
	oms_update_list(Updates).

newSubclass(CCid,PCid,UpD0,UpD) :-
	(subclass(CCid,PCid)  % was if_
	 ->	UpD0 = UpD
	 ;	insert_new_subclass(CCid,PCid,UpD0,UpD)).

insert_new_subclass(CCid,PCid,Upd0,Upd):- 
	sc_parent_exists(CCid),
	sc_child_exists(PCid),
	Upd0 = [asserta(oms_sc(CCid,PCid))|Upd].

sc_parent_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('newSubclass: no existing parent class with ',
		               'CID: ',SCid)),
	  	   fail).

sc_child_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('newSubclass: no existing child class with ',
		     'CID: ',SCid)),
	  	   fail).

%%% RELATIONSHIP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(is_a_relation/1, "@pred{is_a_relation/1} is
the disjunction of @pred{is_an_inheritable_relationship/1},
@pred{is_a_schrel/1} and @pred{is_a_strel/1}.").

is_a_relation(RCid) :-
	is_an_inheritable_relationship(RCid).
is_a_relation(RCid) :-
	is_a_strel(RCid).
is_a_relation(RCid) :-
	is_a_schrel(RCid).

%%% (Inheritable) RELATIONSHIP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(is_an_inheritable_relationship/1,
"@tt{is_an_inheritable__relationship(RCid)} checks that @tt{RCid} is
the class ID of a subclass of @tt{OMS Inheritable Relationships}.  If
@tt{RCid} is unbound, all such (proper) subclasses are returned
nondeterministically.").

is_an_inheritable_relationship(RCid) :-
	class(RelsCid,'OMS Inheritable Relationships',
	              'OMS Inheritable Relationships','OMS'),
	(nonvar(RCid)
	 ->	subclass(RCid,RelsCid), RCid \== RelsCid	% was if_
	 ;	findall(RCid,(subclass_fb(RCid,RelsCid), RCid \== RelsCid),URCids),
		sort(URCids,RCids), % eliminate duplicates from multiple parents
		member(RCid,RCids)
	).

:- comment(immediate_irel/3, "@tt{immediate_irel(SCid,RCid,TCid)}
accesses facts stored directly in @pred{oms_rln/3} in the ontology, or
defined via intensional rules.").

immediate_irel(SCid,RCid,TCid) :- 
	immediate_relationship(SCid,RCid,TCid).

/***immediate_relationship(SCid,RCid,TCid) :-
	(ground(SCid),class_cidbound(SCid,L1,N1,S1) -> Sou=class(SCid,L1,N1,S1) ; Sou = class(SCid,????)),
	(ground(RCid),class_cidbound(RCid,L2,N2,S2) -> Rel=class(RCid,L2,N2,S2) ; Rel = class(RCid,????)),
	(ground(TCid),class_cidbound(TCid,L3,N3,S3) -> Targ=class(TCid,L3,N3,S3) ; Targ = class(TCid,????)),
	writeln(reln(Sou,Rel,Targ)),
	fail.***/
immediate_relationship(SCid,RCid,TCid) :- 
	oms_rln(SCid,RCid,TCid).
immediate_relationship(SCid,RCid,TCid) :-
	immediate_relationship_int(SCid,RCid,TCid).

immediate_relationship_int(SCid,RCid,TCid) :-
	(nonvar(SCid)
	 ->	(nonvar(RCid)
		 ->	class(SCid,_,SNatId,SSou),
			class(RCid,_,RNatId,RSou),
			immediate_relationship_int(SNatId,SSou,
                                                   RNatId,RSou,TNatId,TSou),
			class(TCid,_,TNatId,TSou)
		 ;	class(SCid,_,SNatId,SSou),
			immediate_relationship_int(SNatId,SSou,
                                         RNatId,RSou,TNatId,TSou),
			class(RCid,_,RNatId,RSou),
			class(TCid,_,TNatId,TSou)
		)
	 ;	immediate_relationship_int(SNatId,SSou,
	                                   RNatId,RSou,TNatId,TSou),
		class(SCid,_,SNatId,SSou),
		class(RCid,_,RNatId,RSou),
		class(TCid,_,TNatId,TSou)
	).

irel(SCid,RCid,TCid) :-
	relationship(SCid,RCid,TCid).

:- comment(relationship/3, "@tt{relationship(SCid,RCid,TCid)} defines
the inheritable relationship predicate, where @tt{SCid} is the source
Class ID, @tt{RCid} is the relationship class ID, and @tt{TCid} is the
target class ID.  For these inheritable relationships, the taxonomy is
traversed and the most specific relationships consistent with the
parameters are returned.  ").

relationship(SCid,RCid,TCid) :-
	var(SCid),var(RCid),var(TCid), !,
	immediate_relationship(SCid,RCid,TCid).
relationship(SCid,RCid,TCid) :-
	var(RCid), !,  %% relationship is free var
	is_an_inheritable_relationship(RCid),
	relationship_inh_fr(SCid,RCid,TCid).
relationship(SCid,RCid,TCid) :-
	%%is_an_inheritable_relationship(RCid),  %% should be error if this is false
	relationship_inh(SCid,RCid,TCid).

:- table relationship_inh_fr/3.
relationship_inh_fr(SCid,RCid,TCid) :-
	OutTerm = rln(SCid,RCid,TCid),
	copy_term(OutTerm,CopyTerm),
	relationship_inh_gen_fr(SCid,RCid,TCid),
	(more_specific_relationship(OutTerm,CopyTerm) -> fail ; true).

:- table relationship_inh/3.
relationship_inh(SCid,RCid,TCid) :-
	OutTerm = rln(SCid,RCid,TCid),
	copy_term(OutTerm,CopyTerm),
	relationship_inh_gen(SCid,RCid,TCid),
	(more_specific_relationship(OutTerm,CopyTerm) -> fail ; true).

:- table relationship_inh_gen/3.
relationship_inh_gen(SCid,RCid,TCid) :-
	subclass(RCidP,RCid),
	relationship_inh_gen_fr(SCid,RCidP,TCid).

:- table relationship_inh_gen_fr/3.
relationship_inh_gen_fr(SCid,RCid,TCid) :-
	(var(SCid)
	 ->	(var(TCid)
		 ->	immediate_relationship(SCid,RCid,TCid)
		 ;	subclass(TCidP,TCid),
			immediate_relationship(SCid,RCid,TCidP)
		)
	 ;      subclass(SCid,SCidP),
		immediate_relationship(SCidP,RCid,TCidP),
		(var(TCid)
		 ->	TCid = TCidP
		 ;	subclass(TCidP,TCid) % was if_
		)
	).

/*** old definitions, without reverse indexing:
relationship_inh_gen(SCid,RCid,TCid) :-
%%	subclass(RCid,RCidP),
	subclass(RCidP,RCid),
	subclass(SCid,SCidP),
	immediate_relationship(SCidP,RCidP,TCidP),
	(var(TCid)
	 ->	TCid = TCidP
	 ;	subclass(TCidP,TCid)	% was if_
	).
:- table relationship_inh_gen_fr/3.
relationship_inh_gen_fr(SCid,RCid,TCid) :-
	subclass(SCid,SCidP),
	immediate_relationship(SCidP,RCid,TCidP),
	(var(TCid)
	 ->	TCid = TCidP
	 ;	subclass(TCidP,TCid)	% was if_
	).
****/


more_specific_relationship(OutTerm,CopyTerm) :-
	CopyTerm = rln(SCidO,RCidO,TCidO),
	OutTerm = rln(SCid,RCid,TCid),
	relationship_inh_gen(SCidO,RCidO,TCidO),
	\+ variant(OutTerm,CopyTerm),	
%%	if_subclass(RCid,RCidO),
	subclass(RCidO,RCid),	% was if_
	subclass(SCid,SCidO),	% was if_
	subclass(TCidO,TCid).	% was if_

:- comment(assert_relationship/3,
"@tt{assert_relationship(SCid,RCid,TCid)} adds a new inheritable
relationship tuple to the ontology, if it is not already implied
(using inheritance if applicable) by the relationships already in the
ontology.  A relationship can be added only if @tt{RCid} is a subclass
of @tt{OMS Inheritable Relationships}").

assert_relationship(SCid,RCid,TCid) :-
	newRelationship(SCid,RCid,TCid).

:- comment(retractallRelationship/3,
"@tt{retractallRelationship(SCid,RCid,TCid)} retracts all stored
inheritable relationship tuples that unify with the parameters.  Note
that this is a syntactic operation that simply removes all matching
tuples in @pred{oms_rln/3}.  It does not affect information derived
via @pred{immediate_relationship_int/6}, and may not affect
information derived via inheritance.").

retractall_relationship(SCid,RCid,TCid) :-
	retractallRelationship(SCid,RCid,TCid).

retractallRelationship(SCid,RCid,TCid) :-
	oms_update_list([retractall(oms_rln(SCid,RCid,TCid))]).

:- comment(newRelationship/3, "@tt{newRelationship(SCid,RCid,TCidA)}
adds a new inheritable relationship to the ontology if it is not
already implied (through inheritance, if applicable) by the
relationships already in the ontology.").
newRelationship(SCid,RCid,TCidA) :-
	newRelationship(SCid,RCid,TCidA,Updates,[]),
	oms_update_list(Updates).

newIrel(SCid,RCid,TCidA):- 
	newRelationship(SCid,RCid,TCidA).

/* TLS main change is that I now also check that RCid is a class of
   relation */
newRelationship(SCid,RCid,TCidA,Upd0,Upd) :-
	standardize_value(TCidA,TCid),
	check_incremental_constraints(relationship(SCid,RCid,TCid)),
	(relationship(SCid,RCid,TCid)
	 ->	Upd0 = Upd
	 ; insert_new_relationship(SCid,RCid,TCidA,Upd0,Upd)).

insert_new_relationship(SCid,RCid,TCidA,Upd0,Upd):- 
	relationship_source_class_exists(SCid),
	relationship_relation_exists(RCid),
	relationship_target_class_exists(TCidA),
	Upd0 = [asserta(oms_rln(SCid,RCid,TCidA))|Upd].

relationship_source_class_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('attempt to add an inheritable ',
		    ' relationship where source is missing: ',SCid)),
	   fail).
relationship_relation_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('attempt to add an inheritable ',
		    ' relationship where source is missing: ',SCid)),
	   fail),
	(is_an_inheritable_relationship(SCid) -> true 
	 ; oms_warning(update,('attempt to add an inheritable ',
		    ' relationship for class that is not a ',
		    ' relationship: ',SCid)),
	   fail).
relationship_target_class_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('attempt to add an inheritable ',
		    ' relationship where target is missing: ',SCid)),
	   fail).

standardize_value(X,X) :- var(X), !.
standardize_value(integer(X),integer(Y)) :-
	(var(X)
	 ->	Y = X
	 ; integer(X)
	 ->	Y = X
	 ;	friendly_atom_codes(X,XC),
		number_codes(Y,XC),
		number_codes(Y,YC),
		YC = XC
	),
	!.
standardize_value(X,X).

%%% SET-VALUED RELATION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

:- comment(is_a_strel/1, "@tt{is_a_strel(RCid)} checks that @tt{RCid}
is the class ID of a subclass of @tt{OMS Set-Valued Relations}.  If
@tt{RCid} is unbound, all such (proper) subclasses are returned
nondeterministically.").

is_a_strel(RCid) :-
	class(RelsCid,'OMS Set-Valued Relations',
		      'OMS Set-Valued Relations','OMS'), 
	(nonvar(RCid)
	 ->	subclass(RCid,RelsCid), RCid \== RelsCid	% was if_
	 ;	subclass_fb(RCid,RelsCid), RCid \== RelsCid
	).

/* TLS: dont really need new def for immediate as there is no inh 
immediate_strel(SCid,RCid,TCid) :- strel(SCid,RCid,TCid).*/

:- comment(strel/3, "@tt{strel(SCid,RCid,TCid)} defines the semantic
set-valued relation predicate, where @tt{SCid} is the source Class
ID, @tt{RCid} is the relation class ID, and @tt{TCid} is the
target class ID. ").

strel(SCid,RCid,TCid) :- oms_strel(SCid,RCid,TCid).
strel(SCid,RCid,TCid) :- strel_int(SCid,RCid,TCid).

strel_int(SCid,RCid,TCid) :-
	(nonvar(SCid)
	 ->	(nonvar(RCid)
		 ->	class(SCid,_,SNatId,SSou),
			class(RCid,_,RNatId,RSou),
			strel_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
			class(TCid,_,TNatId,TSou)
		 ;	class(SCid,_,SNatId,SSou),
			strel_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
			class(RCid,_,RNatId,RSou),
			class(TCid,_,TNatId,TSou)
		)
	 ;	strel_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
		class(SCid,_,SNatId,SSou),
		class(RCid,_,RNatId,RSou),
		class(TCid,_,TNatId,TSou)
	).

:- comment(assert_strel/3, "@tt{assert_strel(SCid,RCid,TCid)} adds a
new set-valued relation tuple to the ontology, if it is not already
present.").

assert_strel(SCid,RCid,TCid) :-  newStrel(SCid,RCid,TCid).

:- comment(retractallStrel/3, "@tt{retractallStrel(SCid,RCid,TCid)}
retracts all set-valued relation tuples that unify with the
parameters.  Note that this is a syntactic operation that simply
removes all matching tuples in @pred{oms_strel/3}, but does not affect
@pred{strel_int/6}.").

retractall_strel(SCid,RCid,TCid) :-
	retractallStrel(SCid,RCid,TCid).

retractallStrel(SCid,RCid,TCid) :-
	oms_update_list([retractall(oms_strel(SCid,RCid,TCid))]).

:- comment(newStrel/3, "@tt{newStrel(SCid,RCid,TCidA)} adds a new
set-valued relation to the ontology if it is not already present.").

newStrel(SCid,RCid,TCidA) :-
	newStrel(SCid,RCid,TCidA,Updates,[]),
	oms_update_list(Updates).

/* TLS main change is that I now also check that RCid is a subclass of
   relation */
newStrel(SCid,RCid,TCidA,Upd0,Upd) :-
	standardize_value(TCidA,TCid),
	check_incremental_constraints(strel(SCid,RCid,TCid)),
	(strel(SCid,RCid,TCid)
	 ->	Upd0 = Upd
	 ; insert_new_strel(SCid,RCid,TCidA,Upd0,Upd)).

insert_new_strel(SCid,RCid,TCidA,Upd0,Upd):- 
	strel_source_class_exists(SCid),
	strel_relation_exists(RCid),
	strel_target_class_exists(TCidA),
	Upd0 = [asserta(oms_strel(SCid,RCid,TCidA))|Upd].

strel_source_class_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('attempt to add a ',
		    ' strel where source is missing: ',SCid)),
	   fail).
strel_relation_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('attempt to add a ',
		    'strel where strell class is missing: ',SCid)),
	   fail),
	(is_a_strel(SCid) -> true 
	 ; oms_warning(update,('attempt to add a ',
		    'strel for class that is not a strel: ',SCid)),
	   fail).
strel_target_class_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('attempt to add a ',
		    'strel where target is missing: ',SCid)),
	   fail).

%%% SCHEMA RELATION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(is_a_schrel/1, "@tt{is_a_schrel(RCid)} checks
that @tt{RCid} is the class ID of a subclass of @tt{OMS Schema
Relations}.  If @tt{RCid} is unbound, all such (proper) subclasses
are returned nondeterministically.").

is_a_schrel(RCid) :-
	class(RelsCid,'OMS Schema Relations',
	              'OMS Schema Relations','OMS'),
	(nonvar(RCid)
	 ->	subclass(RCid,RelsCid), RCid \== RelsCid	% was if_
	 ;	subclass_fb(RCid,RelsCid), RCid \== RelsCid
	).

:- comment(immediate_schrel/3, "@tt{immediate_schrel(SCid,RCid,TCid)}
accesses facts stored directly in @pred{oms_schrel/3} and information
produced via @pred{immediate_schrel_int/6}.").

immediate_schrel(SCid,RCid,TCid) :- oms_schrel(SCid,RCid,TCid).
immediate_schrel(SCid,RCid,TCid) :- immediate_schrel_int(SCid,RCid,TCid).

immediate_schrel_int(SCid,RCid,TCid) :-
	(nonvar(SCid)
	 ->	(nonvar(RCid)
		 ->	class(SCid,_,SNatId,SSou),
			class(RCid,_,RNatId,RSou),
			immediate_schrel_int(SNatId,SSou,
			                     RNatId,RSou,TNatId,TSou),
			class(TCid,_,TNatId,TSou)
		 ;	class(SCid,_,SNatId,SSou),
			immediate_schrel_int(SNatId,SSou,
			                     RNatId,RSou,TNatId,TSou),
			class(RCid,_,RNatId,RSou),
			class(TCid,_,TNatId,TSou)
		)
	 ;	immediate_schrel_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
		class(SCid,_,SNatId,SSou),
		class(RCid,_,RNatId,RSou),
		class(TCid,_,TNatId,TSou)
	).

:- comment(schrel/3, "@tt{schrel(SCid,RCid,TCid)} defines the semantic
schema relation predicate, where @tt{SCid} is the source Class ID,
@tt{RCid} is the relation class ID, and @tt{TCid} is the target
class ID.  Since schema relations are inheritable, the taxonomy is
traversed and the most specific schema relations consistent with the
parameters are returned.  ").

schrel(SCid,RCid,TCid) :-
	var(SCid),var(RCid),var(TCid), !,
	immediate_schrel(SCid,RCid,TCid).
schrel(SCid,RCid,TCid) :-
	var(RCid), !,  %% relation is free var
	is_an_inheritable_relationship(RCid),
	schrel_inh_fr(SCid,RCid,TCid).
schrel(SCid,RCid,TCid) :-
	%%is_an_inheritable_relationship(RCid),
	schrel_inh(SCid,RCid,TCid).

:- table schrel_inh_fr/3.
schrel_inh_fr(SCid,RCid,TCid) :-
	OutTerm = schrel(SCid,RCid,TCid),
	copy_term(OutTerm,CopyTerm),
	schrel_inh_gen_fr(SCid,RCid,TCid),
	(more_specific_schrel(OutTerm,CopyTerm) -> fail ; true).

:- table schrel_inh/3.
schrel_inh(SCid,RCid,TCid) :-
	OutTerm = schrel(SCid,RCid,TCid),
	copy_term(OutTerm,CopyTerm),
	schrel_inh_gen(SCid,RCid,TCid),
	(more_specific_schrel(OutTerm,CopyTerm) -> fail ; true).

:- table schrel_inh_gen/3.
schrel_inh_gen(SCid,RCid,TCid) :-
	subclass(RCidP,RCid),
	schrel_inh_gen_fr(SCid,RCidP,TCid).

:- table schrel_inh_gen_fr/3.
schrel_inh_gen_fr(SCid,RCid,TCid) :-
	(var(SCid)
	 ->	(var(TCid)
		 ->	immediate_schrel(SCid,RCid,TCid)
		 ;	subclass(TCidP,TCid),
			immediate_schrel(SCid,RCid,TCidP)
		)
	 ;      subclass(SCid,SCidP),
		immediate_schrel(SCidP,RCid,TCidP),
		(var(TCid)
		 ->	TCid = TCidP
		 ;	subclass(TCidP,TCid) % was if_
		)
	).

/**** old def without reverse indexing
:- table schrel_inh_gen/3.
schrel_inh_gen(SCid,RCid,TCid) :-
%%	subclass(RCid,RCidP),
	subclass(RCidP,RCid),
	subclass(SCid,SCidP),
	immediate_schrel(SCidP,RCidP,TCidP),
	(var(TCid)
	 ->	TCid = TCidP
	 ;	subclass(TCidP,TCid)	% was if_
	).

:- table schrel_inh_gen_fr/3.
schrel_inh_gen_fr(SCid,RCid,TCid) :-
	subclass(SCid,SCidP),
	immediate_schrel(SCidP,RCid,TCidP),
	(var(TCid)
	 ->	TCid = TCidP
	 ;	subclass(TCidP,TCid)	% was if_
	).
****/

more_specific_schrel(OutTerm,CopyTerm) :-
	CopyTerm = schrel(SCidO,RCidO,TCidO),
	OutTerm = schrel(SCid,RCid,TCid),
	schrel_inh_gen(SCidO,RCidO,TCidO),
	\+ variant(OutTerm,CopyTerm),	
%%	if_subclass(RCid,RCidO),
	subclass(RCidO,RCid),	% was if_
	subclass(SCid,SCidO),	% was if_
	subclass(TCidO,TCid).	% was if_

:- comment(assert_schrel/3, "@tt{assert_schrel(SCid,RCid,TCid)} adds a
new schema relation tuple to the ontology, if it is not already
implied (using inheritance if applicable) by the schema relations
already in the ontology.").

assert_schrel(SCid,RCid,TCid) :- newSchrel(SCid,RCid,TCid).

:- comment(retractallSchrel/3, "@tt{retractallSchrel(SCid,RCid,TCid)}
retracts all stored schema relation tuples that unify with the
parameters.  Note that this is a syntactic operation that simply
removes all matching tuples in @pred{oms_schrel/3} but does not affect
@pred{immediate_schrel_int/6} and may not affect information derived via
inheritance.").

retractall_schrel(SCid,RCid,TCid) :-
	retractallSchrel(SCid,RCid,TCid).

retractallSchrel(SCid,RCid,TCid) :-
	oms_update_list([retractall(oms_schrel(SCid,RCid,TCid))]).

:- comment(newSchrel/3, "@tt{newSchrel(SCid,RCid,TCidA)} adds a new
schema relation to the ontology if it is not already implied
(through inheritance, if applicable) by the schema relations
already in the ontology.").  

newSchrel(SCid,RCid,TCidA) :-
	newSchrel(SCid,RCid,TCidA,Updates,[]),
	oms_update_list(Updates).

/* TLS main change is that I now also check that RCid is a subclass of
   relation */
newSchrel(SCid,RCid,TCidA,Upd0,Upd) :-
	standardize_value(TCidA,TCid),
	check_incremental_constraints(schrel(SCid,RCid,TCid)),
	(schrel(SCid,RCid,TCid)
	 ->	Upd0 = Upd
	 ; insert_new_schrel(SCid,RCid,TCidA,Upd0,Upd)).

insert_new_schrel(SCid,RCid,TCidA,Upd0,Upd):- 
	schrel_source_class_exists(SCid),
	schrel_relation_exists(RCid),
	schrel_target_class_exists(TCidA),
	Upd0 = [asserta(oms_schrel(SCid,RCid,TCidA))|Upd].

schrel_source_class_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('attempt to add a ',
		    'schrel where source is missing:',SCid)),
	   fail).
schrel_relation_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('attempt to add a schrel where ',
                               'relationship class is missing:',SCid)),
	   fail),
	(is_an_inheritable_relationship(SCid) -> true 
	 ; oms_warning(update,('attempt to add a schrel for class ',
	                       'that is not an inheritable relationship',
			        SCid)),
	   fail).
schrel_target_class_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('attempt to add a schrel where ',
                               'target is missing:',SCid)),
	   fail).

%%% OBJECT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(object/4,"@tt{object(Oid,Name,NatCid,Source)} retrieves an
object with internal ID of @tt{Oid}, name @tt{Name}, native ID
@tt{NatCid}, and source @tt{Source}.

In the case in which @tt{Oid} or @tt{NatOid} are instantiated to
parameterized object's, they must unify with a currently loaded object
that is a member of a product class that is conformable with the
object.  @tt{object/4} will access either Internal or External
Intensional facts as needed.

@em{Technical Point}.  @pred{object/4} will also intern
@pred{ob_id_map/4} relations as needed for External Intensional facts.
").

object(Oid,Name,NatId,Source) :-
	(nonvar(Oid)
	 ->	(oms_obj(Oid,Name,NatId,Source)
		 ->	true
		 ;	ob_id_map(Oid,Name,NatId,Source)
		)
	 ; nonvar(NatId),nonvar(Source)
	 ->	(oms_obj(Oid,Name,NatId,Source)
		 ->	true
		 ;	get_object_int(Oid,Name,NatId,Source)
 		)
	 ;	(oms_obj(Oid,Name,NatId,Source)
		 ;
		 get_object_int(Oid,Name,NatId,Source)
		)
	).

get_object_int(Oid,Name,NatId,Source) :-
	object_int(Name,NatId,Source),
	(ob_id_map(Oid,Name,NatId,Source)
	 ->	true
		 ;	
	 	newoid(NatId,Oid,unk,Source,_Upd0,_Upd1),
		asserta(ob_id_map(Oid,Name,NatId,Source))
	).

:- comment(updateObject/4,"@tt{updateClass(Cid,Name,NatId,Source)}
updates @tt{Name}, @tt{Native Id}, and/or @tt{Source} information for
the object identified with @tt{CID} -- as long as that object is defined
by an internal fact of the predicate @tt{oms_obj/4}.  Its intended use
is in editors or other GUIs that may manipulate names and identifiers
of objects.").

updateObject(Oid,Label,NatId,Source) :-
	nonvar(Oid),
	object(Oid,_,_,_),
	oms_update_list([retractall(oms_obj(Oid,_,_,_)),
			 asserta(oms_obj(Oid,Label,NatId,Source))]).

:- comment(assert_object/4, "@tt{assert_object(Oid,Name,Native_Id,Source)}
adds a new object to the ontology, if it is not already there.").
assert_object(Oid,Name,Native_Id,Source) :- 
	asserta(oms_obj(Oid,Name,Native_Id,Source)).

:- comment(retractallObject/4,
"@tt{retractallObject(Oid,Name,Native_Id,Source)} retracts all objects
matching the parameters from oms_obj/4 facts.  It does not affect
@pred{object_int/3} facts.  ").

retractall_object(Oid,Name,Native_Id,Source) :-
	retractallObject(Oid,Name,Native_Id,Source).

retractallObject(Oid,Name,Native_Id,Source) :-
	oms_update_list([retractall(oms_obj(Oid,Name,Native_Id,Source))]).

:- comment(newObject/5, "@tt{newObject(Name,Cid,NatOid,Source,Oid)}
adds an object to the ontology, if it is not already present in
internal @pred{oms_obj/4} facts or derivable via external intensional
rules.  @tt{Oid} must be given as a variable and the predicate returns
its newly created object ID.

If the new object @tt{NatOid} is non-atomic, a check is made to ensure
that it is conformable with @tt{Cid}.").

%%%DSW require a class id and add member (analogous to newClass)
newObject(Name,Cid,NatOid,Source,Oid) :-
	newObject(Name,Cid,NatOid,Source,Oid,Updates,[]),
	oms_update_list(Updates).

newObject(Name,Cid,Nid,Source,Oid,Upd0,Upd) :-
	check_new_name(Name,object(Name,Nid,Source)),
	check_new_noid(Nid,object(Name,Nid,Source)),
	check_new_source(Source,object(Name,Nid,Source)),
	check_class_conformability(Nid,Cid),
	(var(Oid) ->	
	    newObject_oidunbound(Oid,Cid,Name,Nid,Source,Upd0,Upd)
	  ;	
	    (object(Oid,Name,Nid,Source)  -> % Oid bound so it must exist  
		add_member_if_nec(Oid,Cid,Upd0,Upd)
	      ;	
	        oms_warning(update,('Illegal OID to newObject',Oid)),
	        fail ) ).

check_class_conformability(Nid,Cid):- (atomic(Nid) ; atomic(Cid)),!.
check_class_conformability(Nid,Cid):- 
	get_product_skeleton(Nid,Nidskel),
	get_product_skeleton(Cid,Cidskel),
	Nidskel = Cidskel,!.
check_class_conformability(Nid,Cid):- 
	oms_error(update,('Cannot create new object ',Nid,
	          'as member of ',Cid,'due to non-conformability.')).

get_product_skeleton(Cid,_):- atomic(Cid),!.
get_product_skeleton(Cid,Skel):- 
	structure(Cid),!,
	Cid =..[Functor|List],
	get_product_skeleton_list(List,NewList),
	Skel =..[Functor|NewList].
get_product_skeleton(Cid,_Skel):- 
	oms_error(update,('Improper Cid: ',Cid)).
	
get_product_skeleton_list([],[]).
get_product_skeleton_list([H|T],[NH|NT]):- 
	get_product_skeleton(H,NH),
	get_product_skeleton_list(T,NT).

newObject_oidunbound(Oid,Cid,Name,Nid,Source,Upd0,Upd):- 
	object(Oid,_Name,Nid,Source)  % already exists
		 ->	add_member_if_nec(Oid,Cid,Upd0,Upd)
		 ;	newoid(Nid,Oid,Cid,Source,Upd0,Upd1),
			Upd1 = [asserta(oms_obj(Oid,Name,Nid,Source))|Upd2],
			add_member_if_nec(Oid,Cid,Upd2,Upd).

newObject_oidunbound_1(Oid,Cid,Nid,Source,Upd0,Upd):- 
	object(Oid,_Name,Nid,Source)  % already exists
		 ->	add_member_if_nec(Oid,Cid,Upd0,Upd)
		 ;	oms_cn(Rootid,_,'OMS Root','OMS'),
		        newoid(Nid,Oid,Rootid,Source,Upd0,Upd1),
			Upd1 = [asserta(oms_obj(Oid,Nid,
			                        Nid,Source))|Upd2],
			add_member_if_nec(Oid,Cid,Upd2,Upd).

new_atomic_oid(Oid):- 
	conget('_oid_ctr',OOid),
	Oid is OOid+1,
	conset('_oid_ctr',Oid).

/* need to handle arity */
newoid(NatOid,Oid,_Rootid,_Source,Upd,Upd) :-
	atomic(NatOid),!,
	new_atomic_oid(Oid).
newoid(NatOid,Oid,Rootid,Source,Upd0,Upd1) :-
%	check_class_for_prod_obj(NatOid,Source),
	NatOid =.. [_Functor|Old_Oid_list],
	newoid_list(Old_Oid_list,_New_Oid_list,Rootid,Source,Upd0,Upd1),
	new_atomic_oid(Oid).
	
%	Oid =.. [Functor|New_Oid_list].

check_class_for_prod_obj(NatOid,Sou):- 
	functor(NatOid,F,A),
	functor(Skel,F,A),
	(oms_cn(_Cid,_Label,Skel,Sou) ;
                   get_class_int(_Cid,_,Skel,Sou)).

newoid_list([],[],_Rootid,_Term,Upd,Upd).
newoid_list([Nid,Src|OT],[Oid|NT],Rootid,Term,Updin,Updout):- !,
	newObject_oidunbound_1(Oid,Rootid,Nid,Src,Updin,Updmid),
	newoid_list(OT,NT,Rootid,Term,Updmid,Updout).
newoid_list(_,_,_,Term,_,_):- 
	oms_error(update,('Cannot intern the class:',Term)).

add_member_if_nec(_Oid,unk,Upd,Upd) :- !.
add_member_if_nec(Oid,Cid,Upd,Upd) :-
	immediate_memberof(Oid,Cid), !.
add_member_if_nec(Oid,Cid,Upd0,Upd) :-
	class(Cid,_,_,_),
	!,
	Upd0 = [asserta(oms_mo(Oid,Cid))|Upd].
add_member_if_nec(Oid,Cid,_,_):-
	oms_warning(update,('No class for memberof',objectID=Oid,classID=Cid)),
	fail.

%%% MEMBEROF %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(immediate_memberof/2, "@tt{immediate_memberof(Oid,Cid)} is
true if there is a fact in @pred{oms_mo/2} or information directly
derivable from a @pred{immediate_memberof_int/4} rule indicating that
@tt{Oid} is an object in the class with ID @tt{Cid}.").

%%immediate_memberof(Oid,Cid) :- writeln(oms_mo(Oid,Cid)),fail.
immediate_memberof(Oid,Cid) :- oms_mo(Oid,Cid).
immediate_memberof(Oid,object(Oid)):- nonvar(Oid).
immediate_memberof(Oid,Cid):- 
	(structure(Oid) -> 
	    % checks for Cid = strucure + var
	    immediate_memberof_struct_bx(Oid,Cid)
           ; 
	    (( var(Oid),structure(Cid),
	        \+ oms_primitive_type(Cid)) 
	    -> 
		immediate_memberof_struct_fb(Oid,Cid) ) ).

immediate_memberof(Oid,Cid) :-
	immediate_memberof_int(Oid,Cid).

immediate_memberof_struct_bx(Oid,Cid):- 
	    (structure(Cid) ->
		Oid =.. [F|OList],
		Cid =.. [F|CList],
		immediate_memberof_list(OList,CList)
	      ; 
	        var(Cid),
	        Oid =.. [F|OList],
		immediate_memberof_list(OList,CList),
		Cid =.. [F|CList],
		class(Cid,_,_,_) ).    % check to see the class is there...

immediate_memberof_struct_fb(Oid,Cid):- 
	Cid =.. [F|CList],
	immediate_memberof_list(OList,CList),
	Oid =.. [F|OList].

immediate_memberof_list([],[]).
immediate_memberof_list([H|T],[NH|NT]):- 
	immediate_memberof(H,NH),
	immediate_memberof_list(T,NT).

immediate_memberof_int(Oid,Cid) :-
	(nonvar(Oid)
	 ->	object(Oid,_Name,CNatId,CSou),
		(nonvar(Cid)
		 ->	class(Cid,_,PNatId,PSou),
			immediate_memberof_int(CNatId,CSou,PNatId,PSou)
		 ;	immediate_memberof_int(CNatId,CSou,PNatId,PSou),
			class(Cid,_,PNatId,PSou)
		)
	 ;      (nonvar(Cid)
		 ->	class(Cid,_,PNatId,PSou),
			immediate_memberof_int(CNatId,CSou,PNatId,PSou)
		 ;	immediate_memberof_int(CNatId,CSou,PNatId,PSou),
			class(Cid,_,PNatId,PSou)
		),
		object(Oid,_,CNatId,CSou)
	).

:- comment(memberof/2, "@tt{memberof(Oid,Cid)} is the semantic
memberof predicate.  It is true if object Oid is an immediate member
of class Cid or any subclass of that class").
memberof(Oid,Cid) :-
	(var(Oid)
	 ->	subclass(DCid,Cid),
		immediate_memberof(Oid,DCid)
	 ;	immediate_memberof(Oid,DCid),
		subclass(DCid,Cid)
	).

:- comment(assert_memberof/2, "@tt{assert_memberof(Oid,Cid)} adds
object Oid to class Cid if it's not already known to be a member.").
assert_memberof(Oid,Cid) :- newMemberof(Oid,Cid).

:- comment(retractallMemberof/2, "@tt{retractallMemberof(Oid,Cid)}
removes object @tt{Oid} from direct membership of @tt{Cid}.  This is a
syntactic operation that directly operates on the @pred{oms_mo/2}
representation and does not affect information derived via
@pred{immediate_memberof_int/4}.").

retractall_memberof(Oid,Cid) :-
	retractallMemberof(Oid,Cid).

retractallMemberof(Oid,Cid) :-
	oms_update_list([retractall(oms_mo(Oid,Cid))]).

:- comment(newMemberof/2, "@tt{newMemberof(CCid,PCid)} adds object
@tt{Oid} to class Cid if it is not already known to be a member
(perhaps through transitivty of memberof).  This predicate adds a new
Internal Format fact @pred{oms_mo/2}.").

newMemberof(Oid,Cid) :-
	newMemberof(Oid,Cid,Upd0,[]),
	oms_update_list(Upd0).

memberof_class_exists(SCid):- 
	(class_exists_for_cid(SCid) -> true
	 ; oms_warning(update,('newMemberof, missing class for ',SCid)),
	   fail).


newMemberof(Oid,Cid,Upd0,Upd) :-
	(memberof(Oid,Cid)
	 ->	Upd0 = Upd
	 ;	(object(Oid,_,_,_)
		 ->	(memberof_class_exists(Cid),
			 Upd0 = [asserta(oms_mo(Oid,Cid))|Upd])
		 ;	oms_warning(update,('newMemberof but object does ',
			         'not exist',Oid)),
			fail
		)
	).

%%% ATTRIBUTE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%attribute(Oid,RCid,TCid) :- oms_at(Oid,RCid,TCid).

:- comment(immediate_attribute/3,
"@tt{immediate_attribute(Oid,RCid,TCid)} is true if the indicated
tuple unifies with a stored attribute tuple in @pred{oms_at/3}, or
with information directly derivable from a @pred{immediate_attribute_int/6}
rule.  ").

/***immediate_attribute(Oid,RCid,TCid) :-
	(ground(Oid),object(Oid,L1,N1,S1) -> Obj=object(Oid,L1,N1,S1) ; Obj = object(Oid,????)),
	(ground(RCid),class_cidbound(RCid,L2,N2,S2) -> Rel=class(RCid,L2,N2,S2) ; Rel = class(RCid,????)),
	(ground(TCid),class_cidbound(TCid,L3,N3,S3) -> Targ=class(TCid,L3,N3,S3) ; Targ = class(TCid,????)),
	writeln(attr(Obj,Rel,Targ)),
	fail.***/
immediate_attribute(Oid,RCid,TCid) :- oms_at(Oid,RCid,TCid).
immediate_attribute(Oid,RCid,TCid) :-
	immediate_attribute_int(Oid,RCid,TCid).

immediate_attribute_int(Oid,RCid,TCid) :-
	(nonvar(Oid)
	 ->	object(Oid,_Name,SNatId,SSou),
		(nonvar(RCid)
		 ->	class(RCid,_,RNatId,RSou),
			(nonvar(TCid)
			 ->	class(TCid,_,TNatId,TSou),
				immediate_attribute_int(SNatId,SSou,RNatId,RSou,TNatId,TSou)
			 ;	immediate_attribute_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
				class(TCid,_,TNatId,TSou)
			)
		 ;	(nonvar(TCid)
			 ->	class(TCid,_,TNatId,TSou),
				immediate_attribute_int(SNatId,SSou,RNatId,RSou,TNatId,TSou)
			 ;	immediate_attribute_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
				class(TCid,_,TNatId,TSou)
			),
			class(RCid,_,RNatId,RSou)
		)
	 ;	(nonvar(RCid)
		 ->	class(RCid,_,RNatId,RSou),
			(nonvar(TCid)
			 ->	class(TCid,_,TNatId,TSou),
				immediate_attribute_int(SNatId,SSou,RNatId,RSou,TNatId,TSou)
			 ;	immediate_attribute_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
				class(TCid,_,TNatId,TSou)
			)
		 ;	(nonvar(TCid)
			 ->	class(TCid,_,TNatId,TSou),
				immediate_attribute_int(SNatId,SSou,RNatId,RSou,TNatId,TSou)
			 ;	immediate_attribute_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
				class(TCid,_,TNatId,TSou)
			),
			class(RCid,_,RNatId,RSou)
		),
		object(Oid,_Name,SNatId,SSou)
	).

:- comment((attribute)/3, "@tt{attribute(Oid,RCid,TCid)} is true if
object @tt{Oid} can be inferred to be related through @tt{RCid} to
@tt{TCid} (using inheritance) and no more specific relation can be
inferred.  This uses inheritance from @tt{relationship/3}, so an
object that has no tuples concerning it in @pred{oms_at/3} or
information concerning it in @pred{immediate_attribute_int/6} could
still have (inherited) attribute information.").

attribute(Oid,RCid,TCid) :-
	immediate_attribute(Oid,RCid,TCid).  

attribute(Oid,RCid,TCid) :-
	(nonvar(Oid)
	 ->	immediate_memberof(Oid,SCid),
		relationship(SCid,RCid,TCid)
	 ;      relationship(SCid,RCid,TCid),
		immediate_memberof(Oid,SCid)
	),
	((immediate_attribute(Oid,ORCid,OTCid),
	  subclass(RCid,ORCid),
	  subclass(OTCid,TCid))
	 ->	fail
	 ;	true
	).

/* check_attribute(+,+,+).  This predicate should be used *only* in
newAttribute. The idea is that newAttribute should add a new attribute
only if that new attribute is not implied by the ontology.  But using
attribute as a check in newAttribute is 1) inefficient and 2) not
quite right.  The not-quite-right part is be cause newAttribute seeks
to backtrack through all *maximal" attribtues implied by the ontology
(last ifthenelse of attribute/3) and we want newAttribute to add only
if the attribute is not implied, regardless if it is maximally implied
or not. */

check_attribute(Oid,RCid,TCid) :-
	(immediate_attribute(Oid,RCid,TCid) 
         ->	true
	 ;	immediate_memberof(Oid,SCid),
		relationship(SCid,RCid,TCid)
	).
%	(  immediate_attribute(Oid,RCid,TCid) 
%         ; immediate_memberof(Oid,SCid),
%	   relationship(SCid,RCid,TCid)).
% would like a cut here but can't over relationship.

:- comment(assert_attribute/3, "@tt{assert_attribute(Oid,RCid,TCid)}
adds this tuple as an attribute tuple, if it is not already implied by
the ontology.").
assert_attribute(Oid,RCid,TCid) :- newAttribute(Oid,RCid,TCid).

:- comment(retractallAttribute/3,
"@tt{retractallAttribute(Oid,RCid,TCid)} retracts all @pred{oms_at/3}
tuples that match the parameters.  Note that this is purely a
syntactic operation operating directly on the @pred{oms_at/3}
representation.  It does not affect information derived via
@pred{immediate_attribute_int/6} and may not affect attribute
information derived via inheritance.").

retractall_attribute(Oid,RCid,TCid) :-
	retractallAttribute(Oid,RCid,TCid).

retractallAttribute(Oid,RCid,TCid) :-
	oms_update_list([retractall(oms_at(Oid,RCid,TCid))]).

:- comment(updateAttribute/5,
"@tt{update_attribute(Oid,RCid,TCid,VarTerm,ValList)} updates a set of
values, only invalidating those that changed.  VarTerm must contain
all the free variables in (Oid,RCid,TCid), and ValList is a list of
instances of VarTerm.  The goal is to minimize invalidation.  The
semantics is: (retractall_attribute(Oid,RCid,TCid),
(member(VarTerm,ValList), assert_attribute(Oid,RCid,TCid)), fail ;
true).").

updateAttribute(Oid,Rid,Cid,Vars,NValList) :-
	findall(Vars,attribute(Oid,Rid,Cid),OValList),
	sort(NValList,SNValList),
	sort(OValList,SOValList),
	updateAttributeMerge(SOValList,SNValList,p(Oid,Rid,Cid,Vars),Updates,[]),
	oms_update_list(Updates).

updateAttributeMerge(SOValList,SNValList,ArgsVars,Updates0,Updates) :-
	SOValList = [OVal|SOVals],
	SNValList = [NVal|SNVals],
	!,
	(OVal == NVal
	 ->	updateAttributeMerge(SOVals,SNVals,ArgsVars,Updates0,Updates)
	 ; OVal @< NVal
	 ->	copy_term(ArgsVars,p(NOid,NRid,NCid,OVal)),
		(oms_at(NOid,NRid,NCid)   % don't delete if inherited
		 ->	Updates0 = [retractall(oms_at(NOid,NRid,NCid))|Updates1],
			updateAttributeMerge(SOVals,SNValList,ArgsVars,
					       Updates1,Updates)
		 ;	updateAttributeMerge(SOVals,SNValList,ArgsVars,
					       Updates0,Updates)
		)
	 ;	copy_term(ArgsVars,p(NOid,NRid,NCid,NVal)),
		newAttribute(NOid,NRid,NCid,Updates0,Updates1),
		updateAttributeMerge(SOValList,SNVals,ArgsVars,Updates1,Updates)
	).
updateAttributeMerge([],[NVal|SNVals],ArgsVars,Updates0,Updates) :- !,
	copy_term(ArgsVars,p(NOid,NRid,NCid,NVal)),
	newAttribute(NOid,NRid,NCid,Updates0,Updates1),
	updateAttributeMerge([],SNVals,ArgsVars,Updates1,Updates).
updateAttributeMerge([OVal|SOVals],[],ArgsVars,Updates0,Updates) :- !,
	copy_term(ArgsVars,p(NOid,NRid,NCid,OVal)),
	(oms_at(NOid,NRid,NCid)   % don't delete if inherited
	 ->	Updates0 = [retractall(oms_at(NOid,NRid,NCid))|Updates1],
		updateAttributeMerge(SOVals,[],ArgsVars,Updates1,Updates)
	 ;	updateAttributeMerge(SOVals,[],ArgsVars,Updates0,Updates)
	).
updateAttributeMerge([],[],_ArgsVars,Updates,Updates).

:- comment(newAttribute/3, "@tt{newAttribute(SOid,RCid,TCid)}adds this
tuple as an @pred{oms_at/3} attribute tuple, if it is not already
implied by the ontology.  Checks attribute facts against schema
information to make sure the schema constraints are not violated.").

newAttribute(SOid,RCid,TCid) :-
	(var(SOid)
	 ->	oms_error(newAttribute,'Calling newAttribute with variable object')
	 ;	newAttribute(SOid,RCid,TCid,Updates,[]),
		oms_update_list(Updates)
	).

newAttribute(SOid,RCid,TCidA,Upd0,Upd) :-
	standardize_value(TCidA,TCid),
	check_incremental_constraints(attribute(SOid,RCid,TCid)),
	(check_attribute(SOid,RCid,TCid)
	 ->	Upd0 = Upd
	 ;	(class_exists_for_cid(RCid),
	         class_exists_for_cid(TCid),object(SOid,_,_,_)
		 ->	Upd0 = [asserta(oms_at(SOid,RCid,TCid))|Upd]
		 ;	oms_warning(update,('newAttribute but class ',
			         'or object does not exist: ',
			         SOid,RCid,TCid)),
			fail
		) 
	).

%%% ATTRIBUTE_OBJECT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(attribute_object/3,"@tt{attribute_object(Oid,RCid,TOid)}
accesses facts stored in @pred{oms_ao/3}, and from the external
intensional rules @pred{attribute_object_int/6}.  Semantically the
meaning is that object @tt{Oid} has an @tt{RCid} relation to object
@tt{TOid}.").

/***attribute_object(Oid,RCid,TOid) :-
	(ground(Oid),object(Oid,L1,N1,S1) -> Obj=object(Oid,L1,N1,S1) ; Obj = object(Oid,????)),
	(ground(RCid),class_cidbound(RCid,L2,N2,S2) -> Rel=class(RCid,L2,N2,S2) ; Rel = class(RCid,????)),
	(ground(TOid),object(TOid,L3,N3,S3) -> TObj=object(TOid,L3,N3,S3) ; TObj = object(TOid,????)),
	writeln(atob(Obj,Rel,TObj)),
	fail.***/

attribute_object(Oid,RCid,TOid) :-
	immediate_attribute_object(Oid,RCid,TOid).
attribute_object(Oid,RCid,TOid) :-
	attribute(Oid,RCid,object(TOid)).

%%immediate_attribute_object(Oid,RCid,TOid) :- writeln(oms_ao(Oid,RCid,TOid)),fail.
immediate_attribute_object(Oid,RCid,TOid) :- oms_ao(Oid,RCid,TOid).
immediate_attribute_object(Oid,RCid,TOid) :-
	attribute_object_int(Oid,RCid,TOid).

attribute_object_int(Oid,RCid,TCid) :-
	(nonvar(Oid)
	 ->	object(Oid,_Name,SNatId,SSou),
		(nonvar(RCid)
		 ->	class(RCid,_,RNatId,RSou),
			(nonvar(TCid)
			 ->	object(TCid,_,TNatId,TSou),
				attribute_object_int(SNatId,SSou,RNatId,RSou,TNatId,TSou)
			 ;	attribute_object_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
				object(TCid,_,TNatId,TSou)
			)
		 ;	(nonvar(TCid)
			 ->	object(TCid,_,TNatId,TSou),
				attribute_object_int(SNatId,SSou,RNatId,RSou,TNatId,TSou)
			 ;	attribute_object_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
				object(TCid,_,TNatId,TSou)
			),
			class(RCid,_,RNatId,RSou)
		)
	 ;	(nonvar(RCid)
		 ->	class(RCid,_,RNatId,RSou),
			(nonvar(TCid)
			 ->	object(TCid,_,TNatId,TSou),
				attribute_object_int(SNatId,SSou,RNatId,RSou,TNatId,TSou)
			 ;	attribute_object_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
				object(TCid,_,TNatId,TSou)
			)
		 ;	(nonvar(TCid)
			 ->	object(TCid,_,TNatId,TSou),
				attribute_object_int(SNatId,SSou,RNatId,RSou,TNatId,TSou)
			 ;	attribute_object_int(SNatId,SSou,RNatId,RSou,TNatId,TSou),
				object(TCid,_,TNatId,TSou)
			),
			class(RCid,_,RNatId,RSou)
		),
		object(Oid,_Name,SNatId,SSou)
	).

assert_attribute_object(Oid,RCid,TOid) :- newAttributeObject(Oid,RCid,TOid).

:- comment(retractallAttribute_object/3,
"@tt{retractallAttribute_object(Oid,RCid,TCid)} retracts all
@pred{oms_ao/3} tuples that match the parameters.  Note that this is
purely a syntactic operation operating directly on the @pred{oms_ao/3}
representation.  It does not affect information derived via
@pred{attribute_object_int/6} and may not affect attribute_object
information derived via inheritance.").

retractall_attribute_object(Oid,RCid,TOid) :-
	retractallAttribute_object(Oid,RCid,TOid).

retractallAttribute_object(Oid,RCid,TOid) :-
	oms_update_list([retractall(oms_ao(Oid,RCid,TOid))]).


:- comment(newAttribute_object/3,
"@tt{newAttribute_object(SOid,RCid,TOid)} adds this tuple as an
Internal Format @pred{oms_ao/3} tuple, if it is not already implied by
the ontology.  The potential fact is checked to make sure that schema
constraints are not violated..").

newAttributeObject(SOid,RCid,TOid) :-
	newAttributeObject(SOid,RCid,TOid,Updates,[]),
	oms_update_list(Updates).

newAttributeObject(SOid,RCid,TOid,Upd0,Upd) :-
	check_incremental_constraints(attribute_object(SOid,RCid,TOid)),
	(attribute_object(SOid,RCid,TOidX),
	 variant(TOidX,TOid)
	 ->	Upd0 = Upd
	 ;	(object(SOid,_,_,_),class_exists_for_cid(RCid),
		 object(TOid,_,_,_)
		 ->	Upd0 = [asserta(oms_ao(SOid,RCid,TOid))|Upd]
		 ;	oms_warning(update,('OMS UPDATE: newAttributeObject',
				 'called but some argument does not exist',
				 SOid,RCid,TOid)),
		 	fail
		)
	).

%%% MIXED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

:- comment(newRelationshipClass/3,"Creates a class that is an
immediate subclass of of @tt{OMS Inheritable Relationships}.  This
predicate only creates a class, and does not create any specific
relationship tuples").

newRelationshipClass(Name,Source,NewCid) :-
	class(RelCid,'OMS Inheritable Relationships',
		     'OMS Inheritable Relationships','OMS'),
	newClass(Name,RelCid,Source,NewCid).

:- comment(newStrelClass/3,"Creates a class that is an immediate
subclass of of @tt{OMS Set-Valued Relations}.  This predicate only
creates a class, and does not create any specific relation tuples").

newStrelClass(Name,Source,NewCid) :-
	class(RelCid,'OMS Set-Valued Relations',
		     'OMS Set-Valued Relations','OMS'),
	newClass(Name,RelCid,Source,NewCid).

:- comment(newSchrelClass/3,"Creates a class that is an immediate
subclass of of @tt{OMS Schema Relations}.  This predicate only creates
a class, and does not create any specific relation tuples").

newSchrelClass(Name,Source,NewCid) :-
	class(RelCid,'OMS Schema Relations',
		     'OMS Schema Relations','OMS'),
	newClass(Name,RelCid,Source,NewCid).

%-----------------------------------------------------------------
% General checks use in more than one create instruction

/* transforms internal to external.  Does not check for class
 * coverage.  stuff with primitive types is an attempt at optimization
 * (other than object, which is special).  */

/* changed to partially reflect ext_int.
   make explicit calls to oms_primitive_class.  Am not sure
   if we can always assume that Cid + , but I'm preserving the
   semantics we had for param_int_ext */

int_ext(Cid,NatCid,Sou):- 
	oms_primitive_class(Cid,_Label,NatCid,Sou),!.
int_ext(Cid,NatCid,Sou):- 
	atomic(Cid),!,
        (oms_cn(Cid,Label,NatCid,Sou) -> true 
         ; get_class_int(Cid,Label,NatCid,Sou)).
int_ext(Cid,NatCid,Sou):- 
%	\+ oms_primitive_class(Cid,Label,NatCid,Sou),
	parameterized_int_ext(Cid,NatCid,Sou).

parameterized_int_ext(Term,Newterm,Sou):- 
	oms_primitive_class(Term,_Label,Newterm,Sou).
parameterized_int_ext(Term,Newterm,Sou):- 
	\+ oms_primitive_type(Term),   %%% dsw?? (changed TLS: using
	                                               %%%  oms_primitive_type/1
	Term =.. [F|List],
	parameterized_int_ext_1(List,Newlist,Term),
	skeleton(Term,Skel),
	get_source_of_skel(Skel,Sou),	% assume unique in OMS.
	Newterm =.. [F|Newlist].

parameterized_int_ext_1([],[],_).
parameterized_int_ext_1([H|T],[N,S|T1],Term):- 
	(atomic(H) -> 	class_nid_or_abort(H,S,N,Term)
	   ; parameterized_int_ext(H,N,S)),
	parameterized_int_ext_1(T,T1,Term).

class_nid_or_abort(H,S,N,_Term):- class(H,_,N,S),!.
class_nid_or_abort(H,S,_N,Term):-
	oms_error(update,('Cannot find class for',H,S,'in',Term)).

/* only want the first skel for source here.  Assume that we can't
   add more than one. */
get_source_of_skel(Skel,Source):- 
	oms_cn(Skel,_,_,Source),!.
get_source_of_skel(Skel,Source):- 
	class_int(_,Skel,Source),!.

class_exists_for_cid(SCid):- 
	class_cidbound(SCid,_,_,_).

% To be used with class and object creation.
check_new_name(Name,Term):- 
	(nonvar(Name)
	 ->	true
	 ;	oms_warning(update,('cannot create OMS fact with ',
			 'name unbound: ',Term)),
		fail
	),
	(atomic(Name)
	 ->	true
	 ;	oms_warning(update,('warning: creating class with ',
			 'non-atomic name: ',Term))
	).

/* To be used with class creation, and with
   merging from external files. */
check_new_nid(Nid,Term):- 
	(nonvar(Nid)
	 ->	true
	 ;	oms_warning(update,('cannot create OMS fact with',
			 'native id unbound ',Term)),
		fail
	).

/* To be used with object creation, and with
   merging from external files. */
check_new_noid(Nid,Term):- 
	(nonvar(Nid)
	 ->	true
	 ;	oms_warning(update,('cannot create OMS fact with ',
			 'native id unbound ',Term)),
		fail
	).

/* To be used with class and object creation, and with
   merging from external files. */
check_new_source(Source,Term):- 
	(nonvar(Source)
	 ->	true
	 ;	oms_warning(update,('cannot create OMS fact ',
                         'source unbound: ',Term)),
		fail
	),
	(atomic(Source)
	 ->	true
	 ;	oms_warning(update,('creating OMS fact with',
			 'non-atomic source: ',Term))
	).


%% Needed for updates
assert_oms(oms_rln(A,B,C)) :- !,
	asserta(oms_rln(A,B,C)),
	abolish_relationship_inherits.
assert_oms(oms_schrel(A,B,C)) :- !,
	asserta(oms_schrel(A,B,C)),
	abolish_schrel_inherits.
assert_oms(oms_sc(A,B)) :- !,
	asserta(oms_sc(A,B)),
	abolish_relationship_inherits,
	abolish_schrel_inherits.
assert_oms(Term) :- asserta(Term).

abolish_relationship_inherits :-
	abolish_table_pred(relationship_inh_gen(_,_,_)),
	abolish_table_pred(relationship_inh_gen_fr(_,_,_)),
	abolish_table_pred(relationship_inh(_,_,_)),
	abolish_table_pred(relationship_inh_fr(_,_,_)).

abolish_schrel_inherits :-
	abolish_table_pred(schrel_inh_gen(_,_,_)),
	abolish_table_pred(schrel_inh_gen_fr(_,_,_)),
	abolish_table_pred(schrel_inh(_,_,_)),
	abolish_table_pred(schrel_inh_fr(_,_,_)).

%%% OTHER PREDS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- import '_$index'/3 from file_op.
%% performance testing predicate
set_chk_index :-
	set_chk_index(oms_cn(_,_,_,_)),
	set_chk_index(oms_sc(_,_)),
	set_chk_index(oms_rln(_,_,_)),
	set_chk_index(oms_strel(_,_,_)),
	set_chk_index(oms_schrel(_,_,_)),
	set_chk_index(oms_obj(_,_,_,_)),
	set_chk_index(oms_mo(_,_)),
	set_chk_index(oms_at(_,_,_)),
	set_chk_index(oms_ao(_,_,_)).

set_chk_index(Goal) :-
	asserta((Goal :- chk_index(Goal))).

chk_index(Goal) :-
	('_$index'(Goal,Index,_)
	 ->	(integer(Index)
		 ->	\+ bound_on([Index],Goal)
		 ;	\+ bound_on(Index,Goal)
		)
	 ;	\+ bound_on([1],Goal)
	),
	telling(OF),tell(user),writeln('Non-indexed call '(Goal)),
	tell(OF),
	fail.

bound_on([ArgNo|_ArgNos],Goal) :-
	bound_on_all(ArgNo,Goal).
bound_on([_ArgNo|ArgNos],Goal) :-
	bound_on(ArgNos,Goal).

bound_on_all(ArgNo,Goal) :-
	ArgNo1 is ArgNo /\ 255,
	arg(ArgNo1,Goal,Arg),
	nonvar(Arg),
	(ArgNo < 256
	 ->	true
	 ;	ArgNoM is ArgNo >> 8,
		bound_on_all(ArgNoM,Goal)
	).

friendly_atom_codes(A,Codes):- 
	(atom(A) ; var(A)) -> atom_codes(A,Codes)
	   ; writeln(non_atomic(A)),
	     atom_codes(A,Codes) . 	% and so abort.

create_new_para_cid_for_int(NatCid,Cid,Sou,Label):- 
	create_new_para_cid_for_int_1(NatCid,Cid,Sou,NatCid),
	call_assert(cn_id_map(Cid,NatCid,Sou,Label)).
	
create_new_para_cid_for_int_1(Term,Term,'OMS',_NatCid):- 
	skeleton(Term,Skel),
	oms_primitive_type(Skel),!.
create_new_para_cid_for_int_1(NativeId,Cid,Sou,NatCid):- 
	NativeId =.. [F|List],
	create_new_para_cid_for_int_2(List,Newlist,NatCid),
	Cid =.. [F|Newlist],
	intern_if_necessary(Cid,NativeId,Sou).

create_new_para_cid_for_int_2([],[],_).
create_new_para_cid_for_int_2([_H],_,Term):- !,
	oms_error(update,('Cannot intern the class:',Term)).
create_new_para_cid_for_int_2([Nid,S|T],[Cid|T1],Term):- 
	(atomic(Nid) -> class_or_abort(Nid,S,Cid,Term)
	   ; create_new_para_cid_for_int_1(Nid,Cid,S,Term)),
	create_new_para_cid_for_int_2(T,T1,Term).

intern_if_necessary(Cid,NativeId,Sou):- 
     (oms_cn(Cid,_,NativeId,Sou) -> 
          true
        ; 
          class_int(Label,NativeId,Sou),	
          call_assert(cn_id_map(Cid,Label,NativeId,Sou))).

end_of_file.

/**paramType(VID):-
	class(CID,_,'OMS Parameterized Types','OMS'),
	proper_subclass(VID,CID).**/

vars_to_all(Var) :- var(Var), !, Var = 'All'.
vars_to_all(Atom) :- atomic(Atom), !.
vars_to_all(Term) :- Term =.. TermList, vars_to_all_map(TermList).

vars_to_all_map([]).
vars_to_all_map([Term|Terms]) :-
	vars_to_all(Term),
	vars_to_all_map(Terms).

%%% delete_subsumed_relationships(+SCid,+RCid,+TCid) deletes all
%%% relationships that are redundant due to being inherited from this
%%% given relationship.
delete_subsumed_relationships(SCid,RCid,TCid) :-
	findall(retractall(oms_rln(SSCid,SRCid,STCid)),
		properly_subsumed_relationship(SCid,RCid,TCid,SSCid,SRCid,STCid),
		UpdateList),
	oms_update_list(UpdateList),
	fail.
delete_subsumed_relationships(_SCid,_RCid,_TCid).

%%% properly_subsumed_relationship(+SCid,+RCid,+TCid,-SSCid,-SRCid,-STCid)
%%% returns relationships implied by input relationship through inheritance.
properly_subsumed_relationship(SCid,RCid,TCid,SSCid,SRCid,STCid) :-
	(if_inherited_relationship(RCid)
	 ->	%%subclass_fb(SRCid,RCid),
		subclass_bf(RCid,SRCid),
		subclass_fb(SSCid,SCid),
		immediate_relationship(SSCid,SRCid,STCid),
		if_subclass(TCid,STCid),
		(SRCid\==RCid
		 ->	true
		 ; SSCid\==SCid
		 ->	true
		 ;	STCid\==TCid
		)
	).
	

if_inherited_relationship(RCid) :-
	(class(RTCid,'OMS Relationship Type','OMS Relationship Type','OMS')
	 ->	(RCid == RTCid  % type relationship is itself inherited
		 ->	true
		 ;	relationship_inh(RCid,RTCid,Type)
		 ->	(Type = integer(0)
			 ->	true
			 ;	fail
			)
		 ;	true
		)
	 ;	true
	).


create_new_para_cid_for_int(NatCid,Cid,Sou):- 
	create_new_para_cid_for_int_1(NatCid,Cid,Sou,NatCid),
        call_assert(cn_id_map(Cid,NatCid,Sou)).
	
create_new_para_cid_for_int_1(Term,Term,'OMS',_NatCid):- 
	skeleton(Term,Skel),
	oms_primitive_type(Skel),!.
create_new_para_cid_for_int_1(NativeId,Cid,Sou,NatCid):- 
	NativeId =.. [F|List],
	create_new_para_cid_for_int_2(List,Newlist,NatCid),
	Cid =.. [F|Newlist],
	intern_if_necessary(Cid,NativeId,Sou).

create_new_para_cid_for_int_2([],[],_).
create_new_para_cid_for_int_2([_H],_,Term):- !,
	oms_error(update,('Cannot intern the class:',Term)).
create_new_para_cid_for_int_2([Nid,S|T],[Cid|T1],Term):- 
	(atomic(Nid) -> class_or_abort(Nid,S,Cid,Term)
	   ; create_new_para_cid_for_int_1(Nid,Cid,S,Term)),
	create_new_para_cid_for_int_2(T,T1,Term).

intern_if_necessary(Cid,NativeId,Sou):- 
	(oms_cn(Cid,_,NativeId,Sou) -> true 
          ; call_assert(cn_id_map(Cid,NativeId,Sou))).

unifiable(Term1,Term2):- 
	\+  \+ Term1 = Term2.

%%% attributes_implying_relationship(+ISCid,+IRCid,+ITCid,-Oid,-RCid,-TCid)
%%% given a relationship, returns immediate attributes that imply it.
%%% (For deletion)

attributes_implying_relationship(ISCid,IRCid,ITCid,Oid,RCid,TCid) :-
	(if_inherited_relationship(RCid)
	 ->	subclass_fb(RCid,IRCid),
		memberof(Oid,ISCid),
		immediate_attribute(Oid,RCid,TCid),
		subclass(TCid,ITCid)	% was if_
	).

set_convert_int_ext([],[],_S).
set_convert_int_ext([Cid|R],[Nid|Nr],S):- 
	int_ext(Cid,Nid,S),
	set_convert_int_ext(R,Nr,S).

set_convert_ext_int([],[],_S).
set_convert_ext_int([Nid|NR],[Cid|CR],S):- 
	ext_int(Cid,_Label,Nid,S),
	set_convert_ext_int(NR,CR,S).

/*
oms_primitive_class(set(X),'SET/1',set(Y,Z),'OMS') :-
	(nonvar(X) -> 
	     set_convert_int_ext(X,Y,Z)
             ;  (nonvar(Y),nonvar(Z) ->	
	            set_convert_ext_int(Y,X,Z)
	          ; true) ).
*/

@item @index{OMS Pragma}.  A user may wish to make certain
semantically meaningful information about the ontology beyond the
axioms in @ref{Semantic Axioms for the Programmer's View}.  In order
to provide extra information the user may specify @em{pragma}.
Pragmas are not explicitly checked by the OMS system: however pragmas
may be checked by type-checking systems on top of the OMS, or and in
the future, such checking may be merged into the OMS per se.  A pragma
can be defined for a given class by the set-valued relation @tt{'OMS
Pragma'} defined as: @begin{verbatim}
       newStrelClass('OMS Pragma','OMS',PragmaRelCid).
@end{verbatim}

Targets of the @tt{OMS Pragma} relation are subclasses of the @tt{OMS
Pragma Domain}, defined as 
@begin{verbatim}
       newClass('OMS Pragma',RootCid,'OMS',PragmaCid).
@end{verbatim}

The current Pragmas (i.e. subclasses of @tt{OMS Pragma}) are:
@begin{itemize}
@item @index{OMS Relation Maximum(integer(_))};  
@item @index{OMS Relation Minimum(integer(_))}:
	These pragma represent the minimum and maximum number of
	values a relation may have for a single input.  They may be
defined for Inheritable, Set-Valued, or Schema Relations.  Defined as:

@begin{verbatim} 
newClass('OMS Relation Maximum'(integer(_)),PragmaCid,'OMS',_AtmCid), 
newClass('OMS Relation Minimum'(integer(_)),PragmaCid,'OMS',_AtlCid).  
@end{verbatim}

@item Class Roles.

Most classes may have objects explicitly defined for them via the
@pred{memberof/2} predicate, but in certain cases explicit object
creation may either not make sense, or may be disallowed.  For
parameterized classes, explicit object creation is disallowed because
the members of parameterized classes are tuples formed over objects.
Since there is currently no way in the OMS to create tuples of
objects, explicit object creation is disallowed for parameterized
classes, and enforced by the OMS.  In other cases, a user may decide
that explicit creation be disallowed for a generic class: for instance
it might make better sense in an application not to allow creation of
objects directly from the class @em{Car}, but only from subclasses of
@em{Car}, such as @em{Chevy} or @em{Volvo}.  An @em{abstract} class is
a class which should have no direct members (i.e. although its
subclasses, if any, may have members if they are not abstract).  A
@em{concrete} class may have direct members.  All non-parameterized
classes of the OMS are concrete; all parameterized classes of the OMS
are abstract.  Defined as: 

@tt{newClass('OMS Class Role Domain',PragmaCid,'OMS',ConCid)};

@tt{newClass('OMS Abstract Class',ConCid,'OMS',_AbsCid)};

@tt{newClass('OMS Concrete Class',ConCid,'OMS',_ConcrCid)}

@item 	newClass('OMS Partition Class',PragmaCid,'OMS',_).

OMS axioms state only that if class @em{a} is a subclass of class
@em{b}, then every element of @em{a} is an element of @em{b}.  However
there are other relations between sets that can be important for
applications.  For instance, one might want to state that the
immediate subclasses of a class @em{a} form a partition of its
elements (i.e. each element of @em{a} belongs to one and only one
subclass).  Enumerated types, for instance, could be declared in this
way.  In the OMS, this property is declared by the pragma @em{OMS
partition Class}.

@end{itemize}
