:- compiler_options([ciao_directives]).

:- document_export 
	  analyze_component/1,
          create_component/1,
	  create_component_internal/2,
          dump_component/1,
          loadmerge_component/1.

:- import slash/1 from machine.

:- import search_module/6 from consult.
:- import concat_atom/2 from string.
:- import write_canonical_lettervar/1 from xsb_writ.
:- import message/1 from standard.
:- import numbervars/3 from num_vars.

/*
component has_status dirty...

Incorporate antirelationships in create_component, etc.
*/

:- comment(module,"Typically, an OMS instance can be partitioned into
several separate cells, or @em{components} -- representing information
that arises from different sources, for instance, from UNSPSC, NAICS,
or DLAFIIG.  There may be a need for these components to be managed
separately so that various applications can update them and
incorporate their information.  The OMS components system attempts to
address this need.

The facts in an OMS instance may be partitioned in various ways.  A
@em{class-based component system} partitions an OMS-instance on

@begin{itemize}

@item the second-argument identifier source of all @em{class/2} and 
@pred{object/2} facts.

@item the first-argument identifier source of all other facts.

@end{itemize}
@noindent
Class-based components thus form a collection
vaguely analagous to a Java package, and are useful when different
processes are responsible for creating or modifying different classes
and objects.

A @em{relation-based component system} partitions an OMS instance on

@begin{itemize} 

@item the second-argument identifier source of all @pred{class/2} and
@pred{object/2} facts.

@item the first-argument identifier source of all @pred{memberof/2}
and @pred{subclass/2} facts.

@item the second-argument identifier source of all @pred{irel/3},
@pred{strel/3}, @pred{schrel/3}, @pred{attribute/3}, and
@pred{attribute_object/3} facts.

@end{itemize}

Relation-based component systems are useful when different processes
may be associated with creating or modifying different relations and
attributes for the same class or object.  By default, the OMS uses a
relation-based component system.

In either case, one component @em{C1} depends on another component
@em{C2} if @em{id(NID2,C2)} occurs in a fact in the @em{C1} component.
By this definition, it is easy to see that component dependency need
not be hierarchical so that two components may depend on one another;
furthermore each component must depend on itself.  In addition, each
component always depends on the component 'OMS' by fiat.

When a user loads a component he or she loads information from files
in external form (e.g. @tt{schema_omsext.P} and @tt{data_omsext.P}
files), or in external intensional form @tt{oms_extint.P}.  The OMS
cannot load as a component information in internal format (i.e. data
in @tt{schema_oms.P} and @tt{data_oms.P} files) as ambiguity arises if
one attempts to combine internal identifiers from different files.  It
does however provide tools to create components from a current loaded
OMS instance.

A convention is made that the name of a component is identical to the
directory in which it resides.  Thus, a component @em{unspsc} must
reside in the directory @em{unspsc}.  The OMS looks for these
directories using XSB's library search paths -- or a full pathname can
also be used.

Information about components resides in the OMS itself.  The OMS knows
about a component @em{C1} when @tt{id(C1,C1)} is a subclass of the
class @tt{id(component,OMS)}.  Component dependency is represented by
the relation @em{id(component_depends,OMS)}.  For components
consisting of external files, the predicate @pred{create_component/1}
can be used to add this information.  @tt{create_component(Dir)} reads
in external files, computes their dependencies, and writes out the
files, plus component information, back to @em{Dir}.  In the case
where a putative component includes an external intensional view,
dependency information for the external intensional view must be added
by hand.  Similarly, @pred{create_component_internal(Name,Dir)}
examines the facts in the component @tt{Name}, computes their
dependencies, and writes them as external facts to @tt{Dir}.

Components may be loaded via @pred{load_component/1} which loads a
component @em{C1} and all components on which @em{C1} transitively
depends.  If a component is modified, it may be saved to file via
@tt{dump_component/1} which dumps the component but not any subcomponents
on which it may depend.
").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(analyze_component/1,
"@tt{analyze_component(-Component,Dependency_list)} examines a loaded
OMS instance to partition it into components and for each component
@em{C} to return a list of components upon which @{C} depends").

:- comment(create_component/1,"@tt{create_component(Dir)} loads from
@tt{Dir} @tt{data_omsext.P}, and @tt{schema_omsext.P} files, creates a
component if possible, then dumps the new omsext that includes the
component information.").

create_component(Name):- 
	retract_omsext,
	abolish_table_pred(find_component_dependency/1),
	find_component_dir(Name,Full),
	load_omsext(Full),
	check_component(Name),
	assert(class_ext(Name,Name,Name)),
	assert(subclass_ext(Name,Name,component,'OMS')),
	create_dependencies(Name),
	dump_component_ext(Full,Name),
	retract_omsext.

/* works on loaded, unmerged omsext */	
create_dependencies(Name):- 
	find_component_dependency(Dep),
	call_assert(relationship_ext(Name,Name,
	                                     component_depends,'OMS',Dep,Dep)),
	fail.
create_dependencies(Name):- 
	asserta(relationship_ext(Name,Name,
	                                     component_depends,'OMS',Name,Name)).

%-----------
/* checks whether a set of loaded,  non-merged external facts with
a given source constitute a component */ 

check_component(Name):- 
	check_class(Name),
	check_object(Name),check_subclass(Name),
	check_memberof(Name),check_relationship(Name),
	check_schrel(Name),check_strel(Name),
	check_attribute(Name),check_attribute_object(Name).

check_class(Name):- 
	(class_ext(Q,W,N),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                                      ' has class with different source: ',
			              class_ext(Q,W,N)])
	; 
	   fail).
check_class(_).

check_object(Name):- 
	(object_ext(Q,W,N),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                                      ' has object with different source: ',
					      object_ext(Q,W,N)])
	; 
	   fail).
check_object(_).

check_subclass(Name):- 
	(subclass_ext(Q,N,W,E),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                                      ' has subclass with different source: ',
					      subclass_ext(Q,N,W,E)])
	; 
	   fail).
check_subclass(_).

check_memberof(Name):- 
	(memberof_ext(Q,N,W,E),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has memberof with different source: ',
			   memberof_ext(Q,N,W,E)])
	; 
	   fail).
check_memberof(_).

check_relationship(Name):- 
	(relationship_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has relationship with different source: ',
			   relationship_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_relationship(_).

check_schrel(Name):- 
	(schrel_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has schrel with different source: ',
			   schrel_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_schrel(_).

check_strel(Name):- 
	(strel_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has strel with different source: ',
			   strel_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_strel(_).

check_attribute(Name):- 
	(attribute_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has attribute with different source: ',
			   attribute_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_attribute(_).

check_attribute_object(Name):- 
	(attribute_object_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has attribute_object with different source: ',
			   attribute_object_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_attribute_object(_).


:- comment(create_component_internal/2,
"@tt{create_component_internal(Name,Dir)} dumps facts and intensional
rules for a component specified by @tt{Name} from a loaded OMS
instance to @tt{Dir}. ").

%-------------------------------------

/* find_component_dependency/1 returns the set of dependencies for a
putative component -- from a set of loaded, non-merged external facts.
Only those dependencies obtained from external form are returned --
extint dependencies must be added "by hand". */

:- table find_component_dependency/1.
find_component_dependency(Dep):- 
	find_component_dependency_1(Dep).

find_component_dependency_1(Dep):- 
	class_ext(_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	object_ext(_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	subclass_ext(_,_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	memberof_ext(_,_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	relationship_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	schrel_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	strel_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	attribute_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	attribute_object_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).

find_pc_dependency(Class,Dep):- 
	compound(Class),
	Class =.. [_|Arglist],
	find_pc_dependency_list(Arglist,Dep).
	
find_pc_dependency_list([_Class,S|_R],S).
find_pc_dependency_list([Class,S|_R],Dep):- 
	S \== 'OMS',
	find_pc_dependency(Class,Dep).
find_pc_dependency_list([_Class,_S|R],Dep):- 
	find_pc_dependency_list(R,Dep).

%-----------
/* dump_component_ext/2 is not to be exported -- it dumps from
extrernal format and is to be used with create component. */
dump_component_ext(Dir,Name):- 
	slash(Slash),
  	concat_atom([Dir,Slash,'schema_omsext.P'],SchFile),
	init_ext_schema_index,
	tell(SchFile),
	write_hdr(class_ext(_,_,_)),
	write_call(class_ext(_,_,Name)),
	write_hdr(subclass_ext(_,_,_,_)),
	write_call(subclass_ext(_,Name,_,_)),
	write_hdr(relationship_ext(_,_,_,_,_,_)),
	write_call(relationship_ext(_,Name,_,_,_,_)),
	write_hdr(schrel_ext(_,_,_,_,_,_)),
	write_call(schrel_ext(_,Name,_,_,_,_)),
	write_hdr(strel_ext(_,_,_,_,_,_)),
	write_call(strel_ext(_,Name,_,_,_,_)),
	told,
  	concat_atom([Dir,Slash,'data_omsext.P'],DataFile),
	init_ext_data_index,
	tell(DataFile),
	write_hdr(object_ext(_,_,_)),
	write_call(object_ext(_,_,Name)),
	write_hdr(memberof_ext(_,_,_,_)),
	write_call(memberof_ext(_,Name,_,_)),
	write_hdr(attribute_ext(_,_,_,_,_,_)),
	write_call(attribute_ext(_,Name,_,_,_,_)),
	write_hdr(attribute_object_ext(_,_,_,_,_,_)),
	write_call(attribute_object_ext(_,Name,_,_,_,_)),
	told.

%---

write_call(Call):- 
	abolish_table_pred(table_call/1),
	table_call(Call),
	write_ext_term(Call),
	fail.
write_call(_Call):-
	abolish_table_pred(table_call/1).

:- table table_call/1.
table_call(Call):- call(Call).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(loadmerge_component/1,"@tt{loadmerge_component(Name)} loads
the component @tt{Name}, and recursively, all other components upon
which @tt{Name} depends.").

loadmerge_component(Name):- 
	retract_omsext,
	load_component(Name),
	message(['Merging in components.']),nl,
	merge_omsext.

load_component(Name):- 
	message(['Loading component: ',Name]),nl,
	find_component_dir(Name,Full),
	overload_omsext(Full),
	is_component(Name),
	load_extint(Full),
            load_component_dependencies(Name).

load_component_dependencies(Name):- 
	relationship_ext(Name,Name,component_depends,'OMS',N,N),
	((N = Name ; N = 'OMS' ; class_ext(N,N,N) ; class(_,N,N,N)) -> 
	    true 
	  ; load_component(N) ),
	fail.
load_component_dependencies(_).

load_extint(Full):- 
	concat_atom([Full,'/oms_extint.P'],File),
	(file_exists(File) -> consult(File) ; true).

/* assuming that this means that all dependencies have been added...*/
is_component('OMS').
is_component(Name):- class_ext(Name,Name,Name).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(dump_component/1,"@tt{dump_component(Name)} dumps the
component @tt{Name}.  It does not dump other components upon which
@tt{Name} depends.").

dump_component(Name):- 
	find_component_dir(Name,Dir),
	throw_oms_writable(Dir),
	slash(Slash),
  	concat_atom([Dir,Slash,'schema_omsext.P'],SchFile),
	init_ext_schema_index,
	tell(SchFile),
	compwrite_class(Name),compwrite_subclass(Name),
	compwrite_irel(Name),compwrite_schrel(Name),
	compwrite_strel(Name),
	told,
  	concat_atom([Dir,Slash,'data_omsext.P'],DataFile),
	init_ext_data_index,
	tell(DataFile),
	compwrite_object(Name),compwrite_memberof(Name),
	compwrite_attribute(Name),compwrite_attribute_object(Name),
	told.

compwrite_class(Source):- 
	write_hdr(class_ext(_,_,_)),
	oms_cn(_,Name,Nid,Source),
	write_ext_term(class_ext(Name,Nid,Source)),
	fail.
compwrite_class(_).

compwrite_subclass(Source):- 
	write_hdr(subclass_ext(_,_,_,_)),
	oms_sc(Sub,Sup),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Sup,_,Nid1,Source1),
	write_ext_term(subclass_ext(Nid,Source,Nid1,Source1)),
	fail.
compwrite_subclass(_).
	
compwrite_object(Source):- 
	write_hdr(object_ext(_,_,_)),
	oms_obj(_,Name,Nid,Source),
	write_ext_term(object_ext(Name,Nid,Source)),
	fail.
compwrite_object(_).

compwrite_memberof(Source):- 
	write_hdr(memberof_ext(_,_,_,_)),
	oms_mo(Sub,Sup),
	oms_obj(Sub,_,Nid,Source),
	oms_cn(Sup,_,Nid1,Source1),
	write_ext_term(memberof_ext(Nid,Source,Nid1,Source1)),
	fail.
compwrite_memberof(_).

compwrite_irel(Source):- 
	write_hdr(relationship_ext(_,_,_,_,_,_)),
	oms_rln(Sub,Mid,Targ),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(
	                 relationship_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_irel(_).

compwrite_schrel(Source):- 
	write_hdr(schrel_ext(_,_,_,_,_,_)),
	oms_schrel(Sub,Mid,Targ),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(schrel_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_schrel(_).

compwrite_strel(Source):- 
	write_hdr(strel_ext(_,_,_,_,_,_)),
	oms_strel(Sub,Mid,Targ),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(strel_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_strel(_).

compwrite_attribute(Source):- 
	write_hdr(attribute_ext(_,_,_,_,_,_)),
	oms_at(Sub,Mid,Targ),
	oms_obj(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(
	           attribute_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_attribute(_).

compwrite_attribute_object(Source):- 
	write_hdr(attribute_object_ext(_,_,_,_,_,_)),
	oms_ao(Sub,Mid,Targ),
	oms_obj(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_obj(Targ,_,Nid2,Source2),
	write_ext_term(
	       attribute_object_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_attribute_object(_).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

find_component_dir(Name,Full):- 
	(search_module(Name,_Dir_part,_Base_part,_Ext,Full,_Obj) 
                -> true 
	    ; 
	        oms_error(component,['can''t find component: ',Name])),
	(path_sysop(isdir,Full) -> 
	    true 
	  ; 
	     oms_error(component,['component name is not a directory',Full])).

overload_omsext(Dir) :-
	oms_fix_dir(Dir,DirS),
	dir_overload_dync(DirS,schema_omsext),
	dir_overload_dync(DirS,data_omsext).

dir_overload_dync(Dir,Base) :-
	concat_atom([Dir,Base,'.P'],File),!,
	(overload_dync(File) 		% i.e. use asserta
              -> true
	  ; oms_warning(permission,('File does not exist ',
                                    'or is not readable: ',File))).

overload_dync(File):- 
	see(File),
	overload_dync_1,
	seen.

overload_dync_1:- 
	repeat,
	read_canonical(T),
	(T = end_of_file -> true ; asserta(T),fail).

end_of_file.

