:- compiler_options([ciao_directives]).

:- document_export 
	  analyze_components/2,
          create_external_component/1,
	  update_all_components/1,
	  update_components/2,
          loadmerge_component/2.

:- import slash/1 from machine.

:- import search_module/6 from consult.
:- import concat_atom/2 from string.
:- import write_canonical_lettervar/1 from xsb_writ.
:- import message/1 from standard.
:- import numbervars/3 from num_vars.
:- import member/2 from basics.

:- ensure_loaded(oms_io).
:- ensure_loaded(oms_queries).

:- comment(module,"Typically, an OMS instance can be partitioned into
several separate cells, representing information that arises from
different sources, for instance, from UNSPSC, NAICS, or DLAFIIG.
There may be a need for these cells to be managed separately so that
various applications can update them and incorporate their
information.  The OMS components system attempts to address this need
by allowing ontologies to be built from non-overlapping
@em{components}.

The facts in an OMS instance may be partitioned in various ways.  A
@em{class-based component system} partitions an OMS-instance on

@begin{itemize}

@item the second-argument identifier source of all @em{class/2} and 
@pred{object/2} facts.

@item the first-argument identifier source of all other facts.

@end{itemize}
@noindent
Class-based components thus form a collection
vaguely analagous to a Java package, and are useful when different
processes are responsible for creating or modifying different classes
and objects.

A @em{relation-based component system} partitions an OMS instance on

@begin{itemize} 

@item the second-argument identifier source of all @pred{class/2} and
@pred{object/2} facts.

@item the first-argument identifier source of all @pred{memberof/2}
and @pred{subclass/2} facts.

@item the second-argument identifier source of all @pred{irel/3},
@pred{strel/3}, @pred{schrel/3}, @pred{attribute/3}, and
@pred{attribute_object/3} facts.

@end{itemize}

Relation-based component systems are useful when different processes
may be associated with creating or modifying different relations and
attributes for the same class or object.  By default, the OMS uses a
relation-based component system.

In either case, one component @em{C1} depends on another component
@em{C2} if @em{id(NID2,C2)} occurs in a fact in the @em{C1} component.
By this definition, it is easy to see that component dependency need
not be hierarchical so that two components may depend on one another;
furthermore each component must depend on itself.  In addition, each
component always depends on the component 'OMS' by fiat.

When a user loads a component he or she loads information from files
in external form (e.g. @tt{schema_omsext.P} and @tt{data_omsext.P}
files), or in external intensional form @tt{oms_extint.P}.  The OMS
cannot load as a component information in internal format (i.e. data
in @tt{schema_oms.P} and @tt{data_oms.P} files) as ambiguity arises if
one attempts to combine internal identifiers from different files.  It
does however provide tools to create components from a current loaded
OMS instance.

Information about components resides in the OMS itself which
represents a component name along with a version using the product
class @tt{compVers{id(Name,Name),id(integer(Version),'OMS'))}$ (in the
'OMS' component).  Information about a component and version is
maintained as a subclass of @tt{id('OMS Component','OMS')}.  Component
dependency is represented by the relation
@em{id('componentDepends',Component)}.  An OMS state can contain only
one version for each component name, which constraint affects the
behavior of certain or the routines below.

A convention is made that a component @tt{Name} with version @tt{V} is
to be found in a directory named @tt{Name_V}. The OMS looks for these
directories using XSB's library search paths -- or a full pathname can
also be used to avoid ambiguity.

Given an OMS state, a user may want to do several things.  
@begin{enumerate}

@item A user may wish to create components from an OMS state, or to
update components used by an OMS state.  One way to do this is by
@{update_all_components(Dir)} which determines a class or relation
based partition of the OMS instance, and computes all dependencies
between these cells.  Cells that are not components are made into
components (with version 0), and that are already components have
their version number updated if necessary (by checking
@tt{oms_dirty/1}).  New and updated components are written as
subdirectories of @tt{Dir}.

Alternately, if a part of a loaded OMS instance is to be saved as a
component the predicate @tt{update_components(List,Dir)} can be used.
@tt{List} is a list of component names, and for each @tt{Name} in
@tt{List}, @pred{update_components/2} writes ou the component
@tt{Name} as a subdirectory of @tt{Dir} whose version is either 0 if
the component is new, or incremented if the component is updated.  The
predicate gives an error if a component @tt{Name} in @tt{List} depends
on an updated component not in @tt{List}, or if it depends on a cell
that has not been made into a component.

In the case where a external intensional view is part of an OMS state,
dependency information for the external intensional view must be added
by hand.

@item A user may wish to create components from external files.  In
this case, the predicate @pred{create_external_component/1} can be
used to add this information.  @tt{create_external_component(Dir)}
reads in external files, computes their dependencies, and writes out
the files, plus component information, back to @em{Dir}.  The
information in this component does not affec the state of the OMS
until it is explicitly loaded.  In the case where a putative component
includes an external intensional view, dependency information for the
external intensional view must be added by hand.

@item A user may wish to load components.  This is done via
@tt{loadmerge_component(Name.Version)} which loads version
@tt{Version} of component @tt{Name} as found in directory @tt{Dir}.
along with a component @em{C1} and all components on which @em{C1}
transitively depends.  If a version conflict is detected between a
component to be loaded and one already in the OMS state or about to be
loaded, @tt{loadmerge_component/2} aborts without changing the OMS
state.  Alternately, a user may give a full path name to
@pred{loadmerge_component(Directory,Name.Version)} to obtain a
component from a particular version.

@tt{fast_loadmerge_component(Name.Version)} calls a
@tt{fast_merge_omsext} which does no redundancy checking and so can be
much faster than @t{_loadmerge_component(Name.Version)}.



@item Finally, a user may analyze component dependency information via
@tt{analyze_dependency/2}, which neither affects the OMS state, nor
saves component information to files.  
@end{enumerate} 

@em{
This version does not handle intensional_rules -- it will once we
agree on conventions for how an intensional rule are to be associated
with components.

This version does not yet use dirty bits to determine when new
versions need to be created.

").

:- dynamic oms_component_type/1.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(analyze_components/2,
"@tt{analyze_components(-Component,-Dependency_list)} examines a loaded
OMS instance to partition it into components and for each component
@em{C} to return a list of components upon which @tt{C} depends.  It
works for either relation or class based components.").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

analyze_components(Name,List):- 
	abolish_table_pred(analyze_component_relation_1/2),
	(oms_component_type(class_based) -> 
 	    analyze_component_class(Name1,List),
	    get_version_info(Name1,Name)
	  ; 
 	    analyze_component_relation(Name1,List),
	    get_version_info(Name1,Name)).

%-----------
analyze_component_relation(Name,List):-
	setof(Dep,analyze_component_relation_w_version(Name,Dep),List).

analyze_component_relation_w_version(Name,Dep):-
	analyze_component_relation_1(Name,Dep1),
        get_version_info(Dep1,Dep)
	  ; 
	 get_version_info('OMS',Dep).

:- table analyze_component_relation_1/2.
analyze_component_relation_1(Name,Name):- 
	analyze_class(Name,Name).
analyze_component_relation_1(Name,Name):- 
	analyze_object(Name,Name).
analyze_component_relation_1(Name,Dep):- 
	analyze_subclass(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_memberof(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_irel_r(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_strel_r(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_schrel_r(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_attribute_r(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_attribute_object_r(Name,Dep).

get_version_info(Name,CV):- 
   (q_immediate_subclass(id(compVers(Name,Name,integer(Version),'OMS'),'OMS'),
			 id('OMS Component','OMS')) -> 
	    CV = compVers(Name,Name,integer(Version),'OMS')
	  ; CV = compVers(Name,Name,integer(0),'OMS')).
	
analyze_irel_r(Name,Dep):-  
	oms_rln(Id1,Id2,Id3),
	source_from_cid(Id2,Name),
	(Dep = Name ; source_from_cid(Id1,Dep) ; source_from_cid(Id3,Dep)).
analyze_strel_r(Name,Dep):-  
	oms_strel(Id1,Id2,Id3),
	source_from_cid(Id2,Name),
	(Dep = Name ; source_from_cid(Id1,Dep) ; source_from_cid(Id3,Dep)).
analyze_schrel_r(Name,Dep):-  
	oms_schrel(Id1,Id2,Id3),
	source_from_cid(Id2,Name),
	(Dep = Name ; source_from_cid(Id1,Dep) ; source_from_cid(Id3,Dep)).
analyze_attribute_r(Name,Dep):-  
	oms_at(Id1,Id2,Id3),
	source_from_cid(Id2,Name),
	(Dep = Name ; source_from_oid(Id1,Dep) ; source_from_cid(Id3,Dep)).
analyze_attribute_object_r(Name,Dep):-  
	oms_at(Id1,Id2,Id3),
	source_from_cid(Id2,Name),
	(Dep = Name ; source_from_oid(Id1,Dep) ; source_from_oid(Id3,Dep)).

%-----------
analyze_component_class(Name,List):-
	setof(Dep,
	      (analyze_component_class_1(Name,Dep) ; Dep = 'OMS'),List).

:- table analyze_component_class_1/2.
analyze_component_class_1(Name,Name):- 
	analyze_class(Name,Name).
analyze_component_class_1(Name,Name):- 
	analyze_object(Name,Name).
analyze_component_class_1(Name,Dep):- 
	analyze_subclass(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_memberof(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_irel_c(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_strel_c(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_schrel_c(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_attribute_c(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_attribute_object_c(Name,Dep).

analyze_irel_c(Name,Dep):-  
	oms_rln(Id1,Id2,Id3),
	source_from_cid(Id1,Name),
	(Dep = Name ; source_from_cid(Id2,Dep) ; source_from_cid(Id3,Dep)).
analyze_strel_c(Name,Dep):-  
	oms_strel(Id1,Id2,Id3),
	source_from_cid(Id1,Name),
	(Dep = Name ; source_from_cid(Id2,Dep) ; source_from_cid(Id3,Dep)).
analyze_schrel_c(Name,Dep):-  
	oms_schrel(Id1,Id2,Id3),
	source_from_cid(Id1,Name),
	(Dep = Name ; source_from_cid(Id2,Dep) ; source_from_cid(Id3,Dep)).
analyze_attribute_c(Name,Dep):-  
	oms_at(Id1,Id2,Id3),
	source_from_cid(Id1,Name),
	(Dep = Name ; source_from_oid(Id2,Dep) ; source_from_cid(Id3,Dep)).
analyze_attribute_object_c(Name,Dep):-  
	oms_at(Id1,Id2,Id3),
	source_from_cid(Id1,Name),
	(Dep = Name ; source_from_oid(Id2,Dep) ; source_from_oid(Id3,Dep)).

%----------------

source_from_cid(Id,Source):-  oms_cn(Id,_,_,Source).
source_from_cid(Id,Source):-  
	compound(Id), 
	\+ (oms_primitive_class(Id,_,_,_)),
	Id =.. [_|Arglist],
	source_from_cid_list(Arglist,Source).
		
source_from_cid_list(Arglist,Source):- 
	member(Id,Arglist),
	source_from_cid(Id,Source).
source_from_cid(Id,Source):-  oms_cn(Id,_,_,Source).

source_from_oid(Id,Source):-  oms_obj(Id,_,_,Source).
source_from_oid(Id,Source):-  
	compound(Id), Id =.. [_|Arglist],
	source_from_oid_list(Arglist,Source).
		
source_from_oid_list(Arglist,Source):- 
	member(Id,Arglist),
	source_from_cid(Id,Source).

analyze_class(Name,Name):-  
	oms_cn(Id,_,_,_),
	source_from_cid(Id,Name).
analyze_object(Name,Name):-  
	oms_obj(Id,_,_,_),
	source_from_oid(Id,Name).
analyze_subclass(Name,Dep):-  
	oms_sc(Id1,Id2),
	source_from_cid(Id1,Name),
	(Dep = Name ; source_from_cid(Id2,Dep)).
analyze_memberof(Name,Dep):-  
	oms_mo(Id1,Id2),
	source_from_oid(Id1,Name),
	(Dep = Name ; source_from_cid(Id2,Dep)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(create_external_component/1,"
@tt{create_external_component(Dir)} loads from @tt{Dir}
@tt{data_omsext.P}, and @tt{schema_omsext.P} files, creates a
component if possible, then dumps the new omsext that includes the
component information.").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

create_external_component(Name):- 
	retract_omsext,
	abolish_table_pred(find_component_dependency/1),
	find_component_dir(Name,Full),
	load_omsext(Full),
	check_component(Name),
	assert(class_ext(Name,Name,Name)),
	assert(subclass_ext(Name,Name,'OMS Component','OMS')),
	create_dependencies_ext(Name),
	dump_component_ext(Full,Name),
	retract_omsext.

/* works on loaded, unmerged omsext */	
create_dependencies_ext(Name):- 
	find_component_dependency(Dep),
	call_assert(relationship_ext(Name,Name,
	                             componentDepends,Name,Dep,Dep)),
	fail.
create_dependencies(Name):- 
	asserta(relationship_ext(Name,Name,
	                         componentDepends,Name,Name,Name)).

%-----------
/* checks whether a set of loaded,  non-merged external facts with
a given source constitute a component */ 

check_component(Name):- 
	check_class(Name),
	check_object(Name),check_subclass(Name),
	check_memberof(Name),check_relationship(Name),
	check_schrel(Name),check_strel(Name),
	check_attribute(Name),check_attribute_object(Name).

check_class(Name):- 
	(class_ext(Q,W,N),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                                      ' has class with different source: ',
			              class_ext(Q,W,N)])
	; 
	   fail).
check_class(_).

check_object(Name):- 
	(object_ext(Q,W,N),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                                      ' has object with different source: ',
					      object_ext(Q,W,N)])
	; 
	   fail).
check_object(_).

check_subclass(Name):- 
	(subclass_ext(Q,N,W,E),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                                      ' has subclass with different source: ',
					      subclass_ext(Q,N,W,E)])
	; 
	   fail).
check_subclass(_).

check_memberof(Name):- 
	(memberof_ext(Q,N,W,E),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has memberof with different source: ',
			   memberof_ext(Q,N,W,E)])
	; 
	   fail).
check_memberof(_).

check_relationship(Name):- 
	(relationship_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has relationship with different source: ',
			   relationship_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_relationship(_).

check_schrel(Name):- 
	(schrel_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has schrel with different source: ',
			   schrel_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_schrel(_).

check_strel(Name):- 
	(strel_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has strel with different source: ',
			   strel_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_strel(_).

check_attribute(Name):- 
	(attribute_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has attribute with different source: ',
			   attribute_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_attribute(_).

check_attribute_object(Name):- 
	(attribute_object_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has attribute_object with different source: ',
			   attribute_object_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_attribute_object(_).

%-------------------------------------

/* find_component_dependency/1 returns the set of dependencies for a
putative component -- from a set of loaded, non-merged external facts.
Only those dependencies obtained from external form are returned --
extint dependencies must be added "by hand". */

:- table find_component_dependency/1.
find_component_dependency(Dep):- 
	find_component_dependency_1(Dep).

find_component_dependency_1(Dep):- 
	class_ext(_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	object_ext(_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	subclass_ext(_,_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	memberof_ext(_,_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	relationship_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	schrel_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	strel_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	attribute_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	attribute_object_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).

find_pc_dependency(Class,Dep):- 
	compound(Class),
	Class =.. [_|Arglist],
	find_pc_dependency_list(Arglist,Dep).
	
find_pc_dependency_list([_Class,S|_R],S).
find_pc_dependency_list([Class,S|_R],Dep):- 
	S \== 'OMS',
	find_pc_dependency(Class,Dep).
find_pc_dependency_list([_Class,_S|R],Dep):- 
	find_pc_dependency_list(R,Dep).

%-----------
/* dump_component_ext/2 is not to be exported -- it dumps from
extrernal format and is to be used with create component. */
dump_component_ext(Dir,Name):- 
	slash(Slash),
  	concat_atom([Dir,Slash,'schema_omsext.P'],SchFile),
	init_ext_schema_index,
	tell(SchFile),
	write_hdr(class_ext(_,_,_)),
	write_call(class_ext(_,_,Name)),
	write_hdr(subclass_ext(_,_,_,_)),
	write_call(subclass_ext(_,Name,_,_)),
	write_hdr(relationship_ext(_,_,_,_,_,_)),
	write_call(relationship_ext(_,Name,_,_,_,_)),
	write_hdr(schrel_ext(_,_,_,_,_,_)),
	write_call(schrel_ext(_,Name,_,_,_,_)),
	write_hdr(strel_ext(_,_,_,_,_,_)),
	write_call(strel_ext(_,Name,_,_,_,_)),
	told,
  	concat_atom([Dir,Slash,'data_omsext.P'],DataFile),
	init_ext_data_index,
	tell(DataFile),
	write_hdr(object_ext(_,_,_)),
	write_call(object_ext(_,_,Name)),
	write_hdr(memberof_ext(_,_,_,_)),
	write_call(memberof_ext(_,Name,_,_)),
	write_hdr(attribute_ext(_,_,_,_,_,_)),
	write_call(attribute_ext(_,Name,_,_,_,_)),
	write_hdr(attribute_object_ext(_,_,_,_,_,_)),
	write_call(attribute_object_ext(_,Name,_,_,_,_)),
	told.

%---

write_call(Call):- 
	abolish_table_pred(table_call/1),
	table_call(Call),
	write_ext_term(Call),
	fail.
write_call(_Call):-
	abolish_table_pred(table_call/1).

:- table table_call/1.
table_call(Call):- call(Call).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(loadmerge_component/2,
"@tt{loadmerge_component(Name,Version)} loads version @tt{Version} of
the component @tt{Name}, and recursively, all other components upon
which @tt{Name} depends.  If a file name or relative pathname is
given, the component is found by searching through XSB library
directories.  Otherwise, if a full pathname is given in Name, the
component is obtained directly ").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

loadmerge_component(Name,Version):- 
	retract_omsext,
	load_component(Name,Version),
	message(['Merging in components.']),nl,
	merge_omsext.

fast_loadmerge_component(Name,Version):- 
	retract_omsext,
	load_component(Name,Version),
	message(['Merging in components.']),nl,
	fast_merge_omsext.

load_component(Name,Version):- 
	message(['Loading component: ',Name,'_',Version]),nl,
	concat_atom([Name,'_',Version],NewName),
	find_component_dir(NewName,Full),
	overload_omsext(Full),
	is_component(Name),
	load_extint(Full),
        load_component_dependencies(Name,Version).

load_component_dependencies(Name,V):- 
	relationship_ext(compVers(Name,Name,integer(V),'OMS'),'OMS',
			 componentDepends,Name,
			 compVers(New,New,integer(Vnew),'OMS'),'OMS'),
	((New = Name ; New = 'OMS' 
	   ; class_ext(New,New,New) ; class(_,New,New,New)) -> 
	    true 
	  ; load_component(New,Vnew) ),
	fail.
load_component_dependencies(_,_).

load_extint(Full):- 
	concat_atom([Full,'/oms_extint.P'],File),
	(file_exists(File) -> consult(File) ; true).

/* TLS: assume that if a component is known, its dependencies are in
_ext facts.  Also, need to create class_ext(Name,Name,Name) in order
to have compVers/2. */
is_component('OMS').
is_component(Name):- class_ext(Name,Name,Name).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(update_all_components/1, "@tt{update_all_components(Dir)}
analyzes components of an OMS state and their states, creates
components when necessary, and dumps facts and intensional rules for
all components, as subdirectories of @tt{Dir}.  New versions are
created for components that have been updated since they were
loaded. ").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

update_all_components(Dir):- 
	analyze_components(Comp,Dep),
	Comp = compVers(Name,Name,integer(V),_),
	newComponent(Name,NameId,RelId),
	create_dependencies_int_1(Dep,Name,NameId,RelId),
	dump_component_1(Dir,Name,V),
	fail.
update_all_components(_Dir).

:- comment(update_components/2, "@tt{update_all_components(Dir,List)}
Updates components in @tt{List} (or creates them) writing them into
subdirectories of @tt{Dir}.  If a component in @tt{List} depends on a
component that needs updating but is not in list or on a source that
has not been made into a component, the predicate abort without
changing the state or file system.  ").

update_components(_Dir,_List):- 
	abort('update_components/2 not yet implemented').

/* Create a new component for each cell name in dependency list or
find the version number of the component to which cell name belongs.
Then, add the dependency structure. */
create_dependencies_int_1([],_Name,_Compid,_Relid).
create_dependencies_int_1([compVers(Name,Name,integer(V),'OMS')|T],
			  Name1,Compid,Relid):- 
	Name \== Name1,!,
	(V == 0 -> 
	      newComponent(Name,NewCompId,_NewRelid) 
	    ; class(NewCompId,_,compVers(Name,Name,integer(V),'OMS'),'OMS') ),
	newIrel(Compid,Relid,NewCompId),
	create_dependencies_int_1(T,Name,Compid,Relid).
create_dependencies_int_1([_|T],Name,Compid,Relid):- 
	create_dependencies_int_1(T,Name,Compid,Relid).

dump_component_1(Dir,Name,Version):- 
	(oms_component_type(class_based) -> 
	    dump_component_1_class(Dir,Name,Version)
	  ; 
	    dump_component_1_relation(Dir,Name,Version)).

dump_component_1_class(Dir,Name,Version):- 
	slash(Slash),
  	concat_atom([Dir,Slash,Name,'_',Version],NewDir),
	xsb_makedir(NewDir),
	concat_atom([NewDir,Slash,'schema_omsext.P'],SchFile),
	init_ext_schema_index,
	tell(SchFile),
	compwrite_class(Name),compwrite_subclass(Name),
	compwrite_irel_c(Name),compwrite_schrel_c(Name),
	compwrite_strel_c(Name),
	told,
  	concat_atom([NewDir,Slash,'data_omsext.P'],DataFile),
	init_ext_data_index,
	tell(DataFile),
	compwrite_object(Name),compwrite_memberof(Name),
	compwrite_attribute_c(Name),compwrite_attribute_object_c(Name),
	told.

compwrite_irel_c(Source):- 
	write_hdr(relationship_ext(_,_,_,_,_,_)),
	oms_rln(Sub,Mid,Targ),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(
                 relationship_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_irel_c(_).

compwrite_schrel_c(Source):- 
	write_hdr(schrel_ext(_,_,_,_,_,_)),
	oms_schrel(Sub,Mid,Targ),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(schrel_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_schrel_c(_).

compwrite_strel_c(Source):- 
	write_hdr(strel_ext(_,_,_,_,_,_)),
	oms_strel(Sub,Mid,Targ),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(strel_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_strel_c(_).

compwrite_attribute_c(Source):- 
	write_hdr(attribute_ext(_,_,_,_,_,_)),
	oms_at(Sub,Mid,Targ),
	oms_obj(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(
	           attribute_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_attribute_c(_).

compwrite_attribute_object_c(Source):- 
	write_hdr(attribute_object_ext(_,_,_,_,_,_)),
	oms_ao(Sub,Mid,Targ),
	oms_obj(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_obj(Targ,_,Nid2,Source2),
	write_ext_term(
	       attribute_object_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_attribute_object_c(_).

%----------

dump_component_1_relation(Dir,Name,Version):- 
	slash(Slash),
  	concat_atom([Dir,Slash,Name,'_',Version],NewDir),
	xsb_makedir(NewDir),
	concat_atom([NewDir,Slash,'schema_omsext.P'],SchFile),
	init_ext_schema_index,
	tell(SchFile),
	compwrite_class(Name),compwrite_subclass(Name),
	compwrite_irel_r(Name),compwrite_schrel_r(Name),
	compwrite_strel_r(Name),
	told,
	concat_atom([NewDir,Slash,'data_omsext.P'],DataFile),
	init_ext_data_index,
	tell(DataFile),
	compwrite_object(Name),compwrite_memberof(Name),
	compwrite_attribute_r(Name),compwrite_attribute_object_r(Name),
	told.

compwrite_irel_r(Source):- 
%	write_hdr(relationship_ext(_,_,_,_,_,_)),
	oms_rln(Sub,Mid,Targ),
%	writeln(oms_rln(Sub,Mid,Targ)),
	class_cidbound(Mid,_,Nid1,Source),
	class_cidbound(Sub,_,Nid,Source1),
	class_cidbound(Targ,_,Nid2,Source2),
	write_ext_term(
                 relationship_ext(Nid,Source1,Nid1,Source,Nid2,Source2)),
	fail.
compwrite_irel_r(_).

compwrite_schrel_r(Source):- 
	write_hdr(schrel_ext(_,_,_,_,_,_)),
	oms_schrel(Sub,Mid,Targ),
	class_cidbound(Sub,_,Nid,Source1),
	class_cidbound(Mid,_,Nid1,Source),
	class_cidbound(Targ,_,Nid2,Source2),
	write_ext_term(schrel_ext(Nid,Source1,Nid1,Source,Nid2,Source2)),
	fail.
compwrite_schrel_r(_).

compwrite_strel_r(Source):- 
	write_hdr(strel_ext(_,_,_,_,_,_)),
	oms_strel(Sub,Mid,Targ),
	class_cidbound(Sub,_,Nid,Source1),
	class_cidbound(Mid,_,Nid1,Source),
	class_cidbound(Targ,_,Nid2,Source2),
	write_ext_term(strel_ext(Nid,Source1,Nid1,Source,Nid2,Source2)),
	fail.
compwrite_strel_r(_).

compwrite_attribute_r(Source):- 
	write_hdr(attribute_ext(_,_,_,_,_,_)),
	oms_at(Sub,Mid,Targ),
	oms_obj(Sub,_,Nid,Source1),
	class_cidbound(Mid,_,Nid1,Source),
	class_cidbound(Targ,_,Nid2,Source2),
	write_ext_term(
	           attribute_ext(Nid,Source1,Nid1,Source,Nid2,Source2)),
	fail.
compwrite_attribute_r(_).

compwrite_attribute_object_r(Source):- 
	write_hdr(attribute_object_ext(_,_,_,_,_,_)),
	oms_ao(Sub,Mid,Targ),
	oms_obj(Sub,_,Nid,Source1),
	class_cidbound(Mid,_,Nid1,Source),
	oms_obj(Targ,_,Nid2,Source2),
	write_ext_term(
	       attribute_object_ext(Nid,Source1,Nid1,Source,Nid2,Source2)),
	fail.
compwrite_attribute_object_r(_).

%---------

compwrite_class(Source):- 
	write_hdr(class_ext(_,_,_)),
	oms_cn(_,Name,Nid,Source),
	write_ext_term(class_ext(Name,Nid,Source)),
	fail.
compwrite_class(_).

compwrite_subclass(Source):- 
	write_hdr(subclass_ext(_,_,_,_)),
	oms_sc(Sub,Sup),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Sup,_,Nid1,Source1),
	write_ext_term(subclass_ext(Nid,Source,Nid1,Source1)),
	fail.
compwrite_subclass(_).
	
compwrite_object(Source):- 
	write_hdr(object_ext(_,_,_)),
	oms_obj(_,Name,Nid,Source),
	write_ext_term(object_ext(Name,Nid,Source)),
	fail.
compwrite_object(_).

compwrite_memberof(Source):- 
	write_hdr(memberof_ext(_,_,_,_)),
	oms_mo(Sub,Sup),
	oms_obj(Sub,_,Nid,Source),
	oms_cn(Sup,_,Nid1,Source1),
	write_ext_term(memberof_ext(Nid,Source,Nid1,Source1)),
	fail.
compwrite_memberof(_).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Utilities
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
find_component_dir(Name,Full):- 
	(search_module(Name,_Dir_part,_Base_part,_Ext,Full,_Obj) 
                -> true 
	    ; 
	        oms_error(component,['can''t find component: ',Name])),
	(path_sysop(isdir,Full) -> 
	    true 
	  ; 
	     oms_error(component,['component name is not a directory',Full])).

overload_omsext(Dir) :-
	oms_fix_dir(Dir,DirS),
	dir_overload_dync(DirS,schema_omsext),
	dir_overload_dync(DirS,data_omsext).

dir_overload_dync(Dir,Base) :-
	concat_atom([Dir,Base,'.P'],File),!,
	(overload_dync(File) 		% i.e. use asserta
              -> true
	  ; oms_warning(permission,('File does not exist ',
                                    'or is not readable: ',File))).

overload_dync(File):- 
	see(File),
	overload_dync_1,
	seen.

overload_dync_1:- 
	repeat,
	read_canonical(T),
	(T = end_of_file -> true ; asserta(T),fail).

xsb_makedir(Dir):- 
	(path_sysop(isdir,Dir) -> true ; path_sysop(mkdir,Dir)).

end_of_file.

:- comment(dump_component/1,"@tt{dump_component(Name)} dumps the
component @tt{Name}.  It does not dump other components upon which
@tt{Name} depends.").

dump_component(Name):- 
	find_component_dir(Name,Dir),
	throw_oms_writable(Dir),
	dump_component_1(Dir,Name).

