:- compiler_options([ciao_directives]).

:- document_export 
	  analyze_components/2,
%          create_external_component/1,
	  update_all_components/1,
	  update_components/2,
          loadmerge_component/2,
	  add_component_initializer/2.

:- import slash/1 from machine.

:- import search_module/6 from consult.
:- import concat_atom/2 from string.
:- import write_canonical_lettervar/1 from xsb_writ.
:- import message/1 from standard.
:- import numbervars/3 from num_vars.
:- import member/2 from basics.
:- import pretty_print/1 from newpp.

:- ensure_loaded(oms_io).
:- ensure_loaded(oms_queries).

:- comment(module,"Typically, an OMS instance can be partitioned into
several separate cells, representing information that arises from
different sources, for instance, from UNSPSC, NAICS, or DLAFIIG.
There may be a need for these cells to be managed separately so that
various applications can update them and incorporate their
information.  The OMS components system attempts to address this need
by allowing ontologies to be built from non-overlapping
@em{components}.

One method of partitioning facts in an OMS instance (whether it be a
loaded state or set of external files) is to choose a @em{component
argument} for each predicate type, and to set as the component of each
fact the source of the identifier in the component argument.  (If the
identifier is a product identifier, the source is the source of the
outer function symbol).  Using this method, the facts in an OMS
instance may be partitioned in various ways.

A @em{class-based component system} chooses as component arguments:

@begin{itemize}

@item the second-argument of all @em{class/2} and @pred{object/2}
facts.

@item the first-argument of all other facts.

@end{itemize} 
@noindent Class-based components thus form a collection
vaguely analagous to a Java package, and are useful when different
processes are responsible for creating or modifying different classes
and objects.

A @em{relation-based component system} chooses as argument identifiers

@begin{itemize} @item the second-argument of all @pred{class/2} and
@pred{object/2} facts.

@item the first-argument of all @pred{memberof/2} and
@pred{subclass/2} facts.

@item the second-argument of all @pred{irel/3}, @pred{strel/3},
@pred{schrel/3}, @pred{attribute/3}, and @pred{attribute_object/3}
facts.

@end{itemize}

Relation-based component systems differ from class-based systems only
in their partitions of relations and attributes.  Relation-based
component systems are useful when different processes may be
associated with creating or modifying different relations and
attributes for the same class or object.  The OMS uses a
relation-based component system.

In either case, one component @em{C1} directly depends on another
component @em{C2} if @em{id(NID2,C2)} is a non-component argument in a
fact in component @em{C1}; or if @em{id(NID2,C2)} occurs in a
component argument in a fact in component @em{C1}.  This definition
implies that a component in a constituent of a product identifier give
rise to dependencies dependencies only if the product identifier is in
the component argument of a fact.  By this definition, it is easy to
see that component dependency need not be hierarchical so that two
components may directly depend on one another; furthermore each
component must directly depend on itself.  In addition, each component
always derectly depends on the component 'OMS' by fiat.  Component
dependency is defined as the transitive closure of direct dependency.

Dependency information is used to determine how to load a component
and when to update it and is usually computed by the OMS.  Computing
dependency information is easy for extensional facts, but computing
dependency information for intensional rules is harder, as the
component system would need to compute all answer substitutions to
determine all dependencies, and this in impractical for some sets of
intensional rules.  Rather, dependencies are computed by checking the
top-level arguments of intensional rules, which leads to an
under-approximation of the dependencies.

When a user loads a component he or she loads information from files
in external form (e.g. @tt{schema_omsext.P} and @tt{data_omsext.P}
files), or in external intensional form @tt{oms_intensional.P}.  The
OMS cannot load as a component information in internal format
(i.e. data in @tt{schema_oms.P} and @tt{data_oms.P} files) as
ambiguity arises if one attempts to combine internal identifiers from
different files.  It does however provide tools to create components
from a current loaded OMS state.  

Information about components resides in the OMS itself which
represents a component name as the class @tt{id(Name,Name)}, which is
maintained as an immediate subclass of @tt{id('OMS Component','OMS')}.
Since components are not expected to have members, information about
them is maintained through @pred{strel/3} facts.  The version of
component @tt{Name} is kept via the strel @tt{id(has_version,Name)},
and its dependency information by the strel
@tt{id('componentDepends',Component)}.  An OMS state can contain only
one version for each component name, which constraint affects the
behavior of certain or the routines below.

Once version @tt{Version} of component @tt{Name} has been loaded,
 the OMS checks to see whether it has a strel
@tt{id(initialization_file,Name)} indicating an initialization file,
represented as the primitive type @tt{atom/1}.  If so, the file is
consulted, and the actions of the file are taken to be transparent to
the 'OMS' (unless they explicitly call OMS routines).  As a
convenience the predicate
@pred{add_component_initializer(Component,File)} can be used to add
@tt{File} as an initialization file for @tt{Component}.

A convention is made that a component @tt{Name} with version @tt{V} is
to be found in a directory named @tt{Name_V}. The OMS looks for these
directories using XSB's library search paths -- or a full pathname can
also be used to avoid ambiguity.

Given an OMS state, a user may want to do several things.  
@begin{enumerate}

@item A user may wish to create components from an OMS state, or to
update components used by an OMS state.  One way to do this is by the
predicate @tt{update_all_components(Dir)} which determines a class or
relation based partition of the OMS instance, and computes all
dependencies between these cells.  Cells that are not components are
made into components (with version 0), and that are already components
have their version number updated if necessary (by checking
@tt{oms_dirty/1}).  New and updated components are written as
subdirectories of @tt{Dir}.

Alternately, if a part of a loaded OMS instance is to be saved as a
component the predicate @tt{update_components(List,Dir)} can be used.
@tt{List} is a list of component names, and for each @tt{Name} in
@tt{List}, @pred{update_components/2} writes ou the component
@tt{Name} as a subdirectory of @tt{Dir} whose version is either 0 if
the component is new, or incremented if the component is updated.  The
predicate gives an error if a component @tt{Name} in @tt{List} depends
on an updated component not in @tt{List}, or if it depends on a cell
that has not been made into a component.

@item A user may wish to load components.  This is done via
@tt{loadmerge_component(Name.Version)} which loads version
@tt{Version} of component @tt{Name} as found in directory @tt{Dir}.
along with a component @em{C1} and all components on which @em{C1}
transitively depends.  If a version conflict is detected between a
component to be loaded and one already in the OMS state or about to be
loaded, @tt{loadmerge_component/2} aborts without changing the OMS
state.  Alternately, a user may give a full path name to
@pred{loadmerge_component(Directory,Name.Version)} to obtain a
component from a particular version.

@tt{fast_loadmerge_component(Name.Version)} calls a
@tt{fast_merge_omsext} which does no redundancy checking and so can be
much faster than @tt{loadmerge_component(Name.Version)}.

@item Finally, a user may analyze component dependency information by
backtracking through @tt{analyze_dependency/2}, which neither affects
the OMS state, nor saves component information to files.
@end{enumerate}

@em{
This version does not yet use dirty bits to determine when new
versions need to be created.}

").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(analyze_components/2,
"@tt{analyze_components(-Component,-Dependency_list)} examines a loaded
OMS instance to partition it into components and for each component
@em{C} to return a list of components upon which @tt{C} depends.  It currently works only for relation-based components.").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

analyze_components(Name,List):- 
	abolish_table_pred(analyze_component_relation_1/2),
	analyze_component_relation(Name1,List),
	get_version_info(Name1,Name).

%-----------
analyze_component_relation(Name,List):-
	setof(Dep,analyze_component_relation_w_version(Name,Dep),List).

analyze_component_relation_w_version(Name,Dep):-
	analyze_component_relation_1(Name,Dep1),
        (get_version_info(Dep1,Dep)
	   ; 
	 get_version_info('OMS',Dep) ).

:- table analyze_component_relation_1/2.
analyze_component_relation_1(Name,Name):- 
	analyze_class(Name,Name).
analyze_component_relation_1(Name,Name):- 
	analyze_object(Name,Name).
analyze_component_relation_1(Name,Dep):- 
	analyze_subclass(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_memberof(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_irel_r(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_strel_r(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_schrel_r(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_attribute_r(Name,Dep).
analyze_component_relation_1(Name,Dep):- 
	analyze_attribute_object_r(Name,Dep).

get_version_info(Name,CV):- 
   (q_strel(id(Name,Name),id(has_version,Name),id(integer(Version),'OMS')) -> 
	    CV = compVers(Name,Name,integer(Version),'OMS')
	  ; CV = compVers(Name,Name,integer(0),'OMS')).
	
analyze_irel_r(Name,Dep):-  
	oms_rln(Id1,Id2,Id3),
	source_from_cid(Id2,Name),
	(source_from_cid(Id1,Dep) ; dep_from_cid(Id2,Dep) 
                                                ; source_from_cid(Id3,Dep)).
analyze_irel_r(Name,Dep):-  
	Term =  immediate_relationship_int(_A,Sa,_B,Sb,_C,Sc),
	get_intensional_rule(Term,Body),
	check_component(Sb,Name,(':-'(Term,Body))),
	(Dep = Name 
  	    ;  check_dependency(Sa,Dep,1,(':-'(Term,Body)))
  	    ;  check_dependency(Sc,Dep,3,(':-'(Term,Body))) ).
analyze_strel_r(Name,Dep):-  
	oms_strel(Id1,Id2,Id3),
	source_from_cid(Id2,Name),
	(source_from_cid(Id1,Dep) ; dep_from_cid(Id2,Dep) 
                                                ; source_from_cid(Id3,Dep)).
analyze_strel_r(Name,Dep):-  
	Term =  strel_int(_A,Sa,_B,Sb,_C,Sc),
	get_intensional_rule(Term,Body),
	check_component(Sb,Name,(':-'(Term,Body))),
	(Dep = Name 
  	    ;  check_dependency(Sa,Dep,1,(':-'(Term,Body)))
  	    ;  check_dependency(Sc,Dep,3,(':-'(Term,Body))) ).
analyze_schrel_r(Name,Dep):-  
	oms_schrel(Id1,Id2,Id3),
	source_from_cid(Id2,Name),
	(source_from_cid(Id1,Dep) ; dep_from_cid(Id2,Dep) 
                                                ; source_from_cid(Id3,Dep)).
analyze_schrel_r(Name,Dep):-  
	Term =  immediate_schrel_int(_A,Sa,_B,Sb,_C,Sc),
	get_intensional_rule(Term,Body),
	check_component(Sb,Name,(':-'(Term,Body))),
	(Dep = Name 
  	    ;  check_dependency(Sa,Dep,1,(':-'(Term,Body)))
  	    ;  check_dependency(Sc,Dep,3,(':-'(Term,Body))) ).
analyze_attribute_r(Name,Dep):-  
	oms_at(Id1,Id2,Id3),
	source_from_cid(Id2,Name),
	(source_from_oid(Id1,Dep) ; dep_from_cid(Id2,Dep) 
                                                ; source_from_cid(Id3,Dep)).
analyze_attribute_r(Name,Dep):-  
	Term =  immediate_attribute_int(_A,Sa,_B,Sb,_C,Sc),
	get_intensional_rule(Term,Body),
	check_component(Sb,Name,(':-'(Term,Body))),
	(Dep = Name 
  	    ;  check_dependency(Sa,Dep,1,(':-'(Term,Body)))
  	    ;  check_dependency(Sc,Dep,3,(':-'(Term,Body))) ).
analyze_attribute_object_r(Name,Dep):-  
	oms_at(Id1,Id2,Id3),
	source_from_cid(Id2,Name),
	(source_from_oid(Id1,Dep) ; dep_from_cid(Id2,Dep) 
                                                ; source_from_oid(Id3,Dep)).
analyze_irel_r(Name,Dep):-  
	Term =  attribute_object_int(_A,Sa,_B,Sb,_C,Sc),
	get_intensional_rule(Term,Body),
	check_component(Sb,Name,(':-'(Term,Body))),
	(Dep = Name 
  	    ;  check_dependency(Sa,Dep,1,(':-'(Term,Body)))
  	    ;  check_dependency(Sc,Dep,3,(':-'(Term,Body))) ).

%----------------

source_from_cid(Id,Source):-  oms_cn(Id,_,_,Source).

dep_from_cid(Id,Source):-  oms_cn(Id,_,_,Source).
dep_from_cid(Id,Source):-  
	compound(Id), 
	\+ (oms_primitive_class(Id,_,_,_)),
	Id =.. [_|Arglist],
	dep_from_cid_list(Arglist,Source).
		
dep_from_cid_list(Arglist,Source):- 
	member(Id,Arglist),
	dep_from_cid(Id,Source).
dep_from_cid(Id,Source):-  oms_cn(Id,_,_,Source).

source_from_oid(Id,Source):-  oms_obj(Id,_,_,Source).

dep_from_oid(Id,Source):-  oms_obj(Id,_,_,Source).
dep_from_oid(Id,Source):-  
	compound(Id), 
	\+ (oms_primitive_class(Id,_,_,_)),   % TLS shd not occur, but check.
	Id =.. [_|Arglist],
	dep_from_oid_list(Arglist,Source).
		
dep_from_oid_list(Arglist,Source):- 
	member(Id,Arglist),
	dep_from_cid(Id,Source).

check_component(Source,Component,Rule):- 
	(atom(Source) -> 
	    Source = Component
	 ;  oms_warning(component,
	                ['Cannot find component for intensional rule: ',
			  Rule])).

check_dependency(Source,Component,Arg,Rule):- 
	(atom(Source) -> 
	    Source = Component
	 ;  oms_warning(component,
	                  ['Cannot find dependencies in arg: ',Arg,
			   ' of intensional rule: ',Rule]),
	    fail).

/* Deep assumptions on XSB's multifile system */
get_intensional_rule(Head,Body1):- 
	clause(Head,Body),
	Head =.. [_|Alist],
	clause(Body,Body1),
	Body =.. [_|Alist].

analyze_class(Name,Dep):-  
	oms_cn(Id,_,_,_),
	source_from_cid(Id,Name),
	dep_from_cid(Id,Dep).
analyze_class(Name,Name):-  
	Term = class_int(_A,_B,Source),
	get_intensional_rule(Term,Body),
	check_component(Source,Name,(':-'(Term),Body)).

analyze_object(Name,Dep):-  
	oms_obj(Id,_,_,_),
	source_from_oid(Id,Name),
	dep_from_oid(Id,Dep).
analyze_object(Name,Name):-  
	Term = object_int(_A,_B,Source),
	get_intensional_rule(Term,Body),
	check_component(Source,Name,(':-'(Term),Body)).

analyze_subclass(Name,Dep):-  
	oms_sc(Id1,Id2),
	source_from_cid(Id1,Name),
	(dep_from_cid(Id1,Dep) ; source_from_cid(Id2,Dep)).
analyze_subclass(Name,Dep):-  
	Term = immediate_subclass_int(_A,Sa,_B,Sb),
	get_intensional_rule(Term,Body),
	check_component(Sa,Name,(':-'(Term),Body)),
	(Dep = Name
  	    ;  check_dependency(Sb,Dep,2,(':-'(Term),Body)) ).

analyze_memberof(Name,Dep):-  
	oms_mo(Id1,Id2),
	source_from_oid(Id1,Name),
	(dep_from_oid(Id1,Dep) ; source_from_cid(Id2,Dep)).
analyze_memberof(Name,Dep):-  
	Term = immediate_membeof_int(_A,Sa,_B,Sb),
	get_intensional_rule(Term,Body),
	check_component(Sa,Name,(':-'(Term),Body)),
	(Dep = Name
  	    ;  check_dependency(Sb,Dep,2,(':-'(Term),Body))  ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(loadmerge_component/2,
"@tt{loadmerge_component(Name,Version)} loads version @tt{Version} of
the component @tt{Name}, and recursively, all other components upon
which @tt{Name} depends.  If a file name or relative pathname is
given, the component is found by searching through XSB library
directories.  Otherwise, if a full pathname is given in Name, the
component is obtained directly. ").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

loadmerge_component(Name,Version):- 
	retract_omsext,
	load_component(Name,Version),
	message(['Merging in components.']),nl,
	merge_omsext,
	initialize_component(Name,Version).

fast_loadmerge_component(Name,Version):- 
	retract_omsext,
	load_component(Name,Version),
	message(['Merging in components.']),nl,
	fast_merge_omsext,
	initialize_component(Name,Version).

load_component(Name,Version):- 
	message(['Loading component: ',Name,'_',Version]),nl,
	concat_atom([Name,'_',Version],NewName),
	find_component_dir(NewName,Full),
	overload_omsext(Full),
	is_component(Name),
	load_intensional_rules(Full,Name),
        load_component_dependencies(Name,Version).

load_component_dependencies(Name,V):- 
	strel_ext(compVers(Name,Name,integer(V),'OMS'),'OMS',
			 componentDepends,Name,
			 compVers(New,New,integer(Vnew),'OMS'),'OMS'),
	((New = Name ; New = 'OMS' 
	   ; class_ext(New,New,New) ; class(_,New,New,New)) -> 
	    true 
	  ; load_component(New,Vnew) ),
	fail.
load_component_dependencies(_,_).

initialize_component(Name,V):- 
	q_strel(id(compVers(Name,Name,integer(V),'OMS'),'OMS'),
	       id(initialization_file,Name),id(atom(File),'OMS')),
	consult(File),
	fail.
initialize_component(_,_).

/* TLS: assume that if a component is known, its dependencies are in
_ext facts.  Also, need to create class_ext(Name,Name,Name) in order
to have compVers/2. */
is_component('OMS').
is_component(Name):- class_ext(Name,Name,Name).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(update_all_components/1, "@tt{update_all_components(Dir)}
analyzes components of an OMS state and their states, creates
components when necessary, and dumps facts and intensional rules for
all components, as subdirectories of @tt{Dir}.  New versions are
created for components that have been updated since they were
loaded. ").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%bb%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

update_all_components(Dir):- 
	analyze_components(Comp,Dep),
	Comp = compVers(Name,Name,integer(V),_),
	newComponent(Name,NameId,RelId),
	create_dependencies_int_1(Dep,Name,NameId,RelId),
	dump_component_1(Dir,Name,V),
	fail.
update_all_components(_Dir).

:- comment(update_components/2, "@tt{update_all_components(Dir,List)}
Updates components in @tt{List} (or creates them) writing them into
subdirectories of @tt{Dir}.  If a component in @tt{List} depends on a
component that needs updating but is not in list or on a source that
has not been made into a component, the predicate abort without
changing the state or file system.  ").

update_components(_Dir,_List):- 
	abort('update_components/2 not yet implemented').

/* Create a new component for each cell name in dependency list or
find the version number of the component to which cell name belongs.
Then, add the dependency structure. */
create_dependencies_int_1([],_Name,_Compid,_Relid).
create_dependencies_int_1([compVers(Name,Name,integer(V),'OMS')|T],
			  Name1,Compid,Relid):- 
	Name \== Name1,!,
	(V == 0 -> 
	      newComponent(Name,NewCompId,_NewRelid) 
	    ; class(NewCompId,_,compVers(Name,Name,integer(V),'OMS'),'OMS') ),
	newStrel(Compid,Relid,NewCompId),
	create_dependencies_int_1(T,Name,Compid,Relid).
create_dependencies_int_1([_|T],Name,Compid,Relid):- 
	create_dependencies_int_1(T,Name,Compid,Relid).

dump_component_1(Dir,Name,Version):- 
	    dump_component_1_relation(Dir,Name,Version).

%----------

dump_component_1_relation(Dir,Name,Version):- 
	Name \== 'OMS',
	slash(Slash),
  	concat_atom([Dir,Slash,Name,'_',Version],NewDir),
	xsb_makedir(NewDir),
	concat_atom([NewDir,Slash,'schema_omsext.P'],SchFile),
	init_ext_schema_index,
	tell(SchFile),
	compwrite_class(Name),compwrite_subclass(Name),
	compwrite_irel_r(Name),compwrite_schrel_r(Name),
	compwrite_strel_r(Name),
	told,
	concat_atom([NewDir,Slash,'data_omsext.P'],DataFile),
	init_ext_data_index,
	tell(DataFile),
	compwrite_object(Name),compwrite_memberof(Name),
	compwrite_attribute_r(Name),compwrite_attribute_object_r(Name),
	told,
	concat_atom([NewDir,Slash,'oms_intensional.P'],IntFile),
	tell(IntFile),
	write_component_intensional(Name),
	told.


compwrite_irel_r(Source):- 
%	write_hdr(relationship_ext(_,_,_,_,_,_)),
	oms_rln(Sub,Mid,Targ),
%	writeln(oms_rln(Sub,Mid,Targ)),
	class_cidbound(Mid,_,Nid1,Source),
	class_cidbound(Sub,_,Nid,Source1),
	class_cidbound(Targ,_,Nid2,Source2),
	write_ext_term(
                 relationship_ext(Nid,Source1,Nid1,Source,Nid2,Source2)),
	fail.
compwrite_irel_r(_).

compwrite_schrel_r(Source):- 
	write_hdr(schrel_ext(_,_,_,_,_,_)),
	oms_schrel(Sub,Mid,Targ),
	class_cidbound(Sub,_,Nid,Source1),
	class_cidbound(Mid,_,Nid1,Source),
	class_cidbound(Targ,_,Nid2,Source2),
	write_ext_term(schrel_ext(Nid,Source1,Nid1,Source,Nid2,Source2)),
	fail.
compwrite_schrel_r(_).

compwrite_strel_r(Source):- 
	write_hdr(strel_ext(_,_,_,_,_,_)),
	oms_strel(Sub,Mid,Targ),
	class_cidbound(Sub,_,Nid,Source1),
	class_cidbound(Mid,_,Nid1,Source),
	class_cidbound(Targ,_,Nid2,Source2),
	write_ext_term(strel_ext(Nid,Source1,Nid1,Source,Nid2,Source2)),
	fail.
compwrite_strel_r(_).

compwrite_attribute_r(Source):- 
	write_hdr(attribute_ext(_,_,_,_,_,_)),
	oms_at(Sub,Mid,Targ),
	oms_obj(Sub,_,Nid,Source1),
	class_cidbound(Mid,_,Nid1,Source),
	class_cidbound(Targ,_,Nid2,Source2),
	write_ext_term(
	           attribute_ext(Nid,Source1,Nid1,Source,Nid2,Source2)),
	fail.
compwrite_attribute_r(_).

compwrite_attribute_object_r(Source):- 
	write_hdr(attribute_object_ext(_,_,_,_,_,_)),
	oms_ao(Sub,Mid,Targ),
	oms_obj(Sub,_,Nid,Source1),
	class_cidbound(Mid,_,Nid1,Source),
	oms_obj(Targ,_,Nid2,Source2),
	write_ext_term(
	       attribute_object_ext(Nid,Source1,Nid1,Source,Nid2,Source2)),
	fail.
compwrite_attribute_object_r(_).

%---------

compwrite_class(Source):- 
	write_hdr(class_ext(_,_,_)),
	oms_cn(_,Name,Nid,Source),
	write_ext_term(class_ext(Name,Nid,Source)),
	fail.
compwrite_class(_).

compwrite_subclass(Source):- 
	write_hdr(subclass_ext(_,_,_,_)),
	oms_sc(Sub,Sup),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Sup,_,Nid1,Source1),
	write_ext_term(subclass_ext(Nid,Source,Nid1,Source1)),
	fail.
compwrite_subclass(_).
	
compwrite_object(Source):- 
	write_hdr(object_ext(_,_,_)),
	oms_obj(_,Name,Nid,Source),
	write_ext_term(object_ext(Name,Nid,Source)),
	fail.
compwrite_object(_).

compwrite_memberof(Source):- 
	write_hdr(memberof_ext(_,_,_,_)),
	oms_mo(Sub,Sup),
	oms_obj(Sub,_,Nid,Source),
	oms_cn(Sup,_,Nid1,Source1),
	write_ext_term(memberof_ext(Nid,Source,Nid1,Source1)),
	fail.
compwrite_memberof(_).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Utilities
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
find_component_dir(Name,Full):- 
	(search_module(Name,_Dir_part,_Base_part,_Ext,Full,_Obj) 
                -> true 
	    ; 
	        oms_error(component,['can''t find component: ',Name])),
	(path_sysop(isdir,Full) -> 
	    true 
	  ; 
	     oms_error(component,['component name is not a directory',Full])).

overload_omsext(Dir) :-
	oms_fix_dir(Dir,DirS),
	dir_overload_dync(DirS,schema_omsext),
	dir_overload_dync(DirS,data_omsext).

dir_overload_dync(Dir,Base) :-
	concat_atom([Dir,Base,'.P'],File),!,
	(overload_dync(File) 		% i.e. use asserta
              -> true
	  ; oms_warning(permission,('File does not exist ',
                                    'or is not readable: ',File))).

overload_dync(File):- 
	see(File),
	overload_dync_1,
	seen.

overload_dync_1:- 
	repeat,
	read_canonical(T),
	(T = end_of_file -> true ; asserta(T),fail).

xsb_makedir(Dir):- 
	(path_sysop(isdir,Dir) -> true ; path_sysop(mkdir,Dir)).

write_component_intensional(Name):- 
	intensional_head(Head,_Arg),
	Head =.. [F|T],
	concat_atom([F,'_',Name],NewF),
	NewHead =.. [NewF|T],
	clause(NewHead,Body), 
	pretty_print(clause(Head,Body)),
	fail.
write_component_intensional(_).

:- comment(add_component_initializer/2,
"@tt{add_component_initializer(Component,File)} can be used to add
@tt{File} as an initialization file for @tt{Component}.
@tt{Component} must already exist as a component and be loaded into an
OMS state, otherwise a warning is given and the predicate fails.").

add_component_initializer(Comp,File):- 
   (q_immediate_subclass(id(Comp,Comp),id('OMS Component','OMS')),
    q_strel(id(Comp,Comp),id(has_version,Comp),id(integer(V),'OMS')) -> 
	q_newStrel(id(compVers(id(Comp,Comp),id(integer(V),'OMS')),'OMS'),
	          id(initialization_file,Comp),
	          id(atom(File),'OMS'))
     ; 
	oms_warning(component,['Cannot initialize uncreated component ',
				Comp]),
	fail).

end_of_file.

@item A user may wish to create components from external files.  In
this case, the predicate @pred{create_external_component/1} can be
used to add this information.  @tt{create_external_component(Dir)}
reads in external files, computes their dependencies, and writes out
the files, plus component information, back to @em{Dir}.  The
information in this component does not affec the state of the OMS
until it is explicitly loaded.  In the case where a putative component
includes an external intensional view, dependency information for the
external intensional view must be added by hand.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(create_external_component/1,"
@tt{create_external_component(Dir)} loads from @tt{Dir}
@tt{data_omsext.P}, and @tt{schema_omsext.P} files, creates a
component if possible, then dumps the new omsext that includes the
component information.").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

create_external_component(Name):- 
	retract_omsext,
	abolish_table_pred(find_component_dependency/1),
	find_component_dir(Name,Full),
	load_omsext(Full),
	check_component(Name),
	assert(class_ext(Name,Name,Name)),
	assert(subclass_ext(Name,Name,'OMS Component','OMS')),
	create_dependencies_ext(Name),
	dump_component_ext(Full,Name),
	retract_omsext.

/* works on loaded, unmerged omsext */	
create_dependencies_ext(Name):- 
	find_component_dependency(Dep),
	call_assert(strel_ext(Name,Name,componentDepends,Name,Dep,Dep)),
	fail.
create_dependencies(Name):- 
	asserta(strel_ext(Name,Name,componentDepends,Name,Name,Name)).

%-----------
/* checks whether a set of loaded,  non-merged external facts with
a given source constitute a component */ 

check_component(Name):- 
	check_class(Name),
	check_object(Name),check_subclass(Name),
	check_memberof(Name),check_relationship(Name),
	check_schrel(Name),check_strel(Name),
	check_attribute(Name),check_attribute_object(Name).

check_class(Name):- 
	(class_ext(Q,W,N),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
                                      ' has class with different source: ',
			              class_ext(Q,W,N)])
	; 
	   fail).
check_class(_).

check_object(Name):- 
	(object_ext(Q,W,N),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
                                      ' has object with different source: ',
					      object_ext(Q,W,N)])
	; 
	   fail).
check_object(_).

check_subclass(Name):- 
	(subclass_ext(Q,N,W,E),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
                                      ' has subclass with different source: ',
					      subclass_ext(Q,N,W,E)])
	; 
	   fail).
check_subclass(_).

check_memberof(Name):- 
	(memberof_ext(Q,N,W,E),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has memberof with different source: ',
			   memberof_ext(Q,N,W,E)])
	; 
	   fail).
check_memberof(_).

check_relationship(Name):- 
	(relationship_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has relationship with different source: ',
			   relationship_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_relationship(_).

check_schrel(Name):- 
	(schrel_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has schrel with different source: ',
			   schrel_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_schrel(_).

check_strel(Name):- 
	(strel_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has strel with different source: ',
			   strel_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_strel(_).

check_attribute(Name):- 
	(attribute_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has attribute with different source: ',
			   attribute_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_attribute(_).

check_attribute_object(Name):- 
	(attribute_object_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has attribute_object with different source: ',
			   attribute_object_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_attribute_object(_).

%-------------------------------------

/* find_component_dependency/1 returns the set of dependencies for a
putative component -- from a set of loaded, non-merged external facts.
Only those dependencies obtained from external form are returned --
extint dependencies must be added "by hand". */

:- table find_component_dependency/1.
find_component_dependency(Dep):- 
	find_component_dependency_1(Dep).

find_component_dependency_1(Dep):- 
	class_ext(_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	object_ext(_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	subclass_ext(_,_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	memberof_ext(_,_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	relationship_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	schrel_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	strel_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	attribute_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	attribute_object_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).

find_pc_dependency(Class,Dep):- 
	compound(Class),
	Class =.. [_|Arglist],
	find_pc_dependency_list(Arglist,Dep).
	
find_pc_dependency_list([_Class,S|_R],S).
find_pc_dependency_list([Class,S|_R],Dep):- 
	S \== 'OMS',
	find_pc_dependency(Class,Dep).
find_pc_dependency_list([_Class,_S|R],Dep):- 
	find_pc_dependency_list(R,Dep).

%-----------
/* dump_component_ext/2 is not to be exported -- it dumps from
extrernal format and is to be used with create component. */
dump_component_ext(Dir,Name):- 
	slash(Slash),
  	concat_atom([Dir,Slash,'schema_omsext.P'],SchFile),
	init_ext_schema_index,
	tell(SchFile),
	write_hdr(class_ext(_,_,_)),
	write_call(class_ext(_,_,Name)),
	write_hdr(subclass_ext(_,_,_,_)),
	write_call(subclass_ext(_,Name,_,_)),
	write_hdr(relationship_ext(_,_,_,_,_,_)),
	write_call(relationship_ext(_,Name,_,_,_,_)),
	write_hdr(schrel_ext(_,_,_,_,_,_)),
	write_call(schrel_ext(_,Name,_,_,_,_)),
	write_hdr(strel_ext(_,_,_,_,_,_)),
	write_call(strel_ext(_,Name,_,_,_,_)),
	told,
  	concat_atom([Dir,Slash,'data_omsext.P'],DataFile),
	init_ext_data_index,
	tell(DataFile),
	write_hdr(object_ext(_,_,_)),
	write_call(object_ext(_,_,Name)),
	write_hdr(memberof_ext(_,_,_,_)),
	write_call(memberof_ext(_,Name,_,_)),
	write_hdr(attribute_ext(_,_,_,_,_,_)),
	write_call(attribute_ext(_,Name,_,_,_,_)),
	write_hdr(attribute_object_ext(_,_,_,_,_,_)),
	write_call(attribute_object_ext(_,Name,_,_,_,_)),
	told.

%---

write_call(Call):- 
	abolish_table_pred(table_call/1),
	table_call(Call),
	write_ext_term(Call),
	fail.
write_call(_Call):-
	abolish_table_pred(table_call/1).

:- table table_call/1.
table_call(Call):- call(Call).

:- comment(dump_component/1,"@tt{dump_component(Name)} dumps the
component @tt{Name}.  It does not dump other components upon which
@tt{Name} depends.").

dump_component(Name):- 
	find_component_dir(Name,Dir),
	throw_oms_writable(Dir),
	dump_component_1(Dir,Name).

%-----------
analyze_component_class(Name,List):-
         setof(Dep,analyze_component_class_w_version(Name,Dep),List).

analyze_component_class_w_version(Name,Dep):-
	analyze_component_class_1(Name,Dep1),
             get_version_info(Dep1,Dep)
	   ; 
	 get_version_info('OMS',Dep).

:- table analyze_component_class_1/2.
analyze_component_class_1(Name,Name):- 
	analyze_class(Name,Name).
analyze_component_class_1(Name,Name):- 
	analyze_object(Name,Name).
analyze_component_class_1(Name,Dep):- 
	analyze_subclass(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_memberof(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_irel_c(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_strel_c(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_schrel_c(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_attribute_c(Name,Dep).
analyze_component_class_1(Name,Dep):- 
	analyze_attribute_object_c(Name,Dep).

analyze_irel_c(Name,Dep):-  
	oms_rln(Id1,Id2,Id3),
	source_from_cid(Id1,Name),
	(dep_from_cid(Id1,Dep) ; source_from_cid(Id2,Dep) 
                                                ; source_from_cid(Id3,Dep)).
analyze_irel_c(Name,Dep):-  
	Term =  immediate_relationship_int(_A,Sa,_B,Sb,_C,Sc),
	get_intensional_rule(Term,Body),
	check_component(Sa,Name,(':-'(Term,Body))),
	(Dep = Name 
  	    ;  check_dependency(Sb,Dep,1,(':-'(Term,Body)))
  	    ;  check_dependency(Sc,Dep,3,(':-'(Term,Body))) ).
analyze_strel_c(Name,Dep):-  
	oms_strel(Id1,Id2,Id3),
	source_from_cid(Id1,Name),
	(dep_from_cid(Id1,Dep) ; source_from_cid(Id2,Dep) 
                                                ; source_from_cid(Id3,Dep)).
analyze_strel_c(Name,Dep):-  
	Term =  strel_int(_A,Sa,_B,Sb,_C,Sc),
	get_intensional_rule(Term,Body),
	check_component(Sa,Name,(':-'(Term,Body))),
	(Dep = Name 
  	    ;  check_dependency(Sb,Dep,1,(':-'(Term,Body)))
  	    ;  check_dependency(Sc,Dep,3,(':-'(Term,Body))) ).
analyze_schrel_c(Name,Dep):-  
	oms_schrel(Id1,Id2,Id3),
	source_from_cid(Id1,Name),
	(dep_from_cid(Id1,Dep) ; source_from_cid(Id2,Dep) 
                                                ; source_from_cid(Id3,Dep)).
analyze_schrel_c(Name,Dep):-  
	Term =  schrel_int(_A,Sa,_B,Sb,_C,Sc),
	get_intensional_rule(Term,Body),
	check_component(Sa,Name,(':-'(Term,Body))),
	(Dep = Name 
  	    ;  check_dependency(Sb,Dep,1,(':-'(Term,Body)))
  	    ;  check_dependency(Sc,Dep,3,(':-'(Term,Body))) ).
analyze_attribute_c(Name,Dep):-  
	oms_at(Id1,Id2,Id3),
	source_from_cid(Id1,Name),
	(dep_from_oid(Id1,Dep) ; source_from_cid(Id2,Dep) 
                                                ; source_from_cid(Id3,Dep)).
analyze_attribute_c(Name,Dep):-  
	Term =  immediate_attribute_int(_A,Sa,_B,Sb,_C,Sc),
	get_intensional_rule(Term,Body),
	check_component(Sa,Name,(':-'(Term,Body))),
	(Dep = Name 
  	    ;  check_dependency(Sb,Dep,1,(':-'(Term,Body)))
  	    ;  check_dependency(Sc,Dep,3,(':-'(Term,Body))) ).
analyze_attribute_object_c(Name,Dep):-  
	oms_at(Id1,Id2,Id3),
	source_from_cid(Id1,Name),
	(dep_from_oid(Id1,Dep) ; source_from_cid(Id2,Dep) 
                                                ; source_from_oid(Id3,Dep)).
analyze_attribute_object_c(Name,Dep):-  
	Term =  attribute_object_int(_A,Sa,_B,Sb,_C,Sc),
	get_intensional_rule(Term,Body),
	check_component(Sa,Name,(':-'(Term,Body))),
	(Dep = Name 
  	    ;  check_dependency(Sb,Dep,1,(':-'(Term,Body)))
  	    ;  check_dependency(Sc,Dep,3,(':-'(Term,Body))) ).

analyze_components(Name,List):- 
	abolish_table_pred(analyze_component_relation_1/2),
	(oms_component_type(class_based) -> 
 	    analyze_component_class(Name1,List),
	    get_version_info(Name1,Name)
	  ; 
 	    analyze_component_relation(Name1,List),
	    get_version_info(Name1,Name)).

:- dynamic oms_component_type/1.
%oms_component_type(class_based).

dump_component_1_class(Dir,Name,Version):- 
	slash(Slash),
  	concat_atom([Dir,Slash,Name,'_',Version],NewDir),
	xsb_makedir(NewDir),
	concat_atom([NewDir,Slash,'schema_omsext.P'],SchFile),
	init_ext_schema_index,
	tell(SchFile),
	compwrite_class(Name),compwrite_subclass(Name),
	compwrite_irel_c(Name),compwrite_schrel_c(Name),
	compwrite_strel_c(Name),
	told,
  	concat_atom([NewDir,Slash,'data_omsext.P'],DataFile),
	init_ext_data_index,
	tell(DataFile),
	compwrite_object(Name),compwrite_memberof(Name),
	compwrite_attribute_c(Name),compwrite_attribute_object_c(Name),
	told.

compwrite_irel_c(Source):- 
	write_hdr(relationship_ext(_,_,_,_,_,_)),
	oms_rln(Sub,Mid,Targ),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(
                 relationship_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_irel_c(_).

compwrite_schrel_c(Source):- 
	write_hdr(schrel_ext(_,_,_,_,_,_)),
	oms_schrel(Sub,Mid,Targ),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(schrel_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_schrel_c(_).

compwrite_strel_c(Source):- 
	write_hdr(strel_ext(_,_,_,_,_,_)),
	oms_strel(Sub,Mid,Targ),
	oms_cn(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(strel_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_strel_c(_).

compwrite_attribute_c(Source):- 
	write_hdr(attribute_ext(_,_,_,_,_,_)),
	oms_at(Sub,Mid,Targ),
	oms_obj(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_cn(Targ,_,Nid2,Source2),
	write_ext_term(
	           attribute_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_attribute_c(_).

compwrite_attribute_object_c(Source):- 
	write_hdr(attribute_object_ext(_,_,_,_,_,_)),
	oms_ao(Sub,Mid,Targ),
	oms_obj(Sub,_,Nid,Source),
	oms_cn(Mid,_,Nid1,Source1),
	oms_obj(Targ,_,Nid2,Source2),
	write_ext_term(
	       attribute_object_ext(Nid,Source,Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_attribute_object_c(_).

analyze_components(Name,List):- 
	abolish_table_pred(analyze_component_relation_1/2),
	(oms_component_type(class_based) -> 
 	    analyze_component_class(Name1,List),
	    get_version_info(Name1,Name)
	  ; 
 	    analyze_component_relation(Name1,List),
	    get_version_info(Name1,Name)).

