:- compiler_options([ciao_directives]).

:- document_export 
	  analyze_components/2,
	  update_components/2,
	  update_all_components/2,
          load_component/3.

:- import slash/1 from machine.
:- import short_directory/2 from directry.

:- import concat_atom/2 from string.
:- import message/1 from standard.
:- import member/2,ground/1 from basics.
:- import pretty_print/1 from newpp.

:- ensure_loaded(oms_io).
:- ensure_loaded(oms_queries).
:- ensure_loaded(oms_config).

:- dynamic temp_depends/4.

/*
% oms_init_oms
:- import class/4, class_ext/3, class_cidbound/4, oms_cn/4,
	object/4, oms_obj/4,
	oms_ao/3, oms_at/3, oms_mo/2, oms_rln/3, oms_sc/2,
	oms_schrel/3, oms_strel/3, 
	immediate_strel/3,
	oms_fix_dir/2, oms_primitive_class/4,
	init_ext_data_index/0, init_ext_schema_index/0 from usermod.

:- import newStrel/3,newComponent/5 from usermod.

% oms_config.
:- import component_table_ext/3,component_table_int/3 from usermod.

% oms_queries.
:- import q_strel/3 from usermod.

:- import oms_warning/2,oms_error/2 from oms_exceptions.

%oms_io
:- import intensional_head/2,load_intensional_rules/2, 
	  fast_merge_omsext/0, merge_omsext/0,
	  retract_omsext/0,
	  write_ext_term/1, write_hdr/1
	from usermod.
*/
/*
handle_load_component_error(Message):- 
	retract_omsext,
	retractall(temp_depends(_,_,_)),
	write_oms_error_noxj(Message),
	abort.
*/

:- comment(module,"Typically, an OMS instance can be partitioned into
several separate cells, representing information that arises from
different sources, for instance, from UNSPSC, NAICS, or DLAFIIG.
There may be a need for these cells to be managed separately so that
various applications can update them and incorporate their
information.  The OMS components system attempts to address this need
by allowing ontologies to be built from non-overlapping
@em{components}.

One method of partitioning facts in an OMS instance (whether it be a
loaded state or set of external files) is to choose a @em{component
argument} for each predicate type, and to set as the component of each
fact the source of the identifier in the component argument.  (If the
identifier is a product identifier, the source is the source of the
outer function symbol).  Using this method, the facts in an OMS
instance may be partitioned in various ways.

A @em{class-based component system} chooses as component arguments:

@begin{itemize}

@item the second-argument of all @em{class/2} and @pred{object/2}
facts.

@item the first-argument of all other facts.

@end{itemize} 
@noindent Class-based components thus form a collection
vaguely analagous to a Java package, and are useful when different
processes are responsible for creating or modifying different classes
and objects.

A @em{relation-based component system} chooses as argument identifiers

@begin{itemize} @item the second-argument of all @pred{class/2} and
@pred{object/2} facts.

@item the first-argument of all @pred{memberof/2} and
@pred{subclass/2} facts.

@item the second-argument of all @pred{irel/3}, @pred{strel/3},
@pred{schrel/3}, @pred{attribute/3}, and @pred{attribute_object/3}
facts.

@end{itemize}

Relation-based component systems differ from class-based systems only
in their partitions of relations and attributes.  Relation-based
component systems are useful when different processes may be
associated with creating or modifying different relations and
attributes for the same class or object.  The OMS uses a
relation-based component system by default, but can be repartitioned
by adjusting the tables in @module{oms_config.P}.

In either case, one component @em{C1} directly depends on another
component @em{C2} if @em{id(NID2,C2)} is an argument in a fact in
component @em{C1}; or if @em{id(Nid1,C1)} is a component argument of a
fact in @em{C1}, @em{Nid1} is a product identifier, and
@em{id(NID2,C2)} occurs as a direct constituent in @em{C1}.  By this
definition, it is easy to see that component dependency need not be
hierarchical so that two components may directly depend on one
another; furthermore each component must directly depend on itself.
In addition, each component always derectly depends on the component
'OMS' by fiat.  Component dependency is defined as the transitive
closure of direct dependency.

Dependency information is used to determine how to load a component
and when to update it and is usually computed by the OMS.  Computing
dependency information is easy for extensional facts, but computing
dependency information for intensional rules is harder, as the
component system would need to compute all answer substitutions to
determine all dependencies, and this in impractical for some sets of
intensional rules.  Rather, dependencies are computed by checking the
top-level arguments of intensional rules, which leads to an
under-approximation of the dependencies.

@section{Components, Paths, and Versions}

Given the notions that components partition an OMS instance, and give
rise to dependency information, the component system must interace
with file systems and databases in order to allow users to manage
components as separate entities.

A component is identified by a structured @index{component tag}, which
consists of a @em{path part} and a @em{name part}.  For example,
information in the directory @tt{/home/tswift/unspsc} would have a
path part of @tt{/home/tswift} and name part @tt{unspsc}.  Inside the
OMS, only the name part is used as a source argument for identifiers;
The path part is maintained separately.  The structuring of component
tags has implications for the behavioral of the component system.  If
two components with the same name part and different path parts are
loaded, facts and rules from the two different components cannot be
distinguished, as only the name part is maintained in their
identifiers.  The attempt to load two such components can be treated
as an error; or the load can be allowed to succeed unioning the
information from both components, implicitly asserting an axiom of
equality for the two component tags.

A component tag corresponds to a directory containing files with data
in external form (e.g. @tt{schema_omsext.P} and @tt{data_omsext.P}
files), or in external intensional form @tt{oms_intensional.P}.  In
addition, the directory may contain an initialization file,
@tt{component_init.P}.  whose actions are taken to be transparent to
the OMS (unless they explicitly call OMS routines).  The OMS cannot
load as a component information in internal format (i.e. data in
@tt{schema_oms.P} and @tt{data_oms.P} files) as ambiguity arises if
one attempts to combine internal identifiers from different files.  It
does however provide tools to create components from a current loaded
OMS state.  

Within the same path, a component can have multiple @em{versions}.  An
OMS state can contain only one version for each component name, which
constraint affects the behavior of certain of the routines below.
A convention is made that a component @tt{Name} with version @tt{V} is
to be found in a directory named @tt{Name_V}. 

@section{Representing Component Information}

@em{This is what we should do once product types can belong to
different sources.}

Information about a component resides in the OMS data itself and is
viewable by the user.  Let @tt{C} be a component with name part
@tt{Name}, path part @tt{Path}.  When version @tt{V} of @tt{C} is
loaded, the class
@begin{verbatim}
id(component(id(Name,Name),id(atom(Path),'OMS'),id(integer(V),'OMS')),Name)
@end{verbatim}
is created as an immediate subclass of @tt{id('OMS Component','OMS')}.
Since components are not expected to have members, information about
them is maintained through @pred{strel/3} facts.  In particular,
dependency information is maintained through the strel
@tt{id('componentDepends',Component)}.

@em{This is what we are doing now}.

Information about a component resides in the OMS data itself and is
viewable by the user.  When a component with tag @tt{C} is loaded, the
class @tt{id(Name,Name)} (where @tt{Name} is the name part of @tt{C})
is created as an immediate subclass of @tt{id('OMS Component','OMS')}.
Since components are not expected to have members, information about
them is maintained through @pred{strel/3} facts.

@begin{itemize} 

@item The path part of component @tt{C} is kept via the strel
@tt{id(hasPath,Name)} whose first argument is @tt{id(Name,Name)}.

@item The version of component @tt{Name} is kept via the strel
@tt{id(hasVersion,Name)}.

@item Dependency information of @tt{C} is maintained through the strel
@tt{id('componentDepends',Component)}.
@end{itemize}

@section{Major Functionality}

Given an OMS state, a user may want to do several things.  
@begin{enumerate}

@item A user may wish to create components from an OMS state, or to
update components used by an OMS state.  One way to do this is by the
predicate @tt{update_all_components(Dir,Options)} which determines a
class or relation based partition of the OMS instance, and computes
all dependencies between these cells.  Cells that are not components
are made into components (with version 0), and those that are already
components have their version number updated if necessary (by checking
@tt{oms_dirty/1}).  Other aspects may be specified by various options.

Alternately, if a part of a loaded OMS instance is to be saved as a
component the predicate @tt{update_components(List,Dir)} can be used.
@tt{List} is a list of component names, and for each @tt{Name} in
@tt{List}, @pred{update_components/2} writes ou the component
@tt{Name} as a subdirectory of @tt{Dir} whose version is either 0 if
the component is new, or incremented if the component is updated.  The
predicate gives an error if a component @tt{Name} in @tt{List} depends
on an updated component not in @tt{List}, or if it depends on a cell
that has not been made into a component.

@item A user may wish to load a component, along with all of its
dependencies.  Loads may be parameterized by
@begin{itemize}
@item Whether it is considered an error to try to load two components
with different path parts and the same name parts.

@item Whether a fast merge or a slower merge with more redundancy
checking is to be used.

@item Whether the latest version is to be loaded or a particular
version is specified.
@end{itemize}

@item Finally, a user may analyze component dependency information by
backtracking through @tt{analyze_dependency/2}, which neither affects
the OMS state, nor saves component information to files.
@end{enumerate}

@em{
This version does not yet use dirty bits to determine when new
versions need to be created.}

").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(analyze_components/2,
"@tt{analyze_components(-Component,-Dependency_list)} examines a loaded
OMS instance to partition it into components and for each component
@em{C} to return a list of components upon which @tt{C} depends.  It currently works only for relation-based components.").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

analyze_components(Name,List):- 
	abolish_table_pred(analyze_component_table/2),
	analyze_component_1(Name1,List),
	get_version_info(Name1,Name).

analyze_component_1(Name,List):-
	setof(Dep,analyze_component_w_version(Name,Dep),List).

analyze_component_w_version(Name,Dep):-
	analyze_component_table(Name,Dep1),
        (get_version_info(Dep1,Dep)
	   ; 
	 get_version_info('OMS',Dep) ).

get_version_info(Name,CV):- 
   (q_strel(id(Name,Name),id(has_version,Name),id(integer(Version),'OMS')) -> 
	    CV = compVers(Name,Name,integer(Version),'OMS')
	  ; CV = compVers(Name,Name,integer(0),'OMS')).

:- table analyze_component_table/2.
analyze_component_table(Name,Dep):- 
	analyze_extensional(Name,Dep).
analyze_component_table(Name,Dep):- 
	analyze_intensional(Name,Dep).

analyze_extensional(Name,Dep):- 
	oms_cn(I0,I1,I2,I3),
	get_component_extensional(oms_cn(I0,I1,I2,I3),Name),
	get_dependency_extensional(oms_cn(I0,I1,I2,I3),Dep).
analyze_extensional(Name,Dep):- 
	oms_obj(I0,I1,I2,I3),
	get_component_extensional(oms_obj(I0,I1,I2,I3),Name),
	get_dependency_extensional(oms_obj(I0,I1,I2,I3),Dep).
analyze_extensional(Name,Dep):- 
	oms_sc(I0,I1),
	get_component_extensional(oms_sc(I0,I1),Name),
	get_dependency_extensional(oms_sc(I0,I1),Dep).
analyze_extensional(Name,Dep):- 
	oms_mo(I0,I1),
	get_component_extensional(oms_mo(I0,I1),Name),
	get_dependency_extensional(oms_mo(I0,I1),Dep).
analyze_extensional(Name,Dep):- 
	oms_rln(I0,I1,I2),
	get_component_extensional(oms_rln(I0,I1,I2),Name),
	get_dependency_extensional(oms_rln(I0,I1,I2),Dep).
analyze_extensional(Name,Dep):- 
	oms_schrel(I0,I1,I2),
	get_component_extensional(oms_schrel(I0,I1,I2),Name),
	get_dependency_extensional(oms_schrel(I0,I1,I2),Dep).
analyze_extensional(Name,Dep):- 
	oms_strel(I0,I1,I2),
	get_component_extensional(oms_strel(I0,I1,I2),Name),
	get_dependency_extensional(oms_strel(I0,I1,I2),Dep).
analyze_extensional(Name,Dep):- 
	oms_at(I0,I1,I2),
	get_component_extensional(oms_at(I0,I1,I2),Name),
	get_dependency_extensional(oms_at(I0,I1,I2),Dep).
analyze_extensional(Name,Dep):- 
	oms_ao(I0,I1,I2),
	get_component_extensional(oms_ao(I0,I1,I2),Name),
	get_dependency_extensional(oms_ao(I0,I1,I2),Dep).

analyze_intensional(Name,Dep):- 
	Term =  class_int(_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  object_int(_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  immediate_subclass_int(_,_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  immediate_memberof_int(_,_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  immediate_memberof_int(_,_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  immediate_relationship_int(_,_,_,_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  immediate_schrel_int(_,_,_,_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  immediate_schrel_int(_,_,_,_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  immediate_attribute_int(_,_,_,_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  attribute_object_int(_,_,_,_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).

%----------------

get_component_extensional(Term,Component):- 
	component_table_ext(Term,arg(Arg,Type),_),
	arg(Arg,Term,CompId),
	source_from_id(Type,CompId,Component).

source_from_id(class,CompId,Component):- 
	oms_cn(CompId,_,_,Component).
source_from_id(obj,CompId,Component):- 
	oms_obj(CompId,_,_,Component).

get_dependency_extensional(Term,Dep):- 
	component_table_ext(Term,arg(Comp,Type),Deps),
	(    arg(Comp,Term,CompId),
	     dep_from_id(Type,CompId,Dep) 
	  ; 
	     member(arg(DepArg,DType),Deps),
	     arg(DepArg,Term,DepId),
	     source_from_id(DType,DepId,Dep) ).

dep_from_id(class,CompId,Component):- 
	dep_from_cid(CompId,Component).
dep_from_id(obj,CompId,Component):- 
	dep_from_oid(CompId,Component).

dep_from_cid(Id,Source):-  oms_cn(Id,_,_,Source).
dep_from_cid(Id,Source):-  
	compound(Id), 
	\+ (oms_primitive_class(Id,_,_,_)),
	Id =.. [_|Arglist],
	dep_from_cid_list(Arglist,Source).
		
dep_from_cid_list(Arglist,Source):- 
	member(Id,Arglist),
	dep_from_cid(Id,Source).

dep_from_oid(Id,Source):-  oms_obj(Id,_,_,Source).
dep_from_oid(Id,Source):-  
	compound(Id), 
	\+ (oms_primitive_class(Id,_,_,_)),   % TLS shd not occur, but check.
	Id =.. [_|Arglist],
	dep_from_oid_list(Arglist,Source).
		
dep_from_oid_list(Arglist,Source):- 
	member(Id,Arglist),
	dep_from_cid(Id,Source).

%------------------
 
get_component_intensional(Term,Body,Component):- 
	component_table_int(Term,Arg,_Deps),
	arg(Arg,Term,Source),
	(atom(Source) -> 
	    Source = Component
	 ;  oms_warning(component,
	                ['Cannot find component for intensional rule: ',
			  (:-(Term,Body))]),
	    fail).

get_dependency_intensional(Term,Body,Component):- 
	component_table_int(Term,Arg,_Deps),
	arg(Arg,Term,Source),
	(atom(Source) -> 
	    Source = Component
	 ;  oms_warning(component,
	                  ['Cannot find dependencies in arg: ',Arg,
			   ' of intensional rule: ', (:-(Term,Body))]),
	    fail).
get_dependency_intensional(Term,Body,Component):- 
	component_table_int(Term,_A,Deps),
	member(arg(Arg,Warn),Deps),
	arg(Arg,Term,Source),
	(atom(Source) -> 
	    Source = Component
	 ;  (Warn == warn -> 
	        oms_warning(component,
	                  ['Cannot find dependencies in arg: ',Arg,
			   ' of intensional rule: ', (:-(Term,Body))])
	        ; true),
	    fail).

/* Assumes that intensional rules have been read in via
   load_intensional_rules/2 */
get_intensional_rule(Head,Body1):- 
	clause(Head,Body),
	Head =.. [_|Alist],
	clause(Body,Body1),
	Body =.. [_|Alist].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% :-
:- comment(load_component/3,
"@tt{load_component(Path,Name,Parameter_list)} loads the
component @tt{Name}, from path @tt{Path} and recursively, all other
components upon which the component depends.  If a version conflict is
detected between a component to be loaded and one already in the OMS
state or about to be loaded, @tt{loadmerge_component/2} aborts without
changing OMS extensional rules in internal form, or intensional rules.

The order of loading is as follows.  First, all extensional facts are
loaded for the component @tt{Path/Name} and for all components on
which it depends.  Next, the dependency graph is re-traversed
intensional rules are loaded, and initialization files are consulted
in a bottom-up manner (i.e. in a post-order traversal of the
dependency graph). 

@tt{Parameter_list} may contain the following elements:
@begin{itemize}

@item @tt{action(Action)} where @tt{Action} is @tt{check} or
@tt{union}.  If the action is to check, two components with the same
name part and different path parts or versions cannot be loaded: an
attempt to do so will cause an error.  If the action is to union, two
components with the same name and different paths may be loaded, and
the effect will look as if the two components had been unioned
together.  However an error will occur if two components with the same
name and paths but different versions are loaded.

@item @tt{merge(Speed)} where @tt{Speed} is @tt{fast} or @tt{slow}
(default @tt{fast}).  This controls the amount of redundancy checking
upon merging in external facts in the components (see @ref{}).

@item @tt{force(Bool)} where @tt{Bool} is @tt{yes} or @tt{no} (default
@tt{no}).  If @tt{Force} is @tt{yes}, any components that have
previously been loaded into the OMS are reloaded, and their
initialization files reconsulted.  If @tt{Force} is @tt{no}, no
actions will be taken to load or initialize components already loaded
into the OMS.

@item @tt{version(V)} where @tt{V} is a version number.  If the
parameter list contains such a term, the loader attempts to load
version @tt{V} of component.  The default action is to load the latest
version of a component.

@end{itemize}
").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

load_component(Name,Path,Arglist):-
	retractall(temp_depends(_,_,_,_)),
	(atom(Path),atom(Name),ground(Arglist) -> 
	    true
	  ; oms_error(load_component,['Component name, path and arglist must',
			' be instantiated to load: ',Path,'/',Name,' ',
			Arglist]) ),
	load_component_1(Name,Path,Arglist).

load_component_1(Name,Path,Arglist):- 
	retract_omsext,
	split_arglist_on_version(Arglist,V,Arglist1),
	(load_component_pass1(Name,Path,V,Arglist1) -> 
	    message(['Merging in components.']),nl,
	    (member(speed(slow),Arglist1) -> 
	        merge_omsext 
	      ; fast_merge_omsext),
	    load_component_pass2(Name,Path,V,[]) 
	  ; true),
	retractall(temp_depends(_,_,_,_)),
	retract_omsext.

split_arglist_on_version([],null,[]).
split_arglist_on_version([version(V)|R],version(V),R):-!.
split_arglist_on_version([H|T],V,[H|T1]):-
	split_arglist_on_version(T,V,T1).

%----------

load_component_pass1(Name,Path,Vin,Arglist):- 
	get_full_path_and_loadname(Name,Path,Vin,Full,V,Loadname),
	(check_component(Name,Full,V,Arglist) -> 
  	    message(['Loading component: ',Full,'/',Loadname]),nl,
  	    concat_atom([Full,'/',Loadname],Absname),
	    overload_omsext(Absname),
	    check_good_component(Name,Full),
            load_component_dependencies_pass1(Name,Full,Arglist) 
	  ; 
	    fail ).

load_component_dependencies_pass1(Name,Path,Arglist):- 
	strel_ext(component(Name,Name,atom(Path),'OMS',
						integer(_V),'OMS'),'OMS',
			 componentDepends,Name,
			 component(New,New,atom(Pathnew),'OMS',
					integer(Vnew),'OMS'),'OMS'),
%	writeln(checking(dep(Name,New))),	
        load_component_pass1(New,Pathnew,version(Vnew),Arglist),
        assert_dependencies_for_path2(Name,New,Pathnew,Vnew),
	fail.
load_component_dependencies_pass1(_,_,_).

assert_dependencies_for_path2(Name,New,Pathnew,Vnew):- 
	New \== 'OMS',
	New \== Name,
	call_assert(temp_depends(Name,New,Pathnew,Vnew)).

call_assert(Term):- (call(Term) -> true ; asserta(Term)).

%----------

/* TLS: pass 2 is to load intensional rules and consult initialization file.
   Assume that all conflict checking has been done in pass2 */
load_component_pass2(Name,Path,Vin,Anclist):- 
	get_full_path_and_loadname(Name,Path,Vin,Full,_V,Loadname),
	message(['Loading int rules and initializing componen: ',
			Full,'/',Loadname]),nl,
        load_component_dependencies_pass2(Name,Full,Anclist),
	load_intensional_rules(Full,Name),
	initialize_component(Loadname,Full).

load_component_dependencies_pass2(Name,_Path,Anclist):- 
	temp_depends(Name,New,Pathnew,Vnew),
	(member(New,Anclist) -> true
	  ; 
	    load_component_pass2(New,Pathnew,Vnew,[Name|Anclist]) ),
	fail.
load_component_dependencies_pass2(_,_,_).

initialize_component(Name,Path):- 
	concat_atom([Path,'/',Name,'/initialization_file.P'],File),
	(file_exists(File) -> consult(File) ; true).

%---------------

check_good_component(Name,Full):- 
	(class_ext(Name,Name,Name) -> 
	    true
	  ;
	    oms_error(component_load,['Pathname: ',Full,
				      ' is not a component']) ).

%---------------

/* If check_component succeeds, we go ahead and do a pass 1 load. */
check_component(Name,Path,V,Arglist):- 
	Name \== 'OMS',
	check_conflicting_path(Name,Path,Arglist),
	check_conflicting_version(Name,Path,V),
	\+ already_present(Name,Path,V,Arglist).

check_conflicting_version(Name,Path,V):- 
	(conflicting_version(Name,Path,V,V1) -> 
	    oms_error(component_load,['Version ',V,' of ',Name,
			' cannot be loaded, as version ',V1,
			' is alreaty loaded '])
	  ; true).

%---------------

/* TLS: For now, each component is taken to depend on some version of
the OMS. */
conflicting_version(Name,Path,V,V1):- 
	(strel_ext(component(Name,Name,atom(Path),'OMS',integer(V1),'OMS'),
			'OMS',componentDepends,Name,_,_)
	 ; 
	     class(Cid,Name,Name,Name),
	     class(Rid,componentDepends,componentDepends,Name),
	     immediate_strel(component(Cid,atom(Path),integer(V1)),Rid,_)
	),
        V \== V1,
	!.

check_conflicting_path(Name,Path,Arglist):- 
	(\+ member(action(union),Arglist) -> 
		(conflicting_path(Name,Path,Path1) -> 
 	            oms_error(component_load,['Component ',Name,' has ',
			'conflicting paths in non-union merge: ',Path,
			' and ',Path1])
		  ; 
		    true) 
	      ;  true).

conflicting_path(Name,P,P1):- 
	(   strel_ext(Name,Name,hasPath,Name,atom(P1),'OMS')
	 ; 
	     class(Cid,Name,Name,Name),
	     class(Rid,hasPath,hasPath,Name),
	     immediate_strel(Cid,Rid,atom(P1))
	),
        P \== P1,
	!.

%---------------

/* TLS: if component is in cache, it has  already scheduled been
traversed in pass1.  Otherwise count merged components as traversed
unless force is yes. */

already_present(Name,Path,V,Arglist):- 
	
	(   strel_ext(Name,Name,hasVersion,Name,integer(V),'OMS'),
	    strel_ext(Name,Name,hasPath,Name,atom(Path),'OMS')
	 ; 
  	     \+ member(force(yes),Arglist),
	     class(Cid,New,New,New),
	     class(Vid,hasVersion,hasVersion,Name),
	     immediate_strel(Cid,Vid,integer(V)),
	     class(Pid,hasPath,hasPath,Name),
	     immediate_strel(Cid,Pid,atom(Path))
	).


%---------------

/* here is where we may do something w. relative paths.
   Name is the name part of a component, and Path its path-part, 
   possibly input as a relative path name.  Upon success, V is
   instantiated to the proper version of the component (which may
   implicitly be the latest version), CanonPath is instantiated
   to a canonical path, and Loadname is the name, plus version if 
   applicable.
 */
get_full_path_and_loadname(Name,Path,Vin,CanonPath,V,Loadname):- 
	Path = CanonPath,
	(Vin = version(V) -> 
	    file_find_version_name(Path,Name,V,Loadname)
	 ; 
	    Loadname = Name,file_latest_version(Path,Name,V) ).

file_find_version_name(Path,Name,Version,Loadname):- 
	file_latest_version(Path,Name,V),
	(V = Version -> 
	    Loadname = Name
	  ; (V > Version -> 
	        concat_atom([Name,'_',Version],Loadname)
	      ; 
		oms_error(load_component,['Improper version number',Version,
				' for ',Path,'/',Name]) ) ).
	  
file_latest_version(Dir,Name,Version):- 
	findall(File,short_directory(Dir,File),Files),
	atom_chars(Name,NameL),
	file_latest_version_1(Files,NameL,-1,Version).
		
file_latest_version_1([],_NameL,V,V1):- V1 is V + 1.
file_latest_version_1([File|Rest],NameL,V,V1):- 
	atom_chars(File,FileL),
	(get_v_from_filelist(NameL,FileL,NumL) -> 
	    number_chars(N,NumL),
	    (N > V -> 
	        file_latest_version_1(Rest,NameL,N,V1)
	      ; 
		file_latest_version_1(Rest,NameL,V,V1))
	  ;
	    file_latest_version_1(Rest,NameL,V,V1)).

get_v_from_filelist([],['_'|Rest],Rest).
get_v_from_filelist([H|T],[H|T1],Rest):- 
	get_v_from_filelist(T,T1,Rest).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(update_all_components/2,
"@tt{update_all_components(Dir,Option_list)} analyzes components of an
OMS state and their dependencies, determining whether they need to be
updated or not, and creating components when necessary.  When a
component is created with path @tt{Dir}, the files @tt{data_omsext.P},
@tt{schema_omsext.P} and @tt{oms_intensional.P} are created.
Initialization files must be added manually for new components.
@tt{Option_list} contains a list of parameters which currently
specifies the effect on previously existing components:

@begin{itemize} @item @tt{action(Action)}.  
@begin{itemize} 

@item If @tt{Action} is @tt{create}, then a new set of components is
created in @tt{Dir}.  Information not previously componetized is added
to new components whose path is @tt{Dir} and whose version number is
0.  Facts that are parts of previously created components are also
written as subdirectories of @tt{Dir}; if their previous path was
@tt{Dir}, their versions are updated if needed (i.e. if any facts in
the component have changed).  Otherwise, if the path of a previously
created component @tt{C} was not @tt{Dir}, @tt{C} is dumped as a
subdirectory of @tt{Dir}, its path is changed to @tt{Dir} and its
version is set to 0.  In addition, the initialization file for @tt{C}
is copied to @tt{Dir}.

@item If @tt{Action} is @tt{in_place}, then components created in
@tt{Dir} only for information that was not previously componetized.
Facts that are parts of newly created components are dumped as
subdirectories of @tt{Dir} which serves as their path, and their
version number is 0.  Previously created components whose paths were
not @tt{Dir} are updated using their present path, if needed.

@end{itemize}

In either case all dependency information reflects new component and
path information.
@end{itemize}


").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

update_all_components(Dir,Options):- 
	analyze_components(Comp,Dep),
	Comp = compVers(Name,Name,integer(V),_),
	(member(action(create),Options) -> 
	    update_component_create(Name,V,Dep,Dir)
	  ; 
	    update_component_in_place(Name,V,Dep,Dir) ),
	fail.
update_all_components(_Dir,_Options).

update_component_create(Name,V,Dep,Dir):- 
	newComponent(Name,Dir,create,NameId,RelId),
	create_dependencies_int_1(Dep,Name,NameId,RelId,Dir,create),
	writeln(dumping(Name)),
	dump_component_1(Dir,Name,V).

update_component_in_place(_Name,_V,_Dep,_Dir):- 
	abort('in_place option not yet implemented -- please use create').

/*
	newComponent(Name,Dir,in_place,NameId,RelId),
	create_dependencies_int_1(Dep,Name,NameId,RelId,Dir,in_place),
	writeln(dumping(Name)),
	dump_component_1(Dir,Name,V).
*/

:- comment(update_components/2, "@tt{update_components(Dir,List)}
Updates components in @tt{List} (or creates them) writing them into
subdirectories of @tt{Dir}.  If a component in @tt{List} depends on a
component that needs updating but is not in list or on a source that
has not been made into a component, the predicate abort without
changing the state or file system.  ").

update_components(_Dir,_List):- 
	abort('update_components/2 not yet implemented').

/* Create a new component for each cell name in dependency list or
find the version number of the component to which cell name belongs.
Then, add the dependency structure. */
create_dependencies_int_1([],_Name,_Compid,_Relid,_Dir,_Action).
create_dependencies_int_1([compVers(Name,Name,integer(V),'OMS')|T],
			  Name1,Compid,Relid,Dir,Action):- 
	Name \== Name1,!,
	(V == 0 -> 
	      newComponent(Name,Dir,Action,NewCompId,_NewRelid) 
	    ; class(NewCompId,_,compVers(Name,Name,integer(V),'OMS'),'OMS') ),
	newStrel(Compid,Relid,NewCompId),
	create_dependencies_int_1(T,Name,Compid,Relid,Dir,Action).
create_dependencies_int_1([_|T],Name,Compid,Relid,Dir,Action):- 
	create_dependencies_int_1(T,Name,Compid,Relid,Dir,Action).

dump_component_1(Dir,Name,Version):- 
	Name \== 'OMS',
	slash(Slash),
	make_component_dir(Dir,Name,Version,NewDir),
	concat_atom([NewDir,Slash,'schema_omsext.P'],SchFile),
	init_ext_schema_index,
	tell(SchFile),
	compwrite_class(Name),compwrite_subclass(Name),
	compwrite_irel(Name),compwrite_schrel(Name),
	compwrite_strel(Name),
	told,
	concat_atom([NewDir,Slash,'data_omsext.P'],DataFile),
	init_ext_data_index,
	tell(DataFile),
	compwrite_object(Name),compwrite_memberof(Name),
	compwrite_attribute(Name),compwrite_attribute_object(Name),
	told,
	concat_atom([NewDir,Slash,'oms_intensional.P'],IntFile),
	tell(IntFile),
	write_component_intensional(Name),
	told.

make_component_dir(Dir,Name,Version,NameDir):- 
	slash(Slash),
        concat_atom([Dir,Slash,Name],NameDir),
	(Version = 0 -> 
	    true
	  ; 
	    LastVersion is Version - 1,
            concat_atom([Dir,Slash,Name,'_',LastVersion],LastDir),
	    shell(['mv ',NameDir,' ',LastDir]) ),
        xsb_makedir(NameDir).


compwrite_class(Source):- 
	write_hdr(class_ext(_,_,_)),
	oms_cn(Id,Name,Nid,Src),
	get_component_extensional(oms_cn(Id,Name,Nid,Src),Source),
	write_ext_term(class_ext(Name,Nid,Source)),
	fail.
compwrite_class(_).

compwrite_object(Source):- 
	write_hdr(object_ext(_,_,_)),
	object(Id,Name,Nid,Src),
	get_component_extensional(oms_obj(Id,Name,Nid,Src),Source),
	write_ext_term(object_ext(Name,Nid,Source)),
	fail.
compwrite_object(_).

compwrite_subclass(Source):- 
	write_hdr(subclass_ext(_,_,_,_)),
	oms_sc(Sub,Sup),
	get_component_extensional(oms_sc(Sub,Sup),Source),
	class_cidbound(Sub,_,Nid1,Source1),
	class_cidbound(Sup,_,Nid2,Source2),
	write_ext_term(
                 subclass_ext(Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_subclass(_).

compwrite_memberof(Source):- 
	write_hdr(memberof_ext(_,_,_,_)),
	oms_mo(Sub,Sup),
	get_component_extensional(oms_mo(Sub,Sup),Source),
	object(Sub,_,Nid1,Source1),
	class_cidbound(Sup,_,Nid2,Source2),
	write_ext_term(
                 memberof_ext(Nid1,Source1,Nid2,Source2)),
	fail.
compwrite_memberof(_).

compwrite_irel(Source):- 
	write_hdr(relationship_ext(_,_,_,_,_,_)),
	oms_rln(Src,Rel,Targ),
	get_component_extensional(oms_rln(Src,Rel,Targ),Source),
	class_cidbound(Src,_,Nid1,Source1),
	class_cidbound(Rel,_,Nid2,Source2),
	class_cidbound(Targ,_,Nid3,Source3),
	write_ext_term(
                 relationship_ext(Nid1,Source1,Nid2,Source2,Nid3,Source3)),
	fail.
compwrite_irel(_).

compwrite_schrel(Source):- 
	write_hdr(schrel_ext(_,_,_,_,_,_)),
	oms_schrel(Src,Rel,Targ),
	get_component_extensional(oms_schrel(Src,Rel,Targ),Source),
	class_cidbound(Src,_,Nid1,Source1),
	class_cidbound(Rel,_,Nid2,Source2),
	class_cidbound(Targ,_,Nid3,Source3),
	write_ext_term(
                 schrel_ext(Nid1,Source1,Nid2,Source2,Nid3,Source3)),
	fail.
compwrite_schrel(_).

compwrite_strel(Source):- 
	write_hdr(strel_ext(_,_,_,_,_,_)),
	oms_strel(Src,Rel,Targ),
	get_component_extensional(oms_strel(Src,Rel,Targ),Source),
	class_cidbound(Src,_,Nid1,Source1),
	class_cidbound(Rel,_,Nid2,Source2),
	class_cidbound(Targ,_,Nid3,Source3),
	write_ext_term(
                 strel_ext(Nid1,Source1,Nid2,Source2,Nid3,Source3)),
	fail.
compwrite_strel(_).

compwrite_attribute(Source):- 
	write_hdr(attribute_ext(_,_,_,_,_,_)),
	oms_at(Src,Rel,Targ),
	get_component_extensional(oms_at(Src,Rel,Targ),Source),
	object(Src,_,Nid1,Source1),
	class_cidbound(Rel,_,Nid2,Source2),
	class_cidbound(Targ,_,Nid3,Source3),
	write_ext_term(
                 attribute_ext(Nid1,Source1,Nid2,Source2,Nid3,Source3)),
	fail.
compwrite_attribute(_).

compwrite_attribute_object(Source):- 
	write_hdr(attribute_object_ext(_,_,_,_,_,_)),
	oms_ao(Src,Rel,Targ),
	get_component_extensional(oms_ao(Src,Rel,Targ),Source),
	object(Src,_,Nid1,Source1),
	class_cidbound(Rel,_,Nid2,Source2),
	object(Targ,_,Nid3,Source3),
	write_ext_term(
                 attribute_object_ext(Nid1,Source1,Nid2,Source2,Nid3,Source3)),
	fail.
compwrite_attribute_object(_).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Utilities
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
overload_omsext(Dir) :-
	oms_fix_dir(Dir,DirS),
	dir_overload_dync(DirS,schema_omsext),
	dir_overload_dync(DirS,data_omsext).

dir_overload_dync(Dir,Base) :-
	concat_atom([Dir,Base,'.P'],File),!,
	(overload_dync(File) 		% i.e. use asserta
              -> true
	  ; oms_warning(permission,('File does not exist ',
                                    'or is not readable: ',File))).

overload_dync(File):- 
	see(File),
	overload_dync_1,
	seen.

overload_dync_1:- 
	repeat,
	read_canonical(T),
	(T = end_of_file -> true ; asserta(T),fail).

xsb_makedir(Dir):- 
	(path_sysop(isdir,Dir) -> true ; path_sysop(mkdir,Dir)).

write_component_intensional(Name):- 
	intensional_head(Head,_Arg),
	Head =.. [F|T],
	concat_atom([F,'_',Name],NewF),
	NewHead =.. [NewF|T],
	clause(NewHead,Body), 
	pretty_print(clause(Head,Body)),
	fail.
write_component_intensional(_).

end_of_file.

@item A user may wish to create components from external files.  In
this case, the predicate @pred{create_external_component/1} can be
used to add this information.  @tt{create_external_component(Dir)}
reads in external files, computes their dependencies, and writes out
the files, plus component information, back to @em{Dir}.  The
information in this component does not affec the state of the OMS
until it is explicitly loaded.  In the case where a putative component
includes an external intensional view, dependency information for the
external intensional view must be added by hand.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(create_external_component/1,"
@tt{create_external_component(Dir)} loads from @tt{Dir}
@tt{data_omsext.P}, and @tt{schema_omsext.P} files, creates a
component if possible, then dumps the new omsext that includes the
component information.").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

create_external_component(Name):- 
	retract_omsext,
	abolish_table_pred(find_component_dependency/1),
	find_component_dir(Name,Full),
	load_omsext(Full),
	check_component(Name),
	assert(class_ext(Name,Name,Name)),
	assert(subclass_ext(Name,Name,'OMS Component','OMS')),
	create_dependencies_ext(Name),
	dump_component_ext(Full,Name),
	retract_omsext.

/* works on loaded, unmerged omsext */	
create_dependencies_ext(Name):- 
	find_component_dependency(Dep),
	call_assert(strel_ext(Name,Name,componentDepends,Name,Dep,Dep)),
	fail.
create_dependencies(Name):- 
	asserta(strel_ext(Name,Name,componentDepends,Name,Name,Name)).

%-----------
/* checks whether a set of loaded,  non-merged external facts with
a given source constitute a component */ 

check_component(Name):- 
	check_class(Name),
	check_object(Name),check_subclass(Name),
	check_memberof(Name),check_relationship(Name),
	check_schrel(Name),check_strel(Name),
	check_attribute(Name),check_attribute_object(Name).

check_class(Name):- 
	(class_ext(Q,W,N),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
                                      ' has class with different source: ',
			              class_ext(Q,W,N)])
	; 
	   fail).
check_class(_).

check_object(Name):- 
	(object_ext(Q,W,N),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
                                      ' has object with different source: ',
					      object_ext(Q,W,N)])
	; 
	   fail).
check_object(_).

check_subclass(Name):- 
	(subclass_ext(Q,N,W,E),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
                                      ' has subclass with different source: ',
					      subclass_ext(Q,N,W,E)])
	; 
	   fail).
check_subclass(_).

check_memberof(Name):- 
	(memberof_ext(Q,N,W,E),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has memberof with different source: ',
			   memberof_ext(Q,N,W,E)])
	; 
	   fail).
check_memberof(_).

check_relationship(Name):- 
	(relationship_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has relationship with different source: ',
			   relationship_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_relationship(_).

check_schrel(Name):- 
	(schrel_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has schrel with different source: ',
			   schrel_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_schrel(_).

check_strel(Name):- 
	(strel_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has strel with different source: ',
			   strel_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_strel(_).

check_attribute(Name):- 
	(attribute_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has attribute with different source: ',
			   attribute_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_attribute(_).

check_attribute_object(Name):- 
	(attribute_object_ext(Q,N,W,E,R,T),N \== Name -> 
	    oms_error(component,['Component specified by ',Name,
	                   ' has attribute_object with different source: ',
			   attribute_object_ext(Q,N,W,E,R,T)])
	; 
	   fail).
check_attribute_object(_).

%-------------------------------------

/* find_component_dependency/1 returns the set of dependencies for a
putative component -- from a set of loaded, non-merged external facts.
Only those dependencies obtained from external form are returned --
extint dependencies must be added "by hand". */

:- table find_component_dependency/1.
find_component_dependency(Dep):- 
	find_component_dependency_1(Dep).

find_component_dependency_1(Dep):- 
	class_ext(_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	object_ext(_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	subclass_ext(_,_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	memberof_ext(_,_,Class,S),
            (Dep = S; (S \== 'OMS',find_pc_dependency(Class,Dep))).
find_component_dependency_1(Dep):- 
	relationship_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	schrel_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	strel_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	attribute_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).
find_component_dependency_1(Dep):- 
	attribute_object_ext(_,_,Rcl,Rs,Tcl,Ts),
	(Rs = Dep ; Rs \== 'OMS',find_pc_dependency(Rcl,Dep)
             ; Ts = Dep ; Ts \== 'OMS',find_pc_dependency(Tcl,Dep)).

find_pc_dependency(Class,Dep):- 
	compound(Class),
	Class =.. [_|Arglist],
	find_pc_dependency_list(Arglist,Dep).
	
find_pc_dependency_list([_Class,S|_R],S).
find_pc_dependency_list([Class,S|_R],Dep):- 
	S \== 'OMS',
	find_pc_dependency(Class,Dep).
find_pc_dependency_list([_Class,_S|R],Dep):- 
	find_pc_dependency_list(R,Dep).

%-----------
/* dump_component_ext/2 is not to be exported -- it dumps from
extrernal format and is to be used with create component. */
dump_component_ext(Dir,Name):- 
	slash(Slash),
  	concat_atom([Dir,Slash,'schema_omsext.P'],SchFile),
	init_ext_schema_index,
	tell(SchFile),
	write_hdr(class_ext(_,_,_)),
	write_call(class_ext(_,_,Name)),
	write_hdr(subclass_ext(_,_,_,_)),
	write_call(subclass_ext(_,Name,_,_)),
	write_hdr(relationship_ext(_,_,_,_,_,_)),
	write_call(relationship_ext(_,Name,_,_,_,_)),
	write_hdr(schrel_ext(_,_,_,_,_,_)),
	write_call(schrel_ext(_,Name,_,_,_,_)),
	write_hdr(strel_ext(_,_,_,_,_,_)),
	write_call(strel_ext(_,Name,_,_,_,_)),
	told,
  	concat_atom([Dir,Slash,'data_omsext.P'],DataFile),
	init_ext_data_index,
	tell(DataFile),
	write_hdr(object_ext(_,_,_)),
	write_call(object_ext(_,_,Name)),
	write_hdr(memberof_ext(_,_,_,_)),
	write_call(memberof_ext(_,Name,_,_)),
	write_hdr(attribute_ext(_,_,_,_,_,_)),
	write_call(attribute_ext(_,Name,_,_,_,_)),
	write_hdr(attribute_object_ext(_,_,_,_,_,_)),
	write_call(attribute_object_ext(_,Name,_,_,_,_)),
	told.

%---

write_call(Call):- 
	abolish_table_pred(table_call/1),
	table_call(Call),
	write_ext_term(Call),
	fail.
write_call(_Call):-
	abolish_table_pred(table_call/1).

:- table table_call/1.
table_call(Call):- call(Call).


:-comment(merge_components/2,"merge_components(+List,+Component)
merges the components in @tt{List} into component @tt{Component}.
Specifically, for each component @tt{C} in @tt{List} it renames any
known identifier @tt{id(Nid,C)} in the OMS state to
@tt{id(Nid,Component)}.  The dirty bit is set on @tt{Component} so
that it will be written out on update.  ").

increment_component_version(Component):- 
	class(Cid,Component,Component,Component),
	class(Rid,_,has_version,Component),
	strel(Cid,Rid,integer(V)),
	retractallStrel(Cid,Rid,integer(V)),
	V1 is V + 1,
	newStrel(Cid,Rid,integer(V1)).

merge_components(List,Component):- 
	newComponent(Component),
	merge_components_1(List,Component),
	increment_component_version(Component).

merge_components_1([],_).
merge_components_1([H|T],Component):- 
	(H == Component -> 
	    true
	  ; 
	    merge_components_2(H,Component)),
	merge_components_1(T,Component).

merge_components_2(H,Component):- 
	rewrite_extensional_facts(H,Component),
	rewrite_intensional_rules(H,Component),
	rewrite_id_cache(H,Component).

rewrite_extensional_facts(H,Component):- 
	dep_from_cid

needs_rewrite(oms_cn(Id,Name,Nid,Src),Clist,Comp,
	      oms_cn(Id,Name,Nid,Src),Flag):- 
	((member(Src,Clist),Src \== Comp) -> 
	     
	check_and_rewrite(oms_cn(Id,Name,Nid,Src),Clist,Comp,Flag),
	
check_and_rewrite(oms_cn(Id,Name,Nid,Src),Clist,Comp,Flag),


dep_from_cid(Id,Source):-  oms_cn(Id,_,_,Source).
dep_from_cid(Id,Source):-  
	compound(Id), 
	\+ (oms_primitive_class(Id,_,_,_)),
	Id =.. [_|Arglist],
	dep_from_cid_list(Arglist,Source).
		
dep_from_cid_list(Arglist,Source):- 
	member(Id,Arglist),
	dep_from_cid(Id,Source).

:- comment(add_component_initializer/2,
"@tt{add_component_initializer(Component,File)} can be used to add
@tt{File} as an initialization file for @tt{Component}.
@tt{Component} must already exist as a component and be loaded into an
OMS state, otherwise a warning is given and the predicate fails.").

add_component_initializer(Comp,File):- 
   (q_immediate_subclass(id(Comp,Comp),id('OMS Component','OMS')),
    q_strel(id(Comp,Comp),id(has_version,Comp),id(integer(V),'OMS')) -> 
	q_newStrel(id(compVers(id(Comp,Comp),id(integer(V),'OMS')),'OMS'),
	          id(initialization_file,Comp),
	          id(atom(File),'OMS'))
     ; 
	oms_warning(component,['Cannot initialize uncreated component ',
				Comp]),
	fail).

find_component_dir(Name,Full):- 
	(search_module(Name,_Dir_part,_Base_part,_Ext,Full,_Obj) 
                -> true 
	    ; 
	        oms_error(component,['can''t find component: ',Name])),
	(path_sysop(isdir,Full) -> 
	    true 
	  ; 
	     oms_error(component,['component name is not a directory',Full])).

top_level_needs_loading(_Path,Name,Arglist):- 
	\+ (Name = 'OMS'),
	(member(force(yes),Arglist) -> 
	    true
	  ; 
	    \+ class(_,Name,Name,Name) ).


conflicting_version(Name,New,V1,Name2,V2):- 
	strel_ext(component(Name,Name,atom(_),'OMS',integer(_),'OMS'),'OMS',
		    componentDepends,Name,
		    component(New,New,atom(_),'OMS',integer(V1),'OMS'),'OMS'),
	(    strel_ext(component(Name2,Name2,atom(_),'OMS',
					     integer(_),'OMS'),'OMS',
			 componentDepends,_,
			 compVers(New,New,atom(_),'OMS',
					  integer(V2),'OMS'),'OMS')
	 ; 
	     class(Cid,New,New,New),
	     class(Rid,componentDepends,componentDepends,Name),
	     immediate_strel(Sid,Rid,component(Cid,atom(_),integer(V2))),
	     Sid = component(Sid2,_,_),class(Sid2,Name2,Name2,Name2)
	),
        V1 \== V2.


dependency_needs_loading(New,Name,Arglist):- 
	New \== 'OMS',New \== Name,
	\+ class_ext(New,New,New),
	(member(force(yes),Arglist) ; \+ class(_,New,New,New) ).

