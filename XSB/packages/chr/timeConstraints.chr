% PATH CONSISTENCY to be used with time.pl
%% thom fruehwirth ECRC 921030,930212,930802,930804,930908,931216,931223
%% christian holzbaur 961022 more mods for Sicstus
%% thom fruehwirth LMU 980206, 980312
% XSB Version Barry Evans 2006


/*---------- start of timeConstraints.chr -------------------------------*/
:- chr_module(timeConstraints).
:- export arc/4, path/6, labeling/0.

:- import globalize/1, var_compare/3, lookup_variable_id/2 from constraintLib.
:- import ground/1, length/2, member/2 from basics.

:- import
	transl/4,
	intersection/3,
	equality/2,
	shift_interval/3,
	bind_value/3,
	unique/1,
	universal/3,
	empty/2,
	path1/5 from time.

% MDL Temporal Constraint Tracing stuff
:- ensure_loaded(mdl_TimeMachine).
:- import	mdl_TraceNewPath/1,
			mdl_TraceConstraintRuleFired/2,
			mdl_TraceConstraintRuleFired/3,
			mdl_GraphStep/0
			from mdl_TimeMachine.

nonground(X) :- \+ ground(X).

%% handler path_consistency.		(Sicstus pragma)

:- constraints (arc)/4, (path)/6.
%:- table (path)/6.

%% arc(X,Y,L,T) there is an arc in the constraint network between variables X and Y with constraint L of type T
%% path(N,X,Y,L,T,I) there is a path in the constraint network between variables X and Y with constraint L of type T

%% start up
add_path @
arc(X,Y,L,T) <=> ground(L),ground(T),length(L,N) |
globalize(X),					% attach attribute to vars to have order on them
globalize(Y),
sort(L,SortedL),
mdl_TraceNewPath(path(N,X,Y,SortedL,T,1)),
path(N,X,Y,SortedL,T,1),
mdl_GraphStep.

%% ground case
ground @
path(N,X,Y,L,T,I) <=> ground(X-Y-L-T)
|
mdl_TraceConstraintRuleFired(ground,path(N,X,Y,L,T,I)),
path1(N,X,Y,L,T).

%% simple cases
empty @
path(N,X,Y,L,T,I) <=> empty(N,L)
|
mdl_TraceConstraintRuleFired(empty,path(N,X,Y,L,T,I)),
fail.

universal @
path(N,X,Y,L,T,I) <=> universal(N,L,T)
|
mdl_TraceConstraintRuleFired(universal,path(N,X,Y,L,T,I)),
true.

equality @
path(N,X,X,L,T,I) <=> equality(L,T),
mdl_TraceConstraintRuleFired(universal,path(N,X,Y,L,T,I)).

unify @
path(1,X,Y,L,T,I) <=> unique(L),equality(L,T)
|
mdl_TraceConstraintRuleFired(unify,path(1,X,Y,L,T,I)),
X=Y. % can cause problems with var order

%% special cases for finite domains
%findom_unique @
%path(1,X,Y,L,p-p,I) <=> number(X),unique(L)
%|
%mdl_TraceConstraintRuleFired(findom_unique,path(1,X,Y,L,p-p,I)),
%bind_value(X,Y,L).

%findom_x @
%path(N,X,Y,L,p-p,I) <=> number(X),X=\=0
%|
%mdl_TraceConstraintRuleFired(findom_x,path(N,X,Y,L,p-p,I)),
%shift_interval(X,L,L1),
%mdl_TraceNewPath(path(N,0,Y,L1,p-p,I)),
%path(N,0,Y,L1,p-p,I),
%mdl_GraphStep.

%findom_y @
%path(N,Y,X,L,p-p,I) <=> number(X)
%|
%mdl_TraceConstraintRuleFired(findom_y,path(N,Y,X,L,p-p,I)),
%equality([Eq],p-p),transl(L,L2,[Eq],p-p-p), % invert path
%shift_interval(X,L2,L1),
%mdl_TraceNewPath(path(N,0,Y,L1,p-p,I)),
%path(N,0,Y,L1,p-p,I),
%mdl_GraphStep.


path_already_in_store1 @
path(N, X, Y, L, T, I) \ path(N, X, Y, L, T, J) <=> I =< J
|
mdl_TraceConstraintRuleFired(path_already_in_store1,path(N,X,Y,L,T,I),path(N,X,Y,L,T,J)),
true.

path_already_in_store2 @
path(N1, X, Y, L1, T, I) \ path(N2, X, Y, L2, T, J) <=>
intersection(L1, L2, L3),
L3 == L1,
N1 < N2
|
mdl_TraceConstraintRuleFired(path_already_in_store2,path(N1,X,Y,L1,T,I),path(N2,X,Y,L2,T,J)),
true.


%% intersection (has to come before transitivity)
intersect_xy_xy @
path(N1, X, Y, L1, U-V, I), path(N2, X, Y, L2, U-V, J) <=> % 10
intersection(L1, L2, L3),
L3 \== L1,
L3 \== L2
|
mdl_TraceConstraintRuleFired(intersect_xy_xy,path(N1,X,Y,L1,U-V,I), path(N2,X,Y,L2,U-V,J)),
length(L3, N3),
K is min(I, J),
mdl_TraceNewPath(path(N3, X, Y, L3, U-V, K)),
path(N3, X, Y, L3, U-V, K),
mdl_GraphStep.
% pragma already_in_heads.

intersect_yx_xy @
path(N1, Y, X, L1, U-V, I), path(N2, X, Y, L, V-U, J) <=> % 11
mdl_TraceConstraintRuleFired(intersect_yx_xy,path(N1,Y,X,L1,U-V,I),path(N2,X,Y,L,V-U,J)),
equality([Eq], V-V), transl(L, L2, [Eq], V-U-V), % invert 2nd path
intersection(L1, L2, L3),
length(L3, N3),
K is min(I, J),
mdl_TraceNewPath(path(N3, Y, X, L3, U-V, K)),
path(N3, Y, X, L3, U-V, K),
mdl_GraphStep.

%% transitivity
propagate_xy_yz @
path(N1, X, Y, L1, U-V, I), path(N2, Y, Z, L2, V-W, J) ==>
nonground(Y),
J=1, (I=1 -> var_compare(<, X, Z) ; true) % or J=1 or N2=1 or X@<Z
|
mdl_TraceConstraintRuleFired(propagate_xy_yz,path(N1,X,Y,L1,U-V,I),path(N2,Y,Z,L2,V-W,J)),
transl(L1, L2, L3, U-V-W),
length(L3, M),
K is I+J,
mdl_TraceNewPath(path(M, X, Z, L3, U-W, K)),
path(M, X, Z, L3, U-W, K),
mdl_GraphStep.

propagate_xy_xz @
path(N1, X, Y, L1, U-V, I), path(N2, X, Z, L3, U-W, J) ==>
nonground(X),
min(I, J)=:=1, var_compare(<, Y, Z) % or J=1 or N2=1
|
mdl_TraceConstraintRuleFired(propagate_xy_xz,path(N1,X,Y,L1,U-V,I),path(N2,X,Z,L3,U-W,J)),
transl(L1, L2, L3, U-V-W),
length(L2, M),
K is I+J,
mdl_TraceNewPath(path(M, Y, Z, L2, V-W, K)),
path(M, Y, Z, L2, V-W, K),
mdl_GraphStep.

propagate_xy_zy @
path(N1, X, Y, L3, U-V, I), path(N2, Z, Y, L2, W-V, J) ==>
nonground(Y),
min(I, J)=:=1, var_compare(<, X, Z) % or J=1 or N2=1
|
mdl_TraceConstraintRuleFired(propagate_xy_zy,path(N1,X,Y,L3,U-V,I),path(N2,Z,Y,L2,W-V,J)),
transl(L1, L2, L3, U-W-V),
length(L1, M),
K is I+J,
mdl_TraceNewPath(path(M, X, Z, L1, U-W, K)),
path(M, X, Z, L1, U-W, K),
mdl_GraphStep.


%% labeling by choice of primitive relation
:- constraints labeling/0.
labeling, path(N, X, Y, L, T, I)#Id <=> N>1 |	
mdl_TraceConstraintRuleFired(labeling,path(N,X,Y,L,T,I)),
member(R, L), 
mdl_TraceNewPath(path(1,X,Y,[R],T,I)),
path(1, X, Y, [R], T, I),
mdl_GraphStep,
labeling
pragma passive(Id).

/*--------------- eof timeConstraints.chr ------------------------------------*/
