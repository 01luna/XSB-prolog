/* 

init_smodels(+Query,+Flag): initializes smodels with the residual
program for Query.  Query must be a call to a tabled predicate that is
currently completely evaluated (and should have a delay list).  If
Flag is 1, then the program will be printed out on STDFDBK.

atom_handle(?Atom,?AtomHandle): is set by init_smodels to be true of
the set of atoms in the residual program (and thus the herbrand base
of the stable models.)  AtomHandle is an integer uniquely identifying
the atom.  The initial query given to init_smodels has the atom-handle
of 1.

in_all_stable_models(+AtomHandle,+Neg): is true if Neg is 0 and the
atom numbered AtomHandle is true in all stable models (of the residual
program set by the previous init_smodels).  If Neg is nonzero, then it
is true if the atom is in NO stable model.

a_stable_model: invokes smodels to find a stable model (of the program
set by the previous invocation of init_smodels.)  If there are no
(more) stable models, it fails.  It will compute all stable models
through backtracking.  Atoms true in a stable model can be obtained by
in_current_stable_model/1.

print_current_stable_model: prints the current stable model on STDFDBK.

in_current_stable_model(?AtomHandle): true of handles of atoms true in
the current stable model (set by an invocation of a_stable_model/0.)

*/

:- compiler_options([cpp_on]).

#include "sig.h"
#include "flag_defs.h"
#include "standard.h"
#include "char_defs.h"

:- dynamic atomhandle/2.
:- local '_$smctr'/0.
:- local '_$smissm'/0.
:- dynamic atomtrie/1.

:- index(atomhandle(_,_),[1,2],1001).


init_smodels(Query,PrintFlag) :-
	(atomtrie(_)
         ->     close_smodels
         ;      true
        ),
	conset('_$smissm',0),
	conset('_$smctr',0),
	new_trie(AtomTrie),
	trie_intern(Query,AtomTrie,Leaf,Flag,_Skel),
	Flag =:= 0,   % first one better be new
	give_atom_handle(Handle,Leaf),
	num_resid(Query,Handle,AtomTrie,Rules,[]),
	conget('_$smctr',NumAtoms),
	assert(atomtrie(AtomTrie)),
	(PrintFlag == 1
         ->     file_nl(STDFDBK), file_write(STDFDBK,'Num Atoms: '), 
	        file_write(STDFDBK,NumAtoms), file_nl(STDFDBK),
	        write_rules(Rules)
	 ;      true
        ),
	send_pgm_to_smodels(Rules,NumAtoms),
	fail.   % fail in order to reclaim space.
init_smodels(_,_).   % init_smodels has only side-effects.

give_atom_handle(Handle,Leaf) :-
	coninc('_$smctr'), conget('_$smctr',Handle),
	assert(atomhandle(Handle,Leaf)).

num_resid(Query,QHandle,AtomTrie,Rules0,Rules) :-
	get_the_delay_lists(Query,DLs),
	num_resid_lists(DLs,QHandle,AtomTrie,Rules0,Rules).

num_resid_lists([],_,_,Rules,Rules).
num_resid_lists([DL|DLs],HHandle,AtomTrie,[[HHandle|NumDL]|Rules0],Rules) :-
	num_resid_list(DL,AtomTrie,NumDL,[],Rules0,Rules1),
	num_resid_lists(DLs,HHandle,AtomTrie,Rules1,Rules).

num_resid_list([],_,NumDL,NumDL,Rules,Rules).
num_resid_list([Lit|Lits],AtomTrie,[NumLit|NumDL0],NumDL,Rules0,Rules) :-
	(Lit = tnot(Rlit)
         ->     NumLit = tnot(Handle)
         ;      Rlit = Lit, NumLit = Handle
        ),
	trie_intern(Rlit,AtomTrie,Leaf,Flag,_),
	(Flag =:= 0   % new
         ->     give_atom_handle(Handle,Leaf),
		num_resid(Rlit,Handle,AtomTrie,Rules0,Rules1)
         ;      atomhandle(Handle,Leaf),
	        Rules1 = Rules0
	),
	num_resid_list(Lits,AtomTrie,NumDL0,NumDL,Rules1,Rules).

get_the_delay_lists(Query,DLs) :-
	excess_vars(Query,[],[],Vars),
	get_calls(Query,S,R),
	is_most_general_list(Vars),
	table_state(S,complete),
	!,
	get_returns(S,R,Leaf),
	get_delay_lists(Leaf,DLs).
get_the_delay_lists(Query, _) :-
	abort(('init_smodels: Query not completly evaluated: ',Query)).

get_delay_lists(A,B) :- get_delay_lists(A,B).  % inline

smodels_initted :-
	atomtrie(_AtomTrie)
         ->     true
         ;      warning('SModels not initialized by init_smodels'),
	        fail.

close_smodels :-
	(retract(atomtrie(OldTrie))
         ->     delete_trie(OldTrie),
                retractall(atomhandle(_Handle,_Leaf)),
		conset('_$smctr',0),
		conset('_$smissm',0),
		smodelsClose
         ;      true
        ).
	

atom_handle(Atom,Handle) :-
	smodels_initted,
	atomtrie(AtomTrie),
	(nonvar(Handle)
         ->     atomhandle(Handle,Leaf),
	        trie_interned(Atom1,AtomTrie,Leaf,_Skel),
		Atom = Atom1
	 ; var(Atom)   % if both vars, backtrack through all
	 ->     trie_interned(Atom,AtomTrie,Leaf,_Skel),
		atomhandle(Handle,Leaf)
	 ;      excess_vars(Atom,[],[],Vars),
	        trie_interned(Atom,AtomTrie,Leaf,Skel),
		is_most_general_term(Skel),
		is_most_general_list(Vars),
		atomhandle(Handle,Leaf)
	).

is_most_general_list(L) :- \+ \+ imgl(L).
imgl([]).
imgl([L|Ls]) :- var(L), L=[], imgl(Ls).

% How about neg?
in_all_stable_models(Handle,Neg) :-
	smodels_initted,
	conget('_$smctr',NumAtoms),
	(integer(Handle),Handle>0,Handle=<NumAtoms
         ->     true
         ;      abort(('in_all_stable_models: illegal atom number: ',Handle))
        ),
	(Neg == 0
         ->     smodelsSetNegCompute(Handle)
	 ;      smodelsSetPosCompute(Handle)
        ),
	smodelsExistsModel(Ret),
	!,
	close_smodels,
	Ret =:= 0.         

a_stable_model :-
	smodels_initted,
	repeat,
	smodelsExistsModel(Ret),
	(Ret =:= 0
         ->     !,
	        close_smodels,
	        fail
         ;      conset('_$smissm',1)
	).

have_sm :-
	conget('_$smissm',F),
	(F =\= 0
         ->     true
         ;      abort('smodels: no current stable model')
        ).

in_current_stable_model(Handle) :-
	smodels_initted,
	have_sm,
	conget('_$smctr',NumAtoms),
	(integer(Handle),Handle>0,Handle=<NumAtoms
         ->     true
         ;      abort(('in_current_stable_model: illegal atom number: ',Handle))
        ),
	smodelsCheckAtom(Handle,Ret),
	Ret =\= 0.
	
print_current_stable_model :-
	smodels_initted,
	have_sm,
	conset('_$smprflg',0),
	conget('_$smctr',NumAtoms),
	file_write(STDFDBK,'{'),
	for(Hand,1,NumAtoms),
	smodelsCheckAtom(Hand,Ret),
	Ret =\= 0,
	(conget('_$smprflg',1)
         ->     file_write(STDFDBK,'; ')
         ;      conset('_$smprflg',1)
        ),
	atom_handle(Atom,Hand),
	file_write(STDFDBK,Atom),
	fail.
print_current_stable_model :-
	file_write(STDFDBK,'}').


write_rules([]).
write_rules([[Head|Body]|Rules]) :-
	atom_handle(HAtom,Head),
	file_write(STDFDBK,HAtom),
	(Body == []
         ->     true
	 ;      file_write(STDFDBK,' <- '),
	        write_body(Body)
	),
	file_write(STDFDBK,'.'),
	file_nl(STDFDBK),
	write_rules(Rules).

write_body([tnot(Handle)]) :- !,
	atom_handle(Atom,Handle),
	file_write(STDFDBK,tnot(Atom)).
write_body([Handle]) :- !,
	atom_handle(Atom,Handle),
	file_write(STDFDBK,Atom).
write_body([tnot(Handle)|Rest]) :- !,
	atom_handle(Atom,Handle),
	file_write(STDFDBK,tnot(Atom)),
	file_write(STDFDBK,', '),
	write_body(Rest).
write_body([Handle|Rest]) :- !,
	atom_handle(Atom,Handle),
	file_write(STDFDBK,Atom),
	file_write(STDFDBK,', '),
	write_body(Rest).

for(L,L,H) :- L =< H.
for(I,L,H) :- L < H, L1 is L+1, for(I,L1,H).

send_pgm_to_smodels(Rules,NumAtoms) :-
	smodelsInit,
	smodelsNumAtoms(NumAtoms),
	send_rules(Rules),
	smodelsCommitRules.

send_rules([]).
send_rules([[Head|Body]|Rules]) :-
	smodelsBeginBasicRule,
	smodelsAddHead(Head),
        send_body(Body),
	smodelsEndRule,
	send_rules(Rules).

send_body([]).
send_body([tnot(Handle)|Rest]) :- !,
	smodelsAddNegBody(Handle),
	send_body(Rest).
send_body([Handle|Rest]) :- 
	smodelsAddPosBody(Handle),
	send_body(Rest).

/*
:- op(1050,xfx,(<-)).
%% for testing
get_delay_lists(Query,DLs) :-
	findall(Body,(Query<-Body),DLs).

a <- [b,c,tnot(d)].
b <- [a,tnot(b),c].
b <- [tnot(d),a].
c <- [tnot(a),tnot(b)].
d <- [d,c,tnot(c)].
*/
