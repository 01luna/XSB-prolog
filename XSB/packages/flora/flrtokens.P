/* File:      flrtokens.P  -- The Flora tokenizer
**
** Author(s): Guizhen Yang       (Flora)
**    	      Bertram Ludaescher (Flip, the Flora precursor)
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) Bertram Ludaescher, 1998
** Copyright (C) The Research Foundation of SUNY, 1999
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: flrtokens.P,v 1.10 1999-09-06 17:32:33 kifer Exp $
**
*/

:- compiler_options([xpp_on]).
#include "char_defs.h"


/****************************************************************************
  read_tokens(-TokenList,-Status)
  scans the input characters, constructs the list of tokens for a rule and
  returns it as the first argument. The second argument denotes the status
  of tokenizer (eof, not_eof, error(message)).
****************************************************************************/
read_tokens(TokenList,Status) :-
	get0(C),
	read_tokens(C,TokenList,Status).


read_tokens(Char,TokenList,Status) :-
	( whitespace(Char) ->
	    TokenList=[atom(white_space)|Tokens],
	    read_whitespace(Tokens,Status)

	  ; Char >= CH_a, Char =< CH_z ->
	    read_identifier(Char,TokenList,Status)

	  ; Char >= CH_A, Char =< CH_Z ->
	    read_variable(Char,TokenList,Status)

	  ; Char == CH_UNDERSCORE ->
	    read_variable(Char,TokenList,Status)

	  ; Char >= CH_0, Char =< CH_9 ->
	    read_number(Char,TokenList,Status)

	  ; Char == -1 ->
	    TokenList=[],
	    Status=[eof]

	  ; Char < CH_SPACE ->
	    TokenList=[],
	    Status=[not_eof,error('unexpected unprintable character')]

	  ; Char >= CH_DELETE ->
	    TokenList=[],
	    Status=[not_eof,error('unexpected DEL or ISO character')]

	  ;
	    read_special(Char,TokenList,Status)
	).


/****************************************************************************
  read_whitespace(-Tokens,-Status)
  scans the input characters  until a non-whitespace char.
****************************************************************************/
read_whitespace(Tokens,Status) :-
	repeat,
	get0(Char),
	not whitespace(Char),
	!,
	read_tokens(Char,Tokens,Status).

whitespace(CH_TAB).
whitespace(CH_NEWLINE).
whitespace(CH_RETURN).
whitespace(CH_SPACE).


/****************************************************************************
  read_identifier(+Char,-TokenList,-Status)
  reads an atom which begins with a lower case letter Char and continues
  with letters, digits, and underscores.
****************************************************************************/
read_identifier(Char,[identifier(Name)|Tokens],Status) :-
	read_name(Char,Chars,NextCh),
	atom_codes(Name,Chars),
	read_tokens(NextCh,Tokens,Status).


/****************************************************************************
  read_name(+Ch,-Chars,-LastCh)
  reads a sequence of letters, digits, and underscores, where the previous
  character read was Ch and it is known that Ch is to be included in the
  result. The desired characters are returned as the list Chars, and the
  next character read as LastCh.
****************************************************************************/
read_name(Ch,[Ch|Chars],LastCh) :-
	get0(C),
	( C >= CH_a, C =< CH_z ->
	    read_name(C,Chars,LastCh)

	  ; C >=CH_A, C =< CH_Z ->
	    read_name(C,Chars,LastCh)

	  ; C >=CH_0, C =< CH_9 ->
	    read_name(C,Chars,LastCh)

	  ; C == CH_UNDERSCORE ->
	    read_name(C,Chars,LastCh)

	  ;
	    Chars=[],
	    LastCh=C
	).


/****************************************************************************
  read_variable(+Char,-TokenList,-Status)
  Char is the first character of a variable name (NOT IS a variable name,
  as in XSB).
****************************************************************************/
read_variable(Char,[var(Name)|Tokens],Status) :-
	read_name(Char,Chars,NextCh),
	atom_codes(Name,Chars),
	read_tokens(NextCh,Tokens,Status).


/****************************************************************************
  Types of comments supported:
  (1) from % or // until a LF character (10) or EOF;
  (2) from / * until * /.
****************************************************************************/
read_special(CH_SLASH,Tokens,Status) :-
	!,
	get0(Ch),
	( Ch == CH_SLASH ->
	    read_comment_line(Tokens,Status)

	  ; Ch == CH_STAR ->
	    read_comment_block(Tokens,Status)

	  ;
	    Tokens=[atom('$/')|Ts],
	    read_tokens(Ch,Ts,Status)
	).

read_comment_line(Tokens,Status) :-
	repeat,
	get0(Ch),
	( Ch == 10 ->
	    get0(NextCh)

	  ; Ch == -1 ->
	    NextCh=Ch

	  ;
	    fail
	),
	!,
	read_tokens(NextCh,Tokens,Status).

read_comment_block(Tokens,Status) :-
	repeat,
	get0(C1),
	( C1 == CH_STAR ->
	    get0(C2),
	    ( C2 == CH_SLASH ->
		get0(C3),
		read_tokens(C3,Tokens,Status)

	      ;
		fail
	    )

	  ; C1 == -1 ->
	    Tokens=[],
	    Status=[eof,error('unexpected end of file in comment')]

	  ;
	    fail
	),
	!.

read_special(CH_PERCENT,Tokens,Status) :-
	!,
	read_comment_line(Tokens,Status).

read_special(CH_LPAREN,[atom('$(')|Tokens],Status) :-
	!,
	get0(NextCh),
	read_tokens(NextCh,Tokens,Status).

read_special(CH_RPAREN,[atom('$)')|Tokens],Status) :-
	!,
	get0(NextCh),
	read_tokens(NextCh,Tokens,Status).

read_special(CH_LBRACKET,[atom('$[')|Tokens],Status) :-
	!,
	get0(NextCh),
	read_tokens(NextCh,Tokens,Status).

read_special(CH_RBRACKET,[atom('$]')|Tokens],Status) :-
	!,
	get0(NextCh),
	read_tokens(NextCh,Tokens,Status).

read_special(CH_LBRACE,[atom('${')|Tokens],Status) :-
	!,
	get0(NextCh),
	read_tokens(NextCh,Tokens,Status).

read_special(CH_RBRACE,[atom('$}')|Tokens],Status) :-
	!,
	get0(NextCh),
	read_tokens(NextCh,Tokens,Status).

read_special(CH_PLUS,[atom('$+')|Tokens],Status) :-
	!,
	get0(NextCh),
	read_tokens(NextCh,Tokens,Status).

read_special(CH_MINUS,[atom('$-')|Tokens],Status) :-
	!,
	get0(NextCh),
	read_tokens(NextCh,Tokens,Status).

read_special(CH_DOT,Tokens,Status) :-
	!,
	get0(NextCh),
	read_fullstop(NextCh,Tokens,Status).

read_special(CH_COMMA,[atom('$,')|Tokens],Status) :-
	!,
	get0(NextCh),
	read_tokens(NextCh,Tokens,Status).

read_special(CH_SEMICOL,[atom('$;')|Tokens],Status) :-
	!,
	get0(NextCh),				
	read_tokens(NextCh,Tokens,Status).	

read_special(CH_DOUBLEQUOTE,[string_list(Chars)|Tokens],Status) :-
	!,
	get0(Ch),
	read_string(Ch,CH_DOUBLEQUOTE,Chars,Tokens,Status).

read_special(CH_QUOTE,[string_atom(Name)|Tokens],Status) :-
	!,
	get0(Ch),
	read_string(Ch,CH_QUOTE,Chars,Tokens,Status),
	atom_codes(Name,Chars).

read_special(Ch,Tokens,Status) :-
	( symbol_char(Ch) ->
	    read_symbol(Ch,Chars,NextCh),
	    append("$",Chars,L),
	    atom_codes(T,L),
	    Tokens=[atom(T)|Ts],
	    read_tokens(NextCh,Ts,Status)

	  ;
	    Tokens=[],
	    Status=[not_eof,error('expected character')]
	).

/****************************************************************************
  read_symbol(+Ch,-Chars,-NextCh)
  reads and returns a list of symbol characters. Any continuous sequence of
  symbol characters will be read as a token. It will be decided later by the
  parser whether the use of it is appropriate. Ch is known as a symbol char.
****************************************************************************/
read_symbol(Ch,[Ch|Chars],NextCh) :-
	get0(C1),
	( symbol_char(C1) ->
	    read_symbol(C1,Chars,NextCh)

	  ;
	    Chars=[],
	    NextCh=C1
	).

symbol_char(CH_STAR).
symbol_char(CH_COLON).
symbol_char(CH_LESS).
symbol_char(CH_EQUAL).
symbol_char(CH_GREATER).
symbol_char(CH_QUESTION).
symbol_char(CH_AT).
symbol_char(CH_BACKSLASH).
symbol_char(CH_TILDE).
symbol_char(CH_EXCLAMATION).
symbol_char(CH_AMPERSAND).
symbol_char(CH_BAR).

/****************************************************************************
  read_string(+Ch,+Quote,-Chars,-Tokens,-Status)
  Formats supported:
  (1) \ followed by x (X) and 1-2 hex symbols;
  (2) \ followed by escape character;
  (3) anything else recognized as it is;
  (4) double quotes equal to single quote.
****************************************************************************/
read_string(CH_BACKSLASH,Quote,Chars,Tokens,Status) :-
	!,
	get0(C1),
	( C1 == -1 ->
	    Chars=[CH_BACKSLASH],
	    Tokens=[],
	    Status=[eof,error('unexpected end of file in string')]

	  ; C1 \/ 32 =:= CH_x ->
	    get0(C2),
	    ( hex_symbol(C2,V2) ->
		get0(C3),
		( hex_symbol(C3,V3) ->
		    V is V2*16+V3,
		    get0(C4)

		  ;
		    V=V2,
		    C4=C3
	        ),
		Chars=[V|Chs],
		read_string(C4,Quote,Chs,Tokens,Status)

	      ;
		Chars=[CH_BACKSLASH,C1],
		Tokens=[],
		( C2 == -1 ->
		    Status=[eof,error('unexpected end of file')]

		  ;
		    Status=[not_eof,error('hex symbol expected in string')]
		)
	    )

	  ; 
	    (escape_char(C1,V) -> Chars=[V|Chs] ; Chars=[CH_BACKSLASH,C1|Chs]),
	    get0(C2),
	    read_string(C2,Quote,Chs,Tokens,Status)
	).

read_string(Quote,Quote,Chars,Tokens,Status) :-
	!,
	get0(C1),
	( C1 == Quote ->
	    Chars=[Quote|Chs],
	    get0(C2),
	    read_string(C2,Quote,Chs,Tokens,Status)

	  ;
	    Chars=[],
	    read_tokens(C1,Tokens,Status)
	).

read_string(-1,_,[],[],[eof,error('unexpected end of file')]) :-
	!.

read_string(Ch,Quote,[Ch|Chars],Tokens,Status) :-
	get0(C1),
	read_string(C1,Quote,Chars,Tokens,Status).

hex_symbol(Ch,Value) :-
	( Ch >= CH_0, Ch =< CH_9 ->
	    Value is Ch-CH_0

	  ; Ch >= CH_a, Ch =< CH_f ->
	    Value is Ch-CH_a+10

	  ; Ch >= CH_A, Ch =< CH_F ->
	    Value is Ch-CH_A+10
	).


/****************************************************************************
  This table is for ASCII.
****************************************************************************/
escape_char(CH_BACKSLASH, CH_BACKSLASH).
%%% escape_char(CH_n, CH_NEWLINE).		% \n = NewLine
%%% escape_char(CH_N, CH_NEWLINE).		% \N = NewLine
escape_char(CH_t,  CH_TAB).		% \t = Tab
escape_char(CH_T,  CH_TAB).		% \T = Tab
escape_char(CH_r, CH_RETURN).		% \r = Return
escape_char(CH_R, CH_RETURN).		% \R = Return
escape_char(CH_v, CH_VERTAB).		% \v = Vertical tab
escape_char(CH_V, CH_VERTAB).		% \V = Vertical tab
escape_char(CH_b,  CH_BACKSPACE).		% \b = Backspace
escape_char(CH_B,  CH_BACKSPACE).		% \B = Backspace
escape_char(CH_f, CH_FORMFEED).		% \f = FormFeed
escape_char(CH_F, CH_FORMFEED).		% \F = FormFeed
escape_char(CH_e, CH_ESC).		% \e = Escape
escape_char(CH_E, CH_ESC).		% \E = Escape
escape_char(CH_d, CH_DELETE).		% \d = Delete
escape_char(CH_D, CH_DELETE).		% \D = Delete
escape_char(CH_s, CH_SPACE).		% \s = visible Space
escape_char(CH_S, CH_SPACE).		% \S = visible Space


/****************************************************************************
  read_fullstop(+Ch,-TokenList,-Status)
  processes the character immediately read after a dot.
****************************************************************************/
read_fullstop(Ch,TokenList,Status) :-
	( whitespace(Ch) ->
	    TokenList=[atom(rule_delimeter)],
	    Status=[not_eof]

	  ; Ch == -1 ->
	    TokenList=[atom(rule_delimeter)],
	    Status=[eof]

	  ; Ch == CH_DOT ->
	    TokenList=[atom('$..')|Tokens],
	    get0(C1),
	    read_tokens(C1,Tokens,Status)

	  ;
	    TokenList=[atom('$.')|Tokens],
	    read_tokens(Ch,Tokens,Status)
	).


/****************************************************************************
  read_number(+Char,-Tokens,-Status)
  Char is already known to be a digit.
****************************************************************************/
read_number(Char,TokenList,Status) :-
	read_digits(Char,IntList,NextCh),
	number_codes(N,IntList),
	( NextCh == CH_QUOTE ->
	    ( N >= 2, N =< 36 ->
		get0(C1),
		( symbol_value(N,C1,_) ->
		    read_based(C1,C2,N,0,Number),
		    TokenList=[num(Number)|Tokens],
		    read_tokens(C2,Tokens,Status)

		  ;
		    TokenList=[num(N)],
		    ( C1 == -1 ->
			Status=[eof,error('unexpected end of file')]

		      ;
			Status=[not_of,error('invalid symbol in number')]
		    )
		)

	      ; N == 0 ->
		get0(C1),
		( C1 == -1 ->
		    TokenList=[num(0)],
		    Status=[eof,error('unexpected end of file in integer')]

		  ;
		    TokenList=[num(C1)|Tokens],
		    get0(C2),
		    read_tokens(C2,Tokens,Status)
		)

	      ;
		TokenList=[num(N)],
		Status=[not_eof,error('invalid radix')]
	    )

	  ; NextCh == CH_DOT ->
	    get0(C1),
	    ( C1 >= CH_0, C1 =< CH_9 ->
		read_float(C1,IntList,TokenList,Status)

	      ; 
		TokenList=[num(N)|Tokens],
		read_fullstop(C1,Tokens,Status)
	    )

	  ;
	    TokenList=[num(N)|Tokens],
	    read_tokens(NextCh,Tokens,Status)
	).


/****************************************************************************
  read_digits(+Ch,-Chars,-NextCh)
  returns in Chars a list of digits.
****************************************************************************/
read_digits(Ch,Chars,NextCh) :-
	(   Ch >= CH_0, Ch =< CH_9
	->  Chars=[Ch|Rest],
	    get0(C1),
	    read_digits(C1,Rest,NextCh)
	;   Ch == CH_UNDERSCORE
	->  get0(C1),
	    read_digits(C1,Chars,NextCh)
	;   NextCh=Ch,
	    Chars=[]
	).


/****************************************************************************
  read_based(+Ch,-NextCh,+Base,+N0,-N)
  reads an integer in base Base. The base has been read as Base.
****************************************************************************/
read_based(Ch,NextCh,Base,N0,N) :-
	(   symbol_value(Base,Ch,Digit)
	->  N1 is N0*Base+Digit,
	    get0(C1),
	    read_based(C1,NextCh,Base,N1,N)
	;   Ch == CH_UNDERSCORE
	->  get0(C1),
	    read_based(C1,NextCh,Base,N0,N)
	;   N=N0,
	    NextCh=Ch
	).


/****************************************************************************
  symbol_value(+Base,+Char,-Digit)
  checks whether Char denotes a valid symbol in base Base and returns the
  value in Digit.
****************************************************************************/
symbol_value(Base,Char,Digit) :-
	( Char >= CH_0, Char =< CH_9 ->
	    Digit is Char-CH_0

	  ; Char >= CH_A, Char =< CH_Z ->
	    Digit is Char-CH_A+10

	  ; Char >= CH_a, Char =< CH_z ->
	    Digit is Char-CH_a+10

	  ;
	    Digit=99
	),
	Digit<Base.


/****************************************************************************
  read_float(+Char,+Integer,Tokens,Status)
  is called when we have parsed <digit>+ '. <digit>. Integer is the list of
  digits preceding the decimal point, and Char is the first digit after the
  decimal point.
****************************************************************************/
read_float(Char,Integer,[num(Number)|Tokens],Status) :-
	read_digits(Char,Fraction,C1),
	append(Integer,[CH_DOT|Fraction],L1),
	(   C1 \/ 32 =:= CH_e
	->  get0(C2),
	    (	C2 =\= CH_MINUS, C2 =\= CH_PLUS
	    ->	Sign=[],
		C3=C2
	    ;	Sign=[C2],
		get0(C3)
	    ),
	    append(L1,[C1|Sign],L2),
	    (	C3 >= CH_0, C3 =< CH_9
	    ->	read_digits(C3,Exponent,NextCh),
		append(L2,Exponent,L3),
		number_codes(Number,L3),
		read_tokens(NextCh,Tokens,Status)
	    ;	atom_codes(Number,L2),
		( C3 == -1
		->  Status=[eof,error('unexpected end of file')]
		;   Status=[not_eof,error('syntax error in exponent')]
		),
		Tokens=[]
	    )
	;   number_codes(Number,L1),
	    read_tokens(C1,Tokens,Status)
	).

