/* File:      flrshell.P  -- The Flora interactive shell
**
** Author(s): Guizhen Yang       (Flora)
**    	      Bertram Ludaescher (Flip, the Flora spiritual father)
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) Bertram Ludaescher, 1998
** Copyright (C) The Research Foundation of SUNY, 1999
**
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: flrshell.P,v 1.34 1999-10-22 04:26:39 kifer Exp $
**
*/


:- compiler_options([xpp_on]).
#include "standard.h"

#mode save
#mode nostring "\!#'"
#define STD_FPREFIX(X)    '_$_$_flora_''X'
#define DYN_FPREFIX(X)    'dyn_$_$_flora_''X'
#mode restore


/*********************************************************************/
STD_FPREFIX(shell) :-
	bootstrap_flora,
	STD_FPREFIX(welcome_msg),
	all,
	push_abort_cutpoint,
	conset(flora_shell_loaded, 1),
	STD_FPREFIX(shell_loop).


/*********************************************************************/
STD_FPREFIX(welcome_msg) :-
	package_configuration(version(flora),V),
	flora_display_msg("\nFLORA Version %S\n", arg(V)),
	flora_display_msg('Type `help.'' to show the help message'),
	flora_display_msg('Type `rundemo(demoName).'' to run demos in XSB/packages/flora/demos/'),
	!.


/*********************************************************************/
STD_FPREFIX(shell_loop) :-
	repeat,
	STD_FPREFIX(write_shell_prompt),
	flora_read_parse_compile(static_mode,
					[atom('$?'),atom('$-')],
					Tokens,
					Rules,
					Status,
					Opts),
	( member(noop,Status) ->
	    file_nl(STDMSG), S=Status

	  ; member(error(_),Status) ->
	    ( (member(eof,Status); member(atom(rule_delimeter),Tokens)) ->
		S=Status
	      ;
	        flora_discard_tokens(S)
	    )

	  ;
	    S=Status,
	    (Opts=[] -> true; STD_FPREFIX(check_library)(Opts)),
	    Rules=[query(Gs,NVs)],
	    STD_FPREFIX(print_answers)(Gs,NVs)
	),
	STD_FPREFIX(loop_guard)(S).

STD_FPREFIX(write_shell_prompt) :-
	pop_abort_cutpoint,
	push_abort_cutpoint,
	seen,
	see(userin),
	told,
	tell(userout),
	file_nl(STDFDBK), file_write(STDFDBK, 'flora ?- ').

STD_FPREFIX(loop_guard)(S) :- (member(eof,S) -> end ; fail).


/*********************************************************************/
STD_FPREFIX(check_library)(Opts) :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	( member(flrassert,Opts)
	->  (	current_predicate(STD_FPREFIX(assert)/1)
	    ->	true
	    ;	fmt_write_string(Assert,
				 '%s%ssyslib%sflrassert.P',f(FloraDir,S,S)),
		consult(Assert)
	    )
	;   true
	),
	( member(flraggregate,Opts)
	->  ( current_predicate(STD_FPREFIX(min)/3)
	    ->	true
	    ;	fmt_write_string(Aggr,
				 '%s%ssyslib%sflraggregate.P',f(FloraDir,S,S)),
		consult(Aggr)
	    )
	;   true
	),
	(   member(skolem,Opts)
	->  STD_FPREFIX(warning_nl)('skolemization may require equality checking')
	;   true
	).


/*********************************************************************/
STD_FPREFIX(print_answers)(Gs,NVs) :-
	( STD_FPREFIX(switch)(all)
	->  STD_FPREFIX(print_all)(Gs,NVs)
	;   STD_FPREFIX(print_one)(Gs,NVs)
	).


/*********************************************************************/
help :-
	flora_display_msg("\nFLORA commands:\n"),
	flora_display_msg('  help                         : show this info'),
	flora_display_msg('  compile(FILE[.P])            : compile FILE.P; create FILE.O'),
	flora_display_msg('  flcompile(FILE.[flr])        : compile FILE.flr; create FILE.P and FILE.O'),
	flora_display_msg('  flcompile(FILE.[flr],[...])  : flcompile(FILE) with options [...]'),
	flora_display_msg('  flconsult(FILE.[flr])        : compile FILE.flr; consult FILE.P'),
	flora_display_msg('  flconsult(FILE.[flr],[...])  : flconsult(FILE) with options [...]'),
	flora_display_msg('  flload(FILE[.{P|O|flr}])     : consult FILE.flr, FILE.P or FILE.O'),
	flora_display_msg('  [FILE[.{P|O|flr}],...]       : consult a list of .flr, .P, or .O files'),
	flora_display_msg('  dyncompile(FILE[.flr])       : compile FILE.flr to dynamic code'),
	flora_display_msg('  dyncompile(FILE[.flr],[...]) : dyncompile(FILE) with options [...]'),
	flora_display_msg('  dynconsult(FILE[.flr])       : dyncompile FILE.flr; dynamically load FILE.P'),
	flora_display_msg('  dynconsult(FILE[.flr],[...]) : dynconsult(FILE) with options [...]'),
	flora_display_msg('  dynload(FILE[.flr])          : dynamically load FILE.flr or FILE.P'),
	flora_display_msg('  <FILE[.EXT],...>             : dynload a list of .flr or .P files'),
	flora_display_msg('  rundemo(FILE[.flr])          : flconsult a demo from FLORA demos directory'),
	flora_display_msg('  rundemo(FILE[.flr],[...])    : rundemo(FILE) with options [...]'),
	flora_display_msg('  abolish_all_tables           : flush all tabled data'),
	flora_display_msg('  all                          : show all solutions (default)'),
	flora_display_msg('  one                          : show solutions one by one'),
	flora_display_msg('  maxerr(all/N)                : set/show the error reporting threshold'),
	flora_display_msg('  end                          : Ciao to FLORA'),
	flora_display_msg('  halt                         : Ciao both to FLORA and XSB').



/*********************************************************************/
rundemo(X,Dtvs) :-
	flora_check_filename(X),
	package_configuration(dir(flora),FloraDir),
	slash(Slash),
	%% Add the demo directory to library_directory
	fmt_write_string(DemoDir, '%s%sdemos', f(FloraDir, Slash)),
	(library_directory(DemoDir)
	       -> true
		; assert(library_directory(DemoDir))
	),
	flconsult(X,Dtvs),
	retract(library_directory(DemoDir)).

rundemo(X) :-
	flora_check_filename(X),
	package_configuration(dir(flora),FloraDir),
	slash(Slash),
	%% Add the demo directory to library_directory
	fmt_write_string(DemoDir, '%s%sdemos', f(FloraDir, Slash)),
	(library_directory(DemoDir)
	       -> true
		; assert(library_directory(DemoDir))
	),
	flconsult(X),
	retract(library_directory(DemoDir)).


/*********************************************************************/
all :-
	(   STD_FPREFIX(switch)(all)
	->  true
	;   trie_assert(STD_FPREFIX(switch)(all))
	).

one :-
	trie_retract_all(STD_FPREFIX(switch)(all)).


%% Turn off printing CPU time and host information
%% These are used in the test suite in order to eliminate 
%% time/host dependent output. 
chatterbox(off) :- trie_assert(STD_FPREFIX(switch)(no_chatter)).
chatterbox(on)  :- trie_retract_all(STD_FPREFIX(switch)(no_chatter)).


/*********************************************************************/

flora_trace :-   (STD_FPREFIX(debugger_data_loaded) 
		  -> true
		  ;  [flrdebugger]
		 ),
    	    	 STD_FPREFIX(trace).
flora_notrace :- (STD_FPREFIX(debugger_data_loaded) 
		  -> true
		  ;  [flrdebugger]
		 ),
    	    	 STD_FPREFIX(notrace).

/*********************************************************************/
end :-
	unload_package(flora),
	conset(flora_shell_loaded,0),
	file_nl(STDMSG), flora_display_msg('Ciao!'),
	pop_abort_cutpoint,
	abort.


/*********************************************************************/
%% Take all *,flr files in ./flora/demos/ and flora-compile them.
%% This relies on the availability of Posix wildcard matcher.
%% It is used only for configuring the demos.
flcompile_all_demos  :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	fmt_write_string(DemoDir,'%s%sdemos',f(FloraDir,S)),
        glob_directory('*.flr', DemoDir, _, DemoList),
	(library_directory(DemoDir) -> true
	    ;
	    assert(library_directory(DemoDir))
	),
	flcompile_demo(DemoList),
	retract(library_directory(DemoDir)).

flcompile_demo([D|Rest]) :- 
	flora_flcompile(static_mode,[],D,noforce,Fname),
	%% strip the suffix (which is .O here)
	search_module(Fname, _,_,_, Base,_),
	compile(Base,[optimize,spec_repr]),
	flcompile_demo(Rest).
flcompile_demo([]).



/********************************************************************/
:- table DYN_FPREFIX(fd)/3.
:- table DYN_FPREFIX(mvd)/3.
:- table DYN_FPREFIX(ifd)/3.
:- table DYN_FPREFIX(imvd)/3.
:- table DYN_FPREFIX(isa)/2.
:- table DYN_FPREFIX(sub)/2.
:- table DYN_FPREFIX(fs)/3.
:- table DYN_FPREFIX(mvs)/3.
:- table DYN_FPREFIX(mvd)/2.
:- table DYN_FPREFIX(imvd)/2.
:- table DYN_FPREFIX(exists)/1.
:- table DYN_FPREFIX(fd_rhs)/3.
:- table DYN_FPREFIX(mvd_rhs)/3.
:- table DYN_FPREFIX(ifd_rhs)/3.
:- table DYN_FPREFIX(imvd_rhs)/3.
:- table DYN_FPREFIX(isa_rhs)/2.
:- table DYN_FPREFIX(sub_rhs)/2.
:- table DYN_FPREFIX(fs_rhs)/3.
:- table DYN_FPREFIX(mvs_rhs)/3.
:- table DYN_FPREFIX(mvd_rhs)/2.
:- table DYN_FPREFIX(imvd_rhs)/2.


:- dynamic DYN_FPREFIX(fd)/3.
:- dynamic DYN_FPREFIX(mvd)/3.
:- dynamic DYN_FPREFIX(ifd)/3.
:- dynamic DYN_FPREFIX(imvd)/3.
:- dynamic DYN_FPREFIX(isa)/2.
:- dynamic DYN_FPREFIX(sub)/2.
:- dynamic DYN_FPREFIX(fs)/3.
:- dynamic DYN_FPREFIX(mvs)/3.
:- dynamic DYN_FPREFIX(mvs)/2.
:- dynamic DYN_FPREFIX(mvd)/2.
:- dynamic DYN_FPREFIX(imvd)/2.
:- dynamic DYN_FPREFIX(exists)/1.
:- dynamic DYN_FPREFIX(fd_rhs)/3.
:- dynamic DYN_FPREFIX(mvd_rhs)/3.
:- dynamic DYN_FPREFIX(ifd_rhs)/3.
:- dynamic DYN_FPREFIX(imvd_rhs)/3.
:- dynamic DYN_FPREFIX(isa_rhs)/2.
:- dynamic DYN_FPREFIX(sub_rhs)/2.
:- dynamic DYN_FPREFIX(fs_rhs)/3.
:- dynamic DYN_FPREFIX(mvs_rhs)/3.
:- dynamic DYN_FPREFIX(mvd_rhs)/2.
:- dynamic DYN_FPREFIX(imvd_rhs)/2.


STD_FPREFIX(fd)(O,M,R)       :- DYN_FPREFIX(fd)(O,M,R).
STD_FPREFIX(mvd)(O,M,R)      :- DYN_FPREFIX(mvd)(O,M,R).
STD_FPREFIX(ifd)(O,M,R)      :- DYN_FPREFIX(ifd)(O,M,R).
STD_FPREFIX(imvd)(O,M,R)     :- DYN_FPREFIX(imvd)(O,M,R).
STD_FPREFIX(isa)(O1,O2)      :- DYN_FPREFIX(isa)(O1,O2).
STD_FPREFIX(sub)(O1,O2)      :- DYN_FPREFIX(sub)(O1,O2).
STD_FPREFIX(fs)(O,M,R)       :- DYN_FPREFIX(fs)(O,M,R).
STD_FPREFIX(mvs)(O,M,R)      :- DYN_FPREFIX(mvs)(O,M,R).
STD_FPREFIX(mvd)(O1,O2)      :- DYN_FPREFIX(mvd)(O1,O2).
STD_FPREFIX(imvd)(O1,O2)     :- DYN_FPREFIX(imvd)(O1,O2).
STD_FPREFIX(exists)(O)       :- DYN_FPREFIX(exists)(O).


/*****************************************************************************
  closure rules for X::Y
*****************************************************************************/
:- table STD_FPREFIX(subclass)/2.
:- table STD_FPREFIX(strict_subclass)/2.

STD_FPREFIX(subclass)(X,X) :- STD_FPREFIX(exists)(X).
STD_FPREFIX(subclass)(X,Y) :- STD_FPREFIX(strict_subclass)(X,Y).

%% Using flora_subclass can be a major source of inefficiency
%% In most cases, we want to use STD_FPREFIX(strict_subclass) 
%% We table strict_sub to avoid repetition
:- table STD_FPREFIX(strict_sub)/2.
STD_FPREFIX(strict_sub)(X,Y) :- 
	ground(X), ground(Y), !,
	X \= Y, STD_FPREFIX(sub)(X,Y).
STD_FPREFIX(strict_sub)(X,Y) :- STD_FPREFIX(sub)(X,Y), X \= Y.
STD_FPREFIX(strict_subclass)(X,Y) :- STD_FPREFIX(strict_sub)(X,Y).

STD_FPREFIX(strict_subclass)(X,Y) :-
	STD_FPREFIX(strict_subclass)(X,Z), 
	STD_FPREFIX(strict_sub)(Z,Y),
	(   X = Y 
	->  STD_FPREFIX(warning_nl)('cyclic subclass hierarchy: %S::%S::%S',
				    args(X,Z,Y))
	;   true
	).


/*****************************************************************************
  closure rules for X:Y, X::Z implies X:Z
*****************************************************************************/
:- table STD_FPREFIX(isa)/2.

STD_FPREFIX(isa)(O,C) :-
	STD_FPREFIX(strict_subclass)(C1,C),
	STD_FPREFIX(isa)(O,C1).


/*****************************************************************************
  rules for monotonic inheritance of signatures
*****************************************************************************/
:- table STD_FPREFIX(fs)/3.
:- table STD_FPREFIX(mvs)/3.
:- table STD_FPREFIX(ifs)/3.
:- table STD_FPREFIX(imvs)/3.

STD_FPREFIX(fs)(O,MethodArgs,R) :-
	STD_FPREFIX(isa)(O,Class),
	STD_FPREFIX(fs)(Class,MethodArgs,R).
STD_FPREFIX(ifs)(O,MethodArgs,R) :-
	STD_FPREFIX(isa)(O,Class),
	STD_FPREFIX(ifs)(Class,MethodArgs,R).

STD_FPREFIX(mvs)(O,MethodArgs,R) :-
	STD_FPREFIX(isa)(O,Class),
	STD_FPREFIX(mvs)(Class,MethodArgs,R).
STD_FPREFIX(imvs)(O,MethodArgs,R) :-
	STD_FPREFIX(isa)(O,Class),
	STD_FPREFIX(imvs)(Class,MethodArgs,R).

STD_FPREFIX(fs)(Sub,MethodArgs,R) :-
	STD_FPREFIX(strict_subclass)(Sub,Class),
	STD_FPREFIX(fs)(Class,MethodArgs,R).
STD_FPREFIX(ifs)(Sub,MethodArgs,R) :-
	STD_FPREFIX(strict_subclass)(Sub,Class),
	STD_FPREFIX(ifs)(Class,MethodArgs,R).

STD_FPREFIX(mvs)(Sub,MethodArgs,R) :-
	STD_FPREFIX(strict_subclass)(Sub,Class),
	STD_FPREFIX(mvs)(Class,MethodArgs,R).
STD_FPREFIX(imvs)(Sub,MethodArgs,R) :-
	STD_FPREFIX(strict_subclass)(Sub,Class),
	STD_FPREFIX(imvs)(Class,MethodArgs,R).


/*****************************************************************************
  rules for nonmonotonic inheritance of behavior
*****************************************************************************/

:- table STD_FPREFIX(fd)/3.
:- table STD_FPREFIX(mvd)/3.
:- table STD_FPREFIX(ifd)/3.
:- table STD_FPREFIX(imvd)/3.
:- table STD_FPREFIX(defined_fd)/2.
:- table STD_FPREFIX(defined_mvd)/2.
:- table STD_FPREFIX(defined_ifd)/2.
:- table STD_FPREFIX(defined_imvd)/2.
:- table STD_FPREFIX(overwritten_fd)/3.
:- table STD_FPREFIX(overwritten_mvd)/3.
:- table STD_FPREFIX(overwritten_ifd)/3.
:- table STD_FPREFIX(overwritten_imvd)/3.
:- table STD_FPREFIX(conflict_fd)/3.
:- table STD_FPREFIX(conflict_ifd)/3.
:- table STD_FPREFIX(conflict_mvd)/3.
:- table STD_FPREFIX(conflict_imvd)/3.

STD_FPREFIX(fd)(Object,Method,Value) :-
	%% If Object,Method are ground, check if Object[Method->...]
	%% is defined right away --an optimization
	(ground(Object), ground(Method) ->
	    tnot(STD_FPREFIX(defined_fd)(Object,Method)),
	    STD_FPREFIX(isa)(Object,Class),
	    STD_FPREFIX(ifd)(Class,Method,Value)
	  ;
	    STD_FPREFIX(isa)(Object,Class),
	    STD_FPREFIX(ifd)(Class,Method,Value),
	    tnot(STD_FPREFIX(defined_fd)(Object,Method))
	),
	tnot(STD_FPREFIX(overwritten_fd)(Object,Class,Method)),
	tnot(STD_FPREFIX(conflict_fd)(Object,Class,Method)).

STD_FPREFIX(defined_fd)(Object,Method) :- STD_FPREFIX(fd)(Object,Method,_).

STD_FPREFIX(overwritten_fd)(Object,Class,Method) :-
	STD_FPREFIX(isa)(Object,SubClass),
	STD_FPREFIX(strict_subclass)(SubClass,Class),
	STD_FPREFIX(ifd)(SubClass,Method,_).

%% When this is called, Object always belongs to Class
STD_FPREFIX(conflict_fd)(Object,Class,Method) :-
	STD_FPREFIX(defined_ifd)(Class1,Method),
	Class \= Class1,
	STD_FPREFIX(isa)(Object,Class1),
	tnot(STD_FPREFIX(strict_subclass)(Class1,Class)),
	tnot(STD_FPREFIX(strict_subclass)(Class,Class1)).


STD_FPREFIX(mvd)(Object,Method,Value) :-
	(ground(Object), ground(Method) ->
	    tnot(STD_FPREFIX(defined_mvd)(Object,Method)),
	    STD_FPREFIX(isa)(Object,Class),
	    STD_FPREFIX(imvd)(Class,Method,Value)
	  ;
	    STD_FPREFIX(isa)(Object,Class),
	    STD_FPREFIX(imvd)(Class,Method,Value),
	    tnot(STD_FPREFIX(defined_mvd)(Object,Method))
	),
	tnot(STD_FPREFIX(overwritten_mvd)(Object,Class,Method)),
	tnot(STD_FPREFIX(conflict_mvd)(Object,Class,Method)).

STD_FPREFIX(defined_mvd)(Object,Method) :-
	STD_FPREFIX(mvd)(Object,Method,_).

STD_FPREFIX(overwritten_mvd)(Object,Class,Method) :-
	STD_FPREFIX(isa)(Object,SubClass),
	STD_FPREFIX(strict_subclass)(SubClass,Class),
	STD_FPREFIX(imvd)(SubClass,Method,_).

STD_FPREFIX(conflict_mvd)(Object,Class,Method) :-
	STD_FPREFIX(defined_imvd)(Class1,Method),
	Class \= Class1,
	STD_FPREFIX(isa)(Object,Class1),
	tnot(STD_FPREFIX(strict_subclass)(Class1,Class)),
	tnot(STD_FPREFIX(strict_subclass)(Class,Class1)).


STD_FPREFIX(ifd)(Class,Method,Value) :-
	(ground(Class), ground(Method) ->
	    tnot(STD_FPREFIX(defined_ifd)(Class,Method)),
	    STD_FPREFIX(strict_subclass)(Class,Super),
	    STD_FPREFIX(ifd)(Super,Method,Value)
	  ;
	    STD_FPREFIX(strict_subclass)(Class,Super),
	    STD_FPREFIX(ifd)(Super,Method,Value),
	    tnot(STD_FPREFIX(defined_ifd)(Class,Method))
	),
	tnot(STD_FPREFIX(overwritten_ifd)(Class,Super,Method)),
	tnot(STD_FPREFIX(conflict_ifd)(Class,Super,Method)).

STD_FPREFIX(defined_ifd)(Class,Method) :- STD_FPREFIX(ifd)(Class,Method,_).

STD_FPREFIX(overwritten_ifd)(Class,Super,Method) :-
	STD_FPREFIX(strict_subclass)(Class,S),
	STD_FPREFIX(strict_subclass)(S,Super),
	STD_FPREFIX(ifd)(S,Method,_).

%% Note: when this is called, Class is always a subclass of Super
STD_FPREFIX(conflict_ifd)(Class,Super,Method) :-
	STD_FPREFIX(defined_ifd)(Super1,Method),
	Super1 \= Super,
	STD_FPREFIX(strict_subclass)(Class,Super1),
	tnot(STD_FPREFIX(strict_subclass)(Super1,Super)),
	tnot(STD_FPREFIX(strict_subclass)(Super,Super1)).


STD_FPREFIX(imvd)(Class,Method,Value) :-
	(ground(Class), ground(Method) ->
	    tnot(STD_FPREFIX(defined_imvd)(Class,Method)),
	    STD_FPREFIX(strict_subclass)(Class,Super),
	    STD_FPREFIX(imvd)(Super,Method,Value)
	  ;
	    STD_FPREFIX(strict_subclass)(Class,Super),
	    STD_FPREFIX(imvd)(Super,Method,Value),
	    tnot(STD_FPREFIX(defined_imvd)(Class,Method))
	),
	tnot(STD_FPREFIX(overwritten_imvd)(Class,Super,Method)),
	tnot(STD_FPREFIX(conflict_imvd)(Class,Super,Method)).

STD_FPREFIX(defined_imvd)(Class,Method) :-
	STD_FPREFIX(imvd)(Class,Method,_).

STD_FPREFIX(overwritten_imvd)(Class,Super,Method) :-
	STD_FPREFIX(strict_subclass)(Class,S),
	STD_FPREFIX(strict_subclass)(S,Super),
	STD_FPREFIX(imvd)(S,Method,_).

%% Note: when this is called, Class is always a subclass of Super
STD_FPREFIX(conflict_imvd)(Class,Super,Method) :-
	STD_FPREFIX(defined_imvd)(Super1,Method),
	Super1 \= Super,
	STD_FPREFIX(strict_subclass)(Class,Super1),
	tnot(STD_FPREFIX(strict_subclass)(Super1,Super)),
	tnot(STD_FPREFIX(strict_subclass)(Super,Super1)).


/*****************************************************************************
  rules for object existence and empty result sets
*****************************************************************************/
:- table STD_FPREFIX(exists)/1.
:- table STD_FPREFIX(mvd)/2.
:- table STD_FPREFIX(imvd)/2.

STD_FPREFIX(exists)(X) :- STD_FPREFIX(fd)(X,_,_).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(fd)(_,_,X).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(mvd)(X,_,_).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(mvd)(_,_,X).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(ifd)(X,_,_).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(ifd)(_,_,X).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(imvd)(X,_,_).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(imvd)(_,_,X).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(isa)(X,_).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(isa)(_,X).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(sub)(X,_).
STD_FPREFIX(exists)(X) :- STD_FPREFIX(sub)(_,X).

STD_FPREFIX(exists)(X) :-
	STD_FPREFIX(fd)(_,M,_),
	M =.. [_|L],
	member(X,L).

STD_FPREFIX(exists)(X) :-
	STD_FPREFIX(mvd)(_,M,_),
	M =.. [_|L],
	member(X,L).

STD_FPREFIX(exists)(X) :-
	STD_FPREFIX(ifd)(_,M,_),
	M =.. [_|L],
	member(X,L).

STD_FPREFIX(exists)(X) :-
	STD_FPREFIX(imvd)(_,M,_),
	M =.. [_|L],
	member(X,L).


STD_FPREFIX(mvd)(O,M) :- STD_FPREFIX(mvd)(O,M,_).

STD_FPREFIX(imvd)(O,M) :- STD_FPREFIX(imvd)(O,M,_).


/*****************************************************************************
  rules for flattened path expressions on RHS
*****************************************************************************/
STD_FPREFIX(fd_rhs)(O,M,R)   :- STD_FPREFIX(fd)(O,M,R).
STD_FPREFIX(mvd_rhs)(O,M,R)  :- STD_FPREFIX(mvd)(O,M,R).
STD_FPREFIX(ifd_rhs)(O,M,R)  :- STD_FPREFIX(ifd)(O,M,R).
STD_FPREFIX(imvd_rhs)(O,M,R) :- STD_FPREFIX(imvd)(O,M,R).
STD_FPREFIX(mvd_rhs)(O,M)    :- STD_FPREFIX(mvd)(O,M).
STD_FPREFIX(imvd_rhs)(O,M)   :- STD_FPREFIX(imvd)(O,M).
STD_FPREFIX(isa_rhs)(O1,O2)  :- STD_FPREFIX(isa)(O1,O2).
STD_FPREFIX(sub_rhs)(O1,O2)  :- STD_FPREFIX(subclass)(O1,O2).
STD_FPREFIX(fs_rhs)(O,M,R)   :- STD_FPREFIX(fs)(O,M,R).
STD_FPREFIX(mvs_rhs)(O,M,R)  :- STD_FPREFIX(mvs)(O,M,R).


/********************************************************************/
