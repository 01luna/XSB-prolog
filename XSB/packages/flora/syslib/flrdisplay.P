/* File:        flrdisplay.P
**
** Author(s): Guizhen Yang 
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) The Research Foundation of SUNY, 1999
**
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
** 
** $Id: flrdisplay.P,v 1.16 1999-11-20 08:16:15 kifer Exp $
** 
*/


:- compiler_options([xpp_on]).
#include "standard.h"
#include "char_defs.h"

#mode save
#mode nostring "\!#'"
#define STD_FPREFIX(X)    '_$_$_flora_''X'
#mode restore


:- import
	call/1, cputime/1, write/1, writeln/1, nl/0,
	goal_cut_trans/3, call_c/1,
	get0/1, functor/3, var/1
   from standard.
:- import file_write/2, file_nl/1 from xsb_writ.

:- import length/2 from basics.

:- import findall/3 from setof.

:- import stat_flag/2 from machine.

:- import shell/5 from shell.

:- import current_predicate/1 from curr_sym.

:- import trie_assert/1, trie_retract_all/1 from tables.

:- import STD_FPREFIX(warning_nl)/2 from flrutils.

:- dynamic STD_FPREFIX(switch)/1.

:- import ground/1 from basics.

:- op(1050,xfy,'##>').
:- op(1100,xfy,'##').

(C ##> T ## _S) :- call(C), call(T).
(C ##> _T ## S) :- ground(C), tnot(C), call(S).

:- table STD_FPREFIX(call)/1.


/********************************************************************/
STD_FPREFIX(print_all)(Gs,NVs) :-
	cputime(T0),
	( NVs == [] ->
	    (    STD_FPREFIX(call)(Gs)
	    ##>  STD_FPREFIX(write_Yes) 
	    ##   STD_FPREFIX(write_No) 
	    )
	
	;   STD_FPREFIX(findall)(NVs,Gs,TempL),
	    sort(TempL,L),
	    cputime(T1),
	    T is T1-T0,
	    length(L,N),
	    ( N = 0 -> STD_FPREFIX(write_No)
	    ;
		(   STD_FPREFIX(switch)(no_chatter)
		->  true
		;   STD_FPREFIX(write_matches)(L), nl,
		    fmt_write(STDFDBK,
			      '%d solution(s) in %S seconds on ',
			      args(N,T)),
		    shell(hostname,block,STDFDBK,block,_)
		),
		STD_FPREFIX(write_Yes)
	    )
	),
	%% We need to fail here because if control reaches the end then 
	%% Prolog top level issues a cut. Since Gs can have tabled predicates,
	%% XSB might complain that there is an illegal cut over tables.
	%% So, we simply let control fail to the second print_answers clauses
	%% (in flrshell.P).
	%% Prolog top level then cuts over that second clause and everyone 
	%% is happy.
	fail.


/********************************************************************/
STD_FPREFIX(print_one)(Gs,NVs) :-
	( NVs == [] ->
	    (   STD_FPREFIX(call)(Gs)
	    ##> STD_FPREFIX(write_Yes)
	    ##  STD_FPREFIX(write_No)
	    )
	
	;
	    ( STD_FPREFIX(call)(Gs),
		STD_FPREFIX(write_pairs)(NVs),
		STD_FPREFIX(fail_unless_return)
	    ##> true
	    ##  STD_FPREFIX(write_No)
	    )
	),
	fail.
	
	
STD_FPREFIX(fail_unless_return) :- 
	get0(C),
	(C == CH_NEWLINE -> true ; get0(_)),
	C=CH_NEWLINE, STD_FPREFIX(write_Yes).

STD_FPREFIX(write_Yes) :- fmt_write(STDFDBK, "\nYes.\n",_).
STD_FPREFIX(write_No)  :- fmt_write(STDFDBK, "\nNo.\n",_).

/********************************************************************/
%% Hookup to the Flora debugger

%% flora_call is a wrapper around XSB call
STD_FPREFIX(call)(Goal) :- 
    	STD_FPREFIX(handle_trace),
    	call(Goal),
	STD_FPREFIX(handle_end_of_call).
STD_FPREFIX(call)(_Goal) :- STD_FPREFIX(handle_notrace), fail.

STD_FPREFIX(findall)(NVs,Gs,TempL) :-
	STD_FPREFIX(handle_trace),
	findall(NVs,Gs,TempL),
	STD_FPREFIX(handle_notrace).
STD_FPREFIX(findall)(_NVs,_Gs,_TempL) :- STD_FPREFIX(handle_notrace), fail.

STD_FPREFIX(handle_trace) :-
    	(  STD_FPREFIX(switch)(trace)
	-> (stat_flag(6, Trace), Trace = 0
	   -> trace
	   ;  true
	   )
	; true
	).
STD_FPREFIX(handle_notrace) :-
    	(   stat_flag(6, Trace), Trace > 0
	->  notrace
	;   true
	).

%% This turns off trace, so that flora internal stuff done after a
%% subgoal call won''t be traced. However, on backtracking, this turns
%% trace on and fails, thereby allowing to backtrack over the previous
%% subgoal.
STD_FPREFIX(handle_end_of_call) :- STD_FPREFIX(handle_notrace).
STD_FPREFIX(handle_end_of_call) :- STD_FPREFIX(handle_trace), fail.


/********************************************************************/
STD_FPREFIX(check_predicates)(G) :-
	functor(G,F,N),
	(   current_predicate(F/N)
	->  true
	;   STD_FPREFIX(warning_nl)('%S/%S is undefined', args(F,N)),
	    fail
	).

STD_FPREFIX(check_predicates)(','(G,Gs)) :-
	functor(G,F,N),
	( current_predicate(F/N) ->
	    STD_FPREFIX(check_predicates)(Gs)

	  ;
	    STD_FPREFIX(warning_nl)('%S/%S is undefined', args(F,N)),
	    fail
	).


/********************************************************************/
STD_FPREFIX(write_matches)([]).

STD_FPREFIX(write_matches)([M|Ms]) :-
	STD_FPREFIX(write_pairs)(M),
	file_nl(STDFDBK),
	STD_FPREFIX(write_matches)(Ms).


STD_FPREFIX(write_pairs)([]).

STD_FPREFIX(write_pairs)([var(N,V)|NVs]) :-
	file_nl(STDFDBK), file_write(STDFDBK, N),
	file_write(STDFDBK, ' = '),
	STD_FPREFIX(write)(V),
	STD_FPREFIX(write_pairs)(NVs).


STD_FPREFIX(write)(X) :-
	var(X),
	!,
	file_write(STDFDBK, X).

STD_FPREFIX(write)(flora_objref_fd(O1,O2)) :-
	!,
	STD_FPREFIX(write)(O1),
	file_write(STDFDBK, '.'),
	STD_FPREFIX(write)(O2).

STD_FPREFIX(write)(flora_objref_ifd(O1,O2)) :-
	!,
	STD_FPREFIX(write)(O1),
	file_write(STDFDBK, '!'),
	STD_FPREFIX(write)(O2).

STD_FPREFIX(write)(X) :-
	X =.. ['flora_@',F|Args],
	!,
	STD_FPREFIX(write)(F),
	( Args == [] ->
	    true
	  ;
	    file_write(STDFDBK, '@('),
	    STD_FPREFIX(write_list)(Args),
	    file_write(STDFDBK, ')')
	).

STD_FPREFIX(write)(X) :-
	file_write(STDFDBK, X).

STD_FPREFIX(write_list)([X]) :-
	!,
	STD_FPREFIX(write)(X).

STD_FPREFIX(write_list)([X1,X2|Xs]) :-
	STD_FPREFIX(write)(X1),
	file_write(STDFDBK, ','),
	STD_FPREFIX(write_list)([X2|Xs]).


/******************** End of flrdisplay.P *************************/


