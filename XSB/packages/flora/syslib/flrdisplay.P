/* File:        flrdisplay.P
**
** Author(s): Guizhen Yang 
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) The Research Foundation of SUNY, 1999
**
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
** 
** $Id: flrdisplay.P,v 1.8 1999-07-31 02:51:32 kifer Exp $
** 
*/




:- import
	call/1, cputime/1, write/1, writeln/1, nl/0,
	goal_cut_trans/3, call_c/1,
	get0/1, functor/3, var/1
   from standard.

:- import length/2 from basics.

:- import findall/3 from setof.

:- import unix/1 from unix.

:- import stat_flag/2 from machine.

:- import current_predicate/1 from curr_sym.

:- import trie_assert/1, trie_retract_all/1 from tables.

:- import '_$_$_write_flora_warnheader'/0 from flrutils.

:- dynamic '_$_$_flora_switch'/1.


/********************************************************************/
'_$_$_flora_print_all'(Gs,NVs) :-
	cputime(T0),
	( NVs == [] ->
	    ( '_$_$_flora_call'(Gs) ->
		'_$_$_flora_write_Yes'
	      ;
	        '_$_$_flora_write_No'
	    )

	  ;
	    '_$_$_flora_findall'(NVs,Gs,TempL),
	    sort(TempL,L),
	    cputime(T1),
	    T is T1-T0,
	    length(L,N),
	    ( N = 0 ->
	        '_$_$_flora_write_No'
	      ;
		('_$_$_flora_switch'(no_chatter) -> true
		  ;
		    '_$_$_flora_write_matches'(L), nl,
		    write(N), write(' solution(s) in '),
		    write(T), write(' seconds on '),
		    unix(hostname)
		),
	        '_$_$_flora_write_Yes'
	    )
	).


/********************************************************************/
'_$_$_flora_print_one'(Gs,NVs) :-
	( NVs == [] ->
	    ( '_$_$_flora_call'(Gs) ->
	        '_$_$_flora_write_Yes'
	      ;
	        '_$_$_flora_write_No'
	    )

	  ;
	    ( '_$_$_flora_call'(Gs),
	      '_$_$_flora_write_pairs'(NVs),
	      '_$_$_flora_fail_unless_return', !
	     ;
	      '_$_$_flora_write_No'
	    )
	).


'_$_$_flora_fail_unless_return' :- 
	get0(C),
	(C == 10 -> true ; get0(_)),
	C=10, '_$_$_flora_write_Yes'.

'_$_$_flora_write_Yes' :- nl, writeln('Yes.').
'_$_$_flora_write_No' :- nl, writeln('No.').

/********************************************************************/
%% Hookup to the Flora debugger

%% flora_call is a wrapper around XSB call
'_$_$_flora_call'(Goal) :- 
    	'_$_$_flora_handle_trace',
    	call(Goal),
	'_$_$_flora_handle_end_of_call'.
'_$_$_flora_call'(_Goal) :- '_$_$_flora_handle_notrace', fail.

'_$_$_flora_findall'(NVs,Gs,TempL) :-
	'_$_$_flora_handle_trace',
	findall(NVs,Gs,TempL),
	'_$_$_flora_handle_notrace'.
'_$_$_flora_findall'(_NVs,_Gs,_TempL) :- '_$_$_flora_handle_notrace', fail.

'_$_$_flora_handle_trace' :-
    	( '_$_$_flora_switch'(trace) -> (stat_flag(6, Trace), Trace = 0
					 -> trace
					 ;  true
					)
	    	    	    	     ; true
	).
'_$_$_flora_handle_notrace' :-
    	(stat_flag(6, Trace), Trace > 0
	  ->  notrace
	  ;   true
	).

%% This turns off trace, so that flora internal stuff done after a
%% subgoal call won't be traced. However, on backtracking, this turns
%% trace on and fails, thereby allowing to backtrack over the previous
%% subgoal.
'_$_$_flora_handle_end_of_call' :- '_$_$_flora_handle_notrace'.
'_$_$_flora_handle_end_of_call' :- '_$_$_flora_handle_trace', fail.


/********************************************************************/
'_$_$_flora_check_predicates'(G) :-
	functor(G,F,N),
	( current_predicate(F/N) ->
	    true

	  ;
	    nl, '_$_$_write_flora_warnheader',
	    write(F/N),
	    writeln(' is undefined'),
	    fail
	).

'_$_$_flora_check_predicates'(','(G,Gs)) :-
	functor(G,F,N),
	( current_predicate(F/N) ->
	    '_$_$_flora_check_predicates'(Gs)

	  ;
	    nl, '_$_$_write_flora_warnheader',
	    write(F/N),
	    writeln(' undefined'),
	    fail
	).


/********************************************************************/
'_$_$_flora_write_matches'([]).

'_$_$_flora_write_matches'([M|Ms]) :-
	'_$_$_flora_write_pairs'(M),
	nl,
	'_$_$_flora_write_matches'(Ms).


'_$_$_flora_write_pairs'([]).

'_$_$_flora_write_pairs'([var(N,V)|NVs]) :-
	nl, write(N),
	write(' = '),
	'_$_$_flora_write'(V),
	'_$_$_flora_write_pairs'(NVs).


'_$_$_flora_write'(X) :-
	var(X),
	!,
	write(X).

'_$_$_flora_write'('_$_$_flora_objref_fd'(O1,O2)) :-
	!,
	'_$_$_flora_write'(O1),
	write('.'),
	'_$_$_flora_write'(O2).

'_$_$_flora_write'('_$_$_flora_objref_ifd'(O1,O2)) :-
	!,
	'_$_$_flora_write'(O1),
	write('!'),
	'_$_$_flora_write'(O2).

'_$_$_flora_write'(X) :-
	X =.. ['_$_$_flora_@',F|Args],
	!,
	'_$_$_flora_write'(F),
	( Args == [] ->
	    true
	  ;
	    write('@('),
	    '_$_$_flora_write_list'(Args),
	    write(')')
	).

'_$_$_flora_write'(X) :-
	write(X).

'_$_$_flora_write_list'([X]) :-
	!,
	'_$_$_flora_write'(X).

'_$_$_flora_write_list'([X1,X2|Xs]) :-
	'_$_$_flora_write'(X1),
	write(','),
	'_$_$_flora_write_list'([X2|Xs]).


/******************** End of flrdisplay.P *************************/


