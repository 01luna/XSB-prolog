/* File:      view_sys.P
** Author(s): David S. Warren
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) David S. Warren 2016
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: altcdf.P,v 1.6 2010-08-19 15:03:38 warren Exp $
** 
*/

:- comment(title,"ViewSys").
:- comment(subtitle,"A View Maintenance System Library").
:- comment(author,"David S. Warren").
:- comment(copyright,"Copyright 2016 David S. Warren, XSB, Inc.").
%%:- comment(version(0*1+1,2016/06/14,16:51*00+'EST'),"Initial system; David S. Warren").
/**:- op(1150,xfy,(do_all)).
:- op(1150,fx,(do_all)).
:- op(1150,xfy,(if_none)).***/

:- export
	viewsys_status/1,	 % viewsys_status(VSDir)
	viewsys_status/2,	 % viewsys_status(VSDir,Option)
	print_viewsys/1,	 % print_viewsys(VSDir)
	check_viewsys/1,	 % check_viewsys(VSDir)
	generate_new_instance/2, % generate_new_instance(VSDir,VInst)
	update_instance/2,	 % update_instance(VSDir,VInst)
	delete_instance/2,	 % delete_instance(VSDir,VInst)
	update_views/4,		 % update_views(VSDir,ViewInstList,ProcName,NProcs)
	invalidate_all_instances/1, % invalidate_all_instances(VSDir)
	invalidate_view_instances/2, % invalidate_view_instances(VSDir,[View:VInst:Version])
	reset_unfinished/2,	% reset_unfinished(VSDir,ProcName)
	show_failed/2,		% show_failed(VSDir,VInst)
	reset_failed/2,		% reset_failed(VSDir,VInst)
	expand_views/1,		% expand_views(VSDir)
	generate_required_dirs/2,	% generate_required(Substitution,XSB_LOGFILES)
	copy_required_files/2.	% copy_required_files(VSDir,FromToSubs)

:- export logfile_file/2, logfile_directory/2.

:- import create_lockfile/1, rm/1, sys_mkdir/2, process_control/2, process_status/2 from shell.
:- import concat_atom/2, concat_atom/3 from string.
:- import member/2, select/3, ith/3, length/2, append/3 from basics.
:- import fmt_write/3, file_time/2 from file_io.
:- import local_datime/1, call_c/1, file_exists/1 from standard.
:- import parsort/4 from machine.
:- import xsb_configuration/2 from xsb_configuration.

:- comment(summary, "The ViewSys package supports workflows that can
be structured as a DAG of view definitions.  ViewSys allows a user to
define such workflows and manage their execution and maintenance.  At
this point it does not provide support for incremental view
maintenance, only full regeneration of views.").

:- comment(module,"
@section{Overview}
A View System supports a DAG of views.  Most simply
a view is a file that is generated by a process applied to a set of
input files.  A view that has no inputs is called a 'base view'.

More precisely we can think of a view as a data source.  Base views
are data sources from outside the system.  A non-base view is a data
source that is determined (and computed) by its process applied to its
input data sources.  The process must be idempotent, so normally it
creates a new file (or table).

A view system workflow (@bf{ViewSys} for short) describes the names of
the views, their input views, the command to be run to generate a view
from its inputs, etc.  A particular @bf{instance} of a ViewSys is
determined by the specific external data sources associated with the
base views of the ViewSys.  It is useful to give names to such an
instance, usually indicating the external source of the base data
sources.  Also since external data sources may change over time,
producing new versions of those sources, ViewSys is structured to
support versions of all views (but this is not currently implemented;
every version is version 0.)  Many view systems will have only one
instance, and each instance only one version.  @footnote{The contents
of a version can change, and the system will manage such cases.  This
is the reason versioning has not (yet?)  been implemented; adding
explicit version numbers may be over-engineering and it would better
for the user to manage backing up of earlier versions outside the
ViewSys system.}

Another useful component of a view system is what is called a
consistency view.  The purpose of a consistency view is to check to
see whether a regular view is 'consistent'.  The command for a
consistency view should return non-zero if the view instance is not
deemed to be consistent.

The view system will run consistency views where applicable and will
not use a view as input to another view that it supports if it is
deemed not consistemt.  A single view may have zero or more
consistency views associated with it.

@section{The ViewSys Data Model}

A ViewSys workflow is described by a set of facts of the following
predicates.  Users should put the appropriate facts for these
predicates that define their view system into a file named
@file{viewsys_view_info.P}.  (But see the split(N) option described
below for an exception.)

@subsection{View Framework Model}

For each view (base or derived), there is a view/7 fact that describes
it:

@noindent view(View,Type,ViewNameTemplate,StdoutFileTemplate,[InputViews],[Opts],ShCmd)
where:
@begin{itemize}
@item @var{View} is the name of the view;

@item @var{Type} is file, dir(<FileNames>) (or maybe in the future
db(...)?).  It is 'file' if the view is stored in a file (that is
generated by the @var{ShCmd}).  It is 'dir(<FileNames>)' if the view
is stored in multiple files in a directory.  <FileNames> are the
(relative) names of the files that store the view in that directory
(instance).

@item @var{ViewNameTemplate} is the path template for where instance
versions are stored.  This template string normally contains the
pattern variable $INSTANCE$ which will be replaced by the instance
name to obtain the filename (or directory name) of an instance of this
view.  A file template may also contain user-defined pattern variables
of the form '$USERVARNAME$' where USERVARNAME is any upper-case letter
sequence.  User-defined pattern variable values are defined in facts
of the form viewsys_uservar('$USERVARNAME$',VarValueString).  When
instantiated by an instance name and user-variable values, this will
be the filename that contains the view contents, or a directory name
that contains the files containing the view contents.

@item @var{StdoutFileTemplate} is the file name template for where to
put the standard output (stdout and stderr) of the execution of the
shell command that generates instance versions of this view. It
normally contains the pattern variable $INSTANCE$ which will be
replaced by the instance name to obtain the stdout filename for the
generation of an instance of this view.  This template is the empty
string for base views.

@item @var{[InputViews]} is a list of the names of views that this
view directly depends on, i.e., the inputs needed to generate this
view.  This is an empty list for base views.  Normally these input
view indicators are atoms for which there is another @pred{view/7}
fact that describes it.  However, if that view generates a directory
and the input to this view is a file in that directory, then that
filename should be put as an argument to the view atom.  E.g., if the
view, m_view, generates a directory and several files in it and this
view needs to use the file 'first_file.P' from that directory, then
the input view indicator in this list should be the term
m_view('first_file.P').

@item @var{[Opts]} is a list of options. The possible options are:

@begin{itemize}				       

@item @tt{split(N)} where @tt{N} is a positive integer.  This tells
@tt{viewsys} to split the first input view file into @tt{N}
subfiles; to run this command on each of those subfiles; and to
concatenate all the resulting subfiles back together to get the output
file for this view.  Of course, this is only appropriate for view
commands for which this process gives the same answer as running it on
the large unsplit file.  When the command satisfies this property,
this option can allow the records in a large file to be processed in
parallel.

If this option is used, then the user should create a file named
@file{viewsys_view_orig_info.P} containing all these predicate
definitions, and use @pred{expand_views/1} to generate the appropriate
@file{viewsys_view_info.P} file, which will drive the @tt{viewsys}
processing.

@end{itemize}				       

@item @var{ShCmd} is the shell command to execute to generate the view
instance from its input view instances. (Ignored for base views.)  The
shell command can be in one of three forms: 1) a string containing
metavariables of the form $INP1$, $INP2$, ..., and $OUT$, which will
be replaced by the filenames of the input view instance
files/directories and the output view instance file/directory,
respectively; or 2) a string containing the metavariables $INPUTFILES$
and $OUTPUTFILE$, which will be replaces with the sequence of input
filenames and the output filename, respectively, where each filename
is enclosed in double-quotes.  This is often appropreate for shell
commands.  If the shell string doesn't contain any of the
metavariables, then it is treated as if it were: '<ShCmd> $INPUTFILES$
$OUTPUTFILE$'.

@end{itemize}

User-defined syntactic variables can be used in filename templates and
in shell command templates to make it easier to define filenames and
commands.  The predicate @pred{viewsys_uservar/2} is used to define
user variables, and facts for this predicate should be places in the
@file{viewsys_view_info.P} file.  For example, assume the user adds
the following facts to that file:

@begin{verbatim}
viewsys_uservar('$DATA_DIR$','C:/userfiles/project1/data').
viewsys_uservar('$SCRIPT_LIB$','c:/userfiles/project1/scripts').
@end{verbatim}

With these declarations in a @file{viewsys_view_info.P} file, a file
templiate string could be of the form '$DATA_DIR$/data_file_13', which
after replacement of the syntactic variable by its value would refer
to the file named 'C:/userfiles/project1/data/data_file_13'.  A shell
command string could be 'sh $SCRIPT_LIB$/script_cc.sh', which after
replacements would casue the command 'sh
c:/userfiles/project1/scripts/script_cc.sh' to be run.  User variables
are normally defind at the beginning of the view file and can be used
to allow locations to be easily changed.  The value of a user variable
may contain another user variable, but, of course, cycles are not
permitted.

For each consistency view, there is a consView/6 fact:

@noindent consView(ConsViewName, CheckedViewName, FileTemplate, StdoutFileTemplate, [Inputs], ShCmd)
where

@begin{itemize}
@item @var{ConsViewName} is the name of the consistency view.

@item @var{ViewName} is the name of the view this view checks.

@item @var{FileTemplate} is the template for the output file for this
consistency check.  This file may be used to provide information as to
why the consistency check failed (or passed.)

@item @var{StdoutFileTemplate} is the template for the filename of
stdout for an execution of this script.

@item @var{[InputViews]} is a list of parameter input views (maybe empty)

@item @var{ShCmd} is the shell command the executes the consistency
check.  The inputs are the the filename containing the view instance
to be checked followd by the input view file instances.  The output is
the output file instance.  These parameters are processed similarly to
the processing for shell-commands for regular views.

@end{itemize}

@subsection{View Instance Model}

A ViewSys Instance is a particular instantiation of a ViewSys workflow
that is identified by a name, usually indicating the source of the
base views.  The base views have associated version numbers, and
non-base views will then have versions determined by the versions of
their input views.  Of course, the files (directories) that contain
instances of views must all be distinct.

View instances are described by another set of facts, which are stored
in a file named @file{viewsys_instance_info.P}.  Whereas the user is
responsible for creating the @file{viewsys_view_info.P} file, viewsys
creates and maintains the @file{viewsys_instance_info.P} file in
response to viewsys commands entered by the user.

For each view instance (base or derived), there is a viewInst/7 fact:

@noindent viewInst(View,InstName,Version,Status,Date,[InputVersions],Began)
where:
@begin{itemize}

@item @var{View} is the name of a view;

@item @var{InstName} is the name of the instance;
	   
@item @var{Version} is a version number of the workflow instance of
this view;

@item @var{Status} is the status of this view instance
@tt{not_generated}, @tt{being_generated(ProcName)}, @tt{generated},
@tt{generation_failed}. (For base view instances this is always
generated.)

@item @var{Date} is the date-time the view instance was generated.

@item @var{[InputVersions]} is a list of the version numbers of
instances of the workflow instances of views that are inputs to this
version of this workflow instance of this view. This is the empty list
for an instance of a base view.

@item @var{Began} is the date-time at which the generation of this
view began.  (This is the same as Date above for base view instances.)
It is used to estimate how long it will take to generated this view
output given its inputs.

@end{itemize}

For each consistency view instance, there is a consViewInst/7 fact:

@noindent consViewInst(ConsViewName, InstName, Version, Status, Date, [InputVersions], Began)
where;

@begin{itemize}

@item @var{ConsViewName} is the name of the consistency view.

@item @var{Version} is the version of the View that is checked. (It is
also used to version the files generated by the consistency check.)

@item @var{Status} is this consistency view, same as for viewInst
status.

@item @var{Date} is the date-time the check was generated.

@item @var{[InputVersions]} is a list of the version numbers of the
instances used in the consistency check.

@item @var{Began} is the date-time at which the generation of this
view began.

@end{itemize}

The ViewSys relations, @pred{view/7}, @pred{consView/6}, and
@pred{viewOrig/7}, are stored in the file named
@file{viewsys_view_info.P}.  It is read for most commands, but not
updated.  (Only @pred{expand_views/1} generates this file from the
file namsd @file{viewsys_view_orig_info.P}.)  @pred{viewInst/7}, and
@pred{consViewInst/7} are stored in the file named
@file{viewsys_instance_info.P}, and the directory containing these
files is explicitly provided to predicates that need to operate on it.
The contents of the files are Prolog terms in canonical form.

A lockfile (named @file{lock_view} in the viewsys directory) is
obtained whenever these files are read, and it is kept until reading
and rewriting (if necessary) is completed.

@section{Using ViewSys}

The viewsys system is normally used as follows.  The user creates a
directory to hold the viewsys information.  She creates a file
@file{viewsys_view_info.P} in this directory containing the desired
@pred{view/7}, and @pred{consView/6} facts that describe the desired
view system.  Then the user consults the viewsys.P package, and runs
@pred{check_viewsys/1} to report any obvious inconsistencies in the
viewsys specification in @file{viewsys_view_info.P}.  After the check
passes, if any views have the @tt{split(N)} option, the user should
copy the @file{viewsys_view_info.P} file to a file named
@file{viewsys_orig_view_info.P} and then run @pred{expand_views/1} to
generate the appropriate file @file{viewsys_view_info.P} to contain
the views necessary to split, execute and combine the results.  This
will overwrite the @file{viewsys_view_info.P} file.  (From then on,
should the viewsys need to be modified, the user should edit the
@file{viewsys_orig_view_info.P} file, and rerun @pred{expand_views/1}
to regenerate the @file{viewsys_view_info.P} file.)  The user will
then run @pred{generate_view_instance/2} to generate an instance (or
instances) of the view system into the file
@file{viewsys_instance_info.P}.  After that the user will run
@pred{update_views/4} to generate all the view contents.  Then the
user checks the generated logging to determine if there were any
errors.  If so, the user corrects the programs (the viewsys
specification, whatever), executes @pred{reset_failed/2} and reruns
@pred{update_views/4}.  The user can also use @pred{viewsys_status/1}
to determine what the state of the view system is, and to determine
what needs to be fixed and what needs to be rerun.  If the execution
of @pred{update_views/4} is aborted or somehow does not complete, the
user can run @pred{reset_unfinished/2} to reset the views that were in
process, so that a subsequent @pred{update_views/4} will try to
recompute those unfinished computations.

@section{Ideas for Possible Future Extensions}
	   
The data structures support version numbers.  For now, versions are
not supported; only version 0 is used.  It is intended, if it becomes
useful, to extend the system to support multiple versions of views.

It may be useful to somehow associate or connect multiple view
systems.  This might support a base view in one ViewSys that is
defined in another ViewSys framework.

Perhaps we should support annotations/options to indicate how/when to
delete versions of intermediate views.

We might explore the integration of incrementally maintained views, by
adding difference files, and generating difference sets to be applied
to the old view.  This will probably initially have to be constrained
to views whose increments can be computed from the inserts/deletes to
a single input file.  " ).

:- comment(generate_new_instance(ViewSys,VInst), "
@pred{generate_new_instance(+ViewSys,+VInst)} creates a brand new
instance of the view system @var{ViewSys} named VInst.  It generates
new viewInst/7 facts for every view (base and derived) according to
the file templates defined in the baseView/4, and view/7 facts of the
ViewSys.  @var{VInst} may be a list of instance names, in which case
initial instances are created for each one."  ).

generate_new_instance(ViewSys,VInstList0) :-
	generate_new_instance(ViewSys,VInstList0,new).

:- comment(update_instance(ViewSys,VInst), "
@pred{update_instance(+ViewSys,+VInst)} updates an instance of the
view system @var{ViewSys} named VInst.  It is similar to
@pred{generate_new_instance/2} but doesn't change existing instance
records.  It generates a new @pred{viewInst/7} (or
@pred{consViewInst/7}) fact for every view (base and derived) that
doesn't already exist in the @file{viewsys_instance_info.P} file.  It
doesn't change instances that already exisit, thus preserving their
statuses and process times.  "  ).

update_instance(ViewSys,VInstList0) :-
	generate_new_instance(ViewSys,VInstList0,update).

generate_new_instance(ViewSys,VInstList0,NewUpd) :-
	(atom(VInstList0)
	 ->	VInstList = [VInstList0]
	 ;	VInstList = VInstList0
	),
	load_viewfile_for_update(ViewSys),
	local_datime(Datime),
	(do_all
	 member(VInst,VInstList),
	 generate_all_vinsts(VInst,NewUpd,Datime)
	),
	save_viewfile(ViewSys).

generate_all_vinsts(VInst,NewUpd,Datime) :-
	(do_all
	 view(View,_Type,FileTemplate,_StdoutFileTemplate,ViewInputList,_Opts,_Cmd),
	 generate_vinst(VInst,Datime,View,FileTemplate,ViewInputList,NewUpd)
	),
	(do_all
	 consView(View,_Type,FileTemplate,_StdoutFileTemplate,ViewInputList,_Cmd),
	 generate_const_vinst(VInst,Datime,View,ViewInputList,NewUpd)
	).

%% generate viewInst facts for base and derived views
generate_vinst(VInst,Datime,View,FileTemplate,ViewInputList,NewUpd) :-
	(ViewInputList == []
	 ->	(str_match('$INSTANCE$',FileTemplate,forward,_,_)
		 ->	GVInst = VInst
		 ;	\+ viewInst(View,all,_Ver,_Stat,_Dt,[],_Beg),
			GVInst = all
		),
		Status = generated
	 ;	GVInst = VInst,
		Status = not_generated
	),
	new_0_versions(ViewInputList,VersionList),
	(NewUpd == update,
	 viewInst(View,VInst,0,_OStatus,_ODatime,VersionList,_ODTBegin)
	 ->	true
	 ;	retractall(viewInst(View,VInst,_,_,_,_,_)),
		assert(viewInst(View,VInst,0,Status,Datime,VersionList,Datime))
	 ).

generate_const_vinst(VInst,Datime,View,ViewInputList,NewUpd) :-
	new_0_versions(ViewInputList,VersionList),
	(NewUpd == update,
	 consViewInst(View,VInst,0,_OStatus,_ODatime,VersionList,_ODTBegin)
	 ->	true
	 ;	retractall(consViewInst(View,VInst,0,_,_,_,_)),
		assert(consViewInst(View,VInst,0,not_generated,Datime,VersionList,datime(0,0,0,0,0,0)))
	).

new_0_versions([],[]).
new_0_versions([_|ViewInputList],[0|VersionList]) :-
	new_0_versions(ViewInputList,VersionList).

:- comment(delete_instance(ViewSys,VInst), "
@pred{delete_instance(+ViewSys,+VInst)} removes an entire instance
(including all versions) from the view system.  Any files of view
contents that have been generated remain; only information concerning
this instance in the @file{viewsys_instance_info.P} file is removed,
so these view instances are no longer maintained.").

delete_instance(ViewSys,VInst) :-
	load_viewfile_for_update(ViewSys),
	retractall(viewInst(_,VInst,_,_,_,_,_)),
	retractall(consViewInst(_,VInst,_,_,_,_,_)),
	save_viewfile(ViewSys).


/* will have to figure out versions; some things above will change...*/

:- comment(define_new_instance_versions(ViewSys,VInst,ViewList), "This
predicate determines what versions are out-of-date, and generates new
version numbers for them and adds new viewInst facts for them.  To
actually update the views, update_views/4 must be invoked.").

:- comment(add_new_base_version(ViewDir,VInst,BaseView,Version,Loc),
"This predicate adds a new version of a base file to a view
instance. @var{ViewDir} is the directory containing the view_*_info.P
files for the view.").

:- comment(update_views(ViewSys,ViewInstList,ProcName,NProcs),
"@pred{update_views(+ViewSys, +ViewInstList, +ProcName, +NProcs)} is
the predicate that runs the shell commands of view instances to create
view instance contents.  It ensures that most recent versions of the
view instances in @var{ViewInstList} (and all instances required for those
views, recursively) are up to date by executing the commands as
necessary.  A view instance is represented in this list by a term
@tt{View:InstName:0}.  If @var{ViewInstList} is the atom 'all', all
view instances will be processed.  This predicate will determine what
computations can be done concurrently and will use up to @var{NProcs}
concurrent processes (using spawn_process on the current machine) to
compute them.  @var{ProcName} is a user-provided process namde that
used to identify this (perhaps very long-running) process; it is used
to indicate, in @tt{Ststus=being_updated(ProcName)} that a view
instance is in the process of being computing by this update_views
invocation.  @tt{reset_unfinished/2} uses the name to identify the
view instances that a particular invocation of this process is
responsible for.  ").

update_views(ViewSys,all,ProcName,NProcs) :-
	!,
	load_viewfile_for_update(ViewSys),
	findall(View:Inst:Version,root_view_instance(View,Inst,Version),VIs0),
	sort(VIs0,ViewInstList),
	start_available_procs(ViewSys,ViewInstList,[],ProcName,NProcs,1,userout).
update_views(ViewSys,ViewInstList,ProcName,NProcs) :-
	load_viewfile_for_update(ViewSys),
	start_available_procs(ViewSys,ViewInstList,[],ProcName,NProcs,1,userout).

%%:- document_export start_available_procs/7.

:- comment(
start_available_procs(ViewSys,ViewInstList,ExecutingPids,ProcName,NProcs,Slp,OStr),
"@pred{start_available_procs(+ViewSys, +ViewInstList, +ExecutingPids,
+ProcName, +NProcs, +Slp, +OStr)} is an internal predicate that
supports the @pred{view_update/4} processing.  It finds all views that
can be generated (or checked), starts processes to compute
@var{NProcs} of them, and then calls @pred{monitor_running_procs/7} to
monitor their progress and start more processes as these terminate.
This is an internal predicate, not available for call from outside the
module. The parameters to @pred{start_available_procs/7} are:

@begin{enumerate}

@item @var{ViewSys} is the directory containing the
@file{viewsys_info.P} file describing the view system.

@item @var{ViewInstList} is a) an explicit list of records of the form
@tt{View:Inst:0} identifying the (derived) views, normally 'root'
views, that are intended to be generated by the currently running
@pred{update_view/4} invocation; or b) the constant 'all' indicating
that all view instances of the view system are intended to be
generated.

@item @var{ExecutingPids} are pid records of the currently running
processes that have been spawned.  A pid record is of the form:
@tt{pid(Pid,ShCmd,SStr,FileOut,Datime,View,Inst,Ver)}, where

@begin{itemize}

@item @var{Pid} is the process ID of the process (as returned by
@pred{spawn_process/5}.)

@item @var{ShCmd} is the shell command that was used to start the process.

@item @var{SStr} is the output stream of the process's stdout and stderr file.

@item @var{FileOut} is the name of the file connected to the stdout/stderr stream.

@item @var{Datime} is the datime that the process was started.

@item @var{View} is the view the process is generating.

@item @var{Inst} is the instance of the view the process is generating.

@item @var{Ver} is the version of the instance of the view the process
is generating. (Currently always 0.)

@end{itemize}

@item @var{ProcName} is the user-provided name of this entire update
process, and is used to mark views (in the
@file{viewsys_instance_info.P} file) during processing so they can be
identified as associated to this view-update process if some error
occurs.

@item @var{NProcs} is the number of 'processors' available for a
process to be scheduled on.  The 'processors' are virtual, and this is
used to control the maximum number of concurrently running processes.

@item @var{Slp} is the number of seconds to sleep if no subprocess is
available for starting before checking again to see if some subprocess
has completed in the interim.

@item @var{OStr} is the output stream used to write progress messages
when processes start and complete.

@end{enumerate}
	   "
	  ).

start_available_procs(ViewSys,ViewInstList,ExecutingPids,ProcName,NProcs,Slp,OStr) :-
	findall(Command,command_to_update_view(ViewInstList,Command),Commands0),
	sort(Commands0,Commands1), % parsort sometimes does not elim dupls??????
	parsort(Commands1,[desc(6)],1,Commands),  
	(Commands == []
	 ->	save_viewfile(ViewSys),
		NewExecPids = ExecutingPids,
		NProcsRem = NProcs
	 ;	local_datime(Datime),
		collect_commands_to_start(Commands,NProcs,Datime,ProcName,CommandsToEx,NProcsRem),
		save_viewfile(ViewSys),
		start_commands(CommandsToEx,OStr,ExecutingPids,NewExecPids)	
	),
	monitor_running_procs(NewExecPids,NProcsRem,ViewSys,ViewInstList,ProcName,Slp,OStr).

command_to_update_view(ViewInstList,Command) :-
	(ViewInstList == all
	 ->	viewInst(View,Inst,Ver,_,_,_,_)
	 ;	member(View:Inst:Ver,ViewInstList)
	),
	view_to_update(View,Inst,Ver,Command).

collect_commands_to_start(_Commands,0,_,_,[],0) :- !.
collect_commands_to_start([],NProcs,_,_,[],NProcs).
collect_commands_to_start([Command|Commands],NProcs,Datime,ProcName,[Command|CommandsToEx],NProcsRem) :-
	Command = cmd(_ShCmd,_StdOut,View,Inst,Ver,_Cost),
	(viewInst(View,Inst,Ver,not_generated,_,IVers,_Began)
	 do_all
	 retractall(viewInst(View,Inst,Ver,not_generated,_,_,_)),
	 assert(viewInst(View,Inst,Ver,being_generated(ProcName),Datime,IVers,Datime))
	),
	(consViewInst(View,Inst,Ver,not_generated,_,IVers,_Began)
	 do_all
	 retractall(consViewInst(View,Inst,Ver,not_generated,_,_,_)),
	 assert(consViewInst(View,Inst,Ver,being_generated(ProcName),Datime,IVers,Datime))
	),
	NProcs1 is NProcs - 1,
	collect_commands_to_start(Commands,NProcs1,Datime,ProcName,CommandsToEx,NProcsRem).

start_commands([],_,Pids,Pids).
start_commands([Command|Commands],OStr,Pids0,Pids) :-
	spawn_one_cmd(Command,OStr,Pid),
	start_commands(Commands,OStr,[Pid|Pids0],Pids).

spawn_one_cmd(cmd(ShCmd,StdOut,View,Inst,Ver,Cost),OStr,pid(Pid,ShCmd,SStr,FileOut,Datime,View,Inst,Ver)) :-
	generate_file_from_template(StdOut,Inst,Ver,FileOut),
	ensure_directories_exist(FileOut,OStr),
	open(FileOut,write,SStr),
	spawn_process(ShCmd,none,SStr,SStr,Pid),
	local_datime(Datime),
	(OStr \== none
	 ->	fmt_write(OStr,"\nSpawned Command: PID %d: view: %s:%s:%d at %S, est %S\n",
			  args(Pid,View,Inst,Ver,Datime,Cost)),
	 	fmt_write(OStr,"  %s\n",args(ShCmd))
	 ;	true
	).
	
%%:- document_export monitor_running_procs/7.

:- comment(
monitor_running_procs(Pids,NProcs,ViewSys,VInstList,ProcName,Slp,OStr),
"@pred{monitor_running_procs(+Pids, +NProcs, +ViewSys, +VInstList,
+ProcName, +Slp, +OStr)} is an internal predicate that monitors
previously spawned running processes, calling
@pred{start_available_procs/7} to spawn new ones when running
processes finish.

@begin{enumerate}

@item @var{Pids} is the list of process IDs of running processes.
Each entry is a record of the form
@tt{pid(Pid,Cmd,StdStr,FileOut,Datime,View,Inst,Ver)} where:

@begin{itemize}

@item @var{Pid} is the process ID of the process (as returned by
@pred{spawn_process/5}.)

@item @var{ShCmd} is the shell command that was used to start the process.

@item @var{SStr} is the output stream of the process's stdout and stderr file.

@item @var{FileOut} is the name of the file connected to the stdout/stderr stream.

@item @var{Datime} is the datime that the process was started.

@item @var{View} is the view the process is generating.

@item @var{Inst} is the instance of the view the process is generating.

@item @var{Ver} is the version of the instance of the view the process
is generating. (Currently always 0.)

@end{itemize}

@item @var{NProcs} is the number of 'processors' that are currently
available for use.  starrt_available_procs can start up to this number
of new processes.

@item @var{ViewSys} is the viewsys directory;

@item @var{VInstList} is the list of view instances (or 'all') that are
being updated by this execution of update_views/4.;

@item @var{ProcName} is the caller-provided name of this update
processor used to mark views that are being updated by this update
process; and

@item @var{Slp} is the number of seconds to sleep if no process is
available for starting.

@item @var{OStr} is the output stream for writing status messages;

@end{enumerate}
"
	  ).

monitor_running_procs([],_NProcs,_ViewSys,_VInstList,_ProcName,_Slp,_OStr) :- !.
monitor_running_procs(Pids,NProcs,ViewSys,VInstList,ProcName,Slp,OStr) :-
	collect_finished_procs(Pids,FinishedPids,UnfinishedPids),
	(FinishedPids \== []
	 ->	local_datime(CurDatime),
		length(FinishedPids,NumFinished),
		NProcsRem is NProcs + NumFinished,
		load_viewfile_for_update(ViewSys),
		(do_all
		 member(PidStr,FinishedPids),
		 process_finished_pid(PidStr,CurDatime,OStr)
		),
		start_available_procs(ViewSys,VInstList,UnfinishedPids,ProcName,NProcsRem,1,OStr)
	 ;	sleep(Slp),
		monitor_running_procs(Pids,NProcs,ViewSys,VInstList,ProcName,2,OStr)
	).

collect_finished_procs([],[],[]).
collect_finished_procs([PidStr|Pids],FinishedPids,UnfinishedPids) :-
	PidStr = pid(Pid,_,_,_,_,_,_,_),
	process_status(Pid,PStatus),
	(PStatus \== running
	 ->	FinishedPids = [PidStr|FinishedPids1],
		collect_finished_procs(Pids,FinishedPids1,UnfinishedPids)
	 ;	UnfinishedPids = [PidStr|UnfinishedPids1],
		collect_finished_procs(Pids,FinishedPids,UnfinishedPids1)
	).

process_finished_pid(pid(Pid,_PCmd,SStr,FileOut,Datime,View,Inst,Ver),CurDatime,OStr) :-
	(process_control(Pid,wait(RetCode))
	 ->	true
	 ;	op_fmt_write(OStr,'\nWarning: wait failed for finished process: %d\n',args(Pid)),
		RetCode = 1
	),
	close(SStr),
	datime_diff(CurDatime,Datime,Elapsed),
	display_datime_diff(Elapsed,Time),
	(RetCode =:= 0
	 ->	op_fmt_write(OStr,"\nFinished PID %d SUCCESSFUL view: %s:%s:%d Time: %s, StdOut: %s\n",
			     args(Pid,View,Inst,Ver,Time,FileOut)),
	 VStatus = generated
	 ;	op_fmt_write(OStr,"\nFinished PID %d FAILED Code: %d, view: %s:%s:%d Time: %s, StdOut: %s\n",
			     args(Pid,RetCode,View,Inst,Ver,Time,FileOut)),
	 VStatus = generation_failed
	),
	(RetCode =:= 0
	 ->	(viewInst(View,Inst,Ver,_,_,IVers,Began)
		 do_all
		 retractall(viewInst(View,Inst,Ver,_,_,_,_)),
		 assert(viewInst(View,Inst,Ver,VStatus,CurDatime,IVers,Began))
		),
		(consViewInst(View,Inst,Ver,_,_,IVers,Began)
		 do_all
		 retractall(consViewInst(View,Inst,Ver,_,_,_,_)),
		 assert(consViewInst(View,Inst,Ver,VStatus,CurDatime,IVers,Began))
		)
	 ;	(viewInst(View,Inst,Ver,_Stat,_Dt,IVers,Began)
		 do_all
		 retractall(viewInst(View,Inst,Ver,_,_,_,_)),
		 assert(viewInst(View,Inst,Ver,generation_failed,CurDatime,IVers,Began))
		),
		(consViewInst(View,Inst,Ver,_,_,IVers,Began)
		 do_all
		 retractall(consViewInst(View,Inst,Ver,_,_,_,_)),
		 assert(consViewInst(View,Inst,Ver,generation_failed,CurDatime,IVers,Began))
		)
	).

op_fmt_write(OStr,FmtString,Args) :-
	(OStr == none
	 ->	true
	 ;	fmt_write(OStr,FmtString,Args)
	).

ensure_directories_exist(File,OStr) :-
	split_dir_path(File,Dir),
	(file_exists(Dir)
	 ->	true
	 ;	ensure_directories_exist(Dir,OStr),
		mkdir(Dir),
		fmt_write(OStr,'Created Directory: %s\n',args(Dir))
	).

mkdir(Dir) :-
	sys_mkdir(Dir,Res),
	(Res =:= 0
	 ->	true
	 ;	throw(error('trying to create directory',Dir))
	).

split_dir_path(Name,Dir) :-
	atom_codes(Name,NameC),
	(lappend(DirC,[0'/|FileC],NameC),FileC \== []
	 ->	true
	 ; lappend(DirC,[0'\\|FileC],NameC),FileC \== []
	 ->	true
	 ;	throw(error('trying to create directory',Name))
	),
	atom_codes(Dir,DirC).

lappend([X|L1],L2,[X|L3]) :- lappend(L1,L2,L3).
lappend([],L,L).

%% find views that are ready to be updated
view_to_update(View,Inst,Ver,Command) :-
	viewInst(View,Inst,Ver,not_generated,Datime,InputVers,Began),
	view(View,_Type,LocTempl,Stdout,ViewsDep,_Opts,ShellCmd),
	ViewsDep \== [],
	(all_view_instances_generated(ViewsDep,Inst,InputVers,InputFiles)
	 ->	generate_file_from_template(LocTempl,Inst,Ver,File),
		generate_shell_command(ShellCmd,InputFiles,File,ShCommand),
		compute_cost(View,Inst,Ver,Datime,Began,Cost),
		Command = cmd(ShCommand,Stdout,View,Inst,Ver,Cost)
	 ;	mem_pair(DepViewTerm,DepVer,ViewsDep,InputVers),
		functor(DepViewTerm,DepView,_),
		\+ view(DepView,_,_,_,[],_,_),
		view_to_update(DepView,Inst,DepVer,Command)
	).
view_to_update(View,Inst,Ver,Command) :-
	viewInst(View,Inst,Ver,generated,_,_,_),
	consView(ConsView,View,CVTempl,Stdout,ViewsDep,ShellCmd),
	consViewInst(ConsView,Inst,Ver,not_generated,Datime,InputVers,Began),
	(all_view_instances_generated(ViewsDep,Inst,InputVers,InputFiles0)
	 ->	generate_file_from_template(CVTempl,Inst,Ver,File),
		view(View,_Type,VLocTempl,_,_,_,_),
		generate_file_from_template(VLocTempl,Inst,Ver,ViewFile),
		generate_shell_command(ShellCmd,[ViewFile|InputFiles0],File,ShCommand),
		datime_diff(Datime,Began,Cost),
		Command = cmd(ShCommand,Stdout,ConsView,Inst,Ver,Cost)
	 ;	fail
	).
	 
compute_cost(View,Inst,Ver,Datime,Began,Cost) :-
	datime_diff(Datime,Began,Cost0),
	(compute_post_cost_e(View,Inst,Ver,Cost1)
	 ->	datime_sum(Cost0,Cost1,Cost)
	 ;	Cost = Cost0
	).

:- table compute_post_cost_e/4 as subsumptive.
compute_post_cost_e(View,Inst,Ver,Cost) :-
	(var(View),var(Inst),var(Ver)
	 ->	compute_post_cost(View,Inst,Ver,Cost)
	 ;	compute_post_cost_e(View1,Inst1,Ver1,Cost1),
		View1 = View, Inst1 = Inst, Ver1= Ver, Cost1= Cost
	).

:- table compute_post_cost(_,_,_,lattice(max(_,_,_))).
compute_post_cost(View,Inst,Ver,Cost) :-
	view(DView,_Type,_Loc,_Std,ViewsDep,_Opt,_Sh),
	ViewsDep \== [],
	ith(I,ViewsDep,ViewTerm),
	functor(ViewTerm,View,_),
	viewInst(DView,Inst,DVer,_Stat,Datime,InputVers,Began),
	ith(I,InputVers,Ver),
	datime_diff(Datime,Began,Cost1),
	(compute_post_cost(DView,Inst,DVer,Cost0)
	 ->	datime_sum(Cost0,Cost1,Cost)
	 ;	Cost = Cost1
	).

max(X,Y,Z) :- (X @>= Y -> Z = X ; Z = Y).

%% first check for individual $INP1$...$INPN$ and $OUT$, and replace them if so.
generate_shell_command(ShellCmd,InputFiles,OutFile,ShCommand) :-
	str_match('$OUT$',ShellCmd,forward,_,_), % explicit indiv file vars
	!,
	build_substitution_list(InputFiles,1,OutFile,SubList),
	add_user_substitutions(SubList,AllSubs),
	substitute_strings(AllSubs,ShellCmd,ShCommand).
%% use "sh script" forms, including double-quote delimiters
generate_shell_command(ShellCmd,InputFiles,OutFile,ShCommand) :-
	concat_atom(InputFiles,'" "',InputFileStr0),
	concat_atom(['"',InputFileStr0,'"'],InputFileStr),
	concat_atom(['"',OutFile,'"'],OutFileStr),
	(str_match('$INPUTFILES$',ShellCmd,forward,_,_)
	 ->	ShellCmd1 = ShellCmd
	 ;	concat_atom([ShellCmd,' ','$INPUTFILES$',' ','$OUTPUTFILE$'],ShellCmd1)
	),
	add_user_substitutions([s(InputFileStr,'$INPUTFILES$'),s(OutFileStr,'$OUTPUTFILE$')],AllSubs),
	substitute_strings(AllSubs,ShellCmd1,ShCommand).

%% build list of substitution pairs for input files, and output file
build_substitution_list([],_,OutFile,[s(OutFile,'$OUT$')]).
build_substitution_list([InputFile|InputFiles],K,OutFile,[s(InputFile,InpVar)|SubList]) :-
	concat_atom(['$INP',K,'$'],InpVar),
	K1 is K+1,
	build_substitution_list(InputFiles,K1,OutFile,SubList).

mem_pair(View,Ver,[View|_Views],[Ver|_Vers]).
mem_pair(View,Ver,[_|Views],[_|Vers]) :-
	mem_pair(View,Ver,Views,Vers).

:- comment(generate_file_from_template/4,
"@pred{generate_file_from_template(+FileTempl,+Inst,+Ver,-FileName)}
takes a file template string (with embedded $$ variable names), an
instance name, @var{Inst}, and version number, @var{Ver}, and replaces
the variable names with their values, returnning @var{FileName}.  ").
generate_file_from_template(FileTempl,Inst,Ver,File) :-
	add_user_substitutions([s(Inst,'$INSTANCE$'),s(VerS,'$VERSION$')],SubList),
	cvt_to_string(Ver,VerS),
	substitute_strings(SubList,FileTempl,File).

add_user_substitutions(SubList,AllSubList) :-
	user_substitutions(UserSubList),
	append(SubList,UserSubList,AllSubList).

:- table user_substitutions/1.
user_substitutions(UserSubList) :-
	findall(s(Val,Var),get_viewsys_uservar(Var,Val),UserSubList0),
	xsb_configuration(install_dir,XSBHome),
	UserSubList1 = [s(XSBHome,'$XSB_HOME$')|UserSubList0],
	rec_apply_user_substitutions(UserSubList1,UserSubList1,10,UserSubList).

get_viewsys_uservar(Var,Val) :-
	viewsys_uservar(Var,Val0),
	(Val0 = lambda(Val,Goal)
	 ->	call_c(Goal)
	 ;	Val = Val0
	).

%% allow variable values to contain other variables.
rec_apply_user_substitutions([],_,_,[]).
rec_apply_user_substitutions([s(Val,Var)|RestSubs],UserSubList0,N,UserSubList) :-
	(N =< 0 -> throw(error('Loop in viewsys_uservar definitions.',_)) ; true),
	substitute_strings(UserSubList0,Val,Val1),
	(Val \== Val1
	 ->	N1 is N-1,
		rec_apply_user_substitutions([s(Val1,Var)|RestSubs],UserSubList0,N1,UserSubList)
	 ;	UserSubList = [s(Val,Var)|RestSubList],
		rec_apply_user_substitutions(RestSubs,UserSubList0,10,RestSubList)
	).

all_view_instances_generated([],_,[],[]).
all_view_instances_generated([ViewTerm|Views],Inst,[Ver|Vers],[InpFile|InpFiles]) :-
	functor(ViewTerm,View,_),
	\+ a_consistency_instance_ungenerated(View,Inst,Ver),
	view(View,_Type,LocTempl,_,_,_,_),
	generate_file_from_template(LocTempl,Inst,Ver,InpFile0),
	(viewInst(View,Inst,Ver,generated,_,_,_)
	 ->	add_inpfile_if_nec(InpFile0,ViewTerm,InpFile)
	 ; viewInst(View,Inst,Ver,_Stat,_Dt,[],_)
	 ->	InpFile = InpFile0
	 ;	viewInst(View,all,Ver,_Stat,_,[],_)
	),
	all_view_instances_generated(Views,Inst,Vers,InpFiles).

add_inpfile_if_nec(InpFile0,ViewTerm,InpFile) :-
	(ViewTerm =.. [_,FileSuff]
	 ->	concat_atom([InpFile0,'/',FileSuff],InpFile)
	 ;	InpFile = InpFile0
	).

a_consistency_instance_ungenerated(View,Inst,Ver) :-
	consView(ConsView,View,_,_,_,_),
	consViewInst(ConsView,Inst,Ver,VStatus,_,_,_),
	VStatus \== generated.

:- comment(invalidate_all_instances(ViewSys),
"@pred{invalidate_all_instances(+ViewSys)} invalidate all views, so a
subsequent invocation of @pred{update_views/4} would recompute them
all."  ).

invalidate_all_instances(ViewSys) :-
	load_viewfile_for_update(ViewSys),
	(viewInst(View,VInst,Ver,_State,Datime,InpVers,Began),
	 InpVers \== []
	 do_all
	 retractall(viewInst(View,VInst,Ver,_,_,_,_)),
	 assert(viewInst(View,VInst,Ver,not_generated,Datime,InpVers,Began))
	),
	(consViewInst(CView,View,Ver,_State,Datime,InpVers,Began)
	 do_all
	 retractall(consViewInst(CView,View,Ver,_,_,_,_)),
	 assert(consViewInst(CView,View,Ver,not_generated,Datime,InpVers,Began))
	),
	save_viewfile(ViewSys).

:- comment(invalidate_view_instances(ViewSys,ViewInstList), "
@pred{invalidate_view_instances(+ViewSys,+ViewInstList)} invalidates a
set of view instances indicated by @var{ViewInstList}.  If
@var{ViewInstList} is the atom 'all', this invalidates all instances
(exactly as @pred{invalidate_all_instances/1)} does.)  If
@var{ViewInstList} is a list of terms of the form
@var{View:VInst:0} then these indicated view instances (and all
views that depend on them) will be invalidated.  If @var{ViewInstList}
is the atom 'filetime', then the times of the instance files will be
used to invalidate view instances where the filetime of some view
instance input file is later than the filetime of the view instance
output file.  Note this does not account for the time it takes to run
the shell command that generates the view output, so for it to work,
no view instance input file should be changed while a view instance is
in the process of being generated.

This predicate can be used if a base instance file is replaced with a
new instance.  It can be used if the contents of a view instance are
found not to be correct, and the generating process has been modified
to fix it."  ).

invalidate_view_instances(ViewSys,all) :-
	!,
	invalidate_all_instances(ViewSys).
invalidate_view_instances(ViewSys,filetime) :-
	!,
	load_viewfile_for_update(ViewSys),
	findall(View:VInst:Ver,out_of_date_view_instance(View,VInst,Ver),ODVIs),
	collect_supported_view_instances(ODVIs,SupportedVIs),
	invalidate_each(SupportedVIs),
	save_viewfile(ViewSys).
invalidate_view_instances(ViewSys,ViewInstList) :-
	load_viewfile_for_update(ViewSys),
	collect_supported_view_instances(ViewInstList,SupportedVIs),
	invalidate_each(SupportedVIs),
	save_viewfile(ViewSys).

collect_supported_view_instances(ODVIs,SupportedVIs) :-
	findall(View:VInst:0,
		((viewInst(OOView,VInst,OOVer,_,_,_,_)
		  ;
		  consViewInst(OOView,VInst,OOVer,_,_,_,_)
		 ),
		 member(OOView:VInst:OOVer,ODVIs),
		 rtransitively_supports(OOView,View)
		),
		SupportedVIs0),
	sort(SupportedVIs0,SupportedVIs). % elim dupls

invalidate_each(InvalVIs) :-
	(do_all
	 member(View:VInst:Ver,InvalVIs),
	 (consViewInst(View,VInst,Ver,generated,Datime,InpVers,Began), %unchanged if failed somehow
	  InpVers \== []	%base views always generated
	  ->	 retractall(consViewInst(View,VInst,Ver,_,_,_,_)),
		 assert(consViewInst(View,VInst,Ver,not_generated,Datime,InpVers,Began)),
		 fmt_write(userout,'Invalidated consistency view %s:%s:%d\n',args(View,VInst,Ver))
	  ; viewInst(View,VInst,Ver,generated,Datime,InpVers,Began),
	    InpVers \== []
	  ->	 retractall(viewInst(View,VInst,Ver,_,_,_,_)),
		 assert(viewInst(View,VInst,Ver,not_generated,Datime,InpVers,Began)),
		 fmt_write(userout,'Invalidated view %s:%s:%d\n',args(View,VInst,Ver))
	 )
	).

/* approximate, since view generation could take time.  Should use
Began time rather than filetime, but OK if we assume base file isnt
updated until after view is generated. */
out_of_date_view_instance(View,VInst,Ver) :-
	%% only if it was generated can it be out-of-date
	viewInst(View,VInst,Ver,generated,_Datime,Vers,_Began),
	Vers \== [],		% base has nothing to compare to, cant be ood.
	view(View,Type,FileTempl,_SFT,SuppViews,_Opts,_Cmd),
	generate_file_from_template(FileTempl,VInst,Ver,ViewFile),
	(Type =.. [dir|RelFiles]
	 ->	findall(t(FT,ViewFileSub),(member(RelFile,RelFiles),
			    concat_atom([ViewFile,'/',RelFile],ViewFileSub),
			    file_time(ViewFileSub,FT)),
			FTs),
	 	FTs = [FT|FTRs],
		maxList(FTRs,FT,FileTimeP),
		FileTimeP = t(FileTime,FileName)
	 ;	file_time(ViewFile,FileTime),
		FileName = ViewFile
	),
	once((mem_pair(SuppView,SuppVer,SuppViews,Vers),
	      filetime_later(SuppView,VInst,SuppVer,FileTime,SuppFile))
	    ),
	writeln(userout,[ood_file=FileName,newer_file=SuppFile]),
	true.

maxList([],Max,Max).
maxList([X|Xs],CMax,Max) :-
	(X @> CMax
	 ->	maxList(Xs,X,Max)
	 ;	maxList(Xs,CMax,Max)
	).

filetime_later(View,VInst,Ver,FileTime,ViewFileSub) :-
	viewInst(View,VInst,Ver,_Status,_Datime,_Vers,_Began),
	view(View,Type,FileTemplate,_,_,_,_),
	generate_file_from_template(FileTemplate,VInst,Ver,ViewFile),
	((Type == file ; Type == dir)
	 ->	file_time(ViewFile,SFileTime),
		SFileTime >= FileTime,
		ViewFileSub = ViewFile
	 ; Type =.. [dir|RelFiles]
	 ->	member(RelFile,RelFiles),
		concat_atom([ViewFile,'/',RelFile],ViewFileSub),
		file_time(ViewFileSub,SFileTime),
		SFileTime > FileTime
	).

:- comment(reset_unfinished(ViewSys,ProcName), "
@pred{reset_unfinished(+ViewSys,+ProcName)} resets view instances that
are unfinished due to some abort, i.e., that are marked as
@tt{being_generated(ProcName)} after the @tt{view_update} process
named @tt{ProcName} is no longer running scripts to generate view
instances.  This should only be called when the @tt{ProcName}
@tt{view_update} process is not running.  The statuses of these view
instances will be reset to @tt{not_generated}.  After this, the next
applicable @pred{update_views/4} will try to recreate these view
instances."  ).

reset_unfinished(ViewSys,ProcName) :-
	load_viewfile_for_update(ViewSys),
	local_datime(Datime),
	(viewInst(View,ViewInst,Ver,being_generated(ProcName),_,Versions,Began)
	 do_all
	 retractall(viewInst(View,ViewInst,Ver,being_generated(ProcName),_,Versions,_)),
	 assert(viewInst(View,ViewInst,Ver,not_generated,Datime,Versions,Began)),
	 fmt_write(userout,'Unfinished view %s:%s:%d reset\n',args(View,ViewInst,Ver))
	),
	(consViewInst(View,ViewInst,Ver,being_generated(ProcName),_DT,Versions,Began)
	 do_all
	 retractall(consViewInst(View,ViewInst,Ver,being_generated(ProcName),_DT,Versions,_)),
	 assert(consViewInst(View,ViewInst,Ver,not_generated,Datime,Versions,Began)),
	 fmt_write(userout,'Unfinished consistency view %s:%s:%d reset\n',args(View,ViewInst,Ver))
	),
	save_viewfile(ViewSys).

:- comment(show_failed(VSDir,VInst),
"@pred{show_failed(+VSDir,+VInst)} displays each failed view
instance and consistency view instance, with file information to help
a user track down why the generation, or check, of the view failed.").

show_failed(VSDir,VInstInd) :-
	(VInstInd = all
	 ->	VInstList = [_]
	 ; atomic(VInstInd)
	 ->	VInstList = [VInstInd]
	 ;	VInstList = VInstInd
	),
	load_viewfile(VSDir),

	(member(VInst,VInstList),
	 viewInst(View,VInst,Ver,generation_failed,_,Versions,Began)
	 do_all
	 view(View,_type,FileTempl,StdoutFileTempl,_InpViews,_Opts,_ShCmd),
	 generate_file_from_template(FileTempl,VInst,Ver,File),
	 generate_file_from_template(StdoutFileTempl,VInst,Ver,StdFile),
	 fmt_write(userout,'\nFailed view: %s:%s:%d  began: %S\n',args(View,VInst,Ver,Began)),
	 fmt_write(userout,'    bad view file: %s\n',atgs(File)),
	 fmt_write(userout,'      stdout file: %s\n',atgs(StdFile))
	),
	
	(member(VInst,VInstList),
	 consViewInst(View,VInst,Ver,generation_failed,_,Versions,Began)
	 do_all
	 consView(View,ChkedView,CTempl,StdoutFileTempl,_InpViews,_ShCmd),
	 generate_file_from_template(CTempl,VInst,Ver,File),
	 generate_file_from_template(StdoutFileTempl,VInst,Ver,StdFile),
	 fmt_write(userout,'\nFailed consistency view: %s:%s:%d, began: %S\n',
		   args(View,VInst,Ver,Began)),
	 fmt_write(userout,'    checking view: %s\n',args(ChkedView)),
	 fmt_write(userout,'  bad output file: %s\n',atgs(File)),
	 fmt_write(userout,'      stdout file: %s\n',atgs(StdFile))
	).

:- comment(reset_failed(ViewSys,VInst), "
@pred{reset_failed(+ViewSys,+VInst)} resets view instances with name
@var{VInst} that had failed, i.e., that are marked as
@tt{generation_failed}.  Their status will be reset to
@tt{not_generated}, so after this, the next applicable call to
@pred{update_views/4} will try to regenerate the view.  If @var{VInst}
is 'all', then views of all instances will be reset."  ).

reset_failed(ViewSys,ViewInstPar) :-
	load_viewfile_for_update(ViewSys),
	reset_failed_1(ViewInstPar),
	save_viewfile(ViewSys).

reset_failed_1(all) :- !,
	local_datime(Datime),
	(viewInst(View,ViewInst,Ver,generation_failed,_,Versions,Began)
	 do_all
	 retractall(viewInst(View,ViewInst,Ver,generation_failed,_,_,_)),
	 assert(viewInst(View,ViewInst,Ver,not_generated,Datime,Versions,Began)),
	 fmt_write(userout,'Failed view %s:%s:%d reset\n',args(View,ViewInst,Ver))
	),
	(consViewInst(View,ViewInst,Ver,generation_failed,_,Versions,Began)
	 do_all
	 retractall(consViewInst(View,ViewInst,Ver,generation_failed,_,Versions,_)),
	 assert(consViewInst(View,ViewInst,Ver,not_generated,Datime,Versions,Began)),
	 consView(View,ChkedView,_,_,_,_), % reset views that were checked by failed checker.
	 (viewInst(ChkedView,ViewInst,Ver,_,DT,CVersions,CBegan)
	  do_all
	  retractall(viewInst(ChkedView,ViewInst,Ver,_,_,_,_)),
	  assert(viewInst(ChkedView,ViewInst,Ver,not_generated,DT,CVersions,CBegan)),
	  fmt_write(userout,'Failed view %s:%s:%d reset\n',args(ChkedView,ViewInst,Ver))
	 )
	).
reset_failed_1(ViewInstPar) :-
	local_datime(Datime),
	(viewInst(View,ViewInstPar,Ver,generation_failed,_,Versions,Began)
	 do_all
	 retractall(viewInst(View,ViewInstPar,Ver,generation_failed,_,_,_)),
	 assert(viewInst(View,ViewInstPar,Ver,not_generated,Datime,Versions,Began)),
	 fmt_write(userout,'Failed view %s:%s:%d reset\n',args(View,ViewInstPar,Ver))
	),
	(consViewInst(View,ViewInstPar,Ver,generation_failed,_DT,Versions,Began)
	 do_all
	 retractall(consViewInst(View,ViewInstPar,Ver,generation_failed,_,_,_)),
	 assert(consViewInst(View,ViewInstPar,Ver,not_generated,Datime,Versions,Began)),
	 fmt_write(userout,'Failed consistency view %s:%s:%d reset\n',args(View,ViewInstPar,Ver))
	).

:- comment(check_viewsys(ViewDir), " @pred{check_viewsys(+ViewDir)}
checks the contents of the @file{viewsys_view_info.P} file of the
@var{ViewDir} viewsys directory for consistency and completeness.").

check_viewsys(ViewDir) :-
	load_viewfile(ViewDir),
	(do_all
	 view_defined_from(View,DefView),
	 \+ view_name(DefView),
	 fmt_write(userout,'***ERROR: View "%s" used but not defined.\n',
		   args(DefView))
	),
	(do_all
	 view_name(View),
	 transitively_depends_on(View,View),
	 fmt_write(userout,'***ERROR: View "%s" depends on itself, which is illegal.\n',
		   args(View))
	),
	(do_all
	 consView(ConsView,View,_,_,_,_),
	 \+ view(View,_,_,_,ViewsDep,_,_),
	 ViewsDep \== [],
	 fmt_write(userout,'***ERROR: Consistency View "%s" checks view "%s", which does not exist.\n',
		   args(ConsView,View))
	),
	(do_all
	 view(View,_,_,_,[],_,_),
	 view(View,_,_,_,ViewsDep,_,_), ViewsDep \== [],
	 fmt_write(userout,'***ERROR: View "%s" is both a base and derived view.\n',
		   args(View))
	),
	(do_all
	 view(View,_,_,_,[],_,_),
	 consView(View,_,_,_,_,_),
	 fmt_write(userout,'***ERROR: View "%s" is both a base and consistency view.\n',
		   args(View))
	),
	(do_all
	 view(View,_,_,_,ViewsDep,_,_), ViewsDep \== [],
	 consView(View,_,_,_,_,_),
	 fmt_write(userout,'***ERROR: View "%s" is both a derived and consistency view.\n',
		   args(View))
	),
	(do_all
	 view(View,A,B,C,D,E,F),view(View,A1,B1,C1,D1,E1,F1),
	 p(A,B,C,D,E,F) \= p(A1,B1,C1,D1,E1,F1),
	 fmt_write(userout,'***ERROR: View "%s" has two definitions.\n',
		   args(View))
	),
	(do_all
	 consView(View,A,B,C,D,E),consView(View,A1,B1,C1,D1,E1),
	 p(A,B,C,D,E) \= p(A1,B1,C1,D1,E1),
	 fmt_write(userout,'***ERROR: Consistency view "%s" has two definitions.\n',
		   args(View))
	),
	(do_all
	 view(View,A,B,C,[],_,_),view(View,A1,B1,C1,[],_,_),
	 p(A,B,C) \= p(A1,B1,C1),
	 fmt_write(userout,'***ERROR: View "%s" has two definitions.\n',
		   args(View))
	),
	(do_all
	 view(View,_,_,_,InpViews,_,_),
	 member(SuppView,InpViews),
	 SuppView =.. [SView,SFile],
	 view(SView,SType,_,_,_,_,_),
	 \+ (SType =.. [dir|SFiles], member(SFile,SFiles)),
	 fmt_write(userout,'***ERROR: View %s uses directory subfile %s from view %s that is not defined in that view.\n',
		   args(View,SFile,SView))
	),
	fmt_write(userout,'View system: "%s" has been checked for consistency.',
		  args(ViewDir)).
	
:- comment(viewsys_status/1, " @pred{viewsys_status(+ViewDir)} prints
out the status of the view system indicated in @var{ViewDir} for all
the options in @pred{viewsys_status/2}. ").

viewsys_status(ViewDir) :-
	viewsys_status(ViewDir,all).

:- comment(viewsys_status/2, " @pred{viewsys_status(+ViewDir,+Option)}
prints out a particular list of view instance statuses as indicated by
the value of @var{option} as follows:

@begin{description}

@item{active:} View instances currently in the process of being
generated.

@item{roots:} Root View instances and their current statuses.  A root
view instance is one that no other view depends on.

@item{failed:} View instances whose generation has failed

@item{waiting:} View instances whose computations are waiting until
views they depend on are successfully update.

@item{checks_waiting:} View instances that are waiting for consistency
checks to be executed.

@item{checks_failed:} View instances whose checks have executed and
failed.

@end{description}

This predicate can be called in one shell when @pred{update_views/4}
is running in another shell.  This allows the user to monitor the
status a long-running invocation of @pred{update_views/4}.
	   ").

viewsys_status(ViewDir,Opt) :-
	load_viewfile(ViewDir),
	(member(Opt,[all,active])
	 ->	write(userout,'View Instances being generated:\n'),
		(viewInst(View,VInst,Version,being_generated(Proc),Date,_,_)
		 do_all
		 fmt_write(userout,"  %s:%s:%d by %s started %S.\n",
			   args(View,VInst,Version,Proc,Date))
		 if_none
		 writeln(userout,'  None')
		),
		nl(userout)
	 ;	true
	),
	(member(Opt,[all,roots])
	 ->	write(userout,'Root View Instances:\n'),
		(root_view_instance(View,VInst,Version)
		 do_all
		 viewInst(View,VInst,Version,VStatus,Date,_,_),
		 (\+ consView(_ConsView,View,_,_,_,_)
		  ->	 PStat = 'No'
		  ;	 (VStatus \== generated
			  ;	 
			  a_consistency_instance_ungenerated(View,VInst,Version)
			 )
		  ->	 PStat = 'Not passed'
		  ;	 PStat = 'Passed'
		 ),
		 fmt_write(userout,"  %s:%s:%d status %S %S (%s checks).\n",
			   args(View,VInst,Version,VStatus,Date,PStat))
		 if_none
		 writeln(userout,'  None')
		),
		nl(userout)
	 ;	true
	),
	(member(Opt,[all,waiting])
	 ->	write(userout,'View Instances awaiting generation:\n'),
		(viewInst(View,VInst,Version,not_generated,_Date,_,_)
		 do_all
		 fmt_write(userout,"  %s:%s:%d\n",
			   args(View,VInst,Version))
		 if_none
		 writeln(userout,'  None')
		),
		nl(userout)
	 ;
	 true
	),
	(member(Opt,[all,failed])
	 ->	write(userout,'View Instances whose generation failed:\n'),
		(viewInst(View,VInst,Version,generation_failed,Date,_,_)
		 do_all
		 fmt_write(userout,"  %s:%s:%d failed at %S.\n",
			   args(View,VInst,Version,Date))
		 if_none
		 writeln(userout,'  None')
		),
		nl(userout)
	 ;	true
	),
	(member(Opt,[all,checks_waiting])
	 ->	write(userout,'View Instances awaiting consistency checks:\n'),
		(viewInst(View,VInst,Version,generated,Date,_,_),
		 consView(ConsView,View,_,_,_,_),
		 consViewInst(ConsView,VInst,Version,being_generated(Proc),CDate,_,_)
		 do_all
		 fmt_write(userout,"  %s:%s:%d, generated at %S, is awaiting consistency check %s, by %s started %S.\n",
			   args(View,VInst,Version,Date,ConsView,Proc,CDate))
		 if_none
		 writeln(userout,'  None')
		),
		nl(userout)
	 ;	true
	),
	(member(Opt,[all,checks_failed])
	 ->	write(userout,'View Instances whose consistency checks failed:\n'),
		(viewInst(View,VInst,Version,generated,Date,_,_),
		 consView(ConsView,View,_,_,_,_),
		 consViewInst(ConsView,VInst,Version,generation_failed,CDate,_,_)
		 do_all
		 fmt_write(userout,"  %s:%s:%d has failed consistency check %s, failed at %S.\n",
			   args(View,VInst,Version,ConsView,CDate))
		 if_none
		 writeln(userout,'  None')
		)
	 ;      true
	).


root_view_instance(View,VInst,Version) :-
	root_view(View),
	viewInst(View,VInst,Version,_VStatus,_Date,_Versions,_Began).

:- comment(print_viewsys(ViewDir), " @pred{print_viewsys(+ViewDir)}
prints an indented hierarchy of the view definitions."  ).

print_viewsys(ViewDir) :-
	load_viewfile(ViewDir),
	findall(RootView,root_view(RootView),RootViews),
	print_viewsys_tree(RootViews,0,[],_).

print_viewsys_tree([],_,Printed,Printed).
print_viewsys_tree([ViewTerm|Views],Ind,Printed0,Printed) :-
	functor(ViewTerm,View,_),
	(member(View,Printed0)
	 ->	tab(Ind),write(userout,'*'), % previously expanded.
		writeln(userout,View),
		Printed2 = Printed0
	 ; view(View,VType,VFileTempl,StdOutTempl,SuppViews,Opts,Script), SuppViews \== []
	 ->	tab(Ind),fmt_write(userout,"%s (view) %S\n",args(View,VType)),
		tab(Ind),fmt_write(userout,"        file template  : %s\n",args(VFileTempl)),
		tab(Ind),fmt_write(userout,"        stdout template: %s\n",args(StdOutTempl)),
		tab(Ind),fmt_write(userout,"        options        : %S\n",args(Opts)),
		tab(Ind),fmt_write(userout,"        command        : %s\n",args(Script)),
		Ind1 is Ind+3,
		print_cons_tree(View,Ind1,[View|Printed0],Printed1),
		print_viewsys_tree(SuppViews,Ind1,Printed1,Printed2)
	 ; view(View,VType,VFileTempl,Src,[],_,_)
	 ->	tab(Ind),fmt_write(userout,"%s (base) %S\n",args(View,VType)),
		tab(Ind),fmt_write(userout,"        file template  : %s\n",args(VFileTempl)),
		tab(Ind),fmt_write(userout,"        source         : %s\n",args(Src)),
		print_cons_tree(View,Ind,[View|Printed0],Printed2)
	),
	print_viewsys_tree(Views,Ind,Printed2,Printed).
	
print_cons_tree(View,Ind,Printed0,Printed1) :-
	findall(CView,consView(CView,View,_,_,_,_),CViews),
	print_cons_trees(CViews,Ind,Printed0,Printed1).
	
print_cons_trees([],_Ind,Printed,Printed).
print_cons_trees([CView|CViews],Ind,Printed0,Printed) :-
	consView(CView,View,FileTempl,StdoutTempl,SuppViews,Script),
	tab(Ind),fmt_write(userout,"%s Consistency view for %s\n",args(CView,View)),
	tab(Ind),fmt_write(userout,"        file template  : %s\n",args(FileTempl)),
	tab(Ind),fmt_write(userout,"        stdout template: %s\n",args(StdoutTempl)),
	tab(Ind),fmt_write(userout,"        command        : %s\n",args(Script)),
	Ind1 is Ind+3,
	print_viewsys_tree(SuppViews,Ind1,[CView|Printed0],Printed1),
	print_cons_trees(CViews,Ind,Printed1,Printed).
	
/********************************************************/
/* "macro" expand for split...				*/
/********************************************************/

:- comment(expand_views(ViewSys), " @pred{expand_views(+ViewSys)}
processes view/7 definitions that have a split(N) option, generates
the necessary new view/7 facts to do the split, component processing,
and rejoin.  It overwrites the viewsys_view_info.P file, putting the
original view/7 facts into viewOrig/7 facts.  This must be called (if
necessary) when creating a new viewsys system and before calling
generate_view_instance/2. " ).

expand_views(ViewSys) :-
	load_viewfile_view_orig_for_update(ViewSys),
	(view(View,Type,NameTempl,StdoutTempl,InpViews,Opts,Cmd),
	 InpViews \== [],
	 select(split(N),Opts,RemOpts)
	 do_all
	 retractall(view(View,_,_,_,_,_,_)),
	 assert(viewOrig(View,Type,NameTempl,StdoutTempl,InpViews,Opts,Cmd)),
	 expand_split(N,View,Type,NameTempl,StdoutTempl,InpViews,RemOpts,Cmd)
	),
	save_viewfile_view(ViewSys).

%% generate split view
expand_split(N,View,Type,NameTempl,StdoutTempl,InpViews,Opts,Cmd) :-
	concat_atom([View,'_split'],SplitView),
	(concat_atom([NameBase,'.',Suff],NameTempl),
	 \+ str_sub('.',Suff)
	 ->	true
	 ;	NameBase = NameTempl
	),
	concat_atom([NameBase,'_splitdir'],SplitName),
	(concat_atom([StdoutBase,'.txt'],StdoutTempl)
	 ->	true
	 ;	StdoutBase = SplitStdout
	),
	InpViews = [ViewToSplit|RemViews],
	
	(%% view to split
	 concat_atom([StdoutBase,'_split.txt'],SplitStdout),
	 findall(SubFile,
		 (for_alpha3(1,N,"aaa",Alpha),concat_atom([infile_,Alpha],SubFile)),
		 SubFiles),
	 DirType =.. [dir|SubFiles],
	 assert(view(SplitView,DirType,SplitName,SplitStdout,[ViewToSplit],Opts,'sh ./view_split.sh')),
	 fail
	 ;	%% views to do the work
	 for_alpha3(1,N,"aaa",Alpha),
	 concat_atom([View,'_each_',Alpha],EachViewName),
	 concat_atom([SplitName,'/outfile_',Alpha],CompFileName),
	 concat_atom([StdoutBase,'_split_',Alpha,'.txt'],CompStdout),
	 concat_atom(['infile_',Alpha],Infile),
	 SplitViewTerm =.. [SplitView,Infile],
	 assert(view(EachViewName,file,CompFileName,CompStdout,[SplitViewTerm|RemViews],
		     [],Cmd)),
	 fail
	 ;	%% view to recombine results
	 findall(EachView,
		 (for_alpha3(1,N,"aaa",Alpha),concat_atom([View,'_each_',Alpha],EachView)),
		 EachViews),
	 assert(view(View,Type,NameTempl,StdoutTempl,EachViews,[],
		     'sh $XSB_HOME$/packages/viewsys/cat_script.sh $OUTPUTFILE$ $INPUTFILES$')),
	 fail
	 ;
	 true
	).


for_alpha3(I,N,LAlpha,Alpha) :-
	I =< N,
	atom_codes(Alpha,LAlpha).
for_alpha3(I,N,[A1,A2,A3],Alpha) :-
	I < N,
	I1 is I+1,
	(A3 < 0'z
	 ->	A3p is A3+1,
		for_alpha3(I1,N,[A1,A2,A3p],Alpha)
	 ; A2 < 0'z
	 ->	A2p is A2+1,
		for_alpha3(I1,N,[A1,A2p,0'a],Alpha)
	 ; A1 < 0'z
	 ->	A1p is A1+1,
		for_alpha3(I1,N,[A1p,0'a,0'a],Alpha)
	 ;	throw(error('Alpha overflow; too many split components'))
	).
	


/********************************************************/
/* view table utilities					*/
/********************************************************/
:- use_subsumptive_tabling transitively_depends_on(-,-).
transitively_depends_on(View,DefView) :-
	(view(View,_,_,_,SuppViews,_,_) ; consView(View,_,_,_,SuppViews,_)),
	member(DefViewTerm,SuppViews),
	functor(DefViewTerm,DefView,_).
transitively_depends_on(View,DefView) :-
	transitively_depends_on(View,DefView1),
	(view(DefView1,_,_,_,SuppViews,_,_) ; consView(DefView1,_,_,_,SuppViews,_)),
	member(DefViewTerm,SuppViews),
	functor(DefViewTerm,DefView,_).

:- use_subsumptive_tabling rtransitively_supports(-,-).
rtransitively_supports(View,View).
rtransitively_supports(View,SupportedView) :-
	transitively_depends_on(SupportedView,View).

/********************************************************/
/* file load utilities					*/
/********************************************************/
load_viewfile(ViewDir) :-
	load_viewfile_for_update(ViewDir),
	unlock_view(ViewDir).

load_viewfile_for_update(ViewDir) :-
	abolish_table_pred(transitively_depends_on(_,_)),
	abolish_table_pred(rtransitively_supports(_,_)),
	(view_info_pred(Goal)
	 do_all
	 retractall(Goal)
	),
	(view_inst_info_pred(Goal)
	 do_all
	 retractall(Goal)
	),
	view_file_name(ViewDir,ViewFile),
	view_instance_file_name(ViewDir,ViewInstFile),
	lock_view(ViewDir),
	readin_viewfile(ViewFile),
	readin_viewfile(ViewInstFile).

readin_viewfile(ViewFile) :-
	%%writeln(userout,readin_file(ViewFile)),
	(file_exists(ViewFile)
	 ->	open(ViewFile,read,IStr),
		repeat,
		read_canonical(IStr,Term),
		(Term \== end_of_file
		 ->	assert(Term),
			fail
		 ;	!
		),
		close(IStr)
	 ;	true
	).

load_viewfile_view_orig_for_update(ViewDir) :-
	abolish_table_pred(transitively_depends_on(_,_)),
	abolish_table_pred(rtransitively_supports(_,_)),
	(view_info_pred(Goal)
	 do_all
	 retractall(Goal)
	),
	view_orig_file_name(ViewDir,ViewFile),
	lock_view(ViewDir),
	readin_viewfile(ViewFile).
	
:- import viewsys_uservar/2, baseView/4, view/7, consView/6, viewInst/7, consViewInst/7,
	viewsys_required_file/1
	from usermod.
:- dynamic viewsys_uservar/2.
:- dynamic viewsys_required_file/1.
:- dynamic baseView/4.
:- dynamic view/7.
:- dynamic consView/6.
:- index(consView/6,[1,2]).
:- dynamic viewInst/7.
:- dynamic consViewInst/7.

view_info_pred(viewsys_required_file(_)).
view_info_pred(viewsys_uservar(_,_)).
view_info_pred(view(_,_,_,_,_,_,_)).
view_info_pred(viewOrig(_,_,_,_,_,_,_)).
view_info_pred(consView(_,_,_,_,_,_)).

view_inst_info_pred(viewInst(_,_,_,_,_,_,_)).
view_inst_info_pred(consViewInst(_,_,_,_,_,_,_)).

save_viewfile(ViewDir) :-
	view_instance_file_name(ViewDir,ViewFile),
	%%writeln(userout,saving_file(ViewFile)),
	open(ViewFile,write,OStr),
	(view_inst_info_pred(Goal),
	 call_c(Goal),
	 write_canonical(OStr,Goal),
	 writeln(OStr,'.'),nl(OStr),
	 fail
	 ;	
	 true
	),
	close(OStr),
	unlock_view(ViewDir).

save_viewfile_view(ViewDir) :-
	view_file_name(ViewDir,ViewFile),
	open(ViewFile,write,OStr),
	(view_info_pred(Goal),
	 call_c(Goal),
	 write_canonical(OStr,Goal),
	 writeln(OStr,'.'),nl(OStr),
	 fail
	;      
	 true
	),
	close(OStr),
	unlock_view(ViewDir).
	
/********************************************************/
/* view table access predicates 			*/
/********************************************************/

root_view(RootView) :-
	view(RootView,_,_,_,_,_,_),
	\+ view_defined_from(_,RootView).

view_name(VName) :-
	view(VName,_,_,_,_,_,_).
view_name(VName) :-
	consView(VName,_,_,_,_,_).

view_defined_from(VName,SuppView) :-
	(view(VName,_,_,_,SuppViews,_,_)
	 ;
	 consView(VName,_,_,_,SuppViews,_)
	),
	member(SuppViewTerm,SuppViews),
	functor(SuppViewTerm,SuppView,_).

/********************************************************/
/* Locking routines 					*/
/********************************************************/

lock_view(Dir) :-
	view_lockfile_name(Dir,ViewLockFile),
	get_lock(ViewLockFile,1).

unlock_view(Dir) :-
	view_lockfile_name(Dir,ViewLockFile),
	%%writeln(userout,removing_lockfile),
	rm(ViewLockFile).

view_lockfile_name(Dir,ViewLockFile) :-
	concat_atom([Dir,'/lock_view'],ViewLockFile).

view_file_name(ViewDir,ViewFile) :-
	concat_atom([ViewDir,'/viewsys_view_info.P'],ViewFile).

view_orig_file_name(ViewDir,ViewFile) :-
	concat_atom([ViewDir,'/viewsys_view_orig_info.P'],ViewFile).

view_instance_file_name(ViewDir,ViewInstFile) :-
	concat_atom([ViewDir,'/viewsys_instance_info.P'],ViewInstFile).

get_lock(LockFile,N) :-
	(create_lockfile(LockFile)
	 ->	true %,writeln(userout,created_lockfile)
	 ;	(N mod 5 =:= 0
		 ->	writeln(userout,'Failed to get lock, still trying '(N,LockFile))
		 ;	true
		),
		N1 is N+1,
		sleep(1),
		get_lock(LockFile,N1)
	).

display_datime_diff(datime(Yr,Mo,Da,Hr,Mi,Se),Time) :-
	 (Yr=:=0, Mo=:=0
	  ->	 (Da=:=0
		  ->	 (Hr =:= 0
			  ->	 fmt_write_string(Time,"%02d:%02d",args(Mi,Se))
			  ;	 fmt_write_string(Time,"%02d:%02d:%02d",args(Hr,Mi,Se))
			 )
		  ;	 fmt_write_string(Time,"%2d days, %02d:%02d:%02d",args(Da,Hr,Mi,Se))
		 )
	  ;	 fmt_write_string(Time,"%d years, %2d months, %2d days, %02d:%02d:%02d",args(Yr,Mo,Da,Hr,Mi,Se))
	 ).

datime_diff(datime(Yr1,Mo1,Day1,Hr1,Min1,Sec1),
	    datime(Yr2,Mo2,Day2,Hr2,Min2,Sec2),
	    datime(Yr,Mo,Day,Hr,Min,Sec)) :-
	(Sec1 >= Sec2
	 ->	Sec is Sec1-Sec2, Min3 = Min1
	 ;	Sec is Sec1+60-Sec2, Min3 is Min1-1
	),
	(Min3 >= Min2
	 ->	Min is Min3-Min2, Hr3 = Hr1
	 ;	Min is Min3+60-Min2, Hr3 is Hr1-1
	),
	(Hr3 >= Hr2
	 ->	Hr is Hr3-Hr2, Day3 = Day1
	 ;	Hr is Hr3+24-Hr2, Day3 is Day1-1
	),
	(Day3 >= Day2
	 ->	Day is Day3-Day2, Mo3 = Mo1
	 ;	Mo3 is Mo1-1,
		modays(Mo3,MoDays),
		Day is Day3+MoDays-Day2
	),
	(Mo3 >= Mo2
	 ->	Mo is Mo3-Mo2, Yr3 = Yr1
	 ;	Mo is Mo3+12-Mo2, Yr3 is Yr1-1
	),
	Yr is Yr3-Yr2.

%% really datime-diff sum
datime_sum(datime(Yr1,Mo1,Day1,Hr1,Min1,Sec1),
	   datime(Yr2,Mo2,Day2,Hr2,Min2,Sec2),
	   datime(Yr,Mo,Day,Hr,Min,Sec)) :-
	SecA is Sec1 + Sec2,
	(SecA >= 60 -> Sec is SecA-60, SecC = 1 ; Sec = SecA, SecC = 0),
	MinA is Min1 + Min2 + SecC,
	(MinA >= 60 -> Min is MinA-60, MinC = 1 ; Min = MinA, MinC = 0),
	HrA is Hr1 + Hr2 + MinC,
	(HrA >= 24 -> Hr is HrA-24, HrC = 1 ; Hr = HrA, HrC = 0),
	DayA is Day1 + Day2 + HrC,
	(DayA >= 30 -> Day is DayA-30, DayC = 1 ; Day = DayA, DayC = 0),
	MoA is Mo1 + Mo2 + DayC,
	(MoA >= 12 -> Mo is MoA-12, MoC = 1 ; Mo = MoA, MoC = 0),
	Yr is Yr1 + Yr2 + MoC.

modays(0,31).
modays(1,31).
modays(2,28). %HACK,NOT RIGHT!
modays(3,31).
modays(4,30).
modays(5,31).
modays(6,30).
modays(7,31).
modays(8,31).
modays(9,30).
modays(10,31).
modays(11,30).
modays(12,31).

cvt_to_string(Ver,VerS) :-
	(number(Ver)
	 ->	number_codes(Ver,VerC),
		atom_codes(VerS,VerC)
	 ;	VerS = Ver
	).

substitute_strings(Subs,StringIn,String) :-
	substitute_strings(Subs,20,StringIn,String).

substitute_strings(_,0,StringIn,StringIn) :- !,
	throw(error('ERROR: loop in substitute_strings/3',[])).
substitute_strings([],_,StringIn,StringIn) :- !.
substitute_strings(Subs,N,StringIn,String) :-
	N1 is N-1,
	Subs = [s(Sub,Repl)|Subs1],
	(str_match(Repl,StringIn,forward,Beg,End)
	 ->	string_substitute(StringIn,[s(Beg,End)],[Sub],StringIn1),
		substitute_strings(Subs,N1,StringIn1,String)
	 ;	substitute_strings(Subs1,N1,StringIn,String)
	).

:- comment(generate_required_dirs/2, " This predicate can be used to
help the user generate @pred{viewsys_required_file/1} facts that may
help in configuration and deployment of view systems.  It is not
needed to create and run normal view systems, only help configure the
viewsys_view_info.P file to support using @pred{copy_required_files/2}
to move them for deployment, when that is necessary.

@pred{generate_required_dirs(+SubstList,+LogFiles)} takes an
XSB_LOGFILE (or list of XSB_LOGFILEs), normally generated by running a
step in the view system, and generates (to userout)
viewsys_required_file/1 facts.  These can be edited and the copied
into the viewsys_view_info.P file to document what directories (XSB
code and general data files) are required for running this view
system.  The viewsys_required_file/1 facts are used by
copy_required_files/2 to generate a new set of files that can run the
view system.

@var{SubstList} is a list of substitutions of the form
@tt{s(VarString,RootDir)} that are applied to @em{generalize} each
directory name.  For example if we have a large library file
structure, in subdirectores of @file{C:/XSBSYS/XSBLIB}, the many
loaded files (in an @file{XSB_LOGFILE}) will start with this prefix,
for example, @file{C:/XSBSYS/XSBLIB/apps/app_1/proc_code.xwam}.  By
using the substitution, @tt{s('$DIR$','C:/XSBCVS/XSBLIB')}, that file
name will be abstracted to: @tt{'$DIR$/apps/app_1'} in the
@pred{viewsys_required_file/1} fact.  Then @pred{copy_required_files/2}
can replace this variable @tt{$DIR$} with different roots to determine
the source and target of the copying.

@var{LogFiles} is an @tt{XSB_LOGFILE}, that is generated by running
xsb and initially calling machine:stat_set_flag(99,1).  This will
generate a file named @file{XSB_LOGFILE.txt} (in the current
directory) that contains the names of all files loaded during that
execution of xsb.  (If the flag is set to @{tt}K > 1, then the name of
the generated file will be @tt{XSB_LOGFILE_<K>.txt} where @tt{<K>} is
the number @tt{K}.)

So, for example, after running three steps in a workflow, setting flag
99 to 2, 3, and 4 for each step respectively, one could execute:
@begin{verbatim}	   
| ?- generate_required_dirs([s('$DIR$','C:/XSBCVS/XSBLIB')],
                            ['XSB_LOGFILE_2.txt',
                             'XSB_LOGFILE_3.txt',
                             'XSB_LOGFILE_4.txt']).
@end{verbatim}	   

@noindent which would print out facts for all directories for files in
those LOGFILEs, each with the root directory abstracted.
").

generate_required_dirs(Substitutions,XSB_LFs) :-
	(do_all
	 logfile_directory(XSB_LFs,Dir0),
	 substitute_strings(Substitutions,Dir0,Dir),
	 writeq(userout,viewsys_required_file(Dir)),
	 writeln(userout,'.')
	).

:- comment(copy_required_files/2, " This predicate can be used
(perhaps with configuration help from @pred{generate_required_dirs/2})
to copy and deploy view systems and the files they need to run.  This
predicate is not needed for normal execution of view systems.

@pred{copy_required_files(+VSDir,+FromToSubs)} uses the
@pred{viewsys_required_file/1} facts in the @file{viewsys_view_info.P}
file in the @var{VSDir} viewsys directory to copy all directories (and
files) in those facts.  @var{FromToSubs} are terms of the form
@tt{s(USERVAR,FROMVAL,TOVAL)}, where @tt{USERVAR} is a variable in the
file templates in the @pred{viewsys_required_file/1} facts.  A
recusrive @tt{cp} shell command will be generated and executed for
each template in @pred{viewsys_required_file/1}, the source file being
the template with @tt{USERVAR} replaced by @tt{FROMVAL} and the target
file being the template with @tt{USERVAR} replaced by @tt{TOVAL}.

All necessary intermediate directories will be automatically created.

E.g.,
@begin{verbatim}
copy_required_files('.',[s('$DIR$','C:/XSBSYS/XSBLIB','C:/XSBSYS/XSBTEST/XSBLIB')]).
@end{verbatim}

@noindent would copy all files/directories indicated in the
@pred{viewsys_required_file/1} facts in the local
@file{viewsys_view_info.P} file from under @tt{C:/XSB/XSBLIB} to a
(possibly) new directory @file{C:/XSBSYS/XSBTEST/XSBLIB} (assuming all file
templates were rooted with @tt{$DIR$}.)
").

copy_required_files(VSDir,FromToSubs) :-
	load_viewfile(VSDir),
	findall(s(FromVal,Var),member(s(Var,FromVal,_),FromToSubs),FromSubList),
	findall(s(ToVal,Var),member(s(Var,_,ToVal),FromToSubs),ToSubList),
	(do_all
	 viewsys_required_file(FileTempl),
	 substitute_strings(FromSubList,FileTempl,FromDirectory),
	 substitute_strings(ToSubList,FileTempl,ToDirectory),
	 ensure_directories_exist(ToDirectory,userout),
	 shell(['cp -r "',FromDirectory,'" "',ToDirectory,'"'])
	).

logfile_file(LogFiles0,File) :-
	(atom(LogFiles0)
	 ->	LogFiles = [LogFiles0]
	 ;	LogFiles = LogFiles0
	),
	findall(Fil,
		(member(LogFile,LogFiles),
		 file_codes_in(LogFile,FilCodes0),
		 to_forward_slash_codes(FilCodes0,FilCodes),
		 atom_codes(Fil,FilCodes) ),
		Fils),
	sort(Fils,UFils),
	member(File,UFils).

logfile_directory(LogFiles0,Directory) :-
	(atom(LogFiles0)
	 ->	LogFiles = [LogFiles0]
	 ;	LogFiles = LogFiles0
	),
	findall(Dir,
		(member(LogFile,LogFiles),
		 directory_codes_in(LogFile,DirCodes0),
		 to_forward_slash_codes(DirCodes0,DirCodes),
		 atom_codes(Dir,DirCodes) ),
		Dirs),
	sort(Dirs,UDirs),
	member(Directory,UDirs).

directory_codes_in(LogFile,DirectoryCodes) :-
	file_codes_in(LogFile,FileCodes),
	once(lappend(DirectoryCodes,[0'\\'|_],FileCodes)).


file_codes_in(LogFile,FileCodes) :-
	file_line_list_file(LogFile,CodeList),
	append_list([CWDCodes,": ",FileCodesle],CodeList),
	(FileCodesle = [0'.'|RelFileCodesle]
	 ->	append(CWDCodes,RelFileCodesle,AbsFileCodesle)
	 ;	AbsFileCodesle = FileCodesle
	),
	(append(FileCodes,"\r\n",FileCodesle)
	 ->	true
	 ; append(FileCodes,"\n",FileCodesle)
	 ->	true
	 ;	FileCodes = FileCodesle
	).

append_list([L],L) :- !.
append_list([L|Ls],FL) :-
	append_list(Ls,FL0),
	append(L,FL0,FL).

file_line_list_file(File,Line) :-
	open(File,read,IStr),
	file_line_list_file1(IStr,Line).

file_line_list_file1(IStr,Line) :-
	(file_read_line_list(IStr,Line0)
	 ->	(Line = Line0
		 ;
		 file_line_list_file1(IStr,Line)
		)
	 ;	close(IStr),
		fail
	).

to_forward_slash_codes([],[]).
to_forward_slash_codes([C|Cs],[R|Rs]) :-
	(C =:= 0'\\'
	 ->	R = 0'/'
	 ;	R = C
	),
	to_forward_slash_codes(Cs,Rs).

