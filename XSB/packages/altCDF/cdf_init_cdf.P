:- compiler_options([ciao_directives]).

:- export
	cdf_id_fields/4,
	isa/2, immed_isa/2, implicit_isa/2,proper_isa/2,
	hasAttr/3, immed_hasAttr/3, 
	allAttr/3, immed_allAttr/3, 
	classHasAttr/3, immed_classHasAttr/3, 
	in_hierarchy/1,
	newExtTerm/1, retractallExtTerm/1,
	initialize_state/0, system_component/1, initialize_cdf/0,
	set_chk_index/0,
	assert_cdf/1, retractall_cdf/1,
	cdf_set_log_on/0, cdf_set_log_off/0, cdf_reset_log/0, show_log/0,
	updateExtTerm/3.

:- (search_module(cdf_xj,_,_,_,_,_)
    ->	   consult(cdf_xj)
    ;	   consult(cdf_cdf)
   ).

:- import check_implication/2, check_types/2,
	classify_if_necessary/3
	from cdf_checks.

:- import isa_ext/2, hasAttr_ext/3, classHasAttr_ext/3, allAttr_ext/3 
							from usermod.

:- import isa_int/2, hasAttr_int/3, classHasAttr_int/3, allAttr_int/3 
							from  usermod.
:- import cdf_flags/2, cdf_log_trie/1, 
	  assert_cdf_int/1, retractall_cdf_int/1 from usermod.

:- import load_component/3 from cdf_components.

:- import cdf_error/2 from cdf_exceptions.
:- import make_cdf_dirty/1, make_cdf_clean/0, cdf_update_list/1
%%	from cdf_xj.
	from cdf_cdf.
:- import get_component_extensional/2 	from cdf_components.

:- import '_$index'/3 from file_op.
%:- import conset/2, conget/2 from gensym.
:- import ground/1, member/2 from basics.
:- import abolish_table_pred/1 from tables.
:- import search_module/6 from consult.
:- import new_trie/1, delete_trie/1, trie_interned/4, 
	  trie_unintern_nr/2, trie_intern/5 from intern.

%%%%%%%%%%%%% Core Declarations 

cdf_dynamic(isa_ext/2).
cdf_index(isa_ext,2,[*(1),*(2)]).

cdf_dynamic(hasAttr_ext/3).
cdf_index(hasAttr_ext,3,[*(1) + *(2),*(1),*(2) + *(3)]).
cdf_dynamic(classHasAttr_ext/3).
cdf_index(classHasAttr_ext,3,[*(1) + *(2),*(1),*(2) + *(3)]).
cdf_dynamic(allAttr_ext/3). 
cdf_index(allAttr_ext,3,[*(1) + *(2),*(1),*(2) + *(3)]).

cdf_dynamic(cdf_logging_state/1).
cdf_dynamic(cdf_log_trie/1).

%%%%%%%%%%%%% Declarations for External Intensional View

cdf_dynamic(isa_int/2).

cdf_dynamic(hasAttr_int/3).
cdf_dynamic(classHasAttr_int/3).
cdf_dynamic(allAttr_int/3).

cdf_index(_,_,_,_):- fail.

%%%%%%%%%%%%% Declarations for caching and XJ interface
/* TLS
:- ensure_loaded(cdf_oblivion).
*/

%%%%%%%%%%%%% Declarations for updatable DB
%%:- ensure_loaded(cdf_db_updatable).

cdf_dynamic(cdf_extint_updatable/1).
%cdf_dynamic(newAttribute_int/3).

cdf_dynamic(assert_cdf_int/1).
cdf_dynamic(retractall_cdf_int/1).

%%%%%%%%%%%%% Declarations for constraint checking

:- ensure_loaded(cdf_config).

:- initialize_cdf.

initialize_cdf:- 
	init_dynamic_code,
	init_index_std,
	retractall(cdf_logging_state(_)),
	asserta(cdf_logging_state(off)),
	cdf_set_log_off,
	load_component(cdf,'',[]),
	load_component(cdfpt,'',[]),
	make_cdf_clean.
	
init_dynamic_code:- 
	cdf_dynamic(F/A),
	dynamic(F/A),
	fail.
init_dynamic_code.

%--------------------------------------------------------------------

:- comment(module,"@section{Using CDF}

@tt{cdf_init_cdf.P} contains most of the predicates needed to
initialize, query or update a CDF state.  It is loaded automatically
upon loading the CDF package.

@section{Builtin Classes and Relations}

The following classes and relations are defined in @em{every} CDF
state.

@begin{itemize}

@item @tt{id(CDF Root,cdf)} @cindex{CDF Root}: Root node of the
Ontology.  Includes all objects and relation tuples.  As a result, all
classes are subclasses of @tt{cid('CDF Root',cdf)} and all relations
are subrelations of @tt{cid('CDF Root',cdf)}.

As mentioned in previous sections, CDF relations can define
inheritable attributes which hold for isaes and objects, inheritable
constraints on attributes, and non-inheritable properties of sets.

@item @tt{cid('CDF Classes',cdf)}: 
@cindex{CDF Classes}

Includes every object of any class.  Defined as an immediate
subclass of @tt{id('CDF Root',cdf)}.

@item @tt{rid('CDF Object-Object Relations',cdf)}: 
@cindex{CDF Object-Object Relations}

Includes all inheritable relation tuples.  Defined as an immediate
subrelation of @tt{id('CDF Root',cdf)}.

@item @tt{crid('CDF Class-Object Relations',cdf)}: 
@cindex{CDF Class-Object Relations}

Includes all non-inheritable class-object relation tuples.
Defined as an immediate subrelation of @tt{id('CDF Root',cdf)}.

@item @tt{crid('CDF Higher-Order Class-Object Relations',cdf)}: 
@cindex{CDF Higher-Order Class-Object Relations}

Includes all higher-order class-object relations on relations.
Defined as an immediate subrelation of @tt{id('CDF Root',cdf)}.

@item @tt{id('CDF Primitive Types',cdfpt)}: 
@cindex{CDF Primitive Types}

Includes several primitive types defined via intensional rules,
including Prolog integers, floats and atoms.  This is an immediate
subclass of @tt{cid('CDF Classes',cdf)}

@end{itemize}

@bf{TLS: will add something about names and descriptions once
higher-order relations are implemented.}

"). 

%%% (Re-)Initialization %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TLS: initialize_state/0 may not get used heavily, but I think its useful
% to have all the re-initialization stuff here in one place, to record
% what the state consists of and to make future maintenance easier. 

:- comment(initialize_state/0,"Normally, initialization is done
automatically upon loading CDF at the start of a session.  The routine
@pred{initialize_state/0} should be called only when a state is to be
reinitialized during a session.  This predicate removes all data in
extensional and intensional forat, and reasserts the basic CDF classes
and relations, and resets internal state variables to values in the
CDF configuration file. ").

initialize_state:- 
	reset_dynamics,
	retractall(cdf_logging_state(_)),
	asserta(cdf_logging_state(off)),
	cdf_set_log_off,
	load_component(cdf,'',[]),
	load_component(cdfpt,'',[]),
	make_cdf_clean.

reset_dynamics:- 
	cdf_dynamic(F/A),
	functor(T,F,A),
	retractall(T),
	fail.
reset_dynamics.

%-------

init_index_std :-
	(    cdf_index(F,A,I),index(F/A,I)
	   ; cdf_index(F,A,I,N),index(F/A,I,N)  ),
	fail.
init_index_std.

%-------

system_component(cdf).
system_component(cdfpt).

:-
comment(cdf_id_fields/4,"@tt{cdf_id_fields(ID,Functor,NatId,Component)}
is true if ID is a legal cdf identifier term, and Functor is its main
functor symbol, NatId is its first field and Component is its second
field.").

cdf_id_fields(id(N,S),id,N,S).
cdf_id_fields(cid(N,S),cid,N,S).
cdf_id_fields(oid(N,S),oid,N,S).
cdf_id_fields(rid(N,S),rid,N,S).
cdf_id_fields(crid(N,S),crid,N,S).
cdf_id_fields(crrid(N,S),crid,N,S).
cdf_id_fields(crcrid(N,S),crid,N,S).

%%%%%%%%%%%%%%%%%%% ISA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

in_hierarchy(Term):- 
	(  immed_isa(Term,_) 
             ; implicit_isa(Term,_) 
	 ; Term = id('CDF Root',cdf) ),
	!.

:- comment(implicit_isa/2,"@tt{implicit_isa(Id1,Id2)} forms a partial
implementation of the implicit isa axioms for product identifiers
@ref{???}.  As an example of implicit isaing of product classes,
@tt{id(f(id(a,source1),id(b,source2),source3)} is a subclass of
@tt{id(f(id(c,source1),id(b,source2),source3)} if @tt{id(a,source1)}
is a subset of @tt{id(a,source1)}.  Because the use of product
identifiers can isa relations that are exponential in the size of the
product identifiers, the implementation described below attempts to
partially traverse the implicit isa relation in a manner that is
semantically meaningful while also remaining tractable.

The semantics of @tt{implicit_isa/2} is mode-dependent.  Let fully
ground inputs be treated as @tt{+} and partially ground inputs treated
as @tt{-}.  Suppose we have a call @tt{implicit_isa(C1,C2)}:

@begin{itemize} @item @tt{implicit_isa(+,+)}: succeeds if @tt{C1} is
not equal to @tt{C2} and @tt{C1} is lower than @tt{C2} on the isa
hierarchy by the isa axioms.

@begin{itemize} @item @tt{implicit_isa(+,-)}: succeeds if @tt{C1} \=
@tt{C2}, @tt{C1} is a subclass, (member, etc) of @tt{C2} by the isa
axioms @em{and} for some @tt{C3} @tt{immed_isa(C2,C3)} is
true.

@item @tt{implicit_isa(-,+)}: fails.

@item @tt{implicit_isa(-,-)}: fails.
@end{itemize}

The motivation for this partial implementation is as follows.  If both
terms are ground, determining their relation in the isa hierarchy is
linear in the sizes of the terms.  In all cases where variables are
present, there is the possibility of backtracking through a large
isa_relation.  For the instantiation pattern @tt{immed_isa(+,-)}
this is addressed by searching through only those product identifiers
that occur in the first argument of the immediate isa relation.
Because of the assumption that product identifiers can occur only in
the first argument of the immediate isa relation, this option is not
available for the instantiation patterns @tt{implicit_isa(-,+)} and
@tt{implicit_isa(-,-)}, so they fail.  ").

implicit_isa(SubCid,SupCid) :- 
	ground(SubCid),
	(ground(SupCid) -> 
	     implicit_isa_bb(SubCid,SupCid)
	  ; 
	     implicit_isa_bf(SubCid,SupCid)).
	
implicit_isa_bf(SubCid,SupCid):- 
        skeleton(SubCid,SubSkel), 
	immed_isa(SubSkel,_),
	term_isa(SubCid,SubSkel),
	SubCid \== SubSkel,
	SupCid = SubSkel.

implicit_isa_bb(SubCid,SupCid) :- 
	SubCid \== SupCid,
	term_isa(SubCid,SupCid).

skeleton(cid(Nid,Src),cid(Nid1,Src)):- 
	functor(Nid,T,A),
	functor(Nid1,T,A).
skeleton(oid(Nid,Src),oid(Nid1,Src)):- 
	functor(Nid,T,A),
	functor(Nid1,T,A).

term_isa(cid(Term1,Src),cid(Term2,Src)):- 
	Term1 =.. [F|R1],
	Term2 =.. [F|R2],
	term_isa_list(R1,R2).

term_isa_list([],[]).
term_isa_list([H|T],[H1|T1]):- 
	once(isa(H,H1)),
	term_isa_list(T,T1).

:- comment(immed_isa/2, "@tt{immed_isa(SubCid,SupCid)} is true
if there is a corresponding fact in @pred{isa_ext/2} or in the
intensional rules.  It does not use the Implicit Isa Axiom or the
Domain Containment Axiom, or reflexive or transitive closure.").

immed_isa(SubCid,SupCid) :- 
	check_types(query,isa(SubCid,SupCid)),
	isa_ext(SubCid,SupCid).
immed_isa(CCid,PCid) :-
	check_types(query,isa(CCid,PCid)),
	isa_int(CCid,PCid).

:- comment(isa/2, "The operational semantics of @tt{isa/2} is defined
in @ref{Using CDF}").

isa(Sub,Sup):- 
	check_types(query,isa(Sub,Sup)),
	(ground(Sub) -> 
	    (ground(Sup) -> 
	        isa_bb(Sub,Sup),!	% want det for bb.
	      ; isa_bf(Sub,Sup))	
	  ; isa_fx(Sub,Sup)).

% Here use implicit bb specialization for first step as al alternative
% to the bf mode.

isa_bb(Sub,Sup):- isa_bf(Sub,Sup).
isa_bb(Sub,Sup):- 
	arg(1,Sub,Suba),structure(Suba),
	arg(1,Sup,Supa),structure(Supa),
	implicit_isa_bb(Sub,Sup).

% Here use implicit bf specialization for first step, then look upwards 
isa_bf(Sub,Sub).
isa_bf(Sub,Sup):- 
	(   immed_isa(Sub,Mid)
	  ; implicit_isa_bf(Sub,Mid) ),
	isa_bf_inner(Mid,Sup).

isa_bf_inner(Sub,Sub).
isa_bf_inner(Sub,Sup):- 
	immed_isa(Sub,Mid),
	isa_bf_inner(Mid,Sup).

% Here implicit would fail; just do immediate, and look down. 
isa_fx(Sub,Sub).
isa_fx(Sub,Sup):- 
	immed_isa(Mid,Sup),
	isa_fx(Sub,Mid).

:- comment(proper_isa/2, "@tt{proper_isa(Sub,Sup)} is true if @tt{Sub}
is lower in the isa hierarchy than @tt{Sup}, but is not the same
identifier.").

proper_isa(SubCid,SupCid) :-
	isa(SubCid,SupCid),
	SubCid \== SupCid.

%%%%%%%%%%%%%%%%%%%%%%%%%%%% hasAttr %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(is_a_rel/1, "@tt{is_a_rel(RCid)} checks that @tt{RCid} is
the identifier of a subrelation of @tt{id('CDF Object-Object
Relations',cdf)}.  If @tt{RCid} is unbound, all such (proper)
subrelations are returned nondeterministically.").

is_a_rel(RCid):- 
	RelsCid = rid('CDF Object-Object Relations',cdf),
	(ground(RCid)
	 ->	isa(RCid,RelsCid), RCid \== RelsCid	
	 ;	findall(RCid,(isa_fx(RCid,RelsCid), RCid \== RelsCid),URCids),
		sort(URCids,RCids), % eliminate duplicates
		member(RCid,RCids)
	).

:- comment(immed_hasAttr/3, "@tt{immed_hasAttr(SCid,RCid,TCid)}
accesses facts stored directly in @pred{hasAttr_ext/3} in the CDF state,
as well as those defined via intensional rules.").

immed_hasAttr(SCid,RCid,TCid) :- 
	check_types(query,hasAttr(SCid,RCid,TCid)),
	hasAttr_ext(SCid,RCid,TCid).
immed_hasAttr(SCid,RCid,TCid) :-
	check_types(query,hasAttr(SCid,RCid,TCid)),
	hasAttr_int(SCid,RCid,TCid).

:- comment(hasAttr/3, "@tt{hasAttr(SCid,RCid,TCid)} defines the
inheritable relation predicate, where @tt{SCid} is the source class or
object ID, @tt{RCid} is the relation ID, and @tt{TCid} is the target
class or object ID.  For these inheritable relations, the taxonomy is
traversed and the most specific relations consistent with the
parameters are returned.  ").

hasAttr(SCid,RCid,TCid) :-
	var(SCid),var(RCid),var(TCid), !,
	immed_hasAttr(SCid,RCid,TCid).
hasAttr(SCid,RCid,TCid) :- 
	var(RCid), !,  %% relation is free var
	is_a_rel(RCid),
	check_types(query,hasAttr(SCid,RCid,TCid)),
	hasAttr_2fix(SCid,RCid,TCid).
hasAttr(SCid,RCid,TCid) :-
	check_types(query,hasAttr(SCid,RCid,TCid)),
	hasAttr_2inh(SCid,RCid,TCid).

:- table hasAttr_2fix/3.
hasAttr_2fix(SCid,RCid,TCid) :-
	OutTerm = rln(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	hasAttr_gen13(SCid,RCid,TCid),
	(not_max_implicative_hasAttr(OutTerm,BindPat) -> fail ; true).

:- table hasAttr_2inh/3.
hasAttr_2inh(SCid,RCid,TCid) :-
	OutTerm = rln(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	hasAttr_gen2(SCid,RCid,TCid),
	(not_max_implicative_hasAttr(OutTerm,BindPat) -> fail ; true).

% Checks downward in arg 2; nee hasAttr_inh_gen/3.
:- table hasAttr_gen2/3.
hasAttr_gen2(SCid,RCid,TCid) :-
	isa(RCidP,RCid),
	hasAttr_gen13(SCid,RCidP,TCid).

% hasAttr_gen13(?,+,?).  Checks downward in arg 1; upward in arg 2.
% nee hasAttr_inh_gen_fr/3.
:- table hasAttr_gen13/3.
hasAttr_gen13(SCid,RCid,TCid) :-
	(var(SCid)
	 ->	(var(TCid)
		 ->	immed_hasAttr(SCid,RCid,TCid)
		 ;	isa(TCidP,TCid),
			immed_hasAttr(SCid,RCid,TCidP)
		)
	 ;      isa(SCid,SCidP), SCidP \== id('CDF Root',cdf),
		immed_hasAttr(SCidP,RCid,TCidP),
		(var(TCid)
		 ->	TCid = TCidP
		 ;	isa(TCidP,TCid) 
		)
	).


% Succeeds if Term is maximally implicative for binding pattern,
% i.e. there is no other Term that unifies with BindPat implied by
% the axioms of the CDF state that implies Term, other than Term itself.
not_max_implicative_hasAttr(Term,BindPat) :-
	BindPat = rln(SCidO,RCidO,TCidO),
	Term = rln(SCid,RCid,TCid),
	hasAttr_gen2(SCidO,RCidO,TCidO),
	\+ (BindPat = Term),	
	isa(RCidO,RCid),	
	isa(SCid,SCidO),	
	isa(TCidO,TCid).	

%%% ClassHasAttr %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(is_a_classHasAttr/1, "@tt{is_a_classHasAttr(RCid)} checks
that @tt{RCid} is the class ID of a subclass of @tt{id('CDF
Class-Object Relations',cdf)}.  If @tt{RCid} is unbound, all such
(proper) subclasses are returned nondeterministically.").

is_a_classHasAttr(RCid) :-
	proper_isa(RCid,crid('CDF Class-Object Relations',cdf)).

:- comment(immed_classHasAttr/3,
"@tt{immed_classHasAttr(SCid,RCid,TCid)} accesses facts stored
directly in @pred{classHasAttr_ext/3} in the CDF state, as well as
those defined via intensional rules.").

immed_classHasAttr(SCid,RCid,TCid) :- 
	check_types(query,classHasAttr(SCid,RCid,TCid)),
	classHasAttr_ext(SCid,RCid,TCid).
immed_classHasAttr(SCid,RCid,TCid) :- 
	check_types(query,classHasAttr(SCid,RCid,TCid)),
	classHasAttr_int(SCid,RCid,TCid).

:- comment(classHasAttr/3, "@tt{classHasAttr(SCid,RCid,TCid)} defines
the semantic set-valued relation predicate, where @tt{SCid} is the
source class ID, @tt{RCid} is the relation class ID, and @tt{TCid} is
the target class ID. ").

classHasAttr(SCid,RCid,TCid) :-
	var(SCid),var(RCid),var(TCid), !,
	immed_classHasAttr(SCid,RCid,TCid).
classHasAttr(SCid,RCid,TCid) :-
	var(RCid), !,  %% relation is free var
	is_a_classHasAttr(RCid),
	check_types(query,classHasAttr(SCid,RCid,TCid)),
	classHasAttr_2fix(SCid,RCid,TCid).
classHasAttr(SCid,RCid,TCid) :-
	check_types(query,classHasAttr(SCid,RCid,TCid)),
	classHasAttr_2inh(SCid,RCid,TCid).

:- table classHasAttr_2fix/3.
classHasAttr_2fix(SCid,RCid,TCid) :-
	OutTerm = classHasAttr(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	classHasAttr_gen13(SCid,RCid,TCid),
	(not_max_implicative_classHasAttr(OutTerm,BindPat) -> fail ; true).

:- table classHasAttr_2inh/3.
classHasAttr_2inh(SCid,RCid,TCid) :-
	OutTerm = classHasAttr(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	classHasAttr_gen2(SCid,RCid,TCid),
	(not_max_implicative_classHasAttr(OutTerm,BindPat) -> fail ; true).

:- table classHasAttr_gen2/3.
classHasAttr_gen2(SCid,RCid,TCid) :-
	isa(RCidP,RCid),
	classHasAttr_gen13(SCid,RCidP,TCid).

:- table classHasAttr_gen13/3.
classHasAttr_gen13(SCid,RCid,TCid) :-
	(var(SCid)
	 ->	(var(TCid)
		 ->	immed_classHasAttr(SCid,RCid,TCid)
		 ;	isa(TCidP,TCid),
			immed_classHasAttr(SCid,RCid,TCidP)
		)
	 ;      immed_classHasAttr(SCid,RCid,TCidP),
		(var(TCid)
		 ->	TCid = TCidP
		 ;	isa(TCidP,TCid) 
		)
	).

not_max_implicative_classHasAttr(Term,BindPat) :-
	BindPat = classHasAttr(SCid,RCidO,TCidO),
	Term = classHasAttr(SCid,RCid,TCid),
	classHasAttr_gen2(SCid,RCidO,TCidO),
	\+ (Term = BindPat),	
	isa(RCidO,RCid),	
	isa(TCidO,TCid).

%%% allAttr/3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(immed_allAttr/3, "@tt{immed_allAttr(SCid,RCid,TCid)}
accesses facts stored directly in @pred{allAttr_ext/3} and information
produced via @pred{allAttr_int/6}.").

immed_allAttr(SCid,RCid,TCid) :- 
	check_types(query,allAttr(SCid,RCid,TCid)),
	allAttr_ext(SCid,RCid,TCid).
immed_allAttr(SCid,RCid,TCid) :- 
	check_types(query,allAttr(SCid,RCid,TCid)),
	allAttr_int(SCid,RCid,TCid).

:- comment(allAttr/3, "@tt{allAttr(SCid,RCid,TCid)} defines the semantic
schema relation predicate, where @tt{SCid} is the source class ID,
@tt{RCid} is the relation class ID, and @tt{TCid} is the target class
ID.  Since schema relations are inheritable, the taxonomy is traversed
and the most specific schema relations consistent with the parameters
are returned.  ").

allAttr(SCid,RCid,TCid) :-
	var(SCid),var(RCid),var(TCid), !,
	immed_allAttr(SCid,RCid,TCid).
allAttr(SCid,RCid,TCid) :-
	var(RCid), !,  %% relation is free var
	is_a_rel(RCid),
	check_types(query,allAttr(SCid,RCid,TCid)),
	allAttr_2fix(SCid,RCid,TCid).
allAttr(SCid,RCid,TCid) :-
	check_types(query,allAttr(SCid,RCid,TCid)),
	allAttr_2inh(SCid,RCid,TCid).

:- table allAttr_2fix/3.
allAttr_2fix(SCid,RCid,TCid) :-
	OutTerm = allAttr(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	allAttr_gen13(SCid,RCid,TCid),
	(not_max_implicative_allAttr(OutTerm,BindPat) -> fail ; true).

:- table allAttr_2inh/3.
allAttr_2inh(SCid,RCid,TCid) :-
	OutTerm = allAttr(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	allAttr_gen2(SCid,RCid,TCid),
	(not_max_implicative_allAttr(OutTerm,BindPat) -> fail ; true).

:- table allAttr_gen2/3.
allAttr_gen2(SCid,RCid,TCid) :-
	isa(RCidP,RCid),
	allAttr_gen13(SCid,RCidP,TCid).

:- table allAttr_gen13/3.
allAttr_gen13(SCid,RCid,TCid) :-
	(var(SCid)
	 ->	(var(TCid)
		 ->	immed_allAttr(SCid,RCid,TCid)
		 ;	isa(TCidP,TCid),
			immed_allAttr(SCid,RCid,TCidP)
		)
	 ;      isa(SCid,SCidP), SCidP \== id('CDF Root',cdf),
		immed_allAttr(SCidP,RCid,TCidP),
		(var(TCid)
		 ->	TCid = TCidP
		 ;	isa(TCidP,TCid) 
		)
	).

not_max_implicative_allAttr(OutTerm,BindPat) :-
	BindPat = allAttr(SCidO,RCidO,TCidO),
	OutTerm = allAttr(SCid,RCid,TCid),
	allAttr_gen2(SCidO,RCidO,TCidO),
	\+ (OutTerm = BindPat),	
	isa(RCid,RCidO),	
	isa(SCid,SCidO),	
	isa(TCidO,TCid).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(retractallExtTerm/1, "@tt{retractallExtTerm(Term)} retracts
all extensional CDF facts that unify with the parameters.  Note that
this operation simply removes all matching tuples.  It does not affect
information derived via intensional rules, and may not affect
information derived via inheritance.").

retractallExtTerm(Term) :- 
	cdf_update_list([retractall(Term)]).

:- comment(newExtTerm/1, "@tt{newExtTerm(Term)} is used to add a new
extensional term to the ontology.
@begin{itemize}
@item By default, checks are made that the identifiers in @tt{Term}
are of the proper type and are consistent.  This can be turned off by
@ref{???.}

@item Checks may also be made that @tt{Term} is not already implied by
the ontology before it can be added.  The default is not to make such
checks, but only to check that @tt{Term} is not extensionally present
before it can be added.

@item Conformability checks.
@end{itemize}
").

newExtTerm(Term):- 
	newExtTerm(Term,Upd0,[]),
	sort(Upd0,Upds),
	cdf_update_list(Upds).

newExtTerm(Term,Upd0,Upd):- 
	check_types(update,Term),
	(check_implication(update,Term) -> 
	    classify_if_necessary(Term,Upd0,Upd1),
%	    write(cin(Term,Upd0,Upd1)),
	    Upd1 = [asserta(Term)|Upd]
	  ; Upd0 = Upd).

%-----------------------------------------------------------
%%%%%%%%%%  Retract tables as appropriate upon update; adjust dirty bits.

:- comment(hide,assert_cdf/1).
assert_cdf(Term) :-
	cdf_log(assert(Term)),
	assert_cdf_term(Term),
	abolish_nec_tables(Term).

assert_cdf_term(Term) :-
	assert_cdf_int(Term),
	!.
assert_cdf_term(Term) :-
	asserta(Term),
	get_component_extensional(Term,Name),
	(cdf_flags(dirty,Name)
	 ->	true
	 ;	make_cdf_dirty(Name)
	).

:- comment(hide,retractall_cdf/1).

retractall_cdf(Term) :-
	cdf_log(retractall(Term)),
	retractall_cdf_term(Term),
	abolish_nec_tables(Term).
 
retractall_cdf_term(Term) :- 
	retractall_cdf_int(Term),
	fail. 
retractall_cdf_term(Term) :-
	retract(Term),
	get_component_extensional(Term,Name),
	(cdf_flags(dirty,Name)
	 ->	true
	 ;	make_cdf_dirty(Name)
	),
	fail.
retractall_cdf_term(_).

abolish_nec_tables(hasAttr_ext(_,_,_)) :- !,
	abolish_hasAttr_inherits.
abolish_nec_tables(allAttr_ext(_,_,_)) :- !,
	abolish_allAttr_inherits.
abolish_nec_tables(classHasAttr_ext(_,_,_)) :- !,
	abolish_classHasAttr_inherits.
abolish_nec_tables(subclass_ext(_,_)) :- !,
	abolish_hasAttr_inherits,
	abolish_allAttr_inherits,
	abolish_classHasAttr_inherits.
abolish_nec_tables(_).

abolish_hasAttr_inherits :-
	abolish_table_pred(hasAttr_gen13(_,_,_)),
	abolish_table_pred(hasAttr_gen2(_,_,_)),
	abolish_table_pred(hasAttr_2inh(_,_,_)),
	abolish_table_pred(hasAttr_2fix(_,_,_)).

abolish_classHasAttr_inherits :-
	abolish_table_pred(classHasAttr_gen2(_,_,_)),
	abolish_table_pred(classHasAttr_gen13(_,_,_)),
	abolish_table_pred(classHasAttr_2fix(_,_,_)),
	abolish_table_pred(classHasAttr_2inh(_,_,_)).

abolish_allAttr_inherits :-
	abolish_table_pred(allAttr_gen13(_,_,_)),
	abolish_table_pred(allAttr_gen2(_,_,_)),
	abolish_table_pred(allAttr_2fix(_,_,_)),
	abolish_table_pred(allAttr_2inh(_,_,_)).

%%% Logging %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(cdf_set_log_on/0,"This predicate creates a new log and
ensures that logging will be performed for further updates until
logging is turned off.").

cdf_set_log_on:- cdf_logging_state(X),
	       (X == on -> 
		   true
	          ;    retractall(cdf_logging_state(_)),
	               asserta(cdf_logging_state(on)),
		   (cdf_log_trie(_) -> 
		        cdf_error(logging,['^%*&^%* log state inconsistent!',
		                                     '(off to on)'])
		     ;  new_trie(T),
		         assert(cdf_log_trie(T)))).


:- comment(cdf_set_log_off/0,"This predicate turns logging off, and
deletes the current log, as it may have become out of date.").

cdf_set_log_off:- cdf_logging_state(X),
	       (X == off -> 
		   true
	          ;    retractall(cdf_logging_state(_)),
	               asserta(cdf_logging_state(off)),
		   (cdf_log_trie(T) -> 
		        delete_trie(T),
		        retractall(cdf_log_trie(_))
		     ;  cdf_error(logging,['^%*&^%* log state inconsistent!',
		                                     '(on to off)']))).

:- comment(cdf_reset_log/0,"If logging is on, this predicate deletes
the current log, and creates a new one.  If logging is off, no action
is taken").

cdf_reset_log:- 
	(cdf_log_trie(X) -> 
	    delete_trie(X),
	    retractall(cdf_log_trie(X))
	  ; true),
	  new_trie(X),
	  assert(cdf_log_trie(X)).

/* Need to handle variables better.  */
cdf_log(Term):- 
	cdf_logging_state(X),
	(X == on -> cdf_log_1(Term) ; true),
	!.

cdf_log_1(assert(Term)):- 
	cdf_log_trie(T),
	(trie_interned(retractall(Term),T,Leaf,_skel) -> 
	    trie_unintern_nr(T,Leaf) ; true),
	trie_intern(assert(Term),T,_,_,_).
cdf_log_1(retractall(Term)):- 
	cdf_log_trie(T),
	(trie_interned(assert(Term),T,Leaf,_skel) -> 
	    trie_unintern_nr(T,Leaf)  
	  ; trie_intern(retractall(Term),T,_,_,_)).

:- comment(hide,show_log/0).	
show_log:- 
	listing(cdf_logging_state(_)),
	cdf_log_trie(T),
	trie_interned(Term,T,_,_),
	writeln(Term),
	fail.

%%% OTHER PREDS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% performance testing predicate
:- comment(hide,set_chk_index/0).
set_chk_index :-
	set_chk_index(isa_ext(_,_)),
	set_chk_index(hasAttr_ext(_,_,_)),
	set_chk_index(classHasAttr_ext(_,_,_)),
	set_chk_index(allAttr_ext(_,_,_)).

set_chk_index(Goal) :-
	asserta((Goal :- chk_index(Goal))).

chk_index(Goal) :-
	('_$index'(Goal,Index,_)
	 ->	(integer(Index)
		 ->	\+ bound_on([Index],Goal)
		 ;	\+ bound_on(Index,Goal)
		)
	 ;	\+ bound_on([1],Goal)
	),
	telling(OF),tell(user),writeln('Non-indexed call '(Goal)),
	tell(OF),
	fail.

bound_on([ArgNo|_ArgNos],Goal) :-
	bound_on_all(ArgNo,Goal).
bound_on([_ArgNo|ArgNos],Goal) :-
	bound_on(ArgNos,Goal).

bound_on_all(ArgNo,Goal) :-
	ArgNo1 is ArgNo /\ 255,
	arg(ArgNo1,Goal,Arg),
	nonvar(Arg),
	(ArgNo < 256
	 ->	true
	 ;	ArgNoM is ArgNo >> 8,
		bound_on_all(ArgNoM,Goal)
	).

%%% ATTRIBUTE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(hide,updateAttribute/5).
:- comment(updateAttribute/5,
"@tt{update_attribute(Oid,RCid,TCid,VarTerm,ValList)} updates a set of
values, only invalidating those that changed.  VarTerm must contain
all the free variables in (Oid,RCid,TCid), and ValList is a list of
instances of VarTerm.  The goal is to minimize invalidation.  The
semantics is: (retractallAttribute(Oid,RCid,TCid),
(member(VarTerm,ValList), assert_attribute(Oid,RCid,TCid)), fail ;
true).").

/**updateAttribute(_Oid,_Rid,_Cid,_Vars,_NValList) :-
	cdf_error(cdf,['updateAttribute/5 has not yet been ported to CDF']),
	fail. **/

updateExtTerm(ExtTerm,Vars,NValList) :-
	findall(Vars,ExtTerm,OValList),
	sort(NValList,SNValList),
	sort(OValList,SOValList),
	updateExtTermMerge(SOValList,SNValList,p(ExtTerm,Vars),Updates,[]),
	cdf_update_list(Updates).

updateExtTermMerge(SOValList,SNValList,ArgsVars,Updates0,Updates) :-
	SOValList = [OVal|SOVals],
	SNValList = [NVal|SNVals],
	!,
	(OVal == NVal
	 ->	updateExtTermMerge(SOVals,SNVals,ArgsVars,Updates0,Updates)
	 ; OVal @< NVal
	 ->	copy_term(ArgsVars,p(NExtTerm,OVal)),
		(call(NExtTerm) % don't delete if inherited
		 ->	Updates0 = 
			   [retractall(NExtTerm)|Updates1],
			updateExtTermMerge(SOVals,SNValList,ArgsVars,
					       Updates1,Updates)
		 ;	updateExtTermMerge(SOVals,SNValList,ArgsVars,
					       Updates0,Updates)
		)
	 ;	copy_term(ArgsVars,p(NExtTerm,NVal)),
		newExtTerm(NExtTerm,Updates0,Updates1),
		updateExtTermMerge(SOValList,SNVals,ArgsVars,Updates1,Updates)
	).
updateExtTermMerge([],[NVal|SNVals],ArgsVars,Updates0,Updates) :- !,
	copy_term(ArgsVars,p(NExtTerm,NVal)),
	newExtTerm(NExtTerm,Updates0,Updates1),
	updateExtTermMerge([],SNVals,ArgsVars,Updates1,Updates).
updateExtTermMerge([OVal|SOVals],[],ArgsVars,Updates0,Updates) :- !,
	copy_term(ArgsVars,p(NExtTerm,OVal)),
	(call(NExtTerm) % don't delete if inherited
	 ->	Updates0 = 
		 	[retractall(NExtTerm)|Updates1],
		updateExtTermMerge(SOVals,[],ArgsVars,Updates1,Updates)
	 ;	updateExtTermMerge(SOVals,[],ArgsVars,Updates0,Updates)
	).
updateExtTermMerge([],[],_ArgsVars,Updates,Updates).


end_of_file.

assert_primitive_types(TypsCid):- 
	newPrimitiveClass(aint(X)),
	newPrimitiveClass(atom(X)),
	newPrimitiveClass(cardinal(X)),
	newPrimitiveClass(float(X)),
	newPrimitiveClass(integer(X)),
	newPrimitiveClass(object(_)),
	newPrimitiveClass(clause(X,Y)),

/* 
check_class_conformability(Nid,Cid):- (atomic(Nid) ; atomic(Cid)),!.
check_class_conformability(Nid,Cid):- 
	get_product_skeleton(Nid,Nidskel),
	get_product_skeleton(Cid,Cidskel),
	Nidskel = Cidskel,!.
check_class_conformability(Nid,Cid):- 
	cdf_error(update,('Cannot create new object ',Nid,
	          'as member of ',Cid,'due to non-conformability.')).

get_product_skeleton(Cid,_):- atomic(Cid),!.
get_product_skeleton(Cid,Skel):- 
	structure(Cid),!,
	Cid =..[Functor|List],
	get_product_skeleton_list(List,NewList),
	Skel =..[Functor|NewList].
get_product_skeleton(Cid,_Skel):- 
	cdf_error(update,('Improper Cid: ',Cid)).
	
get_product_skeleton_list([],[]).
get_product_skeleton_list([H|T],[NH|NT]):- 
	get_product_skeleton(H,NH),
	get_product_skeleton_list(T,NT).

add_member_if_nec(_Oid,unk,Upd,Upd) :- !.
add_member_if_nec(Oid,Cid,Upd,Upd) :-
	immed_memberof(Oid,Cid), !.
add_member_if_nec(Oid,Cid,Upd0,Upd) :-
	Upd0 = [asserta(memberof_ext(Oid,Cid))|Upd].

*/

/* To be used with class and object creation, and with
   merging from external files. 
check_source(id(_,Source),Term):- 
	(nonvar(Source)
	 ->	true
	 ;	cdf_warning(update,('cannot create CDF fact ',
                         'source unbound: ',Term)),
		fail
	),
	(atomic(Source)
	 ->	true
	 ;	cdf_warning(update,('creating CDF fact with',
			 'non-atomic source: ',Term))
	).
*/

/* check_attribute(+,+,+).  This predicate should be used *only* in
newAttribute. The idea is that newAttribute should add a new attribute
only if that new attribute is not implied by the ontology.  But using
attribute as a check in newAttribute is 1) inefficient and 2) not
quite right.  The not-quite-right part is be cause newAttribute seeks
to backtrack through all *maximal" attribtues implied by the ontology
(last ifthenelse of attribute/3) and we want newAttribute to add only
if the attribute is not implied, regardless if it is maximally implied
or not. */

check_attribute(Oid,RCid,TCid) :-
	(immed_attribute(Oid,RCid,TCid) 
         ->	true
	 ;	immed_isa(Oid,SCid),
		irel(SCid,RCid,TCid)
	).

show_cdf_size:- 
	count_success(isa_ext(_,_)),
	count_success(hasAttr_ext(_,_,_)),
	count_success(classHasAttr_ext(_,_,_)),
	count_success(allAttr_ext(_,_,_)).
	
count_success(Term):- 
	conset('_$size_matters',0),
	count_success_1(Term),
	conget('_$size_matters',N),
	functor(Term,F,A),
	writeln(('There are ',N,' ',F,'/',A,' successes')).
	
count_success_1(Term):- 
	call(Term),
	inc_count,
	fail.
count_success_1(_).

inc_count:- 
	conget('_$size_matters',N),
	N1 is N + 1,
	conset('_$size_matters',N1).

