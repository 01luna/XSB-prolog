:- export
	explosive_isa/2,
	cdf_id_fields/4,
	cdf_root/1,
	isa/2, immed_isa/2, implicit_isa/2,proper_isa/2,
	hasAttr/3, immed_hasAttr/3, 
	allAttr/3, immed_allAttr/3, 
	classHasAttr/3, immed_classHasAttr/3, 
	in_hierarchy/1,
	newExtTerm/1, newExtTerm/2, retractallExtTerm/1,
	initialize_state/0, system_component/1, initialize_cdf/0,
	initialize_state_nl/0, 
	set_chk_index/0,
	assert_cdf/1, retractall_cdf/1,
	updateExtTerm/3.

:- (search_module(cdf_xj,_,_,_,_,_)
    ->	   consult(cdf_xj)
    ;	   consult(cdf_cdf)
   ).

%:- import (:-)/2 from usermod.

:- import check_types_checkflag/2,
	  apply_checks/2 
	from cdf_checks.

:- import isa_ext/2, hasAttr_ext/3, classHasAttr_ext/3, allAttr_ext/3 
							from usermod.

:- import isa_int/2, hasAttr_int/3, classHasAttr_int/3, allAttr_int/3 
							from  usermod.

:- import cdf_set_log_off/0, cdf_log/1
	from cdf_concurrency.	

:- import cdf_flags/2, 
	  assert_cdf_int/1, retractall_cdf_int/1 from usermod.

:- import cdf_flag/1, initial_cdf_flag/2 from usermod.

:- import get_component_extensional/2,
	  load_component/3 from cdf_comps_share.

:- import cdf_error/2 from cdf_exceptions.
:- import make_cdf_dirty/1, make_cdf_clean/0, cdf_update_list/1
	from cdf_xj.

:- import '_$index'/3 from file_op.
%:- import conset/2, conget/2 from gensym.
:- import ground/1, member/2 from basics.
:- import abolish_table_pred/1 from tables.
:- import search_module/6 from consult.
:- dynamic user_cdf_flag/2.
:- import user_cdf_flag/2 from usermod.

%%%%%%%%%%%%% Core Declarations 

cdf_dynamic(isa_ext/2).
cdf_index(isa_ext,2,[*(1),*(2)]).

cdf_dynamic(hasAttr_ext/3).
cdf_index(hasAttr_ext,3,[*(1) + *(2),*(1),*(2) + *(3)]).
cdf_dynamic(classHasAttr_ext/3).
cdf_index(classHasAttr_ext,3,[*(1) + *(2),*(1),*(2) + *(3)]).
cdf_dynamic(allAttr_ext/3). 
cdf_index(allAttr_ext,3,[*(1) + *(2),*(1),*(2) + *(3)]).

%%%%%%%%%%%%% Declarations for External Intensional View

cdf_dynamic(isa_int/2).

cdf_dynamic(hasAttr_int/3).
cdf_dynamic(classHasAttr_int/3).
cdf_dynamic(allAttr_int/3).

cdf_index(_,_,_,_):- fail.

%%%%%%%%%%%%% Declarations for caching and XJ interface
/* TLS
:- ensure_loaded(cdf_oblivion).
*/

%%%%%%%%%%%%% Declarations for updatable DB
%%:- ensure_loaded(cdf_db_updatable).

cdf_dynamic(cdf_extint_updatable/1).
%cdf_dynamic(newAttribute_int/3).

cdf_dynamic(assert_cdf_int/1).
cdf_dynamic(retractall_cdf_int/1).

%%%%%%%%%%%%% Declarations for constraint checking

:- ensure_loaded(cdf_config).

:- initialize_cdf.

initialize_cdf:- 
	init_dynamic_code,
	init_index_std,
	cdf_set_log_off,
	initialize_cdf_flags,
%	load_component(cdf,'',[]),
	load_component(cdfpt,'',[]),
	make_cdf_clean.
	
init_dynamic_code:- 
	cdf_dynamic(F/A),
	dynamic(F/A),
	fail.
init_dynamic_code.

% we assume that for all A in cdf_flag(A), there exists a
% corresponding initial_cdf_flag(A,_)
initialize_cdf_flags:- 
	retractall(cdf_flags(_,_)),
	cdf_flag(A),
	(   user_cdf_flag(A,B)
	->  true
	;   initial_cdf_flag(A,B)
	),
	assert(cdf_flags(A,B)),
	fail.
initialize_cdf_flags.

%--------------------------------------------------------------------

:- comment(module,"@section{Using CDF}

@tt{cdf_init_cdf.P} contains most of the predicates needed to
initialize, query or update a CDF state.  It is loaded automatically
upon loading the CDF package.

@section{Builtin Classes and Relations}

The following classes and relations are defined in @em{every} CDF
state.

@begin{itemize}

As mentioned in previous sections, CDF relations can define
inheritable attributes which hold for isaes and objects, inheritable
constraints on attributes, and non-inheritable properties of sets.

@item @tt{cid('CDF Classes',cdf)}: 
@cindex{CDF Classes}

Includes every object of any class.  Defined as a root.

@item @tt{rid('CDF Object-Object Relations',cdf)}: 
@cindex{CDF Object-Object Relations}

Includes all inheritable relation tuples.  Defined as a root

@item @tt{crid('CDF Class-Object Relations',cdf)}: 
@cindex{CDF Class-Object Relations}

Includes all non-inheritable class-object relation tuples.  Defined as
a root.

@item @tt{crrid('CDF Higher-Order (Object-Object)-Object Relations',cdf)}:
@cindex{CDF Higher-Order (Object-Object)-Object Relations}

Includes all relations on object-object relations.  Defined as a root.

@item @tt{crcrid('CDF Higher-Order (Class-Object)-Object Relations',cdf)}:
@cindex{CDF Higher-Order (Class-Object)-Object Relations}

Includes all relations on class-object relations.  Defined as a root.

@item @tt{id('CDF Primitive Types',cdfpt)}: 
@cindex{CDF Primitive Types}

Includes several primitive types defined via intensional rules,
including Prolog integers, floats and atoms.  This is an immediate
subclass of @tt{cid('CDF Classes',cdf)}

@end{itemize}

@bf{TLS: will add something about names and descriptions once
higher-order relations are implemented.}

"). 

%%% (Re-)Initialization %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TLS: initialize_state/0 may not get used heavily, but I think its useful
% to have all the re-initialization stuff here in one place, to record
% what the state consists of and to make future maintenance easier. 

:- comment(initialize_state/0,"Normally, initialization is done
automatically upon loading CDF at the start of a session.  The routine
@pred{initialize_state/0} should be called only when a state is to be
reinitialized during a session.  This predicate removes all data in
extensional and intensional forat, and reasserts the basic CDF classes
and relations, and resets internal state variables to values in the
CDF configuration file. ").

initialize_state:- 
	cdf_set_log_off,
	retractall(cdf_flags(_,_)),
	initialize_cdf_flags,
	initialize_state_nl.

initialize_state_nl :-
	reset_dynamics,
	load_component(cdf,'',[]),
	load_component(cdfpt,'',[]),
	make_cdf_clean.

reset_dynamics:- 
	cdf_dynamic(F/A),
	functor(T,F,A),
	retractall(T),
	fail.
reset_dynamics.

%-------

init_index_std :-
	(    cdf_index(F,A,I),index(F/A,I)
	   ; cdf_index(F,A,I,N),index(F/A,I,N)  ),
	fail.
init_index_std.

%%%%%%%%%%%%%%%%%%% Ids and roots %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

system_component(cdf).
system_component(cdfpt).

cdf_root(cid('CDF Classes',cdf)).
cdf_root(rid('CDF Object-Object Relations',cdf)).
cdf_root(crid('CDF Class-Object Relations',cdf)).
cdf_root(crrid('CDF Higher-Order (Object-Object)-Object Relations',cdf)).
cdf_root(crcrid('CDF Higher-Order (Class-Object)-Object Relations',cdf)).

:- comment(cdf_id_fields/4,
"@tt{cdf_id_fields(ID,Functor,NatId,Component)} is true if ID is a
legal cdf identifier term, and Functor is its main functor symbol,
NatId is its first field and Component is its second field.").

cdf_id_fields(A,B,C,D) :-
	(var(A)
	 ->	cdf_id_fields2(A,B,C,D)
	 ;	cdf_id_fields1(A,B,C,D)
	).

cdf_id_fields1(cid(N,S),cid,N,S).
cdf_id_fields1(oid(N,S),oid,N,S).
cdf_id_fields1(rid(N,S),rid,N,S).
cdf_id_fields1(crid(N,S),crid,N,S).
cdf_id_fields1(crrid(N,S),crrid,N,S).
cdf_id_fields1(crcrid(N,S),crcrid,N,S).

:- index cdf_id_fields2/4-2.
cdf_id_fields2(cid(N,S),cid,N,S).
cdf_id_fields2(oid(N,S),oid,N,S).
cdf_id_fields2(rid(N,S),rid,N,S).
cdf_id_fields2(crid(N,S),crid,N,S).
cdf_id_fields2(crrid(N,S),crrid,N,S).
cdf_id_fields2(crcrid(N,S),crcrid,N,S).

product_identifier(Id):- 
	cdf_id_fields(Id,_F,I,_S),
	structure(I).

abstract_product_identifier(Id,IdAb):- 
	cdf_id_fields(Id,F,I,S),
	functor(I,N,A),functor(I1,N,A),
	cdf_id_fields(IdAb,F,I1,S).

%%%%%%%%%%%%%%%%%%% ISA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

in_hierarchy(Term):- 
	(  immed_isa(Term,_) 
             ; implicit_isa(Term,_) 
	 ; cdf_root(Term) ),
	!.

:- comment(implicit_isa/2,"@tt{implicit_isa(Id1,Id2)} forms a partial
implementation of the implicit isa axioms for product identifiers
@ref{???}.  As an example of implicit isaing of product classes,
@tt{id(f(id(a,source1),id(b,source2),source3)} is a subclass of
@tt{id(f(id(c,source1),id(b,source2),source3)} if @tt{id(a,source1)}
is a subset of @tt{id(a,source1)}.  Because the use of product
identifiers can isa relations that are exponential in the size of the
product identifiers, the implementation described below attempts to
partially traverse the implicit isa relation in a manner that is
semantically meaningful while also remaining tractable.

The semantics of @tt{implicit_isa/2} is mode-dependent.  Let fully
ground inputs be treated as @tt{+} and non-fully ground inputs treated
as @tt{-}.  Suppose we have a call @tt{implicit_isa(C1,C2)}:

@begin{itemize} @item @tt{implicit_isa(+,+)}: succeeds if @tt{C1} is
not equal to @tt{C2} and @tt{C1} is lower than @tt{C2} on the isa
hierarchy by the isa axioms.

@begin{itemize} @item @tt{implicit_isa(+,-)}: succeeds if @tt{C1} \=
@tt{C2}, @tt{C1} is a subclass, (member, etc) of @tt{C2} by the isa
axioms @em{and} for some @tt{C3} @tt{immed_isa(C2,C3)} is
true.

@item @tt{implicit_isa(-,+)}: fails.

@item @tt{implicit_isa(-,-)}: fails.
@end{itemize}

The motivation for this partial implementation is as follows.  If both
terms are ground, determining their relation in the isa hierarchy is
linear in the sizes of the terms.  In all cases where variables are
present, there is the possibility of backtracking through a large
isa_relation.  For the instantiation pattern @tt{immed_isa(+,-)}
this is addressed by searching through only those product identifiers
that occur in the first argument of the immediate isa relation.
Because of the assumption that product identifiers can occur only in
the first argument of the immediate isa relation, this option is not
available for the instantiation patterns @tt{implicit_isa(-,+)} and
@tt{implicit_isa(-,-)}, so they fail.  ").

implicit_isa(SubCid,SupCid) :- 
	ground(SubCid),
	(ground(SupCid) -> 
	     implicit_isa_bb(SubCid,SupCid)
	  ; 
	     implicit_isa_bf(SubCid,SupCid)).
	
implicit_isa_bf(SubCid,SupCid):- 
        skeleton(SubCid,SubSkel), 
	immed_isa(SubSkel,_),
	term_isa(SubCid,SubSkel),
	SubCid \== SubSkel,
	SupCid = SubSkel.

implicit_isa_bb(SubCid,SupCid) :- 
	SubCid \== SupCid,
	term_isa(SubCid,SupCid).

skeleton(cid(Nid,Src),cid(Nid1,Src)):- 
	functor(Nid,T,A),
	functor(Nid1,T,A).
skeleton(oid(Nid,Src),oid(Nid1,Src)):- 
	functor(Nid,T,A),
	functor(Nid1,T,A).
skeleton(rid(Nid,Src),rid(Nid1,Src)):- 
	functor(Nid,T,A),
	functor(Nid1,T,A).

term_isa(cid(Term1,Src),cid(Term2,Src)):- 
	Term1 =.. [F|R1],
	Term2 =.. [F|R2],
	term_isa_list(R1,R2).
term_isa(rid(Term1,Src),rid(Term2,Src)):- 
	Term1 =.. [F|R1],
	Term2 =.. [F|R2],
	term_isa_list(R1,R2).

term_isa_list([],[]).
term_isa_list([H|T],[H1|T1]):- 
	once(isa(H,H1)),
	term_isa_list(T,T1).

/*****************
%%% super_query_terms(+Sub,-Sup) returns query terms for all things higher
%%%  in the isa hierarchy.

:- table super_query_terms/2.
super_query_terms(Sub,Sup) :-
	(var(Sub)
	 ->	Sup = Sub
	 ; ground(Sub)
	 ->	isa_bf(Sub,Sup)
	 ;	cdf_id_fields(Sub,Type,NatId,Comp),
		(var(NatId)
		 ->	Sup = Sub
		 ;	NatId =.. [Fun|Args],
			super_query_terms_list(Args,SupArgs),
			SupNatId =.. [Fun|SupArgs],
			cdf_id_fields(Sup,Type,SupNatId,Comp)
		)
	).

super_query_terms_list([],[]).
super_query_terms_list([A|As],[S|Ss]) :-
	super_query_terms(A,S),
	super_query_terms_list(As,Ss).

%%% sub_query_terms(+Sup,-Sub) returns query terms for all things lower
%%%  in the isa hierarchy.

:- table sub_query_terms/2.
sub_query_terms(Sup,Sub) :-
	(var(Sup)
	 ->	Sub = Sup
	 ; ground(Sup)
	 ->	isa_fx(Sub,Sup)
	 ;	cdf_id_fields(Sup,Type,NatId,Comp),
		(var(NatId)
		 ->	Sub = Sup
		 ;	NatId =.. [Fun|Args],
			sub_query_terms_list(Args,SubArgs),
			SubNatId =.. [Fun|SubArgs],
			cdf_id_fields(Sub,Type,SubNatId,Comp)
		)
	).

sub_query_terms_list([],[]).
sub_query_terms_list([A|As],[S|Ss]) :-
	sub_query_terms(A,S),
	sub_query_terms_list(As,Ss).
********************/

:- comment(immed_isa/2, "@tt{immed_isa(SubCid,SupCid)} is true
if there is a corresponding fact in @pred{isa_ext/2} or in the
intensional rules.  It does not use the Implicit Isa Axiom or the
Domain Containment Axiom, or reflexive or transitive closure.").

immed_isa(SubCid,SupCid) :- 
	check_types_checkflag(query,isa(SubCid,SupCid)),
	isa_ext(SubCid,SupCid).
immed_isa(CCid,PCid) :-
	check_types_checkflag(query,isa(CCid,PCid)),
	isa_int(CCid,PCid).

%------------------------------------
:- comment(isa/2, "The operational semantics of @tt{isa/2} is defined
in @ref{Using CDF}").

isa(Sub,Sup):- 
	check_types_checkflag(query,isa(Sub,Sup)),
	(ground(Sub) -> 
	    (ground(Sup) -> 
	        isa_bb(Sub,Sup),!	% want det for bb.
	      ; isa_bf(Sub,Sup))	
	  ; isa_fx(Sub,Sup)).

% Here use implicit bb specialization for first step as al alternative
% to the bf mode.

isa_bb(Sub,Sup):- isa_bf(Sub,Sup).
isa_bb(Sub,Sup):- 
	arg(1,Sub,Suba),structure(Suba),
	arg(1,Sup,Supa),structure(Supa),
	implicit_isa_bb(Sub,Sup).

% Here use implicit bf specialization for first step, then look upwards 
isa_bf(Sub,Sub).
isa_bf(Sub,Sup):- 
	(   immed_isa(Sub,Mid)
	  ; implicit_isa_bf(Sub,Mid) ),
	isa_bf_inner(Mid,Sup).

isa_bf_inner(Sub,Sub).
isa_bf_inner(Sub,Sup):- 
	immed_isa(Sub,Mid),
	isa_bf_inner(Mid,Sup).

% Here implicit would fail; just do immediate, and look down. 
isa_fx(Sub,Sub).
isa_fx(Sub,Sup):- 
	immed_isa(Mid,Sup),
	isa_fx(Sub,Mid).

:- comment(proper_isa/2, "@tt{proper_isa(Sub,Sup)} is true if @tt{Sub}
is lower in the isa hierarchy than @tt{Sup}, but is not the same
identifier.").

proper_isa(SubCid,SupCid) :-
	isa(SubCid,SupCid),
	SubCid \== SupCid.

:- comment(explosive_isa/2, "@tt{explosive_isa(Id1,Id2) follows the
isa axioms for product identifiers rather than the algorithm of
@tt{implicit_isa/2}. Thus if neither @tt{Id1} nor @tt{Id2} are product
identifiers, or if @tt{Id1} and @tt{Id2} are fully ground product
identifiers, @tt{explosive_isa/2} behaves as @tt{isa/2}.  Otherwise,
suppose @tt{Id1} is a (perhaps partially ground) product identifier
whose Nid has the outer functor @tt{F/A}.  If the Nid of @tt{Id2} is a
variable, it is instantiated to a skeleton of @tt{F/N}; otherwise its
outer functor must be @tt{F/A}.  In either case, both Nids are broken
into their constituent identifiers and @tt{explosive_isa/2} is
recursively called on each of these.  ").

explosive_isa(Id1,Id2):- 
	((cdf_id_fields(Id1,F,N1,S),cdf_id_fields(Id2,F,N2,S),
	  (structure(N1) ; structure(N2))) -> 
	    make_terms_if_necess(N1,N2),
	    N1 =.. [_|Args1],
	    N2 =.. [_|Args2],
	    explosive_isa_list(Args1,Args2)
        ;   isa(Id1,Id2) ).

make_terms_if_necess(N1,N2):- 
	(structure(N1) -> 
	    functor(N1,F,A),
	    functor(N2,F,A)
	  ; functor(N2,F,A),
	    functor(N1,F,A)).

explosive_isa_list([],[]).
explosive_isa_list([Arg1|R1],[Arg2|R2]):- 
    explosive_isa(Arg1,Arg2),
    explosive_isa_list(R1,R2).


%%%%%%%%%%%%%%%%%%%%%%%%%%%% hasAttr %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(is_a_rel/1, "@tt{is_a_rel(RCid)} checks that @tt{RCid} is
the identifier of a subrelation of @tt{id('CDF Object-Object
Relations',cdf)}.  If @tt{RCid} is unbound, all such (proper)
subrelations are returned nondeterministically.").

is_a_rel(RCid):- 
	RelsCid = rid('CDF Object-Object Relations',cdf),
	(ground(RCid)
	 ->	isa(RCid,RelsCid), RCid \== RelsCid	
	 ;	findall(RCid,(isa_fx(RCid,RelsCid), RCid \== RelsCid),URCids),
		sort(URCids,RCids), % eliminate duplicates
		member(RCid,RCids)
	).

:- comment(immed_hasAttr/3, "@tt{immed_hasAttr(SCid,RCid,TCid)}
accesses facts stored directly in @pred{hasAttr_ext/3} in the CDF state,
as well as those defined via intensional rules.").

immed_hasAttr(SCid,RCid,TCid) :- 
	check_types_checkflag(query,hasAttr(SCid,RCid,TCid)),
	hasAttr_ext(SCid,RCid,TCid).
immed_hasAttr(SCid,RCid,TCid) :-
	check_types_checkflag(query,hasAttr(SCid,RCid,TCid)),
	hasAttr_int(SCid,RCid,TCid).

:- comment(hasAttr/3, "@tt{hasAttr(SCid,RCid,TCid)} defines the
inheritable relation predicate, where @tt{SCid} is the source class or
object ID, @tt{RCid} is the relation ID, and @tt{TCid} is the target
class or object ID.  For these inheritable relations, the taxonomy is
traversed and the most specific relations consistent with the
parameters are returned.  ").

/*********
hasAttr(S,R,T) :-
	super_query_terms(S,S1),
	sub_query_terms(R,R1),
	sub_query_terms(T,T1),
	immed_hasAttr(S1,R1,T1).

**********/

/**********/
hasAttr(SCid,Rid,TCid) :-
	var(SCid),var(Rid),var(TCid), !,
	immed_hasAttr(SCid,Rid,TCid).
hasAttr(SCid,Rid,TCid) :-
	product_identifier(Rid),!,
	(ground(Rid) -> 
		check_types_checkflag(query,hasAttr(SCid,Rid,TCid)),
		abstract_product_identifier(Rid,RidAb),
		hasAttr_gen13(SCid,RidAb,TCid),
		isa(RidAb,Rid)
	   ;   	cdf_error(cdf,['partially ground relation identifiers not',
			       'handled in ',hasAttr(SCid,Rid,TCid)]) ).

hasAttr(SCid,Rid,TCid) :- 
	\+ ground(Rid), !, 
	is_a_rel(Rid),
	check_types_checkflag(query,hasAttr(SCid,Rid,TCid)),
	hasAttr_2fix(SCid,Rid,TCid).
hasAttr(SCid,Rid,TCid) :-
	% relation is ground product id
	check_types_checkflag(query,hasAttr(SCid,Rid,TCid)),
	hasAttr_2inh(SCid,Rid,TCid).
/**********/

:- table hasAttr_2fix/3.
hasAttr_2fix(SCid,RCid,TCid) :-
	OutTerm = rln(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	hasAttr_gen13(SCid,RCid,TCid),
	(not_max_implicative_hasAttr(OutTerm,BindPat) -> fail ; true).

:- table hasAttr_2inh/3.
hasAttr_2inh(SCid,RCid,TCid) :-
	OutTerm = rln(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	hasAttr_gen2(SCid,RCid,TCid),
	(not_max_implicative_hasAttr(OutTerm,BindPat) -> fail ; true).

% Checks downward in arg 2; nee hasAttr_inh_gen/3.
:- table hasAttr_gen2/3.
hasAttr_gen2(SCid,RCid,TCid) :-
	isa(RCidP,RCid),
	hasAttr_gen13(SCid,RCidP,TCid).

% hasAttr_gen13(?,+,?).  Checks downward in arg 1; upward in arg 2.
% nee hasAttr_inh_gen_fr/3.
:- table hasAttr_gen13/3.
hasAttr_gen13(SCid,RCid,TCid) :-
	(var(SCid)
	 ->	(var(TCid)
		 ->	immed_hasAttr(SCid,RCid,TCid)
		 ;	isa(TCidP,TCid),
			immed_hasAttr(SCid,RCid,TCidP)
		)
	 ;      isa(SCid,SCidP), \+ cdf_root(SCidP),
		immed_hasAttr(SCidP,RCid,TCidP),
		(var(TCid)
		 ->	TCid = TCidP
		 ;	isa(TCidP,TCid) 
		)
	).


% Succeeds if Term is maximally implicative for binding pattern,
% i.e. there is no other Term that unifies with BindPat implied by
% the axioms of the CDF state that implies Term, other than Term itself.
not_max_implicative_hasAttr(Term,BindPat) :-
	BindPat = rln(SCidO,RCidO,TCidO),
	Term = rln(SCid,RCid,TCid),
	hasAttr_gen2(SCidO,RCidO,TCidO),
	\+ (BindPat = Term),	
	isa(RCidO,RCid),	
	isa(SCid,SCidO),	
	isa(TCidO,TCid).	

%%% ClassHasAttr %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(is_a_classHasAttr/1, "@tt{is_a_classHasAttr(RCid)} checks
that @tt{RCid} is the class ID of a subclass of @tt{id('CDF
Class-Object Relations',cdf)}.  If @tt{RCid} is unbound, all such
(proper) subclasses are returned nondeterministically.").

is_a_classHasAttr(RCid) :-
	proper_isa(RCid,crid('CDF Class-Object Relations',cdf)).

:- comment(immed_classHasAttr/3,
"@tt{immed_classHasAttr(SCid,RCid,TCid)} accesses facts stored
directly in @pred{classHasAttr_ext/3} in the CDF state, as well as
those defined via intensional rules.").

immed_classHasAttr(SCid,RCid,TCid) :- 
	check_types_checkflag(query,classHasAttr(SCid,RCid,TCid)),
	classHasAttr_ext(SCid,RCid,TCid).
immed_classHasAttr(SCid,RCid,TCid) :- 
	check_types_checkflag(query,classHasAttr(SCid,RCid,TCid)),
	classHasAttr_int(SCid,RCid,TCid).

:- comment(classHasAttr/3, "@tt{classHasAttr(SCid,RCid,TCid)} defines
the semantic set-valued relation predicate, where @tt{SCid} is the
source class ID, @tt{RCid} is the relation class ID, and @tt{TCid} is
the target class ID. ").

classHasAttr(SCid,RCid,TCid) :-
	var(SCid),var(RCid),var(TCid), !,
	immed_classHasAttr(SCid,RCid,TCid).
classHasAttr(SCid,Rid,TCid) :-
	product_identifier(Rid),!,
	(ground(Rid) -> 
		check_types_checkflag(query,hasAttr(SCid,Rid,TCid)),
		abstract_product_identifier(Rid,RidAb),
		classHasAttr_gen13(SCid,RidAb,TCid),
		isa(RidAb,Rid)
	   ;   	cdf_error(cdf,['partially ground relation identifiers not',
			       'handled in ',classHasAttr(SCid,Rid,TCid)]) ).
classHasAttr(SCid,RCid,TCid) :-
	\+ ground(RCid), !, 
	is_a_classHasAttr(RCid),
	check_types_checkflag(query,classHasAttr(SCid,RCid,TCid)),
	classHasAttr_2fix(SCid,RCid,TCid).
classHasAttr(SCid,RCid,TCid) :-
	%% relation is ground
	check_types_checkflag(query,classHasAttr(SCid,RCid,TCid)),
	classHasAttr_2inh(SCid,RCid,TCid).

:- table classHasAttr_2fix/3.
classHasAttr_2fix(SCid,RCid,TCid) :-
	OutTerm = classHasAttr(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	classHasAttr_gen13(SCid,RCid,TCid),
	(not_max_implicative_classHasAttr(OutTerm,BindPat) -> fail ; true).

:- table classHasAttr_2inh/3.
classHasAttr_2inh(SCid,RCid,TCid) :-
	OutTerm = classHasAttr(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	classHasAttr_gen2(SCid,RCid,TCid),
	(not_max_implicative_classHasAttr(OutTerm,BindPat) -> fail ; true).

:- table classHasAttr_gen2/3.
classHasAttr_gen2(SCid,RCid,TCid) :-
	isa(RCidP,RCid),
	classHasAttr_gen13(SCid,RCidP,TCid).

:- table classHasAttr_gen13/3.
classHasAttr_gen13(SCid,RCid,TCid) :-
	(var(SCid)
	 ->	(var(TCid)
		 ->	immed_classHasAttr(SCid,RCid,TCid)
		 ;	isa(TCidP,TCid),
			immed_classHasAttr(SCid,RCid,TCidP)
		)
	 ;      immed_classHasAttr(SCid,RCid,TCidP),
		(var(TCid)
		 ->	TCid = TCidP
		 ;	isa(TCidP,TCid) 
		)
	).

not_max_implicative_classHasAttr(Term,BindPat) :-
	BindPat = classHasAttr(SCid,RCidO,TCidO),
	Term = classHasAttr(SCid,RCid,TCid),
	classHasAttr_gen2(SCid,RCidO,TCidO),
	\+ (Term = BindPat),	
	isa(RCidO,RCid),	
	isa(TCidO,TCid).

%%% allAttr/3 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(immed_allAttr/3, "@tt{immed_allAttr(SCid,RCid,TCid)}
accesses facts stored directly in @pred{allAttr_ext/3} and information
produced via @pred{allAttr_int/6}.").

immed_allAttr(SCid,RCid,TCid) :- 
	check_types_checkflag(query,allAttr(SCid,RCid,TCid)),
	allAttr_ext(SCid,RCid,TCid).
immed_allAttr(SCid,RCid,TCid) :- 
	check_types_checkflag(query,allAttr(SCid,RCid,TCid)),
	allAttr_int(SCid,RCid,TCid).

:- comment(allAttr/3, "@tt{allAttr(SCid,RCid,TCid)} defines the semantic
schema relation predicate, where @tt{SCid} is the source class ID,
@tt{RCid} is the relation class ID, and @tt{TCid} is the target class
ID.  Since schema relations are inheritable, the taxonomy is traversed
and the most specific schema relations consistent with the parameters
are returned.  ").

allAttr(SCid,RCid,TCid) :-
	var(SCid),var(RCid),var(TCid), !,
	immed_allAttr(SCid,RCid,TCid).
allAttr(SCid,RCid,TCid) :-
	\+ ground(RCid), !,  
	is_a_rel(RCid),
	check_types_checkflag(query,allAttr(SCid,RCid,TCid)),
	allAttr_2fix(SCid,RCid,TCid).
allAttr(SCid,RCid,TCid) :-
	%% relation is ground!!
	check_types_checkflag(query,allAttr(SCid,RCid,TCid)),
	allAttr_2inh(SCid,RCid,TCid).

:- table allAttr_2fix/3.
allAttr_2fix(SCid,RCid,TCid) :-
	OutTerm = allAttr(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	allAttr_gen13(SCid,RCid,TCid),
	(not_max_implicative_allAttr(OutTerm,BindPat) -> fail ; true).

:- table allAttr_2inh/3.
allAttr_2inh(SCid,RCid,TCid) :-
	OutTerm = allAttr(SCid,RCid,TCid),
	copy_term(OutTerm,BindPat),
	allAttr_gen2(SCid,RCid,TCid),
	(not_max_implicative_allAttr(OutTerm,BindPat) -> fail ; true).

:- table allAttr_gen2/3.
allAttr_gen2(SCid,RCid,TCid) :-
	isa(RCid,RCidP),
	allAttr_gen13(SCid,RCidP,TCid).

:- table allAttr_gen13/3.
allAttr_gen13(SCid,RCid,TCid) :-
	(var(SCid)
	 ->	(var(TCid)
		 ->	immed_allAttr(SCid,RCid,TCid)
		 ;	isa(TCidP,TCid),
			immed_allAttr(SCid,RCid,TCidP)
		)
	 ;      isa(SCid,SCidP),  \+ cdf_root(SCidP),
		immed_allAttr(SCidP,RCid,TCidP),
		(var(TCid)
		 ->	TCid = TCidP
		 ;	isa(TCidP,TCid) 
		)
	).

not_max_implicative_allAttr(OutTerm,BindPat) :-
	BindPat = allAttr(SCidO,RCidO,TCidO),
	OutTerm = allAttr(SCid,RCid,TCid),
	allAttr_gen2(SCidO,RCidO,TCidO),
	\+ (OutTerm = BindPat),	
	isa(RCid,RCidO),	
	isa(SCid,SCidO),	
	isa(TCidO,TCid).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(retractallExtTerm/1, "@tt{retractallExtTerm(Term)} retracts
all extensional CDF facts that unify with the parameters.  Note that
this operation simply removes all matching tuples.  It does not affect
information derived via intensional rules, and may not affect
information derived via inheritance.").

retractallExtTerm(Term) :- 
	apply_checks(retractallExtTermSingle,Term),
	cdf_update_list([retractall(Term)]).

:- comment(newExtTerm/1, "@tt{newExtTerm(Term)} is used to add a new
extensional term to the ontology.
@begin{itemize}
@item By default, checks are made that the identifiers in @tt{Term}
are of the proper type and are consistent.  This can be turned off by
@ref{???.}

@item Checks may also be made that @tt{Term} is not already implied by
the ontology before it can be added.  The default is not to make such
checks, but only to check that @tt{Term} is not extensionally present
before it can be added.

@item Conformability checks.
@end{itemize}
").

newExtTerm(Term):- newExtTerm(newExtTermSingle,Term).

newExtTerm(Context,Term):- 
	(apply_checks(Context,Term) -> 
	    cdf_update_list([asserta(Term)])
	  ; true).

/*
newExtTerm(Context,Term):- 
	apply_checks(Context,Term),
	cdf_update_list([asserta(Term)]).
*/
newExtTerm(Context,Term,Upd0,Upd):- 
	(apply_checks(Context,Term) -> 
	    Upd0 = [asserta(Term)|Upd]
	  ; Upd0 = Upd).		

%-----------------------------------------------------------
%%%%%%%%%%  Retract tables as appropriate upon update; adjust dirty bits.

:- comment(hide,assert_cdf/1).
assert_cdf(Term) :-
	cdf_log(assert(Term)),
	assert_cdf_term(Term),
	abolish_nec_tables(Term).

assert_cdf_term(Term) :-
	assert_cdf_int(Term),
	!.
assert_cdf_term(Term) :-
	asserta(Term),
	get_component_extensional(Term,Name),
	(cdf_flags(dirty,Name)
	 ->	true
	 ;	make_cdf_dirty(Name)
	).

:- comment(hide,retractall_cdf/1).

retractall_cdf(Term) :-
	retractall_cdf_term(Term),
	abolish_nec_tables(Term).
 
retractall_cdf_term(Term) :- 
	retractall_cdf_int(Term),
	cdf_log(retractall(Term)),
	fail. 
retractall_cdf_term(Term) :-
	retract(Term),
	cdf_log(retractall(Term)),
	get_component_extensional(Term,Name),
	(cdf_flags(dirty,Name)
	 ->	true
	 ;	make_cdf_dirty(Name)
	),
	fail.
retractall_cdf_term(_).

abolish_nec_tables(hasAttr_ext(_,_,_)) :- !,
	abolish_hasAttr_inherits.
abolish_nec_tables(allAttr_ext(_,_,_)) :- !,
	abolish_allAttr_inherits.
abolish_nec_tables(classHasAttr_ext(_,_,_)) :- !,
	abolish_classHasAttr_inherits.
abolish_nec_tables(subclass_ext(_,_)) :- !,
	abolish_hasAttr_inherits,
	abolish_allAttr_inherits,
	abolish_classHasAttr_inherits.
abolish_nec_tables(_).

abolish_hasAttr_inherits :-
	abolish_table_pred(hasAttr_gen13(_,_,_)),
	abolish_table_pred(hasAttr_gen2(_,_,_)),
	abolish_table_pred(hasAttr_2inh(_,_,_)),
	abolish_table_pred(hasAttr_2fix(_,_,_)).

abolish_classHasAttr_inherits :-
	abolish_table_pred(classHasAttr_gen2(_,_,_)),
	abolish_table_pred(classHasAttr_gen13(_,_,_)),
	abolish_table_pred(classHasAttr_2fix(_,_,_)),
	abolish_table_pred(classHasAttr_2inh(_,_,_)).

abolish_allAttr_inherits :-
	abolish_table_pred(allAttr_gen13(_,_,_)),
	abolish_table_pred(allAttr_gen2(_,_,_)),
	abolish_table_pred(allAttr_2fix(_,_,_)),
	abolish_table_pred(allAttr_2inh(_,_,_)).

%%% OTHER PREDS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% performance testing predicate
:- comment(hide,set_chk_index/0).
set_chk_index :-
	set_chk_index(isa_ext(_,_)),
	set_chk_index(hasAttr_ext(_,_,_)),
	set_chk_index(classHasAttr_ext(_,_,_)),
	set_chk_index(allAttr_ext(_,_,_)).

set_chk_index(Goal) :-
	asserta((Goal :- chk_index(Goal))).

chk_index(Goal) :-
	('_$index'(Goal,Index,_)
	 ->	(integer(Index)
		 ->	\+ bound_on([Index],Goal)
		 ;	\+ bound_on(Index,Goal)
		)
	 ;	\+ bound_on([1],Goal)
	),
	telling(OF),tell(user),writeln('Non-indexed call '(Goal)),
	tell(OF),
	fail.

bound_on([ArgNo|_ArgNos],Goal) :-
	bound_on_all(ArgNo,Goal).
bound_on([_ArgNo|ArgNos],Goal) :-
	bound_on(ArgNos,Goal).

bound_on_all(ArgNo,Goal) :-
	ArgNo1 is ArgNo /\ 255,
	arg(ArgNo1,Goal,Arg),
	nonvar(Arg),
	(ArgNo < 256
	 ->	true
	 ;	ArgNoM is ArgNo >> 8,
		bound_on_all(ArgNoM,Goal)
	).

%%% ATTRIBUTE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(hide,updateAttribute/5).
:- comment(updateAttribute/5,
"@tt{update_attribute(Oid,RCid,TCid,VarTerm,ValList)} updates a set of
values, only invalidating those that changed.  VarTerm must contain
all the free variables in (Oid,RCid,TCid), and ValList is a list of
instances of VarTerm.  The goal is to minimize invalidation.  The
semantics is: (retractallAttribute(Oid,RCid,TCid),
(member(VarTerm,ValList), assert_attribute(Oid,RCid,TCid)), fail ;
true).").

/**updateAttribute(_Oid,_Rid,_Cid,_Vars,_NValList) :-
	cdf_error(cdf,['updateAttribute/5 has not yet been ported to CDF']),
	fail. **/

updateExtTerm(ExtTerm,Vars,NValList) :-
	findall(Vars,ExtTerm,OValList),
	sort(NValList,SNValList),
	sort(OValList,SOValList),
	updateExtTermMerge(SOValList,SNValList,p(ExtTerm,Vars),Updates,[]),
	cdf_update_list(Updates).

updateExtTermMerge(SOValList,SNValList,ArgsVars,Updates0,Updates) :-
	SOValList = [OVal|SOVals],
	SNValList = [NVal|SNVals],
	!,
	(OVal == NVal
	 ->	updateExtTermMerge(SOVals,SNVals,ArgsVars,Updates0,Updates)
	 ; OVal @< NVal
	 ->	copy_term(ArgsVars,p(NExtTerm,OVal)),
		(call(NExtTerm) % don't delete if inherited
		 ->	Updates0 = 
			   [retractall(NExtTerm)|Updates1],
			updateExtTermMerge(SOVals,SNValList,ArgsVars,
					       Updates1,Updates)
		 ;	updateExtTermMerge(SOVals,SNValList,ArgsVars,
					       Updates0,Updates)
		)
	 ;	copy_term(ArgsVars,p(NExtTerm,NVal)),
		newExtTerm(update_attribute,NExtTerm,Updates0,Updates1),
		updateExtTermMerge(SOValList,SNVals,ArgsVars,Updates1,Updates)
	).
updateExtTermMerge([],[NVal|SNVals],ArgsVars,Updates0,Updates) :- !,
	copy_term(ArgsVars,p(NExtTerm,NVal)),
	newExtTerm(update_attribute,NExtTerm,Updates0,Updates1),
	updateExtTermMerge([],SNVals,ArgsVars,Updates1,Updates).
updateExtTermMerge([OVal|SOVals],[],ArgsVars,Updates0,Updates) :- !,
	copy_term(ArgsVars,p(NExtTerm,OVal)),
	(call(NExtTerm) % don't delete if inherited
	 ->	Updates0 = 
		 	[retractall(NExtTerm)|Updates1],
		updateExtTermMerge(SOVals,[],ArgsVars,Updates1,Updates)
	 ;	updateExtTermMerge(SOVals,[],ArgsVars,Updates0,Updates)
	).
updateExtTermMerge([],[],_ArgsVars,Updates,Updates).


end_of_file.

/* check_attribute(+,+,+).  This predicate should be used *only* in
newAttribute. The idea is that newAttribute should add a new attribute
only if that new attribute is not implied by the ontology.  But using
attribute as a check in newAttribute is 1) inefficient and 2) not
quite right.  The not-quite-right part is be cause newAttribute seeks
to backtrack through all *maximal" attribtues implied by the ontology
(last ifthenelse of attribute/3) and we want newAttribute to add only
if the attribute is not implied, regardless if it is maximally implied
or not. */

check_attribute(Oid,RCid,TCid) :-
	(immed_attribute(Oid,RCid,TCid) 
         ->	true
	 ;	immed_isa(Oid,SCid),
		irel(SCid,RCid,TCid)
	).

show_cdf_size:- 
	count_success(isa_ext(_,_)),
	count_success(hasAttr_ext(_,_,_)),
	count_success(classHasAttr_ext(_,_,_)),
	count_success(allAttr_ext(_,_,_)).
	
count_success(Term):- 
	conset('_$size_matters',0),
	count_success_1(Term),
	conget('_$size_matters',N),
	functor(Term,F,A),
	writeln(('There are ',N,' ',F,'/',A,' successes')).
	
count_success_1(Term):- 
	call(Term),
	inc_count,
	fail.
count_success_1(_).

inc_count:- 
	conget('_$size_matters',N),
	N1 is N + 1,
	conset('_$size_matters',N1).

