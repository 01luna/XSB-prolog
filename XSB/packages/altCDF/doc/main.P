:- compiler_options([ciao_directives]).

:- comment(title,"CDF: Cold Dead Fish").
:- comment(subtitle,"An Ontology Management System").

:- comment(author,"Terrance Swift, David S. Warren").
:- comment(author,"with help from Joseph Gartner, Tanya Vidrevich").

:- comment(copyright,"Copyright XSB, Inc 2001-2003; Medicine Rules,
Inc, 2001.  This document produced via the XSBDOC system.").

:- comment(summary,"@include{READMEcdf}").

:- comment(module,"

Two leading paradigms for formal knowledge representation are
ontologies and logic programming.  Both formalisms have a clear,
logic-based semantics.  Ontologies have advantages in that the
knowledge they represent is easily visualizable.  In addition, if an
ontology is based on a description logic, important problems in
consistency and ontology construction are decidable and can be
performed by deduction engines.  In terms of knowledge representation,
logic programming has advantages in its extensions to incorporate
non-monotonic and constraint-based reasoning.  In addition the
procedurality of logic programming complements an the deduction engine
of an ontology.

@em{Cold Dead Fish (CDF)} provides an experimental platform to combine
logic programming with ontology management @footnote{Historically,
Cold Dead Fish was called the Ontology Management System (OMS).}.
Development of CDF is actively underway, and the initial versions of
many important parts of CDF are not yet available@footnote{ALC-style
class expressions are in the process of being developed for CDF: see
@cite{Swif03}.}.  Nonetheless, CDF has already been used heavily in
commercial and research products to represent and manipulate knowledge
in a way that is useful to XSB, to allow the knowledge to persist in a
database of file system, and to visualize that knowledge through
Interprolog @cite{Cale01} and other tools.

@section{A (somewhat) Formal Introduction to CDF}

In this section we motivate design decisions taken by CDF, and
introduce a semantics of CDF based on a translation of a @em{CDF
instance} into a set of first-order logic sentences that constitute an
@em{Ontology Theory} whose models are the models of a CDF
instance@footnote{The development of this section generally follows
@cite{SwiW03a}.}.  For clarity of presentation of semantic issues, we
use simplified form of identifiers in this section and omit many
operational features.  Identifiers and operational features are
discussed in @ref{Operational Aspects of CDF}.  We also omit higher
order relations that can be defined in CDF, which are discussed in
@ref{Extending the Semantics to Higher-Order Relations}.

From a semantic point of view, a @em{CDF instance} can be thought of
as a set of ground Prolog facts for the following predicates:
@tt{isa/2}, @tt{hasAttr/3}, @tt{allAttr/3}, and @tt{classHasAttr/3}.
(In practice, facts in a CDF instance may be defined either
@em{extensionally}, or @em{intensionally} using XSB rules.)  Each
argument in these facts is an @em{identifier}.  As mentioned, in this
section we use a simplified form of an identifier, defined as follows.

@bf{Definition 1} [@em{Identifiers, simplified form}] A term @em{T} is
an identifier if @em{T} has the functor @tt{id/1}, @tt{cid/1},
@tt{oid/1}, @tt{rid/1}, or @tt{crid/1}, whose first argument is

@begin{enumerate} 

@item a ground atomic Prolog term; or

@item a non-atomic Prolog term, each argument of which is an
identifier.  

@end{enumerate}

@noindent In the first case, an identifer is called an @em{atomic}
identifier and in the second a @em{product} identifier.  As will be
seen, the finctor @tt{cid/1} indicates that an identifier is a
class@footnote{In CDF, sets are termed @em{classes} to stress the
informality of its sets from the perspective of set theory.};
@tt{oid/1} indicates that an identifier is an object; @tt{orid/1}
indicates that an identifier is a relation between objects, and
@tt{crid/1} indicates that an identifier si a relation between a class
and an object.  Because of this special meaning of identifiers, the
semantics of CDF differs from the usual semantics assigned to facts in
Prolog.  In CDF some identifiers identify individuals of a given
structure (as in the semantics of Prolog), but others identify tuples
of individuals, sets of individuals or of tuples of individuals, or
relationships.  Furthermore, the facts of a CDF instance can
implicitly denote inheritance of various relationships among classes
and objects along with constraints about what relationships are
allowed.

The rest of this section has two aims: first it motivates the
semantics of CDF via various examples -- as it does so, it introduces
the formal semantics for the various predicates that are introduced as
well as axioms for CDF as a whole.

@subsection{Classes and Objects}

@bf{Example 1} We begin to construct a fragment of a CDF instance for
representing medical sutures, which will form a running example.  In
the process of modelling this instance, we adapt meta-data from the
U.S. Defence Logistics Information Service (@tt{http://www.dlis.mil}),
from the Universal Standard Products and Services Classification
@cite{UNSPSC}, as well as from the website of various commercial
medical supply companies.

The fragment
@begin{verbatim}
isa(cid(medicalEquipment),id(cdfRoot))  
  isa(cid(woundCareProducts),cid(medicalEquipment)) 
    isa(cid(suturesAndRelatedProducts)),cid(woundCareProducts))
      isa(cid(sutures),cid(suturesandRelatedProducts) 
        isa(cid(absorbableSutures),cid(sutures))  
        isa(cid(nonAbsorbableSutures),cid(sutures)) 
      isa(cid(sutureNeedles),cid(suturesAndRelatedProducts))  
@end{verbatim}

@noindent denotes a hierarchy of classes.  Note that the top of the
hierarchy is called @tt{cdfRoot}, and has a special identifier
functor, @em{id/1} as it includes both objects and relations.

Next, we add the facts 
@begin{verbatim}
  isa(oid(suture547466),oid(absorbableSutures))
  isa(oid(sutureU245H),oid(suturesAndRelatedProducts)) 
@end{verbatim}

@noindent to denote various objects in the classes.  Note that by
these statements, @tt{oid(sutureU245H)} belongs to the class
@tt{cid(suturesAndRelatedProducts)} which is (potentially) more
general than the class @tt{cid(absorbableSutures)}.

@end{example}

Note that the decision of whether to denote an entity as an object or
as a class depends on the use of a given CDF instance.  Here, a given
part number can specify a number of physical parts, but the physical
parts are taken to be identical for the purposes of this instance.
However, if we were constructing a CDF instance for warehouse
management, the above objects might be better represented as classes,
and the physical objects represented as CDF objects.

At this point, we can begin to define the semantics of CDF instances.

@bf{Definition 2} An @em{ontology language} is a first-order language
whose set of predicates contains only: @em{isCls/1,
isObj/1,isRel/1,isCRel/1,memof/2, rel/3}, and @em{crel/3}.  It also
contains the identifier functions @em{id/1}, @em{cid/1}, @em{oid/1},
@em{rid/1} and @em{crid/1}.  An @em{ontology structure} is a structure
defined over an ontology language.  An @em{ontology theory} is a set
of first-order sentences formed over an ontology language that
includes a set of @em{ core axioms}.  If @em{T} is an ontology theory
formed over an ontology language @em{L}, an ontology structure @em{S}
over @em{L} is a model of @em{T} if every sentence of @em{T} is
satisfied in @em{S}.

An ontology theory has both core axioms that belong to every ontology
theory, and @em{instance axioms} that are particular to a given theory
and that are used to represent the meaning of a given CDF instance.
Accordingly, in developing our semantics we present both core and
instance axioms.  As a technical point, if @em{I} is a constant or
function symbol in a CDF instance, then we assume that @em{I} is a
constant in @em{L}, the language underlying the ontology theory to
which we translate.  We thus freely use constants and function symbols
for CDF instances and ontology theories.

Informally @em{isCls/1} indicates that an identifier @em{I} is a class
name or @em{class identifier}; @em{isObj/1} that @em{I} is an object
name or @em{object identifier}; @em{isRel/1} that @em{I} is a name for
a relation between objects or @em{object-object relation identifier};
and @em{isCRel/1} that @em{I} is a name for a relation between classes
and objects or @em{class-object relation identifier}.  @em{memof(O,C)}
indicates that object identifier @em{O} is an ""element"" of class
identifier @em{C}; @em{rel(O1,R,O2)} indicates that object identifier
@em{O1} has an @em{R} relation to an object identifier @em{O2}; and
@em{crel(C1,R,O2)} indicates that the class identifier @em{C1} has a
@em{R} relation to an object identifier @em{O2}.

Our first core axiom ensures that objects, classes, and relations have
distinct identifiers

@bf{Core Axiom} @em{[Distinct Identifiers]}

@noindent
@em{(@bf{not exists} Id).(isCls(Id) @bf{and} (isObj(Id) @bf{or}
isRel(Id) @bf{or} isCRel(Id))) @bf{and}}

@noindent
@em{(@bf{not exists} Id).(isObj(Id) @bf{and} (isRel(Id) @bf{or}
isCRel(Id))) @bf{and}  }

@noindent
@em{(@bf{not exists} Id).(isRel(Id) @bf{and} isCRel(Id)) }

@em{isCls/1}, @em{isObj/1}, @em{isRel/1}, and @em{isCRel/1} provide
a sorting that extends to all predicates, as the next axiom indicates.

@bf{Core Axiom} @em{[Predicate Sorts]}

@noindent
@em{
(@bf{forall} X,Y).(memof(X,Y) @bf{=>} (isObj(X) @bf{and} isCls(Y))) @bf{and}  
}
 
@noindent
@em{   (@bf{forall} X,Y,Z).(rel(X,Y,Z) @bf{=>} (isObj(X) 
	@bf{and} isRel(Y) @bf{and} isObj(Z))) @bf{and}  }

@noindent
@em{
    (@bf{forall} X,Y,Z).(crel(X,Y,Z) @bf{=>} (isCls(X) @bf{and} isRel(Y)
			   @bf{and} isObj(Z)))
}

Before defining our first instance axiom, we present a rule that will
be used to relate identifier functions with the sorts mentioned above.

@bf{Definition 3} @em{[IdType]} @noindent Let @em{I} is be an identifier.
@em{IdType(I)} is equal to @em{isCls(I)} if the main functor symbol of
@em{I} is @tt{cid/1}; @em{isObj(I)} if the main functor symbol of
@em{I} is @tt{oid/1}; @em{isRel(I)} if the main functor symbol of
@em{I} is @tt{rid/1}; and @em{isCRid(I)} if the main functor symbol of
@em{I} is @tt{crid/1}.

@bf{Instance Axiom} [@tt{isa/2}] For each fact of the form
@tt{isa(Id1,Id2)} add the axiom

@em{ IdType(Id1) @bf{and} IdType(Id2) @bf{and}}

@em{((isCls(Id1) @bf{and} isCls(Id2)) @bf{=>}
	(@bf{forall} X).(memof(X,Id1) @bf{=>} memof(X,Id2))) @bf{and}
}

@em{
((isObj(Id1) @bf{and} isCls(Id2)) @bf{=>} memof(Id1,Id2)) @bf{and}
}

@em{((isRel(Id1) @bf{and} isRel(Id2)) @bf{=>}
	(@bf{forall} X,Y).(rel(X,Id1,Y) @bf{=>} rel(X,Id2,Y))) @bf{and} 
}

@em{((isCRel(Id1) @bf{and} isCRel(Id2)) @bf{=>}
	(@bf{forall} X,Y).(crel(X,Id1,Y) @bf{=>} crel(X,Id2,Y)))
}

@noindent
denoted as @em{Int(@tt{isa(Id1,Id2)})}.


It is important for the semantics of relations that each class have at
least one member.

@bf{Core Axiom} @em{[Non-Null Classes]}
@begin{itemize}
@item @em{(@bf{forall} X).(isCls(X) @bf{=>} (@bf{exists} Y).memof(Y,X))}
@end{itemize}

Our last core axiom for these predicates ensures is that each class is
a subclass of @tt{id(cdfRoot)}.

@bf{Core Axiom} @em{[Domain Containment]} @begin{itemize} @item
@em{(@bf{forall} X).(isObj(X) @bf{=>} memof(X,id(cdfRoot)))}
@end{itemize}

@subsection{General Relations between Objects}

Given the @tt{isa/2} predicate among classes and objects, simple but
useful @em{taxonomies} can be developed.  Of course, not all
interesting information about the world can be represented via a fixed
subclass relation.  Hence, there are other predicates that can
indicate arbitrary relations between objects and the classes that
contain them.

The first such relation is the @tt{hasAttr/3} relation whose use is
illustrated as follows.

@bf{Example 2}
The following fragment adds to the facts in the previous examples.

@begin{verbatim}
isa(cid(endTypeDomain),id('CDF Root')) 
   isa(cid(singleArmed),cid(endTypeDomain)) 
   isa(cid(doubleArmed),cid(endTypeDomain))  
   isa(cid(unarmed),cid(endTypeDomain))

hasAttr(cid(sutures),rid(endType),cid(endTypeDomain))  
@end{verbatim}

@noindent This fragment indicates that @em{any} object in the
@tt{cid(sutures)} class has an @tt{rid(endType)} relation to an object
in @tt{cid(endTypeDomain)}.  This immediately implies that any class
that is defined as a subclass of @tt{cid(sutures)} will inherit the
@tt{rid(endType)} relationship.  For given objects in
@tt{cid(sutures)}, this knowledge may be more specific -- that it has
a relation to the class @tt{unarmed}.  As an example, consider the
fragment

@begin{verbatim}
hasAttr(oid(suture547466),rid(endType),cid(singleArmed))
hasAttr(oid(suture547466),rid(suturesRUsMatch),cid(sutureU245H))
@end{verbatim}

@noindent The first fact indicates that the @tt{oid(suture547466)}
object has an @tt{rid(endType)} that is in the class
@tt{cid(singleArmed)} -- which is more specific that
@tt{cid(endTypeDomain)}.  In the case of many types of attributes,
such as needle end types, colors and so on, relating an object to a
class is sufficient as there is no need to distinguish objects within
the target class of colors or end types.  The second fact indicates
that there is a @tt{rid(suturesRusMatch)} between the objects
@tt{oid(suture547466)} and @tt{oid(sutureU245H)}.

@tt{hasAttr/3} thus provides a simple but powerful mechanism for
inheritance in CDF.  To explain its semantics we use the
predicate @em{memof=(X,Y)} which is defined as

@em{
((isCls(Y) @bf{and} memof(X,Y)) @bf{or} (isObj(Y) @bf{and} X=Y))
}

@bf{Instance Axiom} [hasAttr/3]
For each fact of the form @tt{hasAttr(Id1,Rid,Id2)} add the instance
axiom: 

@em{IdType(Id1) @bf{and} IdType(Rid) @bf{and} IdType(Id2) @bf{and} }

@em{
(@bf{forall} X). (memof=(X,Id1) @bf{=>} (@bf{exists} Y).(rel(X,Rid,Y) 
					@bf{and} memof=(Y,Id2))))
}

@noindent
denoted as @em{Int(@tt{hasAttr(Id1,Rid,Id2)})}

As a dual to @tt{hasAttr/3},, it is often useful to indicate typing
via schema relations between sets.  To take a simple example, the
class @em{person} may have a relation @em{brother} to the class of
@em{malePerson}.  This doesn't mean that every person @em{has} a
brother that is a @em{malePerson} (as would be indicated by
@tt{hasAttr/3}), only that @em{if} a person has a brother, the brother
must be a @em{malePerson}.

@bf{Example 3}
The following fragment provides an application-oriented example:
@begin{verbatim}
allAttr(cid(dlaPart),rid(suturesRusMatch),cid(suturesRusPart)) 
@end{verbatim}

@noindent This fragment indiates that a given part in the class
@tt{cid(dlaPart)} may have a @tt{rid(suturesRusMatch)} to a given
@tt{cid(suturesRusPart)} -- but not necessarily -- an equivalent part
may not be in the vendor's catalog.  However, the fragment precludes
the case in which a @tt{cid(dlaPart)} has a @tt{rid(suturesRusMatch)}
to a part in class that is not a @tt{cid(suturesRusPart)}, such as the
parts from a competing vendor.

Not surprisingly, the semantics of @tt{allAttr/3} resembles that of
@tt{hasAttr/3}.

@bf{Instance Axiom} [@tt{allAttr/3}] For each fact of the form
@tt{allAttr(Id1,Rid,Id2)} add the instance axiom: 

@em{ IdType(Id1) @bf{and} IdType(Rid) @bf{and} IdType(Id2) @bf{and} }

@em{ (@bf{forall} X.@bf{forall} Y). ((memof=(X,Id1) @bf{and}
rel(X,Rid,Y)) 	@bf{=>} memof=(Y,Id2))
}

@noindent
denoted as @em{Int(@tt{allAttr(Id1,Rid,Id2)})}.

@subsection{General Relations among Classes and Objects}

Alternatively, sets may have relations that do @em{not} hold for their
subclasses or members.  For instance, a finite set may have a given
cardinality, but its proper subsets will have a different cardinality.
From a practical point of view, such relations on sets are
@em{non-inheritable}.

@bf{Example 4} 
A practical example of a non-inheritable relation comes from an
application that may be called part equivalency matching.  In this
application, the possible attributes for a class of parts are given
various weights.  Two parts match if the sum of the weights of their
attributes that match are above a given threshold.  The weighting for
the @tt{rid(endType)} relation of sutures might be given as:

@begin{verbatim}
classHasAttr(cid(sutures),crid(endTypeWeight),cid(highWeight)))
@end{verbatim} 

@noindent This fragment indicates that the matching weight for the
@tt{rid(endType)} attribute for parts classified to @tt{cid(sutures)}
should be @tt{cid(highweight)}.  Matching weights are denoted as
non-inheritable using the @tt{crid(classHasAttr/3)} predicate, which
indicates a relation whose domain is a class rather than the objects
in the class.  The weights are made non-inheritable because a weight
may depend on a given classification of a part.  For instance if a
part were classified as a @tt{cid(nonAbsorbableSuture)}, its
@tt{rid(endType)} might weigh less (or more) for determining whether
two sutures are equivalent.

@bf{Instance Axiom} [@tt{classHasAttr/3}]
For each fact  @tt{classHasAttr(Id1,Rid,Id2)} add the instance axiom:

@em{ IdType(Id1) @bf{and} IdType(Rid) @bf{and} IdType(Id2) @bf{and} }

@em{ (@bf{exists} X).membof=(X,Id2) @bf{and} crel(Id1,Rid,X) }

@noindent
denoted as @em{Int(@tt{classHasAttr(Id1,Rid,Id2)})}.

@subsection{Product Identifiers}

The above predicates allow the definition of various named binary
relations.  However, binary definitions can sometimes
be inconvenient to use.  For instance, in the part equivalency
matching example, (Example 3), it may be desirable to make explicit
the weight of the match as an indication of the strength of the match.
The weight could be made explicit by a series of definitions

@begin{verbatim}
allAttr(cid(dlaPart),rid(suturesRusMatch_low),cid(suturesRusPart))
:
allAttr(cid(dlaPart),rid(suturesRusMatch_high),cid(suturesRusPart))
@end{verbatim} 
@noindent 
indicting that a given part has a match of weight @tt{low} through
@tt{high}.  However, for a scale with a large number of values,
defining matches in this way is time-consuming and prone to errors.
To address this, CDF provides @em{product classes}, as in the
following fact

@begin{verbatim}
allAttr(cid(dlaPart),rid(suturesRusMatch(cid(matchScale))),cid(suturesRusPart))
@end{verbatim} 

@noindent which indicates that a part in @tt{cid(dlaPart)} can have a
match with some @tt{cid(matchScale)} weight to a
@tt{cid(suturesRusPart)} part.

@bf{Example 5} 
Anoter aspect of product classes is illustrated by the fragment:
@begin{verbatim}
isa(cid(sign,id(cdfRoot))
  isa(cid(('+'),cid(sign))
  isa(cid(('-'),cid(sign))
isa(cid((unit),id(cdfRoot))  
  isa(cid((dimensionUnit),cid(unit))
    isa(cid((length),cid(dimensionUnit))
    isa(cid((width),cid(dimensionUnit))
     isa(cid((height),cid(dimensionUnit))
  isa(cid((timeUnit),cid(unit))
    isa(cid((minutes),cid(timeUnit))
    isa(cid((days),cid(timeUnit))
@end{verbatim}

@noindent

The class @tt{cid(measure(cid(sign),cid(integer),cid(unit)))} can be
thought of as the set of terms with outer functor @tt{measure/3} whose
first argument is a member of the class @tt{cid(sign)}, whose second
argument is an integer @tt{cid(allIntegers)} indicates the class of
all integers, (see @ref{Primitive Classes and Objects}) and whose
third element is a member of @tt{cid(unit)}.  By this reasoning, the
identifiers @tt{cid(measure(cid('+'),cid(integer),cid(length))} and
@tt{measure(cid('-'),cid(2),cid(days)} are both subclasses of
@tt{cid(measure(cid(sign),cid(integer),cid(unit))}, but neither is a
subclass of each other.

We capture the intuition behind product classes through the following
axiom schemas.  The first indicates that product identifiers 
are constructed from @em{constituent identifiers} of the same sort.

@bf{Core Axiom} @em{[Downward Closure]}
For each product identifier @em{f(x1,...,xn)} and for each atomic
identifier @em{c} the following axioms are added,
@begin{itemize}
@item @em{isCls(f(x1,...,xn)) @bf{=>}
	isCls(x1) @bf{and} ... @bf{and} isCls(x_n)}
@item @em{isObj(f(x1,...,xn)) @bf{=>}
	isObj(x1) @bf{and} ... @bf{and} isObj(x_n)}
@item @em{isRel(f(x1,...,xn)) @bf{=>}
	isRel(x1) @bf{and} ... @bf{and} isRel(x_n)}
@item @em{isCRel(f(x1,...,xn)) @bf{=>}
	isCRel(x1) @bf{and} ... @bf{and} isCRel(x_n)}
@end{itemize}

The next axiom associates product classes with the objects they contain.

@bf{Core Axiom} @em{[Implicit Isa]}
For each product identifier @em{f(x1,...,xn)} and for each atomic
identifier @em{c} the following axioms are added,
@begin{enumerate}
@item @em{(@bf{forall} O).(memof(O,f(x1,...,xn)) @bf{<=>}
	 (O = f(y1,...,yn) @bf{and} 
		memof(y1,x1) @bf{and} ... @bf{and} memof(yn,xn)))}

@item @em{(@bf{forall} C).(memof(f(x1,...,xn),C) @bf{=>}
	(C = f(y1,...,yn) @bf{or} C = c))}
@end{enumerate}

@noindent Note that together with the Predicate Sorts Axiom, the
Implicit Isa Axiom implies that if
@em{memof(f(y1,...,yn),f(x1,...,xn))} holds, then
@em{isObj(f(y1,...,yn))},and @em{isCls(f(x1,...,xn))} hold; by the
Downward Closure Axiom so do @em{isObj(yi)} and @em{isCls(xi)} for
@em{1 =< i =< n}.

@cite{SwiW03a} gives conditions that are necessary and sufficient for
a CDF instance to be consistent.

@subsection{Inheritance}

The definition of the @tt{hasAttr/3} relation in Example 3 on the
class of @tt{cid(sutures)} indicates that each object in this class is
related to an object in @tt{cid(endTypeDomain)}.  Thus, if no stronger
information were provided for, say, part @tt{oid(suturesU245H)}, then

@em{Int(@tt{hasAttr(oid(suturesU245H),rid(endType),cid(endTypeDomain))})}

@noindent would be true in any model of the CDF instance.  This
consequence can be seen as a primitive form of ``default'', or more
precisely indefinite, reasoning that is provided by CDF.  Indeed,

@em{Int(@tt{hasAttr(suture547466,endType,endTypeDomain)})}

@noindent is also true in any model, but is of less interest, since
Example 2 indicates there is specific information that
@tt{oid(suture547466)} is related to a subclass of
@tt{cid(endTypeDomain)}, namely @tt{cid(singleArmed)}.

In contrast to the relation @tt{rid(endType)} the relation
@tt{rid(suturesRusMatch)} was defined via the @tt{allAttr/3}
predicate.  So in this case no @tt{hasAttr/3}, will be inferred, as
accords with intuition.  However the constraint that any
@tt{rid(suturesRusMatch)} must be to a @tt{rid(suturesRusPart)}
holds for members of the class @tt{rid(sutures)}, just as it holds
for subclasses of @tt{rid(sutures)}.

The followin formulas summarize inheritance in the first argument of
relations, and can be proved in a straightforward manner.

@bf{Proposition 1.1} @em{[First Argument Inheritance Propagation]}
Let @em{M} be an ontology model.
@begin{itemize}
@item If @em{M |= Int(@tt{hasAttr(Id1,Id2,Id3)}) @bf{and}
	Int(@tt{isa(Id0,Id1)})} then @em{M |= Int(@tt{hasAttr(Id0,Id2,Id3)})}

@item If @em{M |= Int(@tt{allAttr(Id1,Id2,Id3)})} @bf{and}
    	@em{Int(@tt{isa(Id0,Id1)})}
	 then @em{M |= Int(@tt{allAttr(Id0,Id2,Id3)})}

@item If @em{M |= Int(@tt{allAttr(Id1,Id2,Id3)}) @bf{and}
		         Int(@tt{isa(Id0,Id1)}) 
		@bf{and} Int(@tt{hasAttr(Id0,Id2,Id4)})} then 
	@em{M |= Int(@tt{isa(Id4,Id3)})}

@end{itemize}

There is inheritance also in the third argument of relations.
Consider again the @tt{hasAttr/3} fact @tt{rid(endType)}, defined in
Example 3.  This fact states that any element of @tt{cid(sutures)} is
related to a member or subclass of @tt{cid(endTypeDomain)}.  By this
definition, it also holds that @tt{rid(endType)} relates any element
of @tt{cid(sutures)} to a member or subclass of any @em{superclass} of
@tt{cid(endTypeDomain)} so that 

	@em{Int(@tt{hasAttr(cid(sutures),rid(endType),id('CDF Root'))})}

@noindent
should also hold in any model of the CDF instance.  Similiarly, 

@em{Int(@tt{allAttr(cid(dlaPart),rid(suturesRusMatch),id('CDF Root'))})}

@noindent should also hold.  In English, for every member of
@tt{cid(suture)} that has a @tt{rid(suturesRusMatch)} relation, the
target of that relation is a member of @tt{id('CDF Root')}.

@bf{Proposition 1.2} @em{[Third-Argument Inheritance Propagation]}
@begin{itemize}
@item If @em{M |= Int(@tt{hasAttr}(Id1,Id2,Id3)) and
	Int(@tt{isa}(Id3,Id4))} then @em{M |= Int(@tt{hasAttr}(Id0,Id2,Id4))}

@item If @em{M |= Int(@tt{allAttr}(Id1,Id2,Id3)) and
	Int(@tt{isa}(Id3,Id4))} then @em{M |= Int(@tt{allAttr}(Id0,Id2,Id4))}

@item If @em{M |= Int(@tt{classHasAttr}(Id1,Id2,Id3)) and
	Int(@tt{isa}(Id3,Id4))} then 
		@em{M |= Int(@tt{classHasAttr}(Id0,Id2,Id4))}
@end{itemize}

A final aspect of inheritance arises from generalization or
specialization of relations themselves.  For instance, the relation
parent can be generalized to ancestor or specialized to mother.  Thus,
if Abraham is the parent of Isaac, it is true that he is the ancestor
or Isaac but not necessarily the mother of Isaac.  Accordingly the
@tt{hasAttr/3} predicate, which represents this fact holds when its
relation is generalized, but not when it is specialized.
Second-argument inheritance works in the opposite way for
@tt{allAttr/3}: it holds when the relation is specialized, but not
generalized.  Thus if any brother of Isaac is male, then any
twinBrother will be male, but any sibling will not necessarily be
male.  These intuitions are reflected in the final inheritance
propositions.

@bf{Proposition} @em{[Second-Argument Inheritance Propagation]}

@begin{itemize}
@item If @em{M |= @tt{hasAttr}(Id1,Id2,Id3)) and
	@tt{isa}(Id2,Id4))} then @em{M |= @tt{hasAttr}(Id0,Id4,Id3)}

@item If @em{M |= @tt{allAttr}(Id1,Id2,Id3)) and
	@tt{isa}(Id4,Id2))} then @em{M |= @tt{allAttr}(Id0,Id4,Id3)}

@item If @em{M |= @tt{classHasAttr}(Id1,Id2,Id3)) and
	@tt{isa}(Id2,Id4))} then @em{M |= @tt{classHasAttr}(Id0,Id4,Id3)}
@end{itemize}

@section{Extending the Semantics to Higher-Order Relations}

So far we have introduced two types of relations: @em{rel/3} which
relates an object identifier to an object identifier and @em{crel/3}
which relates a class identifier to an object identifier.  We have
also introduced various CDF predicates to make statements about these
relations: a @tt{hasAttr/3} fact makes an existential statement about
the @em{rel/3} predicate for an object or all objects in a class,
while a @tt{allAttr/3} makes a universal statement about the
@em{rel/3} predicate for an object or all objects in a class.  

Alternatively, a @em{classHasAttr/3} predicate makes an existential
statement about the @em{crel/3} predicate for a class identifier.  One
can also imagine a @em{classAllAttr/3} to make a universal statement
about the @em{crel/3} predicate for a class identifier.  This
predicate has not yet been implemented in CDF, although it may be
implemented if a need for it arises in applications.

@em{rel/3} and @em{crel/3} can be seen as part of a hierarchy of
relations.  One may have a relation whose domain consists of a
@em{rel/3}, a @em{crel/3} tuple, an object-object relation identifier
or a object-class relation identifier.  Similarly one can define
further relations on these higher-order relations.

Two such relations have been seen to be important in applications so
far.

@begin{itemize}

@item Relations from an object-object relation identifier @em{RI} to
an object.  Since the domain of this relation is the class of tuples
denoted by @em{RI}, and since @em{RI} is of the form @em{rid/2},
identifiers for this new type of relation use the functor @em{crrid/2}.

@item Relations from a class-object relation identifier @em{CRI} to an
object.  Since the domain of this relation is the class of tuples
denoted by @em{CRI}, and since @em{RI} is of the form @em{crid/2},
identifiers for this new type of relation use the functor
@em{crcrid/2}.

@end{itemize}

@bf{Example 6} Suppose we wish to display the name for the relation
@tt{rid(endType,dla)} in Example 2 as @tt{'Suture End Type'} in a CDF
editor.  This display name can be represented by the fact

@begin{verbatim}
classHasAttr(rid(endType,dla),crrid(displayName,dla),
                                cid('Suture End Type',dla))
@end{verbatim}

Similarly the display name for @tt{crid(endTypeWeight,dla)} can be
represented as 

@begin{verbatim}
classHasAttr(crid(endTypeWeight,dla),crcrid(displayName,dla),
                                cid('Suture End Type Weight',dla))
@end{verbatim}

The CDF semantics presented above can be extended to these new
identifier types in a straightforward manner.

@section{Operational Aspects of CDF}

Section @ref{A (somewhat) Formal Introduction to CDF} abstracts out
many important features of CDF in order to present a clear semantics.
In this section we introduce several implementation features important
to the operation of CDF.

@subsection{Component Format for Identifiers}

The previous section presented identifiers as a unique way of
indicating a class, object, or relation.  In our implementation of CDF
identifiers are defined using a @em{Component Format}.

@bf{Definition 4} [@em{Identifiers, Component Form}] A term @em{T} is
an identifier in component format if @em{T} has the functor @tt{id/2},
@tt{cid/2}, @tt{oid/2}, @tt{orid/2}, @tt{crid/2}, @tt{crrid/2} or
@tt{crcrid/2} whose first argument is @em{A1} and whose second
argument is an atom; and

@begin{enumerate} 

@item @em{A1} is an atomic Prolog term; or

@item @em{A1} is a non-atomic Prolog term and each argument of @em{A1}
is an identifier.  The first argument is called the @em{native id} and
the second the @em{source} of the identifier.
@end{enumerate}

@noindent In the first case, an identifier is called @em{atomic}; in
the second it is called a @em{product identifier}.  For either type of
identifier, the first argument is termed the @em{native id} and the
atomic second argument is called the @em{source}.

@bf{Example 7} While the above convention makes identifiers somewhat
harder to read, it can be extremely useful for combining information
from different ontologies, since identifiers from each ontology can be
tagged, avoiding ambiguity and allowing their direct use.  The
fragment of Example 1 represented by identifiers in component form
might look like:

@begin{verbatim}
isa(cid(medicalEquipment,unspsc),id('CDF Root',cdf))  
  isa(cid(woundCareProducts,unspsc),cid(medicalEquipment,unspsc)) 
  isa(cid(suturesAndRelatedProducts,unspsc)),
                                       cid(woundCareProducts,unspsc))
    isa(cid(sutures,unspsc),cid(suturesandRelatedProducts,unspsc) 
      isa(cid(absorbableSutures,dla),cid(sutures,unspsc))  
      isa(cid(nonAbsorbableSutures,dla),cid(sutures,unspsc)) 
    isa(cid(sutureNeedles,dla),cid(suturesAndRelatedProducts,unspsc))  
@end{verbatim}

This format for identifiers is called the component format because the
source of an identifier has important uses in the CDF component system
@ref{cdf_components (library)}, which loads and maintains dependencies
between different parts of an ontology.  For the rest of this
documentation identifiers will be shown in component format.

@subsection{Extensional, Intensional, Immediate, and Implied Information}

From an operational perspective, it is often useful to distinguish
between the whether a given fact is present in a CDF Instance or is
implied by a CDF instance; and whether a fact is intensionally or
extensionally defined.  We discuss the various syntaxes for these
cases.

@bf{Extensional Facts} The previous section assumed that all
information in a CDF instance was contained in ground atomic facts.
Such information is termed @em{extensional information}, and in the
actual implementation of CDF, this information is kept in the
following predicates, whose names have @tt{_ext} appended to them to
indicate that they represent extensional information: @tt{isa_ext/2},
@tt{hasAttr_ext/3}, @tt{allAttr_ext/3}, and @tt{classHasAttr_ext/3}.

@bf{Example 8} The actual implementation of CDF requires extensional
facts to be written using the above @tt{_ext} predicates.
Accordingly, the fragment from Example 5 would be rewritten as
follows:

@begin{verbatim}
isa_ext(cid(medicalEquipment,unspsc),id('CDF Root',cdf))  
  isa_ext(cid(woundCareProducts,unspsc),cid(medicalEquipment,unspsc)) 
  isa_ext(cid(suturesAndRelatedProducts,unspsc)),
                                         cid(woundCareProducts,unspsc))
    isa_ext(cid(sutures,unspsc),cid(suturesandRelatedProducts,unspsc) 
      isa_ext(cid(absorbableSutures,dla),cid(sutures,unspsc))  
      isa_ext(cid(nonAbsorbableSutures,dla),cid(sutures,unspsc)) 
    isa_ext(cid(sutureNeedles,dla),
	                         cid(suturesAndRelatedProducts,unspsc))  
@end{verbatim}

Extensional facts in all other examples must be similarly rewritten
to be implemented in CDF.

@bf{Intensional Rules} At the same time it is often
convenient to use @em{intensional rules} to produce CDF data
""on-demand"".  This can be particularly useful when representing data
from a legacy database: rules can be written to map the data to CDF
format using the XSB ODBC or Oracle interface.

The format of intensional rules closely resembles that of extensional
CDF predicates, but now each functor is followed by @tt{_int} so that
intensional rules can be defined using rules for the predicates
@tt{isa_int/2}, @tt{hasAttr_int/3}, @tt{allAttr_int/3}, and
@tt{classHasAttr_int/3},

Each of these rules is checked in the same manner as extensional data,
so that intensional rules affect inheritance, subclassing, and other
operations in exactly the same manner as extensional rules.

When intensional rules are loaded, they are dynamically asserted so
that intensional rules can be loaded from several files, but reloading
from file @tt{F} will retract rules previously loaded from @tt{F} and
assert new ones.  Users, however do not need to worry about
@tt{multifile/1} declarations for intensional rules.

@bf{Example 9} Suppose that we wish to include Prolog-defined facts
about approved item names in the dla ontology into CDF.  These
approved item name facts consist of an Item Name Code, the Federal
Item Identification Guidline number (FIIG) to which the Item Name Code
belongs, the Item Name itself, and a description:

@begin{verbatim}
item_name('00001','A516K0','ELECTRON TUBE','An inclosure, including
two or more electrodes, in which a flow of electrons may occur through
a vacuum or a contained gas. The electronic conduction takes place
either by means of electrons emitted from a cathode or by ionization
of the contained gas. Includes phototubes (photoemissive type only),
Geiger-Mueller tubes, traveling wave tubes, cathode ray tubes and
microwave tubes (Klystron, magnetron, or the like). Excludes items
whose primary purpose is to produce light energy. Also excludes
PHOTOELECTRIC CELL; and SEMICONDUCTOR DEVICE (as modified).'). 
@end{verbatim}

We can translate these facts using intensional rules as follows.

@begin{verbatim}
isa_int(cid(Nid,dla),cid(Fiig,dla)):- 
     item_name(Nid,Fiig_,_).

classHasAttr_int(id(Nid,dla),crid(name,dla),cid(Name):- 
     item_name(Nid,_,Name,_).

classHasAttr_int(cid(Nid,dla),cid(description,dla),cid(Descr,cdfpt)):- 
     item_name(Nid,_,_,Descr).
@end{verbatim}

@bf{A CDF Instance and its implications} A CDF instance is therefore
defined in terms of extensional facts and intensional rules.  The
following set of predicates can be used to determine whether a fact is
extensionally or intensionally defined by a CDF instance:
@tt{immediate_isa/2}, @tt{immediate_hasAttr/3},
@tt{immediate_classHasAttr/3}, @tt{immediate_classHasAttr/3},

Given a CDF instance, one uses the following predicates to query
whether a given fact is implied by a CDF instance: @tt{isa/2},
@tt{hasAttr/3}, @tt{classHasAttr/3}, and @tt{classHasAttr/3}.

@subsection{Primitive Classes and Objects}

The mechanisms introduced so far allow the creation of @em{primitive
types}, classes of objects constructed by routines that lie outside of
CDF definitions.  

@bf{Example ???}  In order to define Prolog integers as a primitive
type, one might write an intensional rule as follows.

@begin{verbatim}
isa_int(oid(Integer,cdfpt),cid(allIntegers,cdfpt):- 
    (integer(X) -> 
        true
      ; (var(X) -> oms_warning(instantiation,['Isa for primitive types
             must have first argument instantiated']) ) ).

isa_int(cid(Integer,cdfpt),cid(allIntegers,cdfpt):- 
    (integer(X) -> 
        true
      ; (var(X) -> oms_warning(instantiation,['Isa for primitive types
             must have first argument instantiated']) ) ).
@end{verbatim}

While simple, this example illustrates several points.  First,
intensional rules may be constructed so that they do not succeed for
all modes, a situation that is often useful when trying to model large
domains.  Second, the sources of component identifiers are used in CDF
to help index intensional rules.  In this case, the source @tt{cdfpt}
ensures that calls to @tt{isa/2} that have a ground source in a
component identifier will not execute the rule.  In addition, integers
are defined both as objects and as classes (taken as singleton
classes) so that they can be used both in product classes and product
objects.  Finally, the example illustrates how easy it is for users to
make their own primitive types, for e.g. spatial or temporal
relations.

The @tt{cdfpt} component is loaded upon initialization of CDF.  It
currently contains the following primitive types.

@begin{itemize}

@item @tt{cid(allIntegers,cdfpt)} defined so that @tt{cid(Id1,cdfpt)}
is a subclass and @tt{oid(Id1,cdfpt)} a member of
@tt{cid(allIntegers,cdfpt)} if @tt{?- integer(Id1)} is true.

@item @tt{cid(allAtoms,cdfpt)} defined so that @tt{cid(Id1,cdfpt)} is
a subclass and @tt{oid(Id1,cdfpt)} a member of
@tt{cid(allAtoms,cdfpt)} if @tt{?- atom(Id1)} is true.

@item @tt{cid(allFloats,cdfpt)} defined so that @tt{cid(Id1,cdfpt)} is
a subclass and @tt{oid(Id1,cdfpt)} a member of
@tt{cid(allFloats,cdfpt)} if @tt{?- float(Id1)} is true.

@end{itemize}

@bf{TLS: others as needed.  Still need to figure out clause}

@subsection{Using CDF}

The description of CDF presented so far does not include various
operational aspects such as querying or updating a CDF state, issues
to which we now turn.

@subsubsection{Operational Semantics of @tt{isa/2}}

In CDF, a formula @em{Int(isa(Id1,Id2)} is proven using the Instance
Axiom for @tt{isa/2}, the Domain Containment Axiom and the Implicit
Isa Axiom.  From an operational perspective however, a query @tt{?-
isa(X,Y)} can easily be intractable if product classes are used.

@bf{Example 10} Let @tt{cid(Boolean,s)} be a class containing two
subclasses: @tt{cid(true,s)} and @tt{cid(false,s)}.  Then the product
class @tt{cid(f(cid(Boolean,s),...,cid(Boolean,s),s)} will contain a
number of subclasses exponential in the arity of @em{f}.

In order to use product classes in practical applications the
implementation of @tt{isa/2} distinguishes a general isa relation in
which a given fact may be proved using Instance Axioms, the Domain
Containment Axiom and the Implicit Isa Axiom from @em{explicit} isa
proved without the Implicit Isa Axiom.  Based on this distinction, two
restrictions are made:

@begin{enumerate}

@item @em{Assumption 1} Axioms used to prove answers to the query
@tt{?- isa(X,Y)} depend on the instantiation of @tt{X} and @tt{Y}.

@item @em{Assumption 2} if @tt{immediate_isa(Id1,Id2)} is true then
@tt{Id2} is an product identifier.  
@end{enumerate}

We discuss each assumption in turn.  The behavior of @tt{isa/2} for
various instantiation patterns is as follows.

@begin{enumerate} 

@item If @tt{Id1} and @tt{Id2} are both ground, the Implicit Isa Axiom
is used, if necessary.

@item If @tt{Id1} is not ground, the Implicit Isa Axiom is not used,
in order to avoid returning a number of answers that is exponential in
the size of a product identifier.

@item If @tt{Id1} is ground but not @tt{Id2} then the Implicit
Isa Axiom may used in the first step of a derivation to determine
that

@em{(exists Id3,Id4). (isa(Id1,Id3) @bf{and} immediate_isa(Id3,Id4))}

In other words, in any isa derivation for this instantiation pattern,
the first step may use the Implicit Isa Axiom to ""match"" a term in
the @tt{immediate_isa/2} relation, but subsequent steps must use
explicit isa.  Upon backtracking the Implicit Isa Axiom may be used
again to begin a new derivation, but subsequent steps in this
derivation must cannot use this axiom.  @end{enumerate}

The second assumption helps to reinforce the assumption of case 3
above.  Without it, users might expect that the implicit isa axiom
could be used in each step of a derivation of an @tt{isa/2} fact.

@bf{Example 11}  Suppose we have the following CDF instance.

@begin{verbatim}
isa_ext(cid(bot,s),cid(mid,s)).
isa_ext(cid(mid,s),cid(top,s)).

isa_ext(cid(prod(cid(mid,s),cid(top,s)),s),cid(atomicClass,s)).
@end{verbatim}

@begin{itemize}

@item The query 

@tt{isa(cid(prod(cid(bot,s),cid(mid,s)),s),cid(prod(cid(mid,s),cid(mid,s)),s)} 

would succeed.

@item The query @tt{?- isa(cid(prod(cid(bot,s),cid(mid,s)),s),X)}
would successively unify @tt{X} with
@tt{cid(prod(cid(bot,s),cid(mid,s)),s)},
@tt{cid(prod(cid(mid,s),cid(top,s)),s)}, @tt{cid(atomicClass,s)} and
@tt{id('CDF Root',cdf)}.  

@item The query @tt{?-
isa(X,cid(prod(cid(mid,s),cid(mid,s)),s))} would unify @tt{X} only
with @tt{isa(X,cid(prod(cid(mid,s),cid(mid,s)),s))}.  

@end{itemize}

@subsubsection{Answer Substitutions for Relations}

In the CDF fragment for Example 2 there are several possible answers
for the query @tt{?-
hasAttr(oid(suture547466,dla),rid(endType,dla),X)}.  The first unifies
@tt{X} with @tt{cid(singleArmed),dla)}, the second with
@tt{cid(endTypeDomain),dla)}, and the third with @tt{id('CDF
Root'),cdf)}.  The first provides more specific information than the
second, and the second more than the third.  Care is taken in CDF to
return only the most specific answers, without losing completeness.
In this example CDF would only succeed with the first binding.

While the intuition is simple, its precise description of the set of
answers returned by CDF is somewhat complicated.  Let @em{I} be a CDF
instance @em{Q} be a query and @em{Gamma1} be the set of CDF facts
whose interpretations are true in every model of @em{I}.  Let
@em{Gamma2} be the set of answers returned by CDF.  Then for each fact
@em{F1} in @em{Gamma1} there is some fact @em{F2} such that
@em{Int(F2)} implies @em{Int(F1)} in the ontology theory for @em{I}.
Furthermore for any @em{F2} in @em{Gamma2}, if there is some @em{F1}
in @em{Gamma1} such that @em{Int(F1)} implies @em{Int(F2)} in the ontology
theory for @em{I}, then @em{F1 = F2}.

@subsubsection{Updating Information in CDF}

A user should never simply assert or retract extensional facts or
intensional rules to CDF.  Information from files or databases can be
loaded using te component system (see @ref{cdf_components.P
(library)}), or by the file loading routines upon which the component
system depends (see @ref{cdf_io.P (library)}).  Individual facts can
be asserted or retracted by the predicates @tt{newCDF/1}, and
@tt{retractallCDF/1}.

All of these predicates do various types of consistency checking,
update the CDF log (if turned on), update XJ caches (if XJ is being
used), modify information used by the component system and abolish
tables that may be affected by the assert or retract.  In addition,
certain transformations of CDF facts or rules may be made to ensure
efficient indexing.

@subsubsection{Consistency and Redundancy Checking}

Consistency checking helps ensure that a given set of facts is a
semantically meaningful CDF instance.  Redundancy checking helps
ensure that a given CDF instance is not larger than it has to be to
represent a given set of knowledge.  We discuss three types of checks
currently done by CDF.

@begin{itemize}

@item @em{Type checking} ensures that identifiers in CDF facts have
the right type (i.e. ensures that the Predicate Sorts Axiom holds for
a given CDF fact or state) and that the Downward Closure Axiom holds
for product identifiers.  In addition, using the assumptions for the
operational semantics of @tt{isa/2} type checking also ensures that
part 2 of the Implicit Isa Axiom holds.

@item @em{Redundancy Checking} ensures that new extensional facts
added to a CDF state are not identical to or implied by the CDF
instance.

@item @em{Conformability Checking} ensures that new facts added to a
CDF instance do not lead to inconsistencies or undesirable properties
of the database.  For instance adding the fact

@tt{isa(cid(f(cid(a),s),s),cid(a,s))}

leads to a CDF instance without a finite model.  Conformability is
discussed in greater detail in @em{SwiW03a}.
@end{itemize}

Currently, these checks may be executed upon each execution of
@pred{newCDF/1}, which is called by the CDF file io and component
loading routines.  Batch checking based upon the CDF logs may be
implemented in the future.  Type checking is always done, but by
default redundancy checking checks only whether a fact explicitly
exists in a CDF instance, and not whether it is implied.
Conformability checking is turned off by default.

Further information on setting the checks is in @ref{cdf_checks.P
(library)}.

@section{Comparison and Discussion}

There are at present a great many systems for managing and viewing
ontologies, each of which varies in its aims and functionity.  

@bf{Description Logics} Currently most description logics are based on
an extension of the logic @em{ALC}.  Checking consistency for a finite
set of @em{ALC} sentences is P-space complete @cite{SchmS91}.  The
language of CDF presented so far is a special restriction of @em{ALC}
if objects, higher-order relations, and product identifiers are
removed.  Furthermore, consistency checking is decidable in polynomial
time.  This language is referred to in @cite{Swif03} as a level-0 CDF
language, and a prototype extension of CDF to allow arbitrary class
expressions is described in @cite{Swif03} using the Answer Set
Programming techniques available through XSB's XASP interface to check
consistency of statements and perform classification.

@bf{Object Logics} Unlike object logics such as FLORA
@cite{guiz-flora-00}, no attempt is made to program rules in CDF:
rather CDF is seen as a store of non-procedural knowledge to be
augmented with rules written in XSB -- as a result CDF in principle
can serve as a knowledge store for FLORA just as it can to any set of
XSB rules.

@bf{Ontology Systems} Various ontology systems have been created for
ALC-like languages, for instance OilEd @cite{BHGS01} whose user
interface is based on Protege @cite{protege}.  Many features of Oil
are being included in the OWL standard @cite{PSHH03}.  As discussed
above, level-0 CDF descriptions are not as powerful as full ALC, but
CDF does introduce several new features not addressed in OWL.  First,
CDF allows representation of objects, higher-order relations, and
non-inheritable class-object relations.  In addition, since the
language of CDF is based on identifiers, it becomes easy to define
modular ontologies as building blocks of large ontologies.  And
furthermore, the user of product identifiers provides an easy way to
represent relations that are not naturally thought of as binary.

@bf{The CDF implementation} The CDF language is tightly integrated
with XSB, so that answers are returned only for those relations that
are most specific to a query, and the @tt{isa/2} relation prunes its
search when product identifiers are used.  The CDF component system
allows modular components to be shared by different users, combined in
different ways for various applications and updated separately when
necessary.  The inclusion of intensional rules allows ontologies to be
represented in a ""lazy"" manner that are too large to fit into
memory, such as primitve classes and intensional disk-resident
ontologies.  The database libraries allow CDF extensional facts in
components to be maintained and incrementally saved on disk, fostering
concurrent updates by different agents working on an ontology.
Furthermore, a proprietary interface based on Interprolog
@cite{Cale01} has been used to create a fully functional CDF Editor,
along with numerous CDF-based commercial applications@footnote{The CDF
Editor is a proprietary system owned by XSB, Inc.}.

").

main.


end_of_file.
