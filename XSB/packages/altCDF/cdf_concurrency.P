:- compiler_options([ciao_directives]).

/* Code that supports concurrent access to CDF components. */

/* 1. A user can access a CDF concurrently with another user by
providing the name of a log file.  Then subsequently loaded components
will have all updates to them logged, and written to the file at some
points.  Then at commit time, if the original components have not been
changed, they are simply updated-in-place.  If they have been changed
by some other process, then the log is used to apply the changes to
the new versions of the components, and then components are
updated-in-place.

One can also force the log and exit an application without committing
the updates back to the CDF.  Then on restart the original CDF
components can be reloaded and the contents of the logfile applied to
it to restore the previous current state of the components in memory.
Then the application can continue and eventually commit.

*/

:- export cdf_set_log_on/0, cdf_set_log_off/0, cdf_reset_log/0, show_log/0,
	cdf_logging_state/1, cdf_log/1, cdf_apply_log/0.

:- import new_trie/1, delete_trie/1, trie_interned/4, 
	  trie_unintern_nr/2, trie_intern/5 from intern.
%%:- import cdf_error/2 from cdf_exceptions.

:- import get_component_extensional/2 from cdf_components.

:- import make_cdf_dirty/1
	from cdf_xj.

:- import cdf_flags/2 from usermod.

:- dynamic cdf_logging_state(_).
:- index(cdf_logging_state(_),0).
:- asserta(cdf_logging_state(off)).

:- dynamic cdf_log_trie(_).
:- index(cdf_log_trie(_),0).

:- comment(module,"Logging is used to support concurrent use of a CDF.
Logging is started, and then CDF components are loaded from a stored
CDF, and their versions are noted.  Subsequent updates to the
in-memory CDF are logged as they are done.  Then when the in-memory
CDF is to be written back to disk creating new versions, using
update_all_components(in_shared_place), the following is done.  If the
current most-recent-version on disk is the same as the one orginally
loaded to memory, then update_all_components works exactly as it does
now (in_place).  Otherwise, there is a more recent version of the CDF
on disk.  The most recent version is loaded into memory, and the log
is used to apply all the updates to that new version.  (If conflicts
are detected, they must be resolved.)  Then
update_all_components(in_place) is used to store that updated CDF.
After update_all_components is run, the log is emptied, and the
process can start again.  ").


%%% Logging %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(cdf_set_log_on/2,"@tt{cdf_set_log_on(+LogFile,+Freq)}
This predicate creates a new log and
ensures that logging will be performed for further updates until
logging is turned off.").

cdf_set_log_on:- cdf_logging_state(X),
	(X == on
	 ->	true
	 ;	retractall(cdf_logging_state(_)),
		asserta(cdf_logging_state(on))
	),
	(cdf_log_trie(_)
	 ->	true
	 ;	new_trie(T),
		assert(cdf_log_trie(T))
	).


:- comment(cdf_set_log_off/0,"This predicate turns logging off, but
retains the log, if there is one.  To delete it, you may call
cdf_reset_log.").

cdf_set_log_off:- cdf_logging_state(X),
	(X == off
	 ->	true
	 ;	retractall(cdf_logging_state(_)),
		asserta(cdf_logging_state(off))
	).

:- comment(cdf_reset_log/0,"If logging is on, this predicate deletes
the current log, and creates a new one.  If logging is off, no action
is taken").

cdf_reset_log:- 
	(cdf_log_trie(OldTrie)
	 ->	delete_trie(OldTrie),
		retractall(cdf_log_trie(OldTrie)),
		new_trie(NewTrie),
		assert(cdf_log_trie(NewTrie))
	 ;	true
	).

/* Need to handle variables better.  */
cdf_log(Term):- 
	cdf_logging_state(X),
	(X == on -> cdf_log_1(Term) ; true),
	!.

cdf_log_1(assert(Term)):- 
	(dont_log_term(Term)
	 ->	true
	 ;	cdf_log_trie(T),
		(trie_interned(retractall(Term),T,Leaf,_skel) -> 
			trie_unintern_nr(T,Leaf) ; true),
		trie_intern(assert(Term),T,_,_,_)
	).
cdf_log_1(retractall(Term)):- 
	(dont_log_term(Term)
	 ->	true
	 ;	cdf_log_trie(T),
		(trie_interned(assert(Term),T,Leaf,_skel) -> 
			trie_unintern_nr(T,Leaf)  
		 ;	trie_intern(retractall(Term),T,_,_,_))
	).

dont_log_term(classHasAttr_ext(_,crid(CompRel,_),_)) :- is_component_rel(CompRel).
is_component_rel(hasVersion).
is_component_rel(hasPath).
is_component_rel(componentDepends).

:- comment(hide,show_log/0).	
show_log:- 
	listing(cdf_logging_state(_)),
	cdf_log_trie(T),
	trie_interned(Term,T,_,_),
	writeln(Term),
	fail.
show_log.
	
cdf_apply_log :-
	writeln(applying_log),
	show_log,
	cdf_log_trie(T),
	trie_interned(Term,T,_,_),
	apply_update(Term),
	fail.
cdf_apply_log.

apply_update(retractall(Term)) :-
	retractall(Term),
	get_component_extensional(Term,Name),
	(cdf_flags(dirty,Name)
	 ->	true
	 ;	make_cdf_dirty(Name)
	).
apply_update(assert(Term)) :-
	asserta(Term),
	get_component_extensional(Term,Name),
	(cdf_flags(dirty,Name)
	 ->	true
	 ;	make_cdf_dirty(Name)
	).

