:- compiler_options([ciao_directives]).

:- export 
	  add_component_initializer/3,
              analyze_components/2,
	  get_component_extensional/2,
	  newComponent/4,
	  update_components/2,
	  update_all_components/2,
              load_component/3.

:- import 
	classHasAttr/3,
	retractallExtTerm/1, newExtTerm/1,
	system_component/1 from cdf_init_cdf.

:- import 
	hasAttr_ext/3, isa_ext/2, classHasAttr_ext/3, allAttr_ext/3
 	from usermod.

% cdf_config.
:- import cdf_dirty/1,
	  component_table_ext/3,component_table_int/3 from usermod.

:- import cdf_warning/2,cdf_error/2 from cdf_exceptions.

:- import call_assert/1, file_latest_version/3 from cdf_utilities.

%cdf_io
:- import load_intensional_rules/1,load_extensional_facts/1 from cdf_io.

:- import member/2,ground/1 from basics.
:- import slash/1 from machine.
:- import concat_atom/2 from string.
:- import message/1 from standard.

:- import pretty_print/1 from newpp.

:- ensure_loaded(cdf_config).

:- dynamic temp_depends/4.

/*
handle_load_component_error(Message):- 
	retractall(temp_depends(_,_,_)),
	write_cdf_error_noxj(Message),
	abort.
*/

:- comment(module,"Typically, a CDF instance can be partitioned into
several separate cells representing information that arises from
different sources, for instance from UNSPSC, NAICS, or DLAFIIG.  There
may be a need for these cells to be managed separately so that various
applications can update them and incorporate their information.  The
CDF components system attempts to address this need by allowing
ontologies to be built from discrete @em{components}.

One method of partitioning facts in an CDF instance (whether it be a
loaded state or set of external files) is to choose a @em{component
argument} for each predicate type, and to set as the component of each
fact the source of the identifier in the component argument.  (If the
identifier is a product identifier, the source is the source of the
outer function symbol).  Using this method, the facts in an CDF
instance may be partitioned in various ways.

A @em{class-based component system} chooses as component arguments:

@begin{itemize}

@item the second-argument of all @em{class/2} and @pred{object/2}
facts.

@item the first-argument of all other facts.

@end{itemize} 
@noindent Class-based components thus form a collection
vaguely analagous to a Java package, and are useful when different
processes are responsible for creating or modifying different classes
and objects.

A @em{relation-based component system} chooses as argument identifiers

@begin{itemize} @item the second-argument of all @pred{class/2} and
@pred{object/2} facts.

@item the first-argument of all @pred{memberof/2} and
@pred{subclass/2} facts.

@item the second-argument of all @pred{irel/3}, @pred{classHasAttr/3},
@pred{schrel/3}, @pred{attribute/3}, and @pred{attribute_object/3}
facts.

@end{itemize}

Relation-based component systems differ from class-based systems only
in their partitions of relations and attributes.  Relation-based
component systems are useful when different processes may be
associated with creating or modifying different relations and
attributes for the same class or object.  The CDF uses a
relation-based component system by default, but can be repartitioned
by adjusting the tables in @module{cdf_config.P}.

In either case, one component @em{C1} directly depends on another
component @em{C2} if @em{id(NID2,C2)} is an argument in a fact in
component @em{C1}; or if @em{id(Nid1,C1)} is a component argument of a
fact in @em{C1}, @em{Nid1} is a product identifier, and
@em{id(NID2,C2)} occurs as a direct constituent in @em{C1}.  By this
definition, it is easy to see that component dependency need not be
hierarchical so that two components may directly depend on one
another; furthermore each component must directly depend on itself.
In addition, each component always derectly depends on the component
cdf by fiat.  Component dependency is defined as the transitive
closure of direct dependency.

Dependency information is used to determine how to load a component
and when to update it and is usually computed by the CDF.  Computing
dependency information is easy for extensional facts, but computing
dependency information for intensional rules is harder, as the
component system would need to compute all answer substitutions to
determine all dependencies, and this in impractical for some sets of
intensional rules.  Rather, dependencies are computed by checking the
top-level arguments of intensional rules, which leads to an
under-approximation of the dependencies.

@section{Components, Paths, and Versions}

Given the notions that components partition an CDF instance, and give
rise to dependency information, the component system must interace
with file systems and databases in order to allow users to manage
components as separate entities.

A component is identified by a structured @index{component name},
which consists of a @em{path} and a @em{source}.  For example,
information in the directory @tt{/home/tswift/unspsc} would have a
path of @tt{/home/tswift} and source @tt{unspsc}.  Inside the CDF,
only the source is used as a source argument for identifiers; The path
is maintained separately.  The structuring of component tags has
implications for the behavioral of the component system.  If two
components with the same names and different paths are loaded, facts
and rules from the two different components cannot be distinguished,
as only the source is maintained in their identifiers.  The attempt to
load two such components can be treated as an error; or the load can
be allowed to succeed unioning the information from both components,
implicitly asserting an axiom of equality for the two (structured)
component names.

A component name corresponds to a directory containing files with data
in external form (e.g. @tt{schema_cdfext.P} and @tt{data_cdfext.P}
files), or in external intensional form @tt{cdf_intensional.P}.  In
addition, the directory may contain an initialization file,
@tt{component_init.P}.  whose actions are taken to be transparent to
the CDF (unless they explicitly call CDF routines).  The CDF cannot
load as a component information in internal format (i.e. data in
@tt{schema_cdf.P} and @tt{data_cdf.P} files) as ambiguity arises if
one attempts to combine internal identifiers from different files.  It
does however provide tools to create components from a current loaded
CDF state.

The same component name can have multiple @em{versions}.  An CDF state
can contain only one version for each component name, and an attempt
to load two different versions for the same name always gives rise to
an error.  A convention is made that a component @tt{Name} with
version @tt{V} is to be found in a directory named @tt{Name_V}.  On
the other hand, if two component names @em{C1} and @em{C2} have the
same source and different paths, they do not have the same name.  If
they are loaded so that their information is unioned together an error
does not occur if @em{C1} and @em{C2} have different versions.

@section{Representing Component Information}

Information about a component resides in the CDF data itself and is
viewable by the user.  When a component with name @tt{C} is loaded,
the class @tt{id(N,N)} (where @tt{N} is the source of @tt{C})
is created as an immed subclass of @tt{id('CDF Component',cdf)}.
Since components are not expected to have members, information about
them is maintained through @pred{classHasAttr/3} facts.

@begin{itemize} 

@item The path of component @tt{C} is kept via 
@begin{verbatim}
classHasAttr(cid(N,N),crid(hasPath,N),oid(Path,cdfpt))
@end{verbatim}

@item The version of component @tt{C} is kept via 

@begin{verbatim}
classHasAttr(cid(compName(cid(N,N),cid(Path,cdfpt)),N),
                crid(hasVersion,N),cid(V,cdfpt)
@end{verbatim}

@item Dependency information of @tt{C} is maintained via 
@begin{verbatim}
classHasAttr(cid(component(cid(N,N),cid(Path,cdfpt),cid(V,cdfpt)),N),
             crid(componentDepends,N),
             cid(component(cid(N2,N2),cid(P2,cdfpt),cid(V2,cdfpt)),N))
@end{verbatim}
@end{itemize}

@section{Major Functionality}

Given an CDF state, a user may want to do several things.  
@begin{enumerate}

@item A user may wish to create components from an CDF state, or to
update components used by an CDF state.  One way to do this is by the
predicate @tt{update_all_components(Dir,Options)} which determines a
class or relation based partition of the CDF instance, and computes
all dependencies between these cells.  Cells that are not components
are made into components (with version 0), and those that are already
components have their version number updated if necessary (by checking
@tt{cdf_dirty/1}).  Other aspects may be specified by various options.

Alternately, if a part of a loaded CDF instance is to be saved as a
component the predicate @tt{update_components(List,Dir)} can be used.
@tt{List} is a list of component names, and for each @tt{Name} in
@tt{List}, @pred{update_components/2} writes ou the component
@tt{Name} as a subdirectory of @tt{Dir} whose version is either 0 if
the component is new, or incremented if the component is updated.  The
predicate gives an error if a component @tt{Name} in @tt{List} depends
on an updated component not in @tt{List}, or if it depends on a cell
that has not been made into a component.

@item A user may wish to load a component, along with all of its
dependencies.  Loads may be parameterized by
@begin{itemize}
@item Whether it is considered an error to try to load two components
with different path parts and the same name parts.

@item Whether a fast merge or a slower merge with more redundancy
checking is to be used.

@item Whether the latest version is to be loaded or a particular
version is specified.
@end{itemize}

@item Finally, a user may analyze component dependency information by
backtracking through @tt{analyze_components/2}, which neither affects
the CDF state, nor saves component information to files.
@end{enumerate}

@em{
This version does not yet use dirty bits to determine when new
versions need to be created.}

").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(analyze_components/2,
"@tt{analyze_components(-Component,-Dependency_list)} examines a
loaded CDF instance to partition it into components and for each
component @em{C} to return a listF of components upon which @tt{C}
depends.").

analyze_components(Name,List):- 
%	abolish_table_pred(analyze_component_table/2),
	analyze_component_1(Name,List).

analyze_component_1(Name,List):-
	setof(Dep,analyze_component_table(Name,Dep),List).

:- table analyze_component_table/2.
%:- use_subsumptive_tabling  analyze_component_table(_,_).

analyze_component_table(Name,Dep):- 
	analyze_extensional(Name,Dep1),
	(Dep = Dep1 ; Dep = cdf).
analyze_component_table(Name,Dep):- 
	analyze_intensional(Name,Dep).

analyze_extensional(Name,Dep):- 
	isa_ext(I0,I1),
	get_component_extensional(isa_ext(I0,I1),Name),
	get_dependency_extensional(isa_ext(I0,I1),Dep).
analyze_extensional(Name,Dep):- 
	hasAttr_ext(I0,I1,I2),
	get_component_extensional(hasAttr_ext(I0,I1,I2),Name),
	get_dependency_extensional(hasAttr_ext(I0,I1,I2),Dep).
analyze_extensional(Name,Dep):- 
	allAttr_ext(I0,I1,I2),
	get_component_extensional(allAttr_ext(I0,I1,I2),Name),
	get_dependency_extensional(allAttr_ext(I0,I1,I2),Dep).
analyze_extensional(Name,Dep):- 
	classHasAttr_ext(I0,I1,I2),
	get_component_extensional(classHasAttr(I0,I1,I2),Name),
	get_dependency_extensional(classHasAttr(I0,I1,I2),Dep).

analyze_intensional(Name,Dep):- 
	Term =  isa_int(_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  hasAttr_int(_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  allAttr_int(_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).
analyze_intensional(Name,Dep):- 
	Term =  classHasAttr_int(_,_,_),
	get_intensional_rule(Term,Body),
	get_component_intensional(Term,Body,Name),
	get_dependency_intensional(Term,Body,Dep).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

get_component_extensional(Term,Comp):- 
	component_table_ext(Term,Arg,_),
	arg(Arg,Term,CompId),
	comp_from_id(CompId,Comp).

get_dependency_extensional(Term,Dep):- 
	component_table_ext(Term,CompArg,Deps),
	(    arg(CompArg,Term,CompId),
	     comp_from_id(CompId,Dep) 
	  ; 
	     member(DepArg,Deps),
	     arg(DepArg,Term,DepId),
	     comp_from_id(DepId,Dep) ).

comp_from_id(CompId,Comp):-  arg(2,CompId,Comp).	

%------------------
 
get_component_intensional(Term,Body,Component):- 
	component_table_int(Term,Arg,_Deps),
	arg(Arg,Term,SourceArg),
	(arg(2,SourceArg,Source),atom(Source) -> 
	    Source = Component
	 ;  cdf_warning(component,
	                ['Cannot find component for intensional rule: ',
			  (:-(Term,Body))]),
	    fail).

get_dependency_intensional(Term,Body,Component):- 
	component_table_int(Term,_A,Deps),
	member(arg(Arg,Warn),Deps),
	arg(Arg,Term,SourceArg),
	(arg(2,SourceArg,Source),atom(Source) -> 
	    Source = Component
	 ;  (Warn == warn -> 
	        cdf_warning(component,
	                  ['Cannot find dependencies in arg: ',Arg,
			   ' of intensional rule: ', (:-(Term,Body))])
	        ; true),
	    fail).

/* Assumes that intensional rules have been read in via
   load_intensional_rules/2 */
get_intensional_rule(Head,Body1):- 
	clause(Head,Body),
	Head =.. [_|Alist],
	clause(Body,Body1),
	Body =.. [_|Alist].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% :-
:- comment(load_component/3,
"@tt{load_component(Name,Path,Parameter_list)} loads the component
@tt{Name}, from path @tt{Path} and recursively, all other components
upon which the component depends.  If a version conflict is detected
between a component tag to be loaded and one already in the CDF state
or about to be loaded, @tt{loadmerge_component/2} aborts without
changing CDF extensional rules in internal form, or intensional rules.

The order of loading is as follows.  First, all extensional facts are
loaded for the component @tt{Path/Name} and for all components on
which it depends.  Next, the dependency graph is re-traversed
intensional rules are loaded, and initialization files are consulted
in a bottom-up manner (i.e. in a post-order traversal of the
dependency graph). 

@tt{Parameter_list} may contain the following elements:
@begin{itemize}

@item @tt{action(Action)} where @tt{Action} is @tt{check} or
@tt{union}.  If the action is to check, two components with the same
name part and different path parts or versions cannot be loaded: an
attempt to do so will cause an error.  If the action is to union, two
components with the same name and different paths may be loaded, and
the effect will look as if the two components had been unioned
together.  However an error will occur if two components with the same
name and paths but different versions are loaded.

@item @tt{force(Bool)} where @tt{Bool} is @tt{yes} or @tt{no} (default
@tt{no}).  If @tt{Force} is @tt{yes}, any components that have
previously been loaded into the CDF are reloaded, and their
initialization files reconsulted.  If @tt{Force} is @tt{no}, no
actions will be taken to load or initialize components already loaded
into the CDF.

@item @tt{version(V)} where @tt{V} is a version number.  If the
parameter list contains such a term, the loader attempts to load
version @tt{V} of component.  The default action is to load the latest
version of a component.

@end{itemize}
").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

load_component(Name,Path,Arglist):-
	retractall(temp_depends(_,_,_,_)),
	(atom(Path),atom(Name),ground(Arglist) -> 
	    true
	  ; cdf_error(load_component,['Component name, path and arglist must',
			' be instantiated to load: ',Path,'/',Name,' ',
			Arglist]) ),
	load_component_1(Name,Path,Arglist).

load_component_1(Name,Path,Arglist):- 
	split_arglist_on_version(Arglist,V,Arglist1),
	(load_component_pass1(Name,Path,V,Arglist1) -> 
	    message(['Merging in components.']),nl,
	    load_component_pass2(Name,Path,V,[]) 
	  ; true),
	retractall(temp_depends(_,_,_,_)).

split_arglist_on_version([],null,[]).
split_arglist_on_version([version(V)|R],version(V),R):-!.
split_arglist_on_version([H|T],V,[H|T1]):-
	split_arglist_on_version(T,V,T1).

%----------

load_component_pass1(Name,Path,Vin,Arglist):- 
	get_full_path_and_loadname(Name,Path,Vin,Full,V,Loadname),
	(check_component(Name,Full,V,Arglist) -> 
  	    message(['Loading component: ',Full,'/',Loadname]),nl,
                concat_atom([Full,'/',Loadname],Absname),
	    load_extensional_facts(Absname),
	    check_good_component(Name,Full),
                load_component_dependencies_pass1(Name,Full,Arglist) 
	  ; 
	    fail ).

load_component_dependencies_pass1(Name,Path,Arglist):- 
	classHasAttr_ext(cid(component(cid(Name,Name),cid(Path,cdfpt),
				       cid(_V,cdfpt)),Name),
			 crid(componentDepends,Name),
			 cid(component(cid(New,New),cid(Pathnew,cdfpt),
				       cid(Vnew,cdfpt)),New)),
%        writeln(checking(dep(Name,New))),	
        load_component_pass1(New,Pathnew,version(Vnew),Arglist),
        assert_dependencies_for_path2(Name,New,Pathnew,Vnew),
	fail.
load_component_dependencies_pass1(_,_,_).

assert_dependencies_for_path2(Name,New,Pathnew,Vnew):- 
	system_component(New),
	New \== Name,
	call_assert(temp_depends(Name,New,Pathnew,Vnew)).

%----------

/* TLS: pass 2 is to load intensional rules and consult initialization file.
   Assume that all conflict checking has been done in pass2 */
load_component_pass2(Name,Path,Vin,Anclist):- 
	slash(Slash),
	get_full_path_and_loadname(Name,Path,Vin,Full,_V,Loadname),
	message(['Loading int rules and initializing componen: ',
			Full,Slash,Loadname]),nl,
            load_component_dependencies_pass2(Name,Full,Anclist),
	concat_atom([Full,Slash,Loadname],Dir),
	load_intensional_rules(Dir),
	initialize_component(Loadname,Full).

load_component_dependencies_pass2(Name,_Path,Anclist):- 
	temp_depends(Name,New,Pathnew,Vnew),
	(member(New,Anclist) -> true
	  ; 
	    load_component_pass2(New,Pathnew,Vnew,[Name|Anclist]) ),
	fail.
load_component_dependencies_pass2(_,_,_).

initialize_component(Name,Path):- 
	concat_atom([Path,'/',Name,'/initialization_file.P'],File),
	(file_exists(File) -> consult(File) ; true).

%---------------

check_good_component(Name,Full):- 
	(component_exists(Name) -> 
	    true
	  ;
	    cdf_error(component_load,['Pathname: ',Full,
				      ' is not a component']) ).
component_exists(Name):- 
	classHasAttr(cid(Name,Name),crid(hasPath,Name),_).
%---------------

/* If check_component succeeds, we go ahead and do a pass 1 load. */
check_component(Name,Path,V,Arglist):- 
	\+ system_component(Name),
	check_conflicting_path(Name,Path,Arglist),
	check_conflicting_version(Name,Path,V),
	\+ already_present(Name,Path,V,Arglist).

check_conflicting_version(Name,Path,V):- 
	(conflicting_version(Name,Path,V,V1) -> 
	    cdf_error(component_load,['Version ',V,' of ',Name,
			' cannot be loaded, as version ',V1,
			' is halreaty loaded '])
	  ; true).

/* TLS: For now, each component is taken to depend on some version of
the CDF. */
conflicting_version(Name,Path,V,V1):- 
	classHasAttr_ext(cid(compName(cid(Name,Name),
	                                                 cid(Path,cdfpt)),Name),
	                          cid(hasVersion,Name),cid(V1,cdfpt)),
	V \== V1.

%---------------

check_conflicting_path(Name,Path,Arglist):- 
	(\+ member(action(union),Arglist) -> 
		(conflicting_path(Name,Path,Path1) -> 
 	            cdf_error(component_load,['Component ',Name,' has ',
			'conflicting paths in non-union merge: ',Path,
			' and ',Path1])
		  ; 
		    true) 
	      ;  true).

conflicting_path(Name,P,P1):- 
	classHasAttr_ext(cid(Name,Name),crid(hasPath,Name),cid(P1,cdfpt)),
	P \== P1.

%---------------

already_present(Name,Path,V,Arglist):- 
	\+ member(force(yes),Arglist),
	classHasAttr_ext(cid(compName(cid(Name,Name),
	                                                cid(Path,cdfpt)),Name),
	                          crid(hasVersion,Name),cid(V,cdfpt)).

%---------------

/* here is where we may do something w. relative paths.
   Name is the name part of a component, and Path its path-part, 
   possibly input as a relative path name.  Upon success, V is
   instantiated to the proper version of the component (which may
   implicitly be the latest version), CanonPath is instantiated
   to a canonical path, and Loadname is the name, plus version if 
   applicable.
 */
get_full_path_and_loadname(Name,Path,Vin,CanonPath,V,Loadname):- 
	Path = CanonPath,
	(Vin = version(V) -> 
	    file_find_version_name(Path,Name,V,Loadname)
	 ; 
	    Loadname = Name,file_latest_version(Path,Name,V) ).

file_find_version_name(Path,Name,Version,Loadname):- 
	file_latest_version(Path,Name,V),
	(V = Version -> 
	    Loadname = Name
	  ; (V > Version -> 
	        concat_atom([Name,'_',Version],Loadname)
	      ; 
		cdf_error(load_component,['Improper version number',Version,
				' for ',Path,'/',Name]) ) ).
	  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(update_all_components/2,
"@tt{update_all_components(Dir,Option_list)} analyzes components of an
CDF state and their dependencies, determining whether they need to be
updated or not, and creating components when necessary.  When a
component is created with path @tt{Dir}, the files @tt{data_cdfext.P},
@tt{schema_cdfext.P} and @tt{cdf_intensional.P} are created.
Initialization files must be added manually for new components.
@tt{Option_list} contains a list of parameters which currently
specifies the effect on previously existing components:

@begin{itemize} @item @tt{action(Action)}.  
@begin{itemize} 

@item If @tt{Action} is @tt{create}, then a new set of components is
created in @tt{Dir}.  Information not previously componetized is added
to new components whose path is @tt{Dir} and whose version number is
0.  Facts that are parts of previously created components are also
written as subdirectories of @tt{Dir}; if their previous path was
@tt{Dir}, their versions are updated if needed (i.e. if any facts in
the component have changed).  Otherwise, if the path of a previously
created component @tt{C} was not @tt{Dir}, @tt{C} is dumped as a
subdirectory of @tt{Dir}, its path is changed to @tt{Dir} and its
version is set to 0.  In addition, the initialization file for @tt{C}
is copied to @tt{Dir}.

@item If @tt{Action} is @tt{in_place}, then components created in
@tt{Dir} only for information that was not previously componetized.
Facts that are parts of newly created components are dumped as
subdirectories of @tt{Dir} which serves as their path, and their
version number is 0.  Previously created components whose paths were
not @tt{Dir} are updated using their present path, if needed.

@end{itemize}

In either case all dependency information reflects new component and
path information.
@end{itemize}
").

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- dynamic temp_new_version/2.

update_all_components(Dir,Options):- 
	retractall(temp_new_version(_,_)),
	(member(action(create),Options) -> 
	    Action = create,initialize_for_create(Dir)
	  ; Action = in_place,initialize_for_in_place(Dir) ),
	((Action = in_place,merge_has_occurred) -> 
	    cdf_error(update_components,['Cannot update in place: two ',
		'components have been merged'])
	    ; true ),
	analyze_component_1(Comp,Dep),
	writeln((Comp,Dep)),
	update_component_1(Action,Comp,Dep,Dir),
	writeln(updated(Comp)),
	fail.
update_all_components(_Dir,_Options):- 
	retractall(temp_new_version(_,_)).

%----------

/* In initialize for create, old versions don't matter -- the only
   thing that matters is the version of the file in Dir, if any */

initialize_for_create(Dir):- 
	analyze_components(Name,_),
	concat_atom([Dir,'/',Name],File),
	(file_exists(File) ->
  	     file_latest_version(Dir,Name,V),
	     V1 is V + 1,
	     assert(temp_new_version(Name,V1))
	  ;  assert(temp_new_version(Name,0))),
	fail.
initialize_for_create(_Dir).

%----------

initialize_for_in_place(Dir):- 
	propagate_dirty_bits(Dir).

/* TLS: this pass is needed becasue we dont know the order in which
the name/list pairs will be returned. Thus if c is dirty, and a
depends on b depends on c, we might get a,[b] back first, and b will
be unmarked.  While we do the pass, we assert the new version so we
dont get confused when doing the dependencies.  */

propagate_dirty_bits(Dir):- 
	abolish_table_pred(comp_depends_on/2),
	analyze_components(Name,_List),
	propagate_for_name(Name),
	(component_exists(Name) -> 
	     versions_for_existing_component(Name)
	  ;  versions_for_new_component(Dir,Name) ),
  	fail.
propagate_dirty_bits(_Dir).

versions_for_new_component(Dir,Name):- 
	concat_atom([Dir,'/',Name],File),
	(file_exists(File) ->
    	     file_latest_version(Dir,Name,V),
	     V1 is V + 1,
	     call_assert(temp_new_version(Name,V1))
	  ;  call_assert(temp_new_version(Name,0)) ).

/* also, adjust version here */
versions_for_existing_component(Name):- 
	classHasAttr_ext(cid(compName(cid(Name,Name),cid(P,cdfpt)),Name),
	                       crid(hasVersion,Name),cid(V,cdfpt)),
        ((needs_update(Name),Name \== cdf) -> 
	      V1 is V + 1,
	      call_assert(temp_new_version(Name,V1)),
	      retractallExtTerm(classHasAttr_ext(
			         cid(compName(cid(Name,Name),
					      cid(P,cdfpt)),Name),
		                 crid(hasVersion,Name),cid(V,cdfpt))),
	      retractallExtTerm(classHasAttr_ext(cid(compName(cid(Name,Name),
						  cid(P,cdfpt)),Name),
	                             crid(hasVersion,Name),cid(V,cdfpt))),
	      newExtTerm(classHasAttr_ext(cid(compName(cid(Name,Name),
						  cid(P,cdfpt)),Name),
	                             crid(hasVersion,Name),cid(V,cdfpt)))
	    ; call_assert(temp_new_version(Name,V))).

propagate_for_name(Name):- 
	((\+ component_exists(Name) ; needs_update_tran(Name)) -> 
	     call_assert(cdf_dirty(Name))
	   ; true).	

/* demand could go here */
needs_update_tran(Name):- 
	(    needs_update(Name)
	  ;  comp_depends_on(Name,Comp),needs_update(Comp) ).

:- table comp_depends_on/2.	
comp_depends_on(X,Z):- 
	analyze_component_1(X,List),member(Y,List),
	(Z = Y ; comp_depends_on(Y,Z) ).

merge_has_occurred:- 
	classHasAttr_ext(cid(Name,Name),crid(hasPath,Name),cid(P1,cdfpt)),
	classHasAttr_ext(cid(Name,Name),crid(hasPath,Name),cid(P2,cdfpt)),
	P1 \== P2.

%-----------------

/* Need to get oldpath in order to copy init files.  Note that 
   the component may be created (i.e. namexname is a class) but 
   its dependencies not yet added. In addition, need to get right
   version. */

update_component_1(create,Name,Dep,Dir):- 
	Name \== cdf,
	(classHasAttr_ext(
  	                    cid(component(cid(Name,Name),
	                                  cid(Oldp,_),_V),_),_,_) -> 
               true
	    ;  Oldp = nocopy),
	newComponent(cid(Name,Name),cid(Dir,cdfpt),create,CompId),
	writeln(newcomponent(cid(Name,Name),cid(Dir,cdfpt),create,CompId)),
	CompId = cid(component(_Nameid,cid(Newpath,cdfpt),_V),_),
	temp_new_version(Name,Version),
	NewCompid = cid(component(cid(Name,Name),
				  cid(Newpath,cdfpt),cid(Version,cdfpt)),Name),
	create_dependencies_create(Dep,Name,NewCompid,Dir),
	dump_component_1(Name,Newpath,Version,Oldp).

/* No copy for in_place: updates in place, and Dir is only for new comps.
   Note that we have already checked for merge, so Newpath is functional
   on Nameid. */
update_component_1(in_place,Name,Dep,Dir):- 
	Name \== cdf,needs_update(Name),
	newComponent(cid(Name,Name),cid(Dir,cdfpt),in_place,CompId),
	CompId = cid(component(_Nameid,cid(Newpath,cdfpt),_V),_),
	temp_new_version(Name,Version),
	NewCompid = cid(component(cid(Name,Name),
				  cid(Newpath,cdfpt),cid(Version,cdfpt)),Name),
	create_dependencies_in_place(Dep,Name,NewCompid,Dir),
	dump_component_1(Name,Newpath,Version,nocopy).

%--------------------- 

:- comment(update_components/2, "@tt{update_components(Dir,List)}
Updates components in @tt{List} (or creates them) writing them into
subdirectories of @tt{Dir}.  If a component in @tt{List} depends on a
component that needs updating but is not in list or on a source that
has not been made into a component, the predicate abort without
changing the state or file system.  ").

update_components(_Dir,_List):- 
	abort('update_components/2 not yet implemented').

%--------------------- 

/* 
Adds dependency structures for each component as needed, omitting
self-dependencies.  These dependency structures are of two kinds,
dependencies to newly created components (in Dir, specified at the
top-level) and dependencies to previously created components.  In the
second case, a check must be made whether the action is create or
in_place.  If the action is create, depdendency information that may
contain the old path is retracted, and dependency information is
created with the new path.  If the action is in_place, dependency
information with current the path information is created if needed.
*/

create_dependencies_create([],_From,_Compid,_Dir).
create_dependencies_create([ToName|T],FromName,Compid,Dir):- 
	FromName \== ToName,!,
	create_all_dependencies_create(ToName,Dir,Compid),
	create_dependencies_create(T,FromName,Compid,Dir).
create_dependencies_create([_|T],FromName,Compid,Dir):- 
	create_dependencies_create(T,FromName,Compid,Dir).

/* TLS: in first clause, we are not necessarily creating a component: 
   we may be removing it so that it can be moved, so we need to
   retract all old dependencies, using the version we have previously found */
create_all_dependencies_create(cdf,_Dir,FromCompid):- !,
	FromCompid = cid(_,FromName),
	classHasAttr_ext(cid(component(cid(cdf,cdf),cid(Pcdf,cdfpt),
					     cid(Vcdf,cdfpt)),cdf),
			crid(componentDepends,cdf),_),	
	retractallExtTerm(classHasAttr_ext(FromCompid,
	                               crid(componentDepends,FromName),
			               cid(component(cid(cdf,cdf),_,_V),cdf))),
	newExtTerm(classHasAttr_ext(FromCompid,crid(componentDepends,FromName),
		                cid(component(cid(cdf,cdf),
	                                      cid(Pcdf,cdfpt),
					      cid(Vcdf,cdfpt)),cdf))).
create_all_dependencies_create(ToName,Dir,FromCompid):- !,
	FromCompid = cid(_,FromName),
	temp_new_version(ToName,V),
	retractallExtTerm(classHasAttr_ext(FromCompid,
				       crid(componentDepends,FromName),
			               cid(component(ToName,_,_),_))),
	newExtTerm(classHasAttr_ext(FromCompid,crid(componentDepends,FromName),
				cid(component(cid(ToName,ToName),
					      cid(Dir,cdfpt),
					      cid(V,cdfpt)),ToName))).

create_dependencies_in_place([],_FromName,_NewCompid,_Dir).
create_dependencies_in_place([ToName|T],FromName,FromCompid,Dir):- 
	ToName \== FromName,!,
	create_all_dependencies_in_place(ToName,Dir,FromCompid),
	create_dependencies_in_place(T,FromName,FromCompid,Dir).
create_dependencies_in_place([_|T],FromName,FromCompid,Dir):- 
	create_dependencies_in_place(T,FromName,FromCompid,Dir).

/*  There are 3 cases: 
    1) Component has been created.
    2) Component has not been created, but the component name has been 
	interned.
    3) Component has not been created, and name must be interned */
 
create_all_dependencies_in_place(ToName,Dir,FromCompid):- !,	
	FromCompid = cid(_,FromName),
	(classHasAttr_ext(cid(ToName,ToName),crid(hasPath,ToName),
				              cid(ToPath,cdfpt)) -> 
  	    true
	  ;  
	    ToPath = Dir),
	temp_new_version(ToName,V),
	retractallExtTerm(
		classHasAttr_ext(FromCompid,crid(componentDepends,FromName),
	                     cid(component(cid(ToName,ToName),_,_),_))),
        newExtTerm(classHasAttr_ext(FromCompid,crid(componentDepends,FromName),
			        cid(component(cid(ToName,ToName),
		                              cid(ToPath,cdfpt),
					      cid(V,cdfpt)),ToName))).

%---------------------

dump_component_1(Name,Dir,Version,Oldpath):- 
	Name \== cdf,
	slash(Slash),
	make_component_dir(Dir,Name,Version,NewDir),
	concat_atom([NewDir,Slash,'cdf_extensional.P'],SchFile),
	tell(SchFile),
	compwrite_isa(Name),
	compwrite_hasAttr(Name),compwrite_allAttr(Name),
	compwrite_classHasAttr(Name),
	told,
	concat_atom([NewDir,Slash,'cdf_intensional.P'],IntFile),
	tell(IntFile),
	write_component_intensional(Name),
	told,
	(Oldpath = nocopy -> 
	    true
	  ; 
	    (concat_atom([Oldpath,'/initialization_file.P'],Oldfile),
	     (file_exists(Oldfile) -> 
	         shell(['cp ',Oldfile,' ',Dir]) 
	       ; true ) ) ),
	writeln(dumped(Name)).

make_component_dir(Dir,Name,Version,NameDir):- 
	slash(Slash),
        concat_atom([Dir,Slash,Name],NameDir),
	(Version = 0 -> 
	    true
	  ; 
	    LastVersion is Version - 1,
            concat_atom([Dir,Slash,Name,'_',LastVersion],LastDir),
	    shell(['mv ',NameDir,' ',LastDir]) ),
        xsb_makedir(NameDir).


compwrite_isa(Source):- 
	isa_ext(Sub,Sup),
	get_component_extensional(isa_ext(Sub,Sup),Source),
	write_ext_term(isa_ext(Sub,Sup)),
	fail.
compwrite_isa(_).

compwrite_hasAttr(Source):- 
	hasAttr_ext(Src,Rel,Targ),
	get_component_extensional(hasAttr_ext(Src,Rel,Targ),Source),
	write_ext_term(hasAttr_ext(Src,Rel,Targ)),
	fail.
compwrite_hasAttr(_).

compwrite_allAttr(Source):- 
	allAttr_ext(Src,Rel,Targ),
	get_component_extensional(allAttr_ext(Src,Rel,Targ),Source),
	write_ext_term(allAttr_ext(Src,Rel,Targ)),
	fail.
compwrite_allAttr(_).

compwrite_classHasAttr(Source):- 
	classHasAttr_ext(Src,Rel,Targ),
	get_component_extensional(classHasAttr_ext(Src,Rel,Targ),Source),
	write_ext_term(classHasAttr_ext(Src,Rel,Targ)),
	fail.
compwrite_classHasAttr(_).

write_ext_term(Term):- 
	write_canonical(Term),writeln('.').

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Utilities
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
xsb_makedir(Dir):- 
	(path_sysop(isdir,Dir) -> true ; path_sysop(mkdir,Dir)).

write_component_intensional(Name):- 
	component_table_int(Head,_Arg,_Arg2),
	Head =.. [F|T],
	concat_atom([F,'_',Name],NewF),
	NewHead =.. [NewF|T],
	clause(NewHead,Body), 
	pretty_print(clause(Head,Body)),
	fail.
write_component_intensional(_).

needs_update(Component):- cdf_dirty(Component).

/* New component initializes a new component, creating version,
dependency and path information.  Given a previously existing component, 
re-creating the component with the same path is a safe operation.

	If Action unifies with check and
		if a previous component exists with the same path, 
			no action is taken; 
		otherwise if a previous component exists with a different path,
 			an error occurs. 
	If Action is replace
		if a previous component exists 
		    its directoryPath is overwritten with the new path
*/

/*
newComponent(Name,Path,Compout):- 
	newComponent(Name,Path,check,Compout).
*/

newComponent(cid(Name,Name),Path,Action,
		cid(component(cid(Name,Name),Pathout,Version),Name)):- 
	newPathandVersion(Action,cid(Name,Name),Path,Pathout,Version).

/* check gives an error if a component exists whose file path is not
equal to PATH.  New components are created with filepath PATH and
version 0 

create renames the path of each component to PATH if its file path is
not equal to PATH (apart from CDF which it leaves alone). If the
component is new, or has had its file path reset, its version is 0,
and its version is updated otherwise.

in_place does not affect existing components.  New components are
created with filepath PATH and version 0.

The latter two should just be used in component updates. */

newPathandVersion(check,cid(Src,Src),Path,Path,Version):-
	((classHasAttr(cid(Src,Src),crid(hasPath,Src),Path1),Path1 \= Path) ->
	      cdf_error(component,['Creating a component path ',Path,
			' for ',Src,' which has path ',Path1]) 
	    ; 
	      newExtTerm(classHasAttr_ext(cid(Src,Src),crid(hasPath,Src),
						Path)) ),
	(classHasAttr(cid(compName(cid(Src,Src),Path),Src),
			crid(hasVersion,Src),Version) -> 
	     true 
	   ; 
	     newExtTerm(classHasAttr_ext(
	                                           cid(compName(cid(Src,Src),Path),Src),
 	                                           crid(hasVersion,Src),cid(0,cdfpt))),
	     Version = cid(0,cdfpt) ).
newPathandVersion(create,cid(cdf,cdf),_Pathin,Path,V):- !,
	classHasAttr_ext(cid(cdf,cdf),crid(hasPath,cdf),Path),
	classHasAttr_ext(cid(compName(cid(cdf,cdf),Path),cdf),
			crid(hasVersion,cdf),V).
/* On create, even if the component has been loaded from somewhere else,  
   it needs a new path and version, (obtained from the path). */
newPathandVersion(create,cid(Src,Src),cid(Pathin,cdfpt),cid(Pathin,cdfpt),
							cid(V1,cdfpt)):- 
        retractallExtTerm(classHasAttr_ext(cid(Src,Src),crid(hasPath,Src),_)),
        retractallExtTerm(classHasAttr_ext(cid(compName(cid(Src,Src),_),Src),
			 	cid(hasVersion,Src),_Int)),
        newExtTerm(classHasAttr_ext(cid(Src,Src),
				    crid(hasPath,Src),cid(Pathin,cdfpt))),
        concat_atom([Pathin,'/',Src],File),
        (file_exists(File) ->
  	     file_latest_version(Pathin,Src,Vold),
	     V1 is Vold + 1
	  ;  V1 = 0),
       newExtTerm(classHasAttr_ext(cid(compName(cid(Src,Src),
						cid(Pathin,cdfpt)),Src),
			           crid(hasVersion,Src),cid(V1,cdfpt))).
/* Assumes merge_check has been done.  Do nothing if the component has been
   loaded from somewhere.  Otherwise, create it with the new directory path, 
   and check the directory for the proper version to make the component.  */
newPathandVersion(in_place,cid(Src,Src),Pathin,Path,V):- 
	(classHasAttr(cid(compName(cid(Src,Src),Path),Src),
				crid(hasVersion,Src),V) -> 
  	     true
	  ; 
    	     newExtTerm(classHasAttr_ext(cid(Src,Src),crid(hasPath,Src),Path)),
	     concat_atom([Pathin,'/',Name],File),
  	     (file_exists(File) ->
  	         file_latest_version(Pathin,Name,Vold),
	          V is Vold + 1
	       ;  V = 0),
	     newExtTerm(classHasAttr_ext(cid(Src,Src),crid(hasPath,Src),Pathin)),
  	     newExtTerm(
		classHasAttr_ext(cid(compName(cid(Src,Src),Pathin),Src),
 				 crid(hasVersion,Src),V)),
	     Pathin = Path ).

end_of_file.

@item A user may wish to create components from external files.  In
this case, the predicate @pred{create_external_component/1} can be
used to add this information.  @tt{create_external_component(Dir)}
reads in external files, computes their dependencies, and writes out
the files, plus component information, back to @em{Dir}.  The
information in this component does not affec the state of the CDF
until it is explicitly loaded.  In the case where a putative component
includes an external intensional view, dependency information for the
external intensional view must be added by hand.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
:- comment(create_external_component/1,"
@tt{create_external_component(Dir)} loads from @tt{Dir}
@tt{data_cdfext.P}, and @tt{schema_cdfext.P} files, creates a
component if possible, then dumps the new cdfext that includes the
component information.").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/* find_component_dependency/1 returns the set of dependencies for a
putative component -- from a set of loaded, non-merged external facts.
Only those dependencies obtained from external form are returned --
extint dependencies must be added "by hand". */


write_call(Call):- 
	abolish_table_pred(table_call/1),
	table_call(Call),
	write_ext_term(Call),
	fail.
write_call(_Call):-
	abolish_table_pred(table_call/1).

:- table table_call/1.
table_call(Call):- call(Call).


:-comment(merge_components/2,"merge_components(+List,+Component)
merges the components in @tt{List} into component @tt{Component}.
Specifically, for each component @tt{C} in @tt{List} it renames any
known identifier @tt{id(Nid,C)} in the CDF state to
@tt{id(Nid,Component)}.  The dirty bit is set on @tt{Component} so
that it will be written out on update.  ").

:- comment(add_component_initializer/3,
"@tt{add_component_initializer(Source,Path,File)} can be used to add
@tt{File} as an initialization file for the component whose source is
@tt{Source}, and whose path is @tt{Path}.  The component must already
exist and be loaded into an CDF state, otherwise a warning is given
and the predicate fails.").

find_component_dir(Name,Full):- 
	(search_module(Name,_Dir_part,_Base_part,_Ext,Full,_Obj) 
                -> true 
	    ; 
	        cdf_error(component,['can''t find component: ',Name])),
	(path_sysop(isdir,Full) -> 
	    true 
	  ; 
	     cdf_error(component,['component name is not a directory',Full])).


