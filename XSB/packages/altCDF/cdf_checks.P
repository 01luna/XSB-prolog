:- compiler_options([ciao_directives]).

:- comment(module,"

The CDF checking system is based on the ability to dynamically specify
any checks thet need to be applied at various stages of execution (or
@em{contexts}) during the course of managing an ontology.  A check has
two arguments that must be ground on call, the first argument being
the context, and the second context-specific.  The check may succeed,
fail, or throw an error; and may also execute side-effects
(e.g. printing warning messages, automatically classifying facts).  By
making restrictions on the framework we use, it becomes easier for a
given user to omit or add checks for a given context and even code new
checks and / or new contexts.

Checks are called in two ways: 

@begin{enumerate} 
@item Based on the Context.  This is done by calling
@tt{apply_checks(Context,Argument)}

as in 

newExtTerm(Context,Term):- 
	apply_checks(Context,Term),
	cdf_update_list([asserta(Term)]).

apply_checks/2 (defined below) backtracks through all of the checks
defined for a context and calls them in a specified order.
apply_checks/2 checks the global table @tt{cdf_flags/2} to determine
the checks to be done in a particular context.  Note that since checks
depend on cdf_flags/2, they can be dynamically changed, or overridden
by flag definitions in a .xsbrc file.  As indicated by the code, the
checks must all be imported to usermod to be called.

In order for apply_checks/2 to work efficiently, the flags must be set
up using a particular convention.  An example is

cdf_flags(newExtTermSingle,check(A,B,[check_ground(A,B),
	  			      check_types(A,B),
				      check_identity(A,B)]))).

The first argument is the context, and the second two argument
variables, along with a list of checks, each of which uses the
argument variables.  Checks are called using the order in the list.
Using this mechanism, a user can add her own checks by importing a
predicate, setting the flags appropriately, and adding an
apply_checks/2 goal to user code (if necessary).  Note that, a user
can also write new checks for existing CDF contexts without changing
the files in the CDF directory.

@item The other way to call a check is by xxx_checkflag/2, where xxx
is the name of a check.  These calls check whether a check is turned
on for a given component, and calls it if so... otherwise the check is
avoided and the predicate succeeds.

The first argument of a checking routine is called the @em{context
argument}, and the second the @em{checking argument}..  Right now, the
checking argument can be an extensional cdf fact or a component name,
but you could imagine others -- like intensional rules.  Thus, some
contexts serve to check facts, and others a component.  The code wont
run well if you put, say, a fact check in a component context, but I
dont think I'll check the checks for now.  Here are some examples:


-- newExtTermSingle.  This context designates the action of calling
newExtTerm/2 to add an extensional fact to the CDF store.

	Checking Argument: Extensional CDF Fact
	Default Setting: 
cdf_flags(newExtTermSingle,check(A,B,[check_ground(A,B),
	  			      check_types(A,B),
				      check_identity(A,B)]))).

-- retractallExtTermSingle  This context designates the action of calling
retractallExtTerm/2 to delete an extensional fact from the CDF store.

	Checking Argument: Extensional CDF Fact
	Default Setting: None (probably some consist. checks in the future).

-- newExtTermBatch.  This context designates calling newExtTerm/2
repeatedly, as in loading a file.

	Checking Argument: Extensional CDF Fact
	Default Setting: 
cdf_flags(newExtTermBatch,check(A,B,[check_ground(A,B),
	  			      check_types(A,B),
				      check_identity(A,B)]))).

-- componentUpdate.  This context designates the action of saving a
component.

	Checking Argument: component
	Default Setting: 
initial_cdf_flag(component_update,check(A,B,[classify_if_necessary(A,B)])).
  	  cdf_flag(checks(componentLoad,1),classify_if_necessary(Comp))
  	  cdf_flag(checks(componentLoad,1),check_implication(Comp))

-- componentLoad.  This context designates the action of loading a
component.

	Checking Argument: component
	Default Setting: None (but you can turn on checks for this
			       context if you like) 
			 

There may be other contexts such as  obliterate_xxx.

As a first pass, I think the component checks should check a flag

cdf_flag(component_check,Component)

before actually checking the component within a context.  This means
that newExtTerm, and retractallExtTerm will need to set this flag
along with 

cdf_flag(cdf_dirty,Component)

(Im not doing this yet).
So with this, by default we check each check once in ""normal""
evaluation -- loading or adding extensional terms and then saving them
to and loading them from a component.

").

%-----------------------------------------------------------------

:- export apply_checks/2,
%	  check_dummy/2,
	  check_ground_checkflag/2, check_ground/2, 
	  check_types_checkflag/2, check_types/2,
          check_identity_checkflag/2, check_identity/2,
	  check_implication_checkflag/2, check_implication/2,
	  classify_if_necessary_checkflag/2, classify_if_necessary/2,
	  hasAttr_redundancy_check/0.

% fool that module system... 
:- export check_isa_types/4, check_ind_types/3.

:- import cdf_error/2, cdf_warning/2 from cdf_exceptions.
:- import in_hierarchy/1,
	  newExtTerm/1,
	  immed_hasAttr/3, isa/2,
	  cdf_id_fields/4 from cdf_init_cdf.

:- import cdf_flags/2 from usermod.

:- import ground/1, member/2, memberchk/2  from basics.

:- import get_component_extensional/2 from cdf_components.
:- import call0/1 from machine.

/*
   TLS: right now need to check: 
    types on insert / query.
    implication on insert
    classify on insert.
*/

apply_checks(Context,Term):- 
	cdf_flags(Context,check(Context,Term,Chklist)),
	member(Check,Chklist),
%	arg(1,Check,Context),
%	arg(2,Check,Arg),
	call0(Check),
	fail.
apply_checks(_,_).

% check_dummy(_,_).

check_ground_checkflag(Context,Term):- 
	((cdf_flags(check(Context),List),
	  member(check_ground(_,_),List)) -> 
	    check_ground(Context,Term)
	  ; true).

check_ground(Context,Term):- 
        get_component_extensional(Term,Comp),
	(Comp \== cdfpt-> 
	   (ground(Term) -> 
	       true
	     ; cdf_error(Context,[Term,' is not ground ']),fail)
	   ; true).

%-----------------

% Type checking.	
% TLS: should be turned on and off...
check_types_checkflag(Context,Term):- 
	((cdf_flags(check(Context),List),
	  member(check_ground(_,_),List)) -> 
	    check_types(Context,Term)
	  ; true).	

check_types(Context,Term):- 
        ((get_component_extensional(Term,Comp),
	  Comp \== cdfpt)-> 
  	    (type_table(Term,Typecall) -> 
	        arg(1,Typecall,Context),
	        call0(Typecall)
	        ; cdf_warning(Context,[Term,
				' is not an extensional fact and cannot ',
				'be added.']),
	           fail)
 	   ;  true).

%------
:- comment(hide,check_isa_types/2).

check_isa_types(Context,First,Second,Term):- 
	check_isa_arg_1(First,Term,Context,F1),
	check_isa_arg_2(Second,Term,Context,F1).

check_isa_types(query,First,Second,Term):- 
	(var(First) -> 
	     true
	  ; check_isa_arg_1(First,Term,Context,F1)),
	(var(Second) -> 
	     true
	  ; check_isa_arg_2(Second,Term,Context,F1)).

check_isa_arg_1(First,Term,Context,Fnct1):- 
	(cdf_id_fields(First,Fnct1,Nid,Src) -> 
  	    check_arg_consist(Src,Nid,Fnct1,First,Context,Term)
	  ; cdf_warning(Context,[First,' in ',Term,' is not of proper type.']),
	    fail ).

check_isa_arg_2(Second,Term,Context,Fnct1):- 
	((cdf_id_fields(Second,Fnct2,Nid,Src),isa_consist(Fnct1,Fnct2)) -> 
  	    check_arg_consist(Src,Nid,Fnct2,Second,Context,Term)
	  ; cdf_warning(Context,['Arguments in ',Term,
				' are not of proper type.']),
	    fail ).

isa_consist(F,F):-!.
isa_consist(oid,cid).

%------
:- comment(hide,check_ind_types/2).

check_ind_types(Context,Term,List):- 
	Term =.. [_|R],
	check_ind_types_1(R,List,Context,Term).

% TLS: goes through the arguments of the CDF fact.
check_ind_types_1([],[],_,_).
check_ind_types_1([Id|T],[List|LT],Context,Term):- 
	(var(Id) -> 
	    true
	  ; 
	    (cdf_id_fields(Id,F,Nid,Src),memberchk(F,List) -> 

	        check_arg_consist(Src,Nid,F,Id,Context,Term)
    	      ; cdf_warning(Context,
			    [Id,' in ',Term,' is not of proper type.']),
	        fail ) ),
	check_ind_types_1(T,LT,Context,Term).


%TLS could perhaps also test to see that F \in oid,cid
check_arg_consist(cdfpt,_Nid,_F,_Id,_Context,_Term):- !.
%	check_primitive_type(Nid,Context,Term).
check_arg_consist(_Src,Nid,F,Id,Context,Term):- 
	(structure(Nid) -> 
	    Nid =.. [_Funct|L],
	    check_arg_consist_list(L,F,Id,Context,Term) 
	  ; true).

check_arg_consist_list([],_F,_Id,_Context,_Term). 
check_arg_consist_list([Nid|T],F,Id,Context,Term):- 
	(var(Nid) -> 
	    true
	  ; 
	    (cdf_id_fields(Nid,F,A,Src) -> 
		check_arg_consist(Src,A,F,Id,Context,Term)
	      ; cdf_warning(Context,[Id,' in ',Term,' is ill-formed.']),
		fail ) ),
	  check_arg_consist_list(T,F,Id,Context,Term).
	
/*
check_primitive_type(Nid,Context,Term):- 
	(atomic(Nid) -> 
	    true
	  ; structure(Nid),
	    (cdf_id_fields(Nid,_,_,_) -> 
    	         cdf_warning(Context,
			    [Nid,' in ',Term,
			     ' is not a proper primitive type.']),
	         fail
              ; 
	         Nid =.. [_|List],
  	         check_primitive_type_list(List,Context,Term) ) ).

check_primitive_type_list([],_Context,_Term).
check_primitive_type_list([H|T],Context,Term):- 
	check_primitive_type(H,Context,Term),
	check_primitive_type_list(T,Context,Term).
*/

type_table(isa(A,B),check_isa_types(_,A,B,isa(A,B))).
type_table(isa_ext(A,B),check_isa_types(_,A,B,isa_ext(A,B))).
type_table(isa_int(A,B),check_isa_types(_,A,B,isa_int(A,B))).

type_table(hasAttr(A,B,C),check_ind_types(_,hasAttr(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(hasAttr_ext(A,B,C),check_ind_types(_,hasAttr_ext(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(hasAttr_int(A,B,C),check_ind_types(_,hasAttr_int(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).

type_table(allAttr(A,B,C),check_ind_types(_,allAttr(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(allAttr_ext(A,B,C),check_ind_types(_,allAttr_ext(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(allAttr_int(A,B,C),check_ind_types(_,allAttr_int(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(classHasAttr(A,B,C),check_ind_types(_,classHasAttr(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).
type_table(classHasAttr_ext(A,B,C),check_ind_types(_,classHasAttr_ext(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).
type_table(classHasAttr_int(A,B,C),check_ind_types(_,classHasAttr(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).


%----------------------------------------------------------------------

% want to change so that it checks for implication also.
check_identity_checkflag(Context,Term):- 
	((cdf_flags(check(Context),List),
	  member(check_identity(_,_),List)) -> 
	    check_identity(_,Term)
	  ; true).

check_identity(_,Term):- 
	(call0(Term) -> fail ; true).
	
%----------------------------------------------------------------------

% want to change so that it checks for implication also.
check_implication_checkflag(Context,Term):- 
	((cdf_flags(check(Context),List),
	  member(check_impliction(_,_),List)) -> 
	    check_implication(Context,Term)
	  ; true).

check_implication(_Context,Term):- 
	remove_ext(Term,Term1),
	(call0(Term1) -> fail ; true).
	
remove_ext(isa_ext(A,B),isa(A,B)).
remove_ext(hasAttr_ext(A,B,C),hasAttr(A,B,C)).
remove_ext(classHasAttr_ext(A,B,C),classHasAttr(A,B,C)).
remove_ext(allAttr_ext(A,B,C),allAttr(A,B,C)).

%----------------------------------------------------------------------

classify_if_necessary_checkflag(Context,Name):-
	(cdf_flags(classify_if_necessary,Context) -> 
	    classify_if_necessary(_Context,Name)
	  ; true).
	    
classify_if_necessary(_Context,Name):- 
	get_component_fact(Name,Term),
	classify_if_necessary_term(Term,Upd1,[]),
	member(Term1,Upd1),
	newExtTerm(Term1),
	fail.
classify_if_necessary(_,_Term).

get_component_fact(Name,Fact):- 
	(  Fact = isa_ext(One,Two) ; Fact = classHasAttr_ext(One,Two,Three)
	   ; Fact = allAttr_ext(One,Two,Three) 
	   ; Fact = hasAttr_ext(One,Two,Three) ),
	call0(Fact),
	get_component_extensional(Fact,Name).

classify_if_necessary_term(Term,Upd1,Upd):-
	\+ (Term = isa_ext(_)),!,
	Term =.. [_|L],
	classify_if_necessary_list(L,Upd1,Upd).
classify_if_necessary_term(isa_ext(First,Second),Upd1,Upd):-
	arg(1,First,Arg),
	(structure(Arg) -> 
	    Arg =.. [_|L],
	    classify_if_necessary_list([Second|L],Upd1,Upd)
	  ; classify_arg(Second,Upd1,Upd)).

classify_if_necessary_list([],Upd,Upd).
classify_if_necessary_list([Arg|R],Updin,Upd):- 
	classify_arg(Arg,Updin,Updmid),
	classify_if_necessary_list(R,Updmid,Upd).

classify_arg(Id,Upd1,Upd):- 
%	writeln(ca(Id)),
	(in_hierarchy(Id) -> 
	    Upd1 = Updmid
	  ; functor(Id,F,_),
	    classification_type(F,Sup),
	    Upd1 = [isa_ext(Id,Sup)|Updmid]),
	  arg(1,Id,Nid),
	   (structure(Nid) -> 
	       Nid =.. [_|L],
	       classify_if_necessary_list(L,Updmid,Upd)
	     ; Updmid = Upd).

classification_type(oid,cid('CDF Classes',cdf)).
classification_type(cid,cid('CDF Classes',cdf)).
classification_type(rid,rid('CDF Object-Object Relations',cdf)).
classification_type(crid,crid('CDF Class-Object Relations',cdf)).

%classification_type(crrid,crrid('CDF Higher-Order (Object-Object)-Object Relations',cdf)).
%classification_type(crcrid,crrid('CDF Higher-Order (Object-Object)-Object Relations',cdf)).

/************************************************************************/
/*									*/
/*	hasAttr_redundancy_check checks for redundancies in		*/
/*	immed_hasAttr.  I.e., it finds tuples that could be deleted	*/
/*	without changing the semantics of hasAttr.			*/
/*	It currently just prints out the redundancies; it could be	*/
/*	modified to save them, for later deletion.			*/
/*									*/
/*	It uses marginals to try to determine which index is better	*/
/*	to use.								*/
/*									*/
/************************************************************************/

:- import  marginal_clear/0, marginal_add/1, marginal_get/2 from marginals.
:- import conset/2, conget/2, coninc/1 from gensym.
hasAttr_redundancy_check :-
	cputime(T0),
	(marginal_clear,
	 immed_hasAttr(S,R,T),
	 marginal_add(first(R,S)),
	 marginal_add(last(R,T)),
	 fail
	 ;	
	 writeln('marginals generated'),
	 conset(lastind,0), conset(firstind,0),
	 F = f(S,R,T), F1 = f(S1,R1,T1),
	 immed_hasAttr(S,R,T),
	 isa(R1,R),
	 marginal_get(first(R1,S),CntFirst),
	 marginal_get(last(R1,T),CntLast),
	 (CntLast < CntFirst
	  ->	 coninc(lastind),
		 isa(T1,T),
		 immed_hasAttr(S1,R1,T1),
		 F \== F1,
		 isa(S,S1)
	  ;	 coninc(firstind),
		 isa(S,S1),
		 immed_hasAttr(S1,R1,T1),
		 F \== F1,
		 isa(T1,T)
	 ),
	 writeln(hasAttr(S,R,T)),writeln(hasAttr(S1,R1,T1)),nl,
	 fail
	 ;
	 marginal_clear
	),
	cputime(T1),
	T is T1-T0, writeln(cputime=T),
	conget(lastind,Last), conget(firstind,First),
	writeln(['Use 1+2 index count'=First, 'Use 2+3 index count'=Last]).


end_of_file.

