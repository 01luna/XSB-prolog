:- compiler_options([ciao_directives]).

:- export check_types/2, 
          check_implication/2,
	  classify_if_necessary/2.

% fool that module system... 
:- export check_isa_types/4, check_ind_types/3.

:- import cdf_error/2, cdf_warning/2 from cdf_exceptions.
:- import in_hierarchy/1,newExtTerm/1 from cdf_init_cdf.

:- import cdf_flags/2 from usermod.

:- import ground/1, member/2, memberchk/2  from basics.

:- import get_component_extensional/2 from cdf_components.

/*
   TLS: right now need to check: 
    types on insert / query.
    implication on insert
    classify on insert.
*/

% Type checking.	
% TLS: should be turned on and off...
check_types(Context,Term):- 
	(cdf_flags(check_types,Context) -> 
	    check_types_no_checkflag(Context,Term)
	  ; true).	

check_types_no_checkflag(term_update,Term):- 
	(ground(Term) -> 
	    true
	  ; cdf_error(term_update,[Term,' must be bound in newExtTerm/1']),
	    fail ),
	(type_table(Term,Typecall) -> 
	    arg(1,Typecall,term_update),
	    call(Typecall)
	  ; cdf_warning(term_update,[Term,
				' is not an extensional fact and cannot ',
				'be added.']),
	    fail ).

check_types_no_checkflag(query,Term):- 
	(var(Term) -> 
	    true
	  ; 
	    (type_table(Term,Typecall) -> 
  	        arg(1,Typecall,query),
		call(Typecall)
	      ; cdf_warning(query,[Term,
				    ' is not an extensional fact and cannot ',
				    'be added.']),
	        fail ) ).

%------
:- comment(hide,check_isa_types/2).

check_isa_types(term_update,First,Second,Term):- 
	check_isa_arg_1(First,Term,Context,F1),
	check_isa_arg_2(Second,Term,Context,F1).

check_isa_types(query,First,Second,Term):- 
	(var(First) -> 
	     true
	  ; check_isa_arg_1(First,Term,Context,F1)),
	(var(Second) -> 
	     true
	  ; check_isa_arg_2(Second,Term,Context,F1)).

check_isa_arg_1(First,Term,Context,F1):- 
	(functor(First,F1,2) -> 
	    true
	  ; cdf_warning(Context,[First,' in ',Term,' is not of proper type.']),
	    fail ),
	arg(1,First,A1),
	check_arg_consist(A1,F1,First,Context,Term).

check_isa_arg_2(Second,Term,Context,F1):- 
	arg(2,Term,Second),
	((functor(Second,F2,2),isa_consist(F1,F2)) -> 
	    true
	  ; cdf_warning(Context,['Arguments in ',Term,
				' are not of proper type.']),
	    fail ),
	arg(1,Second,A2),
	check_arg_consist(A2,F2,Second,Context,Term).

isa_consist(F,F):-!.
isa_consist(oid,cid).

%------
:- comment(hide,check_ind_types/2).

check_ind_types(Context,Term,List):- 
	Term =.. [_|R],
	check_ind_types_1(R,List,Context,Term).

check_ind_types_1([],[],_,_).
check_ind_types_1([Id|T],[List|LT],Context,Term):- 
	(var(Id) -> 
	    true
	  ; 
	    (functor(Id,F,2),memberchk(F,List) -> 
	        arg(1,Id,A),
	        check_arg_consist(A,F,Id,Context,Term)
    	      ; cdf_warning(Context,
			    [Id,' in ',Term,' is not of proper type.']),
	        fail ) ),
	check_ind_types_1(T,LT,Context,Term).

check_arg_consist(Nid,F,Id,Context,Term):- 
	(structure(Nid) -> 
	    Nid =.. [_Funct|L],
	    check_arg_consist_list(L,F,Id,Context,Term) 
	  ; true).

check_arg_consist_list([],_F,_Id,_Context,_Term). 
check_arg_consist_list([Nid|T],F,Id,Context,Term):- 
	(var(Nid) -> 
	    true
	  ; 
	    (functor(Nid,F,2) -> 
	        arg(1,Nid,A),
		check_arg_consist(A,F,Id,Context,Term)
	      ; cdf_warning(Context,[Id,' in ',Term,' is ill-formed.']),
		fail ) ),
	  check_arg_consist_list(T,F,Id,Context,Term).
	
type_table(isa(A,B),check_isa_types(_,A,B,isa(A,B))).
type_table(isa_ext(A,B),check_isa_types(_,A,B,isa_ext(A,B))).
type_table(isa_int(A,B),check_isa_types(_,A,B,isa_int(A,B))).

type_table(hasAttr(A,B,C),check_ind_types(_,hasAttr(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(hasAttr_ext(A,B,C),check_ind_types(_,hasAttr_ext(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(hasAttr_int(A,B,C),check_ind_types(_,hasAttr_int(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).

type_table(allAttr(A,B,C),check_ind_types(_,allAttr(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(allAttr_ext(A,B,C),check_ind_types(_,allAttr_ext(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(allAttr_int(A,B,C),check_ind_types(_,allAttr_int(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(classHasAttr(A,B,C),check_ind_types(_,classHasAttr(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).
type_table(classHasAttr_ext(A,B,C),check_ind_types(_,classHasAttr_ext(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).
type_table(classHasAttr_int(A,B,C),check_ind_types(_,classHasAttr(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).

% want to change so that it checks for implication also.
check_implication(Context,Term):- 
	(cdf_flags(check_implication,Context) -> 
	    check_implication_no_checkflag(Term)
	  ; (call(Term) -> fail ; true) ).

check_implication_no_checkflag(Term):- 
	remove_ext(Term,Term1),
	(call(Term1) -> fail ; true).
	
remove_ext(isa_ext(A,B),isa(A,B)).
remove_ext(hasAttr_ext(A,B,C),hasAttr(A,B,C)).
remove_ext(classHasAttr_ext(A,B,C),classHasAttr(A,B,C)).
remove_ext(allAttr_ext(A,B,C),allAttr(A,B,C)).

%----------------------------------------------------------------------

classify_if_necessary(component_load,Name):-
	(cdf_flags(classify_if_necessary,component_load) -> 
	    classify_if_necessary_no_checkflag(Name)
	  ; true).
	    
classify_if_necessary_no_checkflag(Name):- 
	get_component_fact(Name,Term),
	classify_if_necessary_term(Term,Upd1,[]),
	member(Term1,Upd1),
	newExtTerm(Term1),
	fail.
classify_if_necessary_no_checkflag(_Term).

get_component_fact(Name,Fact):- 
	(  Fact = isa_ext(One,Two) ; Fact = classHasAttr_ext(One,Two,Three)
	   ; Fact = allAttr_ext(One,Two,Three) 
	   ; Fact = hasAttr_ext(One,Two,Three) ),
	call(Fact),
	get_component_extensional(Fact,Name).

classify_if_necessary_term(Term,Upd1,Upd):-
	\+ (Term = isa_ext(_,_)),!,
	Term =.. [_|L],
	classify_if_necessary_list(L,Upd1,Upd).
classify_if_necessary_term(isa_ext(First,Second),Upd1,Upd):-
	arg(1,First,Arg),
	(structure(Arg) -> 
	    Arg =.. [_|L],
	    classify_if_necessary_list([Second|L],Upd1,Upd)
	  ; classify_arg(Second,Upd1,Upd)).

classify_if_necessary_list([],Upd,Upd).
classify_if_necessary_list([Arg|R],Updin,Upd):- 
%	foo(Arg),
	classify_arg(Arg,Updin,Updmid),
	classify_if_necessary_list(R,Updmid,Upd).

classify_arg(Id,Upd1,Upd):- 
%	writeln(ca(Id)),
	(in_hierarchy(Id) -> 
	    Upd1 = Updmid
	  ; functor(Id,F,_),
	    classification_type(F,Sup),
	    Upd1 = [isa_ext(Id,Sup)|Updmid]),
	  arg(1,Id,Nid),
	   (structure(Nid) -> 
	       Nid =.. [_|L],
	       classify_if_necessary_list(L,Updmid,Upd)
	     ; Updmid = Upd).

classification_type(oid,cid('CDF Classes',cdf)).
classification_type(cid,cid('CDF Classes',cdf)).
classification_type(rid,rid('CDF Object-Object Relations',cdf)).
classification_type(crid,crid('CDF Class-Object Relations',cdf)).

%classification_type(crrid,crrid('CDF Higher-Order (Object-Object)-Object Relations',cdf)).
%classification_type(crcrid,crrid('CDF Higher-Order (Object-Object)-Object Relations',cdf)).

end_of_file.