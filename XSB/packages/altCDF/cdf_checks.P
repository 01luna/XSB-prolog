:- comment(module,

"The CDF checking system allows a user to dynamically specify
different checks thet need to be applied at various stages of
execution (or @em{contexts}) during the course of managing an
ontology.  A check has two arguments that must be ground on call, the
first argument being the context, and the second context-specific.
The check may succeed, fail, or throw an error; and may also execute
side-effects (e.g. printing warning messages, automatically
classifying facts).  By making restrictions on the syntax of checks,
it becomes easier for a given user to omit or add checks for a given
context and even code new checks and / or new contexts.

Checks are called in two ways: 

@begin{enumerate} 
@item Based on the Context.  This is done by calling
@tt{apply_checks(Context,Argument)}

as in 

@begin{verbatim}
newExtTerm(Context,Term):- 
	apply_checks(Context,Term),
	cdf_update_list([asserta(Term)]).
@end{verbatim}

@tt{apply_checks/2} (defined below) backtracks through all of the
checks defined for a context and calls them in a specified order.
@tt{apply_checks/2} checks the global table @tt{cdf_flags/2} to
determine the checks to be done in a particular context.  Note that
since checks depend on @tt{cdf_flags/2}, they can be dynamically
changed, or overridden by flag definitions in a @file{.xsbrc} file.
As indicated by the code, the checks must all be imported to
@tt{usermod} to be called.

In order for @tt{apply_checks/2} to work efficiently, the flags must
be set up using a particular convention.  An example is

@begin{verbatim}
cdf_flags(newExtTermSingle,check(A,B,[cdf_check_ground(A),
	  			      check_types(A,B),
				      check_identity(A,B)]))).
@end{verbatim}

The first argument is the context, and the second two argument
variables, along with a list of checks, each of which uses the
argument variables.  Checks are called using the order in the list.
Using this mechanism, a user can add her own checks by importing a
predicate, setting the flags appropriately, and adding an
apply_checks/2 goal to user code (if necessary).  Note that, a user
can also write new checks for existing CDF contexts without changing
the files in the CDF directory.

@item The other way to call a check is by xxx_checkflag/2, where xxx
is the name of a check.  These calls check whether a check is turned
on for a given component, and calls it if so... otherwise the check is
avoided and the predicate succeeds.

The first argument of a checking routine is called the @em{context
argument}, and the second the @em{checking argument}.  Right now, the
checking argument can be an extensional cdf fact or a component name,
but you could imagine others -- like intensional rules.  Thus, some
contexts serve to check individual facts, and others information in a
component.  The code won't run well if you put, say, a fact check in a
component context, but I dont think I'll check the checks for now.
Here are some examples:

@begin{itemize} 

@item @tt{newExtTermSingle}.  This context designates the action of
explicitly calling @tt{newExtTerm/2} to add an extensional fact to the
CDF store.
@begin{itemize}
	@item Checking Argument: Extensional CDF Fact
	@item Default Setting: 
cdf_flags(newExtTermSingle,check(A,B,[cdf_check_ground(A),
	  			      check_types(A,B),
				      check_identity(A,B)]))).
@end{itemize}

@item @tt{retractallExtTermSingle} This context designates the action
of calling @tt{retractallExtTerm/2} to delete an extensional fact from the
CDF store.

@begin{itemize}
	@item Checking Argument: Extensional CDF Fact
	@item Default Setting: None (probably some consist. checks in
                       the future). 
@end{itemize}

@item @tt{newExtTermBatch}.  This context designates calling newExtTerm/2
repeatedly, as in loading a file.

@begin{itemize}
	@item Checking Argument: Extensional CDF Fact
	@item Default Setting: 
         cdf_flags(newExtTermBatch,check(A,B,[cdf_check_ground(A),
	  			      check_types(A,B),
				      check_identity(A,B)]))).
@end{itemize}

@item @tt{componentUpdate}.  This context designates the action of saving a
component.

@begin{itemize}
	@item Checking Argument: component
	@item Default Setting: 
       cdf_flags(componentUpdate,check(A,B,[classify_if_necessary(A,B)])).
  	  cdf_flag(checks(componentLoad,1),classify_if_necessary(Comp))
  	  cdf_flag(checks(componentLoad,1),check_implication(Comp))
@end{itemize}

@item @tt{componentLoad}.  This context designates the action of loading a
component.

@begin{itemize}
	@item Checking Argument: component
	@item Default Setting: None (but you can turn on checks for this
			       context if you like) 
@end{itemize}
			 
There may be other contexts such as @em{obliterate_xxx}.

As a first pass, I think the component checks should check a flag

@begin{verbatim}
cdf_flag(component_check,Component)
@end{verbatim}

before actually checking the component within a context.  This means
that @tt{newExtTerm}, and @tt{retractallExtTerm} will need to set this
flag along with

@begin{verbatim}
cdf_flag(cdf_dirty,Component)
@end{verbatim}

(Im not doing this yet).
So with this, by default we check each check once in ""normal""
evaluation -- loading or adding extensional terms and then saving them
to and loading them from a component.

").

%-----------------------------------------------------------------

:- export apply_checks/2,
	  check_ground_checkflag/2, cdf_check_ground/1, 
	  check_types_checkflag/2, check_types/2,
	  check_identity_checkflag/2, check_identity/2,
	  check_implication_checkflag/2, check_implication/2,
	  classify_if_necessary_checkflag/2, classify_if_necessary/2,
	  check_redundancies_checkflag/2,  check_redundancies/2,
	  check_object_constraints/2.

% fool that module system... 
:- export check_isa_types/4, check_ind_types/3.

:- import cdf_warning/2 from cdf_exceptions.
:- import in_hierarchy/1,
	  newExtTerm/1,retractallExtTerm/1,
	  immed_allAttr/3, 
	  immed_classHasAttr/3, 
	  immed_hasAttr/3, isa/2,
	  immed_minAttr/4,immed_maxAttr/4,
	  cdf_id_fields/4 from cdf_init_cdf.
:- import get_component_extensional/2 from cdf_comps_share.

:- import cdf_flags/2,component_table_ext/3 from usermod.
:- import allAttr_ext/3, classHasAttr_ext/3, hasAttr_ext/3,
	   maxAttr_ext/4, minAttr_ext/4 from usermod.

:- import member/2, memberchk/2,length/2  from basics.
:- import check_ground/3, domain_error/4 from error_handler.
:- import conset/2, conget/2 from gensym.

:- import call0/1 from machine.

apply_checks(Context,Term):- 
        conset('_$cdf_check_flag', 1),
	cdf_flags(Context,check(Context,Term,Chklist)),
	member(Check,Chklist),
	call_check(Check),
	fail.
apply_checks(_,_):- 
        conget('_$cdf_check_flag', Bool),
	(Bool == 1 -> true ; fail).

call_check(Check):- 
        (call0(Check) -> true ; conset('_$cdf_check_flag', 0)).

%-----------------
check_ground_checkflag(Context,Term):- 
	((cdf_flags(Context,check(_,_,List)),
	  member(cdf_check_ground(_),List)) -> 
	    cdf_check_ground(Term)
	  ; true).

cdf_check_ground(Term):- 
	component_table_ext(Term,Main,Dep),
	member(Arg,[Main|Dep]),
	cdf_id_fields(Arg,_,_,Comp),
	(Comp \== cdfpt->
	   check_ground(Term,'cdf_check_ground/1',2)
	   ; true),
	  fail.
cdf_check_ground(_Term).

%-----------------

check_types_checkflag(Context,Term):- 
	((cdf_flags(Context,check(_,_,List)),
	  member(check_types(_,_),List)) -> 
	    check_types(Context,Term)
	  ; true).	

check_types(Context,Term):- 
        ((get_component_extensional(Term,Comp),
	  Comp \== cdfpt)-> 
  	    (type_table(Term,Typecall) -> 
	        arg(1,Typecall,Context),
	        call0(Typecall)
	        ; cdf_warning(Context,[Term,
				' is not an extensional fact and cannot ',
				'be added.']),
	           fail)
 	   ;  true).

%------
:- comment(hide,check_isa_types/2).

check_isa_types(query,First,Second,Term):- !,
	(var(First) -> 
	     true
	  ; check_isa_arg_1(First,Term,Context,F1)),
	(var(Second) -> 
	     true
	  ; check_isa_arg_2(Second,Term,Context,F1)).
check_isa_types(Context,First,Second,Term):- 
	check_isa_arg_1(First,Term,Context,F1),
	check_isa_arg_2(Second,Term,Context,F1).

check_isa_arg_1(First,Term,Context,Fnct1):- 
	(cdf_id_fields(First,Fnct1,Nid,Src) -> 
  	    check_arg_consist(Src,Nid,Fnct1,First,Context,Term)
	  ; cdf_warning(Context,[First,' in ',Term,' is not of proper type.']),
	    fail ).

check_isa_arg_2(Second,Term,Context,Fnct1):- 
	((cdf_id_fields(Second,Fnct2,Nid,Src),isa_consist(Fnct1,Fnct2)) -> 
  	    check_arg_consist(Src,Nid,Fnct2,Second,Context,Term)
	  ; cdf_warning(Context,['Arguments in ',Term,
				' are not of proper type.']),
	    fail ).

isa_consist(F,F):-!.
isa_consist(oid,cid).

%------
:- comment(hide,check_ind_types/2).

check_ind_types(Context,Term,List):- 
	Term =.. [_|R],
	check_ind_types_1(R,List,Context,Term).

% TLS: goes through the arguments of the CDF fact.
check_ind_types_1([],[],_,_).
check_ind_types_1([Id|T],[List|LT],Context,Term):- 
	(var(Id) -> 
	    true
	  ; 
	    (List == posint -> 
	         cdfCheckPosInt(Id,Term)
	       ; 
	         (cdf_id_fields(Id,F,Nid,Src),memberchk(F,List) -> 
	             check_arg_consist(Src,Nid,F,Id,Context,Term)
    	           ; cdf_warning(Context,
			    [Id,' in ',Term,' is not of proper type.']),
	           fail ) ) ),
	check_ind_types_1(T,LT,Context,Term).

% TLS: check gives an error here, because min and max will give an arithmetic
% exception if not of the proper type.
cdfCheckPosInt(Id,Term):- 
	(integer(Id),Id > 0 -> 
	    true 
	  ;
	 domain_error(positive_integer,Term,cdfCheckPosint,3) ).

%TLS could perhaps also test to see that F \in oid,cid
check_arg_consist(cdfpt,_Nid,_F,_Id,_Context,_Term):- !.
%	check_primitive_type(Nid,Context,Term).
check_arg_consist(_Src,Nid,F,Id,Context,Term):- 
	(structure(Nid) -> 
	    Nid =.. [_Funct|L],
	    check_arg_consist_list(L,F,Id,Context,Term) 
	  ; true).

check_arg_consist_list([],_F,_Id,_Context,_Term). 
check_arg_consist_list([Nid|T],F,Id,Context,Term):- 
	(var(Nid) -> 
	    true
	  ; 
	    (cdf_id_fields(Nid,F,A,Src) -> 
		check_arg_consist(Src,A,F,Id,Context,Term)
	      ; cdf_warning(Context,[Id,' in ',Term,' is ill-formed.']),
		fail ) ),
	  check_arg_consist_list(T,F,Id,Context,Term).
	
/*
check_primitive_type(Nid,Context,Term):- 
	(atomic(Nid) -> 
	    true
	  ; structure(Nid),
	    (cdf_id_fields(Nid,_,_,_) -> 
    	         cdf_warning(Context,
			    [Nid,' in ',Term,
			     ' is not a proper primitive type.']),
	         fail
              ; 
	         Nid =.. [_|List],
  	         check_primitive_type_list(List,Context,Term) ) ).

check_primitive_type_list([],_Context,_Term).
check_primitive_type_list([H|T],Context,Term):- 
	check_primitive_type(H,Context,Term),
	check_primitive_type_list(T,Context,Term).
*/

type_table(isa(A,B),check_isa_types(_,A,B,isa(A,B))).
type_table(isa_ext(A,B),check_isa_types(_,A,B,isa_ext(A,B))).
type_table(isa_int(A,B),check_isa_types(_,A,B,isa_int(A,B))).

type_table(hasAttr(A,B,C),check_ind_types(_,hasAttr(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(hasAttr_ext(A,B,C),check_ind_types(_,hasAttr_ext(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(hasAttr_int(A,B,C),check_ind_types(_,hasAttr_int(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).

type_table(allAttr(A,B,C),check_ind_types(_,allAttr(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(allAttr_ext(A,B,C),check_ind_types(_,allAttr_ext(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(allAttr_int(A,B,C),check_ind_types(_,allAttr_int(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).

type_table(minAttr(A,B,C,N),check_ind_types(_,minAttr(A,B,C,N),
				[ [cid,oid], [rid], [cid,oid] ] ,posint) ).
type_table(minAttr_ext(A,B,C,N),check_ind_types(_,minAttr_ext(A,B,C,N),
				[ [cid,oid], [rid], [cid,oid], posint ] ) ).
type_table(minAttr_int(A,B,C,N),check_ind_types(_,minAttr_int(A,B,C,N),
				[ [cid,oid], [rid], [cid,oid], posint ] ) ).

type_table(maxAttr(A,B,C,N),check_ind_types(_,maxAttr(A,B,C,N),
				[ [cid,oid], [rid], [cid,oid], posint] ) ).
type_table(maxAttr_ext(A,B,C,N),check_ind_types(_,maxAttr_ext(A,B,C,N),
				[ [cid,oid], [rid], [cid,oid], posint ] ) ).
type_table(maxAttr_int(A,B,C,N),check_ind_types(_,maxAttr_int(A,B,C,N),
				[ [cid,oid], [rid], [cid,oid], posint ] ) ).

type_table(classHasAttr(A,B,C),check_ind_types(_,classHasAttr(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).
type_table(classHasAttr_ext(A,B,C),check_ind_types(_,classHasAttr_ext(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).
type_table(classHasAttr_int(A,B,C),check_ind_types(_,classHasAttr(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).


%----------------------------------------------------------------------

check_identity_checkflag(Context,Term):- 
	((cdf_flags(Context,check(_,_,List)),
	   member(check_identity(_,_),List)) -> 
	    check_identity(_,Term)
	  ; true).

check_identity(_,Term):- 
	(call0(Term) -> 
	    fail 
	  ; (ext_to_int_call(Term, TermInt), call0(TermInt) -> fail ; true)).

ext_to_int_call(isa_ext(A,B), isa_int(A,B)).
ext_to_int_call(hasAttr_ext(A,B,C), hasAttr_int(A,B,C)).
ext_to_int_call(allAttr_ext(A,B,C), allAttr_int(A,B,C)).
ext_to_int_call(classHasAttr_ext(A,B,C), classHasAttr_int(A,B,C)).
	
%----------------------------------------------------------------------

check_implication_checkflag(Context,Term):- 
	((cdf_flags(Context,check(_,_,List)),
	  member(check_implication(_,_),List)) -> 
	    check_implication(Context,Term)
	  ; true).

check_implication(_Context,Term):- 
	remove_ext(Term,Term1),
	(call0(Term1) -> fail ; true).
	
remove_ext(allAttr_ext(A,B,C),allAttr(A,B,C)).
remove_ext(classHasAttr_ext(A,B,C),classHasAttr(A,B,C)).
remove_ext(hasAttr_ext(A,B,C),hasAttr(A,B,C)).
remove_ext(isa_ext(A,B),isa(A,B)).
remove_ext(minAttr_ext(A,B,C,N),minAttr(A,B,C,N)).
remove_ext(maxAttr_ext(A,B,C,N),maxAttr(A,B,C,N)).

%----------------------------------------------------------------------

classify_if_necessary_checkflag(Context,Name):-
	((cdf_flags(Context,check(_,_,List)),
	   member(classify_if_necessary(_,_),List)) -> 
	     classify_if_necessary(_Context,Name)
	  ;  true).
	    
classify_if_necessary(_Context,Name):- 
	get_component_fact(Name,Term),
	classify_if_necessary_term(Term,Upd1,[]),
	member(Term1,Upd1),
	newExtTerm(Term1),
	fail.
classify_if_necessary(_,_Term).

get_component_fact(Name,Fact):- 
	(  Fact = isa_ext(One,Two) ; Fact = classHasAttr_ext(One,Two,Three)
	   ; Fact = allAttr_ext(One,Two,Three) 
	   ; Fact = hasAttr_ext(One,Two,Three) ),
	call0(Fact),
	get_component_extensional(Fact,Name).

classify_if_necessary_term(Term,Upd1,Upd):-
	\+ (Term = isa_ext(_,_)),!,
	Term =.. [_|L],
	classify_if_necessary_list(L,Upd1,Upd).
classify_if_necessary_term(isa_ext(First,Second),Upd1,Upd):-
	arg(1,First,Arg),
	(structure(Arg) -> 
	    Arg =.. [_|L],
	    classify_if_necessary_list([Second|L],Upd1,Upd)
	  ; classify_arg(Second,Upd1,Upd)).

classify_if_necessary_list([],Upd,Upd).
classify_if_necessary_list([Arg|R],Updin,Upd):- 
	classify_arg(Arg,Updin,Updmid),
	classify_if_necessary_list(R,Updmid,Upd).

classify_arg(Id,Upd1,Upd):- 
%	writeln(ca(Id)),
	(in_hierarchy(Id) -> 
	    Upd1 = Updmid
	 ; Id = cid(Cmp,Cmp)
	 -> Upd1 = Updmid
	  ; functor(Id,F,_),
	    classification_type(F,Sup),
	    Upd1 = [isa_ext(Id,Sup)|Updmid]),
	  arg(1,Id,Nid),
	   (structure(Nid) -> 
	       Nid =.. [_|L],
	       classify_if_necessary_list(L,Updmid,Upd)
	     ; Updmid = Upd).

classification_type(oid,cid('CDF Classes',cdf)).
classification_type(cid,cid('CDF Classes',cdf)).
classification_type(rid,rid('CDF Object-Object Relations',cdf)).
classification_type(crid,crid('CDF Class-Object Relations',cdf)).

%classification_type(crrid,crrid('CDF Higher-Order (Object-Object)-Object Relations',cdf)).
%classification_type(crcrid,crrid('CDF Higher-Order (Object-Object)-Object Relations',cdf)).

%-----------------------------------------------------------------
:- comment(check_redundancies/2,"

@tt{check_redundancies/2}  checks for redundancies in the immediate
predicates of a module  I.e., it finds tuples that could be deleted 
without changing the semantics of the predicate.  The redundancies are
currently emitted as a warning, but the predicate could be modified to
delete them.  
").

%TLS the original was saved after end_of_file.

:- import conset/2, conget/2, coninc/1 from gensym.
:- import message/1 from standard.

check_redundancies(Context,f(Component,Mode)):- 
	cputime(Start),
	conset(redund,0),
	allAttr_redundancy_check(Context,Component,Mode),
	classHasAttr_redundancy_check(Context,Component,Mode),
	hasAttr_redundancy_check(Context,Component,Mode),
	maxAttr_redundancy_check(Context,Component,Mode),
	minAttr_redundancy_check(Context,Component,Mode),
	cputime(End),
	Tot is End - Start,
	conget(redund,N),
	message(['Redundancy Cputime ',Tot,' for ',N,' Fact checks.']).
 
allAttr_redundancy_check(Context,Component,Mode) :-
	 allAttr_ext(S,R,T),
             coninc(redund),
	 get_component_extensional(allAttr_ext(S,R,T),Component),
	 allAttr_redundancy_check_1(Context,Component,allAttr(S,R,T),Mode),
	 fail.
allAttr_redundancy_check(_Context,_Component,_Mode).

allAttr_redundancy_check_1(Context,Component,allAttr(S,R,T),Mode):- 
	 immed_allAttr(S1,R1,T1),
	 \+ (S1 = S,R1 =R,T1 = T),
	 get_component_extensional(allAttr_ext(S1,R1,T1),Component),
	 ((isa(S,S1),isa(R,R1),isa(T1,T)) -> 
	     cdf_warning(Context,[allAttr(S,R,T),' is implied by ',
	                                                     allAttr(S1,R1,T1)]),
	     (Mode = retract -> retractallExtTerm(allAttr_ext(S,R,T)) ; true)
	   ; 
                 fail),!.

classHasAttr_redundancy_check(Context,Component,Mode) :-
	 classHasAttr_ext(S,R,T),
             coninc(redund),
	 get_component_extensional(classHasAttr_ext(S,R,T),Component),
	 classHasAttr_redundancy_check_1(Context,Component,
	                                                     classHasAttr(S,R,T),Mode),
	 fail.
classHasAttr_redundancy_check(_Context,_Component,_Mode).

classHasAttr_redundancy_check_1(Context,Component,
	                                       classHasAttr(S,R,T),Mode):- 
	 immed_classHasAttr(S,R1,T1),
	 \+ (R1 == R,T1 == T),
	 get_component_extensional(classHasAttr_ext(S,R1,T1),Component),
	 ((isa(R,R1),isa(T1,T)) -> 	
	     cdf_warning(Context,[classHasAttr(S,R,T),' is implied by ',
	                                                     classHasAttr(S,R1,T1)]),
	     (Mode = retract -> 
		 retractallExtTerm(classHasAttr_ext(S,R,T)) ; true)
	   ; 
                 fail),!.

hasAttr_redundancy_check(Context,Component,Mode) :-
	 hasAttr_ext(S,R,T),
             coninc(redund),
	 get_component_extensional(hasAttr_ext(S,R,T),Component),
	 hasAttr_redundancy_check_1(Context,Component,hasAttr(S,R,T),
	                                            Mode),
	 fail.
hasAttr_redundancy_check(_Context,_Component,_Mode).

hasAttr_redundancy_check_1(Context,Component,hasAttr(S,R,T),Mode):- 
	 immed_hasAttr(S1,R1,T1),
	 \+ (S1 = S,R1 = R,T1 = T),
	 get_component_extensional(hasAttr_ext(S1,R1,T1),Component),
	 ((isa(S,S1),isa(R,R1),isa(T1,T)) -> 	
	     cdf_warning(Context,[hasAttr(S,R,T),' is implied by ',
	                                                     hasAttr(S1,R1,T1)]),
	     (Mode = retract -> retractallExtTerm(hasAttr_ext(S,R,T)) ; true)
	   ; 
                 fail),!.

minAttr_redundancy_check(Context,Component,Mode) :-
	 minAttr_ext(S,R,T,N),
             coninc(redund),
	 get_component_extensional(minAttr_ext(S,R,T,N),Component),
	 minAttr_redundancy_check_1(Context,Component,minAttr(S,R,T,N),
                                                         Mode),
	 fail.
minAttr_redundancy_check(_Context,_Component,_Mode).

minAttr_redundancy_check_1(Context,Component,minAttr(S,R,T,N),Mode):- 
	 immed_minAttr(S1,R1,T1,N1),
	 \+ (S1 == S,R1 == R,T1 == T,N = N1),
	 get_component_extensional(minAttr_ext(S1,R1,T1,N1),Component),
	 ((isa(S,S1),isa(R,R1),isa(T1,T),N1 >= N) -> 	
	     cdf_warning(Context,[minAttr(S,R,T,N),' is implied by ',
	                                                     minAttr(S1,R1,T1,N1)]),
	     (Mode = retract -> retractallExtTerm(minAttr_ext(S,R,T,N)) ; true)
	   ; 
                 fail),!.

maxAttr_redundancy_check(Context,Component,Mode) :-
	 maxAttr_ext(S,R,T,N),
             coninc(redund),
	 get_component_extensional(maxAttr_ext(S,R,T,N),Component),
	 maxAttr_redundancy_check_1(Context,Component,maxAttr(S,R,T,N),
	                                             Mode),
	 fail.
maxAttr_redundancy_check(_Context,_Component,_Mode).

maxAttr_redundancy_check_1(Context,Component,maxAttr(S,R,T,N),Mode):- 
	 immed_maxAttr(S1,R1,T1,N1),
	 \+ (S1 == S,R1 == R,T1 == T,N1 == N),
	 get_component_extensional(maxAttr_ext(S1,R1,T1,N1),Component),
	 ((isa(S,S1),isa(R,R1),isa(T1,T),N1 =< N) -> 	
	     cdf_warning(Context,[maxAttr(S,R,T,N),' is implied by ',
	                                                     maxAttr(S1,R1,T1,N1)]),
	     (Mode = retract -> retractallExtTerm(maxAttr_ext(S,R,T,N)) ; true)
	   ; 
                 fail),!.

%-----------------------------------------------------------------

check_object_constraints(Context,Component):- 
	cputime(Start),
	conset(object,0),
	check_allAttr_constraints(Context,Component),
	check_minAttr_constraints(Context,Component),
	check_maxAttr_constraints(Context,Component),
	cputime(End),
	Tot is End - Start,
	conget(object,N),
	message(['Object Check Cputime ',Tot,' for ',N,' Fact checks.']).

check_allAttr_constraints(Context,Component):- 
	coninc(object),
	immed_allAttr(S,R,T),
	get_component_extensional(allAttr_ext(S,R,T),Component),
	check_allAttr_constraints_1(Context,allAttr(S,R,T)),
	fail.
check_allAttr_constraints(_Context,_Component).

check_allAttr_constraints_1(Context,allAttr(S,R,T)):- 
	isa(oid(Oid,Src),S),
	hasAttr(oid(Oid,Src),R,T1),
	(isa(T1,T) -> 
	    true
	  ; cdf_warning(Context,[hasAttr(oid(Oid,Src),R,T1),' does not ',
	                                     'explicitly satisfy the ',
                                                 'constraint ',allAttr(S,R,T)]) ).

check_minAttr_constraints(Context,Component):- 
	coninc(object),
	immed_minAttr(S,R,T,N),
	get_component_extensional(minAttr_ext(S,R,T,N),Component),
	check_minAttr_constraints_1(Context,minAttr(S,R,T,N)),
	fail.
check_minAttr_constraints(_Context,_Component).
	
check_minAttr_constraints_1(Context,minAttr(S,R,T,N)):- 
	isa(oid(Oid,Src),S),
	findall(oid(Oid1,Src1),(hasAttr(oid(Oid,Src),R,oid(Oid1,Src1)),
	                               isa(oid(Oid1,Src1),T)),NewOids),
	length(NewOids,L),
	(L >= N -> 
	    true
	  ; cdf_warning(Context,[oid(Oid1,Src1),' does not satisfy the',
                                                 ' constraint ',minAttr(S,R,T,N)]) ).

check_maxAttr_constraints(Context,Component):- 
	coninc(object),
	immed_maxAttr(S,R,T,N),
	get_component_extensional(maxAttr_ext(S,R,T,N),Component),
	check_maxAttr_constraints_1(Context,maxAttr(S,R,T,N)),
	fail.
check_maxAttr_constraints(_Context,_Component).
	
check_maxAttr_constraints_1(Context,maxAttr(S,R,T,N)):- 
	isa(oid(Oid,Src),S),
	findall(oid(Oid1,Src1),(hasAttr(oid(Oid,Src),R,oid(Oid1,Src1)),
	                               isa(oid(Oid1,Src1),T)),NewOids),
	length(NewOids,L),
	(L =< N -> 
	    true
	  ; cdf_warning(Context,[oid(Oid1,Src1),' does not satisfy the
                                                  constraint ',maxAttr(S,R,T,N)]) ).


end_of_file.

:- import  marginal_clear/0, marginal_add/1, marginal_get/2 from marginals.
:- import conset/2, conget/2, coninc/1 from gensym.

hasAttr_redundancy_check :-
	cputime(T0),
	(marginal_clear,
	 immed_hasAttr(S,R,T),
	 marginal_add(first(R,S)),
	 marginal_add(last(R,T)),
	 fail
	 ;	
	 writeln('marginals generated'),
	 conset(lastind,0), conset(firstind,0),
	 F = f(S,R,T), F1 = f(S1,R1,T1),
	 immed_hasAttr(S,R,T),
	 isa(R1,R),
	 marginal_get(first(R1,S),CntFirst),
	 marginal_get(last(R1,T),CntLast),
	 (CntLast < CntFirst
	  ->	 coninc(lastind),
		 isa(T1,T),
		 immed_hasAttr(S1,R1,T1),
		 F \== F1,
		 isa(S,S1)
	  ;	 coninc(firstind),
		 isa(S,S1),
		 immed_hasAttr(S1,R1,T1),
		 F \== F1,
		 isa(T1,T)
	 ),
	 writeln(hasAttr(S,R,T)),writeln(hasAttr(S1,R1,T1)),nl,
	 fail
	 ;
	 marginal_clear
	),
	cputime(T1),
	T is T1-T0, writeln(cputime=T),
	conget(lastind,Last), conget(firstind,First),
	writeln(['Use 1+2 index count'=First, 'Use 2+3 index count'=Last]).
