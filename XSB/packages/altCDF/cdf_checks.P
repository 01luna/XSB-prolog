:- compiler_options([ciao_directives]).

:- export check_types/2, 
          check_implication/2,
	  classify_if_necessary/2,
	  classify_if_necessary_no_checkflag/2,
	  hasAttr_redundancy_check/0.

% fool that module system... 
:- export check_isa_types/4, check_ind_types/3.

:- import cdf_error/2, cdf_warning/2 from cdf_exceptions.
:- import in_hierarchy/1,
	  newExtTerm/1,
	  immed_hasAttr/3, isa/2,
	  cdf_id_fields/4 from cdf_init_cdf.

:- import cdf_flags/2 from usermod.

:- import ground/1, member/2, memberchk/2  from basics.

:- import get_component_extensional/2 from cdf_components.

/*
   TLS: right now need to check: 
    types on insert / query.
    implication on insert
    classify on insert.
*/

% Type checking.	
% TLS: should be turned on and off...
check_types(Context,Term):- 
	((cdf_flags(check_types,Context),
               get_component_extensional(Term,Comp),
	   Comp \== cdfpt)-> 
	    check_types_no_checkflag(Context,Term)
	  ; true).	

check_types_no_checkflag(term_update,Term):- 
	(ground(Term) -> 
	    true
	  ; cdf_error(term_update,[Term,' must be bound in newExtTerm/1']),
	    fail ),
	(type_table(Term,Typecall) -> 
	    arg(1,Typecall,term_update),
	    call(Typecall)
	  ; cdf_warning(term_update,[Term,
				' is not an extensional fact and cannot ',
				'be added.']),
	    fail ).

check_types_no_checkflag(query,Term):- 
	(var(Term) -> 
	    true
	  ; 
	    (type_table(Term,Typecall) -> 
  	        arg(1,Typecall,query),
		call(Typecall)
	      ; cdf_warning(query,[Term,
				    ' is not an extensional fact and cannot ',
				    'be added.']),
	        fail ) ).

%------
:- comment(hide,check_isa_types/2).

check_isa_types(Context,First,Second,Term):- 
	check_isa_arg_1(First,Term,Context,F1),
	check_isa_arg_2(Second,Term,Context,F1).

check_isa_types(query,First,Second,Term):- 
	(var(First) -> 
	     true
	  ; check_isa_arg_1(First,Term,Context,F1)),
	(var(Second) -> 
	     true
	  ; check_isa_arg_2(Second,Term,Context,F1)).

check_isa_arg_1(First,Term,Context,Fnct1):- 
	(cdf_id_fields(First,Fnct1,Nid,Src) -> 
  	    check_arg_consist(Src,Nid,Fnct1,First,Context,Term)
	  ; cdf_warning(Context,[First,' in ',Term,' is not of proper type.']),
	    fail ).

check_isa_arg_2(Second,Term,Context,Fnct1):- 
	((cdf_id_fields(Second,Fnct2,Nid,Src),isa_consist(Fnct1,Fnct2)) -> 
  	    check_arg_consist(Src,Nid,Fnct2,Second,Context,Term)
	  ; cdf_warning(Context,['Arguments in ',Term,
				' are not of proper type.']),
	    fail ).

isa_consist(F,F):-!.
isa_consist(oid,cid).

%------
:- comment(hide,check_ind_types/2).

check_ind_types(Context,Term,List):- 
	Term =.. [_|R],
	check_ind_types_1(R,List,Context,Term).

% TLS: goes through the arguments of the CDF fact.
check_ind_types_1([],[],_,_).
check_ind_types_1([Id|T],[List|LT],Context,Term):- 
	(var(Id) -> 
	    true
	  ; 
	    (cdf_id_fields(Id,F,Nid,Src),memberchk(F,List) -> 

	        check_arg_consist(Src,Nid,F,Id,Context,Term)
    	      ; cdf_warning(Context,
			    [Id,' in ',Term,' is not of proper type.']),
	        fail ) ),
	check_ind_types_1(T,LT,Context,Term).


%TLS could perhaps also test to see that F \in oid,cid
check_arg_consist(cdfpt,_Nid,_F,_Id,_Context,_Term):- !.
%	check_primitive_type(Nid,Context,Term).
check_arg_consist(_Src,Nid,F,Id,Context,Term):- 
	(structure(Nid) -> 
	    Nid =.. [_Funct|L],
	    check_arg_consist_list(L,F,Id,Context,Term) 
	  ; true).

check_arg_consist_list([],_F,_Id,_Context,_Term). 
check_arg_consist_list([Nid|T],F,Id,Context,Term):- 
	(var(Nid) -> 
	    true
	  ; 
	    (cdf_id_fields(Nid,F,A,Src) -> 
		check_arg_consist(Src,A,F,Id,Context,Term)
	      ; cdf_warning(Context,[Id,' in ',Term,' is ill-formed.']),
		fail ) ),
	  check_arg_consist_list(T,F,Id,Context,Term).
	
/*
check_primitive_type(Nid,Context,Term):- 
	(atomic(Nid) -> 
	    true
	  ; structure(Nid),
	    (cdf_id_fields(Nid,_,_,_) -> 
    	         cdf_warning(Context,
			    [Nid,' in ',Term,
			     ' is not a proper primitive type.']),
	         fail
              ; 
	         Nid =.. [_|List],
  	         check_primitive_type_list(List,Context,Term) ) ).

check_primitive_type_list([],_Context,_Term).
check_primitive_type_list([H|T],Context,Term):- 
	check_primitive_type(H,Context,Term),
	check_primitive_type_list(T,Context,Term).
*/

type_table(isa(A,B),check_isa_types(_,A,B,isa(A,B))).
type_table(isa_ext(A,B),check_isa_types(_,A,B,isa_ext(A,B))).
type_table(isa_int(A,B),check_isa_types(_,A,B,isa_int(A,B))).

type_table(hasAttr(A,B,C),check_ind_types(_,hasAttr(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(hasAttr_ext(A,B,C),check_ind_types(_,hasAttr_ext(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(hasAttr_int(A,B,C),check_ind_types(_,hasAttr_int(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).

type_table(allAttr(A,B,C),check_ind_types(_,allAttr(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(allAttr_ext(A,B,C),check_ind_types(_,allAttr_ext(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(allAttr_int(A,B,C),check_ind_types(_,allAttr_int(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(classHasAttr(A,B,C),check_ind_types(_,classHasAttr(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).
type_table(classHasAttr_ext(A,B,C),check_ind_types(_,classHasAttr_ext(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).
type_table(classHasAttr_int(A,B,C),check_ind_types(_,classHasAttr(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).

%----------------------------------------------------------------------

% want to change so that it checks for implication also.
check_implication(Context,Term):- 
	(cdf_flags(check_implication,Context) -> 
	    check_implication_no_checkflag(Term)
	  ; (call(Term) -> fail ; true) ).

check_implication_no_checkflag(Term):- 
	remove_ext(Term,Term1),
	(call(Term1) -> fail ; true).
	
remove_ext(isa_ext(A,B),isa(A,B)).
remove_ext(hasAttr_ext(A,B,C),hasAttr(A,B,C)).
remove_ext(classHasAttr_ext(A,B,C),classHasAttr(A,B,C)).
remove_ext(allAttr_ext(A,B,C),allAttr(A,B,C)).

%----------------------------------------------------------------------

classify_if_necessary(component_load,Name):-
%	writeln(cin(Name)),
	(cdf_flags(classify_if_necessary,component_load) -> 
%	    writeln(cin(Name)),
	    classify_if_necessary_no_checkflag(Name)
	  ; true).
	    
classify_if_necessary_no_checkflag(Name):- 
	get_component_fact(Name,Term),
	classify_if_necessary_term(Term,Upd1,[]),
	member(Term1,Upd1),
	newExtTerm(Term1),
	fail.
classify_if_necessary_no_checkflag(_Term).

get_component_fact(Name,Fact):- 
	(  Fact = isa_ext(One,Two) ; Fact = classHasAttr_ext(One,Two,Three)
	   ; Fact = allAttr_ext(One,Two,Three) 
	   ; Fact = hasAttr_ext(One,Two,Three) ),
	call(Fact),
	get_component_extensional(Fact,Name).

classify_if_necessary_term(Term,Upd1,Upd):-
	\+ (Term = isa_ext(_,_)),!,
	Term =.. [_|L],
	classify_if_necessary_list(L,Upd1,Upd).
classify_if_necessary_term(isa_ext(First,Second),Upd1,Upd):-
	arg(1,First,Arg),
	(structure(Arg) -> 
	    Arg =.. [_|L],
	    classify_if_necessary_list([Second|L],Upd1,Upd)
	  ; classify_arg(Second,Upd1,Upd)).

classify_if_necessary_list([],Upd,Upd).
classify_if_necessary_list([Arg|R],Updin,Upd):- 
	classify_arg(Arg,Updin,Updmid),
	classify_if_necessary_list(R,Updmid,Upd).

classify_arg(Id,Upd1,Upd):- 
%	writeln(ca(Id)),
	(in_hierarchy(Id) -> 
	    Upd1 = Updmid
	  ; functor(Id,F,_),
	    classification_type(F,Sup),
	    Upd1 = [isa_ext(Id,Sup)|Updmid]),
	  arg(1,Id,Nid),
	   (structure(Nid) -> 
	       Nid =.. [_|L],
	       classify_if_necessary_list(L,Updmid,Upd)
	     ; Updmid = Upd).

classification_type(oid,cid('CDF Classes',cdf)).
classification_type(cid,cid('CDF Classes',cdf)).
classification_type(rid,rid('CDF Object-Object Relations',cdf)).
classification_type(crid,crid('CDF Class-Object Relations',cdf)).

%classification_type(crrid,crrid('CDF Higher-Order (Object-Object)-Object Relations',cdf)).
%classification_type(crcrid,crrid('CDF Higher-Order (Object-Object)-Object Relations',cdf)).

/************************************************************************/
/*									*/
/*	hasAttr_redundancy_check checks for redundancies in		*/
/*	immed_hasAttr.  I.e., it finds tuples that could be deleted	*/
/*	without changing the semantics of hasAttr.			*/
/*	It currently just prints out the redundancies; it could be	*/
/*	modified to save them, for later deletion.			*/
/*									*/
/*	It uses marginals to try to determine which index is better	*/
/*	to use.								*/
/*									*/
/************************************************************************/

:- import  marginal_clear/0, marginal_add/1, marginal_get/2 from marginals.
:- import conset/2, conget/2, coninc/1 from gensym.
hasAttr_redundancy_check :-
	cputime(T0),
	(marginal_clear,
	 immed_hasAttr(S,R,T),
	 marginal_add(first(R,S)),
	 marginal_add(last(R,T)),
	 fail
	 ;	
	 writeln('marginals generated'),
	 conset(lastind,0), conset(firstind,0),
	 F = f(S,R,T), F1 = f(S1,R1,T1),
	 immed_hasAttr(S,R,T),
	 isa(R1,R),
	 marginal_get(first(R1,S),CntFirst),
	 marginal_get(last(R1,T),CntLast),
	 (CntLast < CntFirst
	  ->	 coninc(lastind),
		 isa(T1,T),
		 immed_hasAttr(S1,R1,T1),
		 F \== F1,
		 isa(S,S1)
	  ;	 coninc(firstind),
		 isa(S,S1),
		 immed_hasAttr(S1,R1,T1),
		 F \== F1,
		 isa(T1,T)
	 ),
	 writeln(hasAttr(S,R,T)),writeln(hasAttr(S1,R1,T1)),nl,
	 fail
	 ;
	 marginal_clear
	),
	cputime(T1),
	T is T1-T0, writeln(cputime=T),
	conget(lastind,Last), conget(firstind,First),
	writeln(['Use 1+2 index count'=First, 'Use 2+3 index count'=Last]).


end_of_file.