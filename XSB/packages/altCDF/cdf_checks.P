:- compiler_options([ciao_directives]).

:- export check_types/2, check_implication/2.

% fool that module system... 
:- export check_isa_types/2, check_ind_types/3.

:- import ground/1,memberchk/2  from basics.
:- import cdf_error/2, cdf_warning/2 from cdf_exceptions.

% Type checking.	
% TLS: should be turned on and off...
check_types(update,Term):- 
	(ground(Term) -> 
	    true
	  ; cdf_error(update,[Term,' must be bound in newExtTerm/1']),
	    fail ),
	(type_table(Term,Typecall) -> 
	    arg(1,Typecall,update),
	    call(Typecall)
	  ; cdf_warning(update,[Term,' is not an extensional fact and cannot ',
				'be added.']),
	    fail ).

check_types(query,Term):- 
	(var(Term) -> 
	    true
	  ; 
	    (type_table(Term,Typecall) -> 
  	        arg(1,Typecall,query),
		call(Typecall)
	      ; cdf_warning(query,[Term,
				    ' is not an extensional fact and cannot ',
				    'be added.']),
	        fail ) ).

%------
:- comment(hide,check_isa_types/2).
check_isa_types(Context,isa_ext(First,Second)):- 
	(functor(First,F1,2) -> 
	    true
	  ; cdf_warning(Context,[First,' in ',Term,' is not of proper type.']),
	    fail ),
	arg(1,First,A1),
	check_arg_consist(A1,F1,First,Context,Term),	
	((Second = id('CDF Root',cdf) 
	    ; functor(Second,F2,2),isa_consist(F1,F2)) -> 
	    true
	  ; cdf_warning(Context,['Arguments in ',isa_ext(First,Second),
				' are not of proper type.']),
	    fail ),
	arg(1,Second,A2),
	check_arg_consist(A2,F2,Second,Context,Term).

isa_consist(F,F):-!.
isa_consist(oid,cid).

%------
:- comment(hide,check_ind_types/2).

check_ind_types(Context,Term,List):- 
	Term =.. [_|R],
	check_ind_types_1(R,List,Context,Term).

check_ind_types_1([],[],_,_).
check_ind_types_1([Id|T],[List|LT],Context,Term):- 
	(var(Id) -> 
	    true
	  ; 
	    (functor(Id,F,2),memberchk(F,List) -> 
	        arg(1,Id,A),
	        check_arg_consist(A,F,Id,Context,Term)
    	      ; cdf_warning(Context,
			    [Id,' in ',Term,' is not of proper type.']),
	        fail ) ),
	check_ind_types_1(T,LT,Context,Term).

check_arg_consist(Nid,F,Id,Context,Term):- 
	(structure(Nid) -> 
	    Nid =.. [_Funct|L],
	    check_arg_consist_list(L,F,Id,Context,Term) 
	  ; true).

check_arg_consist_list([],_F,_Id,_Context,_Term). 
check_arg_consist_list([Nid|T],F,Id,Context,Term):- 
	(var(Nid) -> 
	    true
	  ; 
	    (functor(Nid,F,2) -> 
	        arg(1,Nid,A),
		check_arg_consist(A,F,Id,Context,Term)
	      ; cdf_warning(Context,[Id,' in ',Term,' is ill-formed.']),
		fail ) ),
	  check_arg_consist_list(T,F,Id,Context,Term).
	
type_table(isa(A,B),check_isa_types(_,isa(A,B))).
type_table(isa_ext(A,B),check_isa_types(_,isa_ext(A,B))).
type_table(isa_int(A,B),check_isa_types(_,isa_int(A,B))).

type_table(hasAttr(A,B,C),check_ind_types(_,hasAttr(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(hasAttr_ext(A,B,C),check_ind_types(_,hasAttr_ext(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(hasAttr_int(A,B,C),check_ind_types(_,hasAttr_int(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).

type_table(allAttr(A,B,C),check_ind_types(_,allAttr(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(allAttr_ext(A,B,C),check_ind_types(_,allAttr_ext(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(allAttr_int(A,B,C),check_ind_types(_,allAttr_int(A,B,C),
				[ [cid,oid], [rid], [cid,oid] ] ) ).
type_table(classHasAttr(A,B,C),check_ind_types(_,classHasAttr(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).
type_table(classHasAttr_ext(A,B,C),check_ind_types(_,classHasAttr_ext(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).
type_table(classHasAttr_int(A,B,C),check_ind_types(_,classHasAttr(A,B,C),
			[ [cid,rid,crid], [crid,crrid,crcrid], [cid,oid] ] ) ).

% want to change so that it checks for implication also.
check_implication(update,Term):- 
	(call(Term) -> fail ; true).

%----------------------------------------------------------------------
