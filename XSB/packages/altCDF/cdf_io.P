:- export load_extensional_facts/1, 
	dump_extensional_facts/1, 
	load_intensional_rules/1,
	merge_intensional_rules/0,
	retract_intensional_rules/1,
	cdf_exists/1.

%:- import (:-)/2 from usermod.

:- import isa_ext/2, hasAttr_ext/3, classHasAttr_ext/3, allAttr_ext/3,
	ic_ext/1, minAttr_ext/4, maxAttr_ext/4
		 from usermod.

:- import isa_int/2, hasAttr_int/3, classHasAttr_int/3, allAttr_int/3,
	  ic_int/1, minAttr_int/4, maxAttr_int/4
		 from usermod.

:- import component_table_int/3 from usermod.

:- import newExtTerm/2 from cdf_init_cdf.

:- import cdf_error/2 from cdf_exceptions.

:- import cdf_fix_dir/2 from cdf_utilities.

:- import member/2,reverse/2 from basics.
:- import concat_atom/2 from string.
%:- import load_dync/2 from consult.
:- import path_sysop/2 from file_io.
:- import slash/1 from machine.

:- comment(module, "These routines load CDF files from a disk file
system into memory, save them from memory to disk, and merge
information into a CDF state.  Both intensional an extensional
information may be dumped.  They are also used as building blocks of
the components system.").

%-----------------------------------------------------------------
	
:- comment(dump_extensional_facts/1,"@tt{dump_extensional_facts(Dir)}
writes extensional facts to the file @tt{cdf_extensional.P} in
@tt{Directory}.  No intensional rules are dumped by this predicate.

@pred{dump_extensional_facts/0} writes the @tt{cdf_extensional.P} file
to the current directory.
").

dump_extensional_facts(Dir) :-
	throw_cdf_writable(Dir),
	dump_extensional_facts_1(Dir).

dump_extensional_facts_1(Dir) :-
	cdf_fix_dir(Dir,DirS),
  	concat_atom([DirS,'cdf_extensional.P'],File),
	tell(File),
	dump_extensional_facts_2,
	told.

throw_cdf_writable(Dir):-
	((slash(Slash),concat_atom([Dir,Slash,'cdf_extensional.P'],SchemaPath),
	  file_exists(SchemaPath), path_sysop(writable, SchemaPath)) -> 
	    true
	 ; path_sysop(writable, Dir)
	 ->	true
	 ;	cdf_error(permissions,['Directory is not writable: ',Dir])).

sort_and_write_terms(Terms) :-
	sort(Terms,STerms),
	member(Term,STerms),
	write_canonical(Term),writeln('.'),
	fail.
sort_and_write_terms(_Terms).

cdf_ext_inst(Term):-
	(Term = allAttr_ext(_,_,_) ; 
	 Term = classHasAttr_ext(_,_,_) ; Term = hasAttr_ext(_,_,_) ; 
	 Term = ic_ext(_) ; Term = isa_ext(_,_) ; 
	 Term = minAttr_ext(_,_,_,_) ; Term = maxAttr_ext(_,_,_,_) ).

dump_extensional_facts_2:- 
	cdf_ext_inst(Term),
	findall(Term,Term,Set),
	sort_and_write_terms(Set),
	fail.
dump_extensional_facts_2.
%-----------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(load_extensional_facts/1,
"@tt{load_extensional_facts(DirectoryList)}: loads the file
@tt{cdf_extensional.P} from directories in @tt{DirectoryList}.  The
files loaded must contain extensional data.
@pred{load_extensional_facts/1} does not abolish any extsnsional
information already in memory; rather, it merges the information from
the various files with that already loaded.  Intensional rules will
not be affected by this predicate.  ").

load_extensional_facts([]) :- !.
load_extensional_facts([Dir|DirList]) :-
	!,
	load_extensional_facts(Dir),
	load_extensional_facts(DirList).
load_extensional_facts(Dir) :-
	cdf_fix_dir(Dir,DirS),
	write('Loading '),writeln(Dir),
	reload_extensional(DirS).

reload_extensional(Dir):- 
	concat_atom([Dir,'cdf_extensional.P'],File),
	see(File),
	reload_extensional,
	seen.

reload_extensional :-
	repeat,
	read_canonical(Term),
	(Term == end_of_file
	 ->	!
	 ; Term = :-(_)
	 ->	fail
	 ; 	newExtTerm(newExtTermBatch,Term),
	  	fail).

%-------------------------------------------------------------- 

:- comment(merge_intensional_rules/0, "@tt{merge_intensional_rules/0}:
This utility predicate takes the current intensional rules for all
sources and transforms them to extensional form by backtracking
through them, and asserting them to the Prolog store.  All intensional
information is then retracted.").

/* TLS: question: should this do an assert or a newExtTerm? */
merge_intensional_rules :-
	 allAttr_int(SCid,RCid,TCid), \+allAttr_ext(SCid,RCid,TCid),
	 asserta(allAttr_ext(SCid,RCid,TCid)),
	 fail
	 ;
	 retractall(allAttr_int(_,_,_)),

	 classHasAttr_int(SCid,RCid,TCid), \+classHasAttr_ext(SCid,RCid,TCid),
	 asserta(classHasAttr_ext(SCid,RCid,TCid)),
	 fail
	 ;
	 retractall(classHasAttr_int(_,_,_)),

	 hasAttr_int(SCid,RCid,TCid),  \+hasAttr_ext(SCid,RCid,TCid),
	 asserta(hasAttr_ext(SCid,RCid,TCid)),
	 fail
	 ;
	 retractall(hasAttr_int(_,_,_)),

	 ic_int(Form),\+ ic_ext(Form),
	 asserta(ic_ext(Form)),
	 fail
	 ;
	 retractall(ic_int(_)),

	 isa_int(CCid,PCid),\+ isa_ext(CCid,PCid),
	 asserta(isa_ext(CCid,PCid)),
	 fail
	 ;
	 retractall(isa_int(_,_)),

	 minAttr_int(SCid,RCid,TCid,N),  \+minAttr_ext(SCid,RCid,TCid,N),
	 asserta(minAttr_ext(SCid,RCid,TCid,N)),
	 fail
	 ;
	 retractall(minAttr_int(_,_,_,_)),

	 maxAttr_int(SCid,RCid,TCid,N),  \+maxAttr_ext(SCid,RCid,TCid,N),
	 asserta(maxAttr_ext(SCid,RCid,TCid,N)),
	 fail
	 ;
	 retractall(maxAttr_int(_,_,_,_)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(load_intensional_rules/1," @tt{load_intensional_rules(Dir)}
ynamically loads intensional rules from @tt{cdf_intensional.P} in
@tt{Directory}.  This predicate is designed for the component system,
but can be used outside of it.  The leaf directory name in @tt{Dir} is
assumed to be the component name of the rules.  As the intensional
rules are loaded, their functors are rewritten from @tt{XXX_int} to
@tt{XXX_int_Name}, to avoid any conflicts with intensional rules
loaded from other components or directories.").

load_intensional_rules(Dir):- 
	extract_file_name(Dir,Name),
	load_intensional_rules(Dir,Name).	

extract_file_name(File,Name):- 
	atom_chars(File,Flist),
	reverse(Flist,Rlist),
	strip_extension(Rlist,Rl1),
	read_till_slash(Rl1,Rn2),
	reverse(Rn2,Nl),
	atom_chars(Name,Nl).

strip_extension(Rlist,Rl1):- 
	(member('.',Rlist) -> 
	    strip_extension_1(Rlist,Rl1) 
	  ; Rl1 = Rlist).

strip_extension_1(['.'|T],T):- !.
strip_extension_1([_|T],Tnew):- 
	strip_extension_1(T,Tnew).

read_till_slash(L,L1):- 
	slash(S),
	(member(S,L) -> 	
	    read_till_slash_1(L,L1,S)
	  ; L = L1).

read_till_slash_1([S|_R],[],S):- !.
read_till_slash_1([H|R],[H|R1],S):- 
	read_till_slash_1(R,R1,S).

load_intensional_rules(Path,Name):- 
	retract_intensional_rules(Name),
	concat_atom([Path,'/cdf_intensional.P'],File),
	(file_exists(File) -> 
   	    see(File),
	    read_intensional_rules_1(Name),
	    seen
	  ; cdf_error(update,['File does not exist or is unreadable:'
					,File]) ).

retract_intensional_rules(Name):- 
	component_table_int(Head,_,_),
	Head =.. [F|T],
	concat_atom([F,'_',Name],NewF),
	NewHead =.. [NewF|T],
	retractall(NewHead),
	retract((:-(Head,NewHead))),
	fail.
retract_intensional_rules(_).

read_intensional_rules_1(Name):- 
	repeat,
	read(T),
	(T = end_of_file -> 
	   true
	 ; T = (:-(Query))
	 ->	call(Query),
		fail
	 ; T = (:-(Head,Body))
	 ->	transform_intensional_rules(Head,NewHead,Name),
		asserta((:-(Head,NewHead))),
		asserta((:-(NewHead,Body))),
		fail
	 ;	transform_intensional_rules(T,NewHead,Name),
		asserta((:-(T,NewHead))),
		asserta(NewHead),
		fail
	),
	!.

transform_intensional_rules(Head,NewHead,Name):- 
	component_table_int(Head,_,_),
	Head =.. [F|T],
	concat_atom([F,'_',Name],NewF),
	NewHead =.. [NewF|T].

:- comment(cdf_exists/1, "@tt{cdf_exists(Dir)} checks whether
@tt{cdf_extensional.P} file is present in directory @tt{Dir}").

cdf_exists(Dir):-
	concat_atom([Dir,'/cdf_extensional.P'],SchemaFile),
	file_exists(SchemaFile).

end_of_file.

check_intensional_head(Head,Name):- 
	(component_table_int(Head,_,_) -> 
	    true
	  ; cdf_warning(component,[Head,
			' is not an intensional rule in component ',Name])).




