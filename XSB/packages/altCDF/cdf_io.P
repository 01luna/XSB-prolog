:- compiler_options([xpp_on]).

#include "standard.h"

:- import message/1, messageln/2 from standard.

messageln(Message) :- messageln(Message, STDMSG).

:- export load_extensional_facts/1, 
	dump_extensional_facts/1, 
	load_intensional_rules/1,
	merge_intensional_rules/0,
	retract_intensional_rules/1,
	cdf_exists/1.

:- import allAttr_ext/3, isa_ext/2, hasAttr_ext/3, classHasAttr_ext/3, 
	minAttr_ext/4, maxAttr_ext/4,
	necessCond_ext/2, coversAttr_ext/3 
		 from usermod.

:- import isa_int/2, allAttr_int/3, hasAttr_int/3, classHasAttr_int/3, 
	  minAttr_int/4, maxAttr_int/4,
	  necessCond_int/2, coversAttr_int/3
		 from usermod.

:- import component_table_int/3 from usermod.

:- import newExtTerm/2 from cdf_init_cdf.

:- import dlrule_to_cdf/2 from cdftp_rules.

:- import cdf_warning/2 from cdf_exceptions.

:- import cdf_fix_dir/2 from cdf_utilities.

:- import existence_error/4, permission_error/4 from error_handler.
:- import member/2,reverse/2 from basics.
:- import concat_atom/2 from string.
%:- import load_dync/2 from consult.
:- import path_sysop/2 from file_io.
:- import slash/1 from machine.

:- comment(module, "These routines load CDF files from a disk file
system into memory, save them from memory to disk, and merge
information into a CDF state.  Both intensional and extensional
information may be dumped.  They are also used as building blocks of
the components system.").

%-----------------------------------------------------------------
	
:- comment(dump_extensional_facts/1,"@tt{dump_extensional_facts(Dir)}
writes extensional facts to the file @tt{cdf_extensional.P} in
@tt{Directory}.  No intensional rules are dumped by this predicate.

@pred{dump_extensional_facts/0} writes the @tt{cdf_extensional.P} file
to the current directory.
").

dump_extensional_facts(Dir) :-
	throw_cdf_writable(Dir),
	dump_extensional_facts_1(Dir).

dump_extensional_facts_1(Dir) :-
	cdf_fix_dir(Dir,DirS),
  	concat_atom([DirS,'cdf_extensional.P'],File),
	tell(File),
	dump_extensional_facts_2,
	told.

throw_cdf_writable(Dir):-
	((slash(Slash),concat_atom([Dir,Slash,'cdf_extensional.P'],SchemaPath),
	  file_exists(SchemaPath), path_sysop(writable, SchemaPath)) -> 
	    true
	 ; path_sysop(writable, Dir)
	 ->	true
	 ;	permission_error(write,directory,Dir,'throw_cdf_writeable/1') ).

	 
sort_and_write_terms(Terms) :-
	sort(Terms,STerms),
	member(Term,STerms),
	write_canonical(Term),writeln('.'),
	fail.
sort_and_write_terms(_Terms).

cdf_ext_inst(Term):-
	(Term = isa_ext(_,_) ; Term = allAttr_ext(_,_,_) ; 
	 Term = classHasAttr_ext(_,_,_) ; Term = hasAttr_ext(_,_,_) ; 
             Term = necessCond_ext(_,_) ; coversAttr_ext(_,_,_) ; 
	 Term = minAttr_ext(_,_,_,_) ; Term = maxAttr_ext(_,_,_,_) ).

dump_extensional_facts_2:- 
	cdf_ext_inst(Term),
	findall(Term,Term,Set),
	sort_and_write_terms(Set),
	fail.
dump_extensional_facts_2.
%-----------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(load_extensional_facts/1,
"@tt{load_extensional_facts(DirectoryList)}: loads the file
@tt{cdf_extensional.P} from directories in @tt{DirectoryList}.  The
files loaded must contain extensional data.
@pred{load_extensional_facts/1} does not abolish any extsnsional
information already in memory; rather, it merges the information from
the various files with that already loaded.  Intensional rules will
not be affected by this predicate.  ").

load_extensional_facts([]) :- !.
load_extensional_facts([Dir|DirList]) :-
	!,
	load_extensional_facts(Dir),
	load_extensional_facts(DirList).
load_extensional_facts(Dir) :-
	cdf_fix_dir(Dir,DirS),
% TLS: use message here for testscript.
	message('Loading '),messageln(Dir,STDMSG),
	reload_extensional(DirS).

reload_extensional(Dir):- 
	concat_atom([Dir,'cdf_extensional.P'],File),
	see(File),
	reload_extensional,
	seen.

reload_extensional :-
	repeat,
	read_canonical(Term),
%	writeln(Term),
	(Term == end_of_file
	 ->	!
	 ; Term = :-(_)
	 ->	fail
	 ; 	newExtTerm(newExtTermBatch,Term),
	  	fail).

%-------------------------------------------------------------- 

:- comment(merge_intensional_rules/0, "@tt{merge_intensional_rules/0}:
This utility predicate takes the current intensional rules for all
sources and transforms them to extensional form by backtracking
through them, and asserting them to the Prolog store.  All intensional
information is then retracted.").

/* TLS: question: should this do an assert or a newExtTerm? */
merge_intensional_rules :-
	 isa_int(CCid,PCid),\+ isa_ext(CCid,PCid),
	 asserta(isa_ext(CCid,PCid)),
	 fail
	 ;
	 retractall(isa_int(_,_)),

	 allAttr_int(SCid,RCid,TCid), \+allAttr_ext(SCid,RCid,TCid),
	 asserta(allAttr_ext(SCid,RCid,TCid)),
	 fail
	 ;
	 retractall(allAttr_int(_,_,_)),

	 classHasAttr_int(SCid,RCid,TCid), \+classHasAttr_ext(SCid,RCid,TCid),
	 asserta(classHasAttr_ext(SCid,RCid,TCid)),
	 fail
	 ;
	 retractall(classHasAttr_int(_,_,_)),

	 hasAttr_int(SCid,RCid,TCid),  \+hasAttr_ext(SCid,RCid,TCid),
	 asserta(hasAttr_ext(SCid,RCid,TCid)),
	 fail
	 ;
	 retractall(hasAttr_int(_,_,_)),

	 necessCond_int(Class,Form),\+ necessCond_ext(Class,Form),
	 asserta(necessCond_ext(Class,Form)),
	 fail
	 ;
	 retractall(necessCond_int(_,_)),

	 coversAttr_int(SCid,RCid,TCid),  \+coversAttr_ext(SCid,RCid,TCid),
	 asserta(coversAttr_ext(SCid,RCid,TCid)),
	 fail
	 ;
	 retractall(coversAttr_int(_,_,_)),

	 minAttr_int(SCid,RCid,TCid,N),  \+minAttr_ext(SCid,RCid,TCid,N),
	 asserta(minAttr_ext(SCid,RCid,TCid,N)),
	 fail
	 ;
	 retractall(minAttr_int(_,_,_,_)),

	 maxAttr_int(SCid,RCid,TCid,N),  \+maxAttr_ext(SCid,RCid,TCid,N),
	 asserta(maxAttr_ext(SCid,RCid,TCid,N)),
	 fail
	 ;
	 retractall(maxAttr_int(_,_,_,_)).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- comment(load_intensional_rules/1," @tt{load_intensional_rules(Dir)}
ynamically loads intensional rules from @tt{cdf_intensional.P} in
@tt{Directory}.  This predicate is designed for the component system,
but can be used outside of it.  The leaf directory name in @tt{Dir} is
assumed to be the component name of the rules.  As the intensional
rules are loaded, their functors are rewritten from @tt{XXX_int} to
@tt{XXX_int_Name}, to avoid any conflicts with intensional rules
loaded from other components or directories.").

load_intensional_rules(Dir):- 
	extract_file_name(Dir,Name),
	load_intensional_rules(Dir,Name).	

% TLS: at some point should use utility instead.
extract_file_name(File,Name):- 
	atom_chars(File,Flist),
	reverse(Flist,Rlist),
	strip_extension(Rlist,Rl1),
	read_till_slash(Rl1,Rn2),
	reverse(Rn2,Nl),
	atom_chars(Name,Nl).

strip_extension(Rlist,Rl1):- 
	(member('.',Rlist) -> 
	    strip_extension_1(Rlist,Rl1) 
	  ; Rl1 = Rlist).

strip_extension_1(['.'|T],T):- !.
strip_extension_1([_|T],Tnew):- 
	strip_extension_1(T,Tnew).

read_till_slash(L,L1):- 
	slash(S),
	(member(S,L) -> 	
	    read_till_slash_1(L,L1,S)
	  ; L = L1).

read_till_slash_1([S|_R],[],S):- !.
read_till_slash_1([H|R],[H|R1],S):- 
	read_till_slash_1(R,R1,S).

%TLS: dont know if permission error is right here.	   :	
load_intensional_rules(Path,Name):- 
	retract_intensional_rules(Name),
	concat_atom([Path,'/cdf_intensional.P'],File),
	(file_exists(File) -> 
   	    see(File),
	    read_intensional_rules_1(Name),
	    seen
	  ; existence_error(file,File,'load_intensional_rules/2',2) ).

retract_intensional_rules(Name):- 
	component_table_int(Head,_,_),
	Head =.. [F|T],
	concat_atom([F,'_',Name],NewF),
	NewHead =.. [NewF|T],
	retractall(NewHead),
	retract((:-(Head,NewHead))),
	fail.
retract_intensional_rules(_).

read_intensional_rules_1(Name):- 
	repeat,
	read(T),
%	(T = (H :- B) -> write(true) ; write(false)),
%	(T = (H <= B) -> write(true) ; write(false)),
	read_intensional_rules_2(T,Name),
	!.

read_intensional_rules_2(end_of_file,_Name).
read_intensional_rules_2('<='(Head,Body),Name):- !,
	dlrule_to_cdf('<='(Head,Body),CDFList),
	member((:-(H,B)),CDFList),
	transform_intensional_rules(H,BlankBody,NewHead,Name),
%	transform_intensional_rules(H,NewHead,Name),
	functor(H,T,A),
	functor(BlankHead,T,A),
	BlankHead =.. [_|Args],
	BlankBody =.. [_|Args],
	clause_assert(BlankHead,BlankBody),
	assert((:-(NewHead,B))),
	fail.
% these should be executable directives ala table.
read_intensional_rules_2((:-(Query)),_Name):- !,
	call(Query),
	fail.
read_intensional_rules_2((Head :- Body),Name):- !,
	transform_intensional_rules(Head,BlankBody,NewHead,Name),
	functor(Head,T,A),
	functor(BlankHead,T,A),
	BlankHead =.. [_|Args],
	BlankBody =.. [_|Args],
	clause_assert(BlankHead,BlankBody),
	assert((:-(NewHead,Body))),
	fail.
%read_intensional_rules_2(auxiliary_cdf_rule(Head,Body),Name):- !,
%	auxiliary_cdf_rule(Name,Head,Body):- !,
%	asserta((:-(Head,Body))),
%	fail.
read_intensional_rules_2(Head,Name):- 
	transform_intensional_rules(Head,BlankBody,NewHead,Name),
%	transform_intensional_rules(T,NewHead,Name),
	functor(Head,T,A),
	functor(BlankHead,T,A),
	BlankHead =.. [_|Args],
	BlankBody =.. [_|Args],
	clause_assert(BlankHead,BlankBody),
	assert(NewHead),
	fail.

clause_assert(Head,Body):- 
	(clause(Head,Body) -> true ; asserta((:-(Head,Body)))).

% hasAttr_int(_,_,_) , hasAttr_int_Name(_,_,_)  ; hasAttr_int_name(<Orig stuff>) 
transform_intensional_rules(Head,BlankHead,NewHead,Name):- 
	component_table_int(Head,_,_),
	Head =.. [F|T],
	functor(Head,F,N),
	concat_atom([F,'_',Name],NewF),
	NewHead =.. [NewF|T],
	functor(BlankHead,NewF,N),
	!.
transform_intensional_rules(Head,_BlankHead,_NewHead,Name):- 
	cdf_warning(rule_load,['Cannot intern intensional rule with head ',
	                                  Head,' for directory ',Name]),
	fail.

:- comment(cdf_exists/1, "@tt{cdf_exists(Dir)} checks whether
@tt{cdf_extensional.P} file is present in directory @tt{Dir}").

cdf_exists(Dir):-
	concat_atom([Dir,'/cdf_extensional.P'],SchemaFile),
	file_exists(SchemaFile).

end_of_file.

check_intensional_head(Head,Name):- 
	(component_table_int(Head,_,_) -> 
	    true
	  ; cdf_warning(component,[Head,
			' is not an intensional rule in component ',Name])).




