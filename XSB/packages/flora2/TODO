1. Make :- table imply :- firstorder.
   Do variable analysis in delete{...}/insert{...}
   to avoid errors like in demo/aggregate.flr
   Move the decision about how to compile @prolog(module) from the compiler
   to the coder. Make the compilation different depending on whether it is
   in the shell or in the batch.


2. Implement undefined predicate/method handling infrastructure.

   a. Take the intermediate repesentation of the program from the compiler.

   b. Compute the skeletons for rule heads (including facts).
      A skeleton represents a generalization of the terms in the rule heads.
      For instance, for
	  p(X)(a,Z)(b,D) :- ...
      the skeleton is 
          flapply(flapply(flapply(p,_),_,_) _, _)
      for 
          Z(X)(c,Z)(c,D) :- ...
      it is 
          flapply(flapply(flapply(_,_),_,_) _, _)
      For F-logic molecules, say,

	T[Z(X)(c,Z)(c,D) -> ...] :- ...
	Q[p(X)(a,Z)(b,D) ->> ...] :- ...

      you put into the trie the following skeletons:

	fd(_, flapply(flapply(flapply(_,_),_,_) _, _), _)
	mvd(_, flapply(flapply(flapply(p,_),_,_) _, _), _)

   c. Remove duplicates from Step (b).

   d. For each skeleton, generate a rule like:
      For each skeleton, generate a query
      ?- storage_insert_fact(storagename,Skeleton).

      Skeleton :-
	       ( storage_check_fact(storagename,Skeleton) ->
	       fail
	       ;
	       print error message (undefined predicate...),
	       abort
	       )
      This rule should be represented in the intermediate format
      and submited to the coder.

      The idea behind this rule is that if the storage area doesn't have an
      appropriate skeleton, it means that the call doesn't have a 
      rule that can possibly match it. It is a generalization of the idea
      of undefined predicates in Prolog.

   e. Need to dump the rules from Step (c) into a separate file, F.
      Name of storage should be local to the module name.

      The above file F is to be generated and/or included  ONLY if the
	  :- debug 
      directive appears in the file.
      This is because such error checking is potentially expensive to do in
      "production" runs.

      This file (F) should be included before the rules of the
      program, if the debug option is on.
      Before loading this file, need to expunge whatever is
      in the storage. (Use storage_delete_all.)
      We can probably simply add the query 
	  ?- storage_delete_all(WORKSPACE)
      at the top of the file F.



3. Implement the debugger.

4. Encapsulation.

   GENERAL IDEA: 
       When referring to Flora predicates in another module, e.g., 
	   p(X)@foo
       translate as:
           ...,p'foo'exported(X)
       In module foo, p/1 must be declared as
           :- export p/1.

       Which would insert the rule

           p'foo'exported(X) :- p'foo(X).

       Same for methods.
       Should have something like:
           :- export method123/5 ->. (for all kinds of arrows)
	   :- export :.  (for membership)
	   :- export ::. (for subclass)

       For hilog predicates:
          p(a,Y)(X)@foo
       means:
          ...,flapply'foo'export(flapply(p,a,Y),X)
       and in foo we should have:

          :- export p(_,_)/1.

       which adds the fact
          foo'exported'hilog'registry(flapply(p,_,_)).
			              ^^^^^^^^^^ - hilog translation of p(_,_).
       There also will be a rule:
          flapply'foo'exported(HiLogPred,Arg) :-
			foo'exported'hilog'registry(HiLogPred),
			flapply'foo(HiLogPred,Arg).
    ISSUES:
       - What about meta programming?
         ..., X(...)@foo, ...
	 Here X shouldn't range over hilog predicates that aren't exported.
	 Likewise,
	 ..., a[ X(...) -> ...]@foo, ...
	 should not bind X to non-exported methods.
	 Probably the same HiLog's trick with registry will work.

      - What about asserting?
        ..., insert{p(a)@foo}, ...

	What if p/1 is not exported in foo?
	One solution: in debug mode insert should check the registry of
	exported things in the module foo.

    More fine-grained encapsulation based on the ideas from annotated logic.
       

5. Asserting Flora rules.

   Proposal:
      - Allow assertion only into modules that are declared as 
        :- dynamicmodule
	(in the file loaded into that module).

      - The dynamicmodule directive should tell the compiler that only
	directives are allowed in that paticular file.

      - The rules connecting the storage tries (the patch rules)
        of the form

	  p(X) :- storage_find_fact(p(X),_).

	for firstorder predicates, hilog and F-logic wrappers must be
	asserted into the dynamic modules (but the trailer can be compiled
	and appended).

	For the Flora rules we don't need to change the translation much.
	We assert
	   derived_fd'foo(X,Y,Z) :- ....
	We should also add to the trailer (of the dynamic modules) the 
	appropriate declarations of the form
	   :- dynamic derived_fd'foo/3.
	   .....
	Since these predicates occur only in the rule bodies in the
	trailer, we are safe from clashes with static predicates.

	To enable the current parser parse the rules inside
	insert{...} correctly, we have to give the following argument
	definition for ':-'

	:- arguments ':-'(hform,bform).

	where "bform" is the existing argument type and "hform" needs to be
	added. The effect of "hform" is to force the compiler to compile
	the head of the rule as a list of formulas rather than an oid term.

6. Metaprogramming

     - Need to implement the @foreign module123 wrapper which should tell
       the coder to wrap F-molecule into one call:

         ..., (p(X), a[(m->Y, k->P); l->>123])@foreign(foo),...

       should be wrapped as
         foo'foreign(and(p(X),
		         or(and(fd'foo(a,m,Y), fd'foo(a,k,P)),
			    mvd'foo(a,l,123))))

    - Need to implement the Flora analog of =.., which should work with
      different types of atomic formulas. Call it ..=.. for now (find a
      better name later). Format:

	     Atom ..=.. [Type, Module, Functor, Arity | Args]

      where Type: hlgpred, hlgterm, plgterm, flpred, ->, =>, ->>, etc.
            Module: the module of the predicate or method.
		    For hilog terms and prolog terms the module is '' (or a
		    var?).
	    Functor: the name of the predicate, functor, or method.

   Note: foreign(foo) should not be distributive or nested, unlike @module,
	 @flora(...) and @ prolog(...). Any nesting of foreign inside
	 foreign should be an error.

7. Implement asserting the storage-linking rules (the patch rules) in the
   Flora shell, so that we'll be able to use insert/delete for firstorder
   predicates in the shell.

   The way to do this is to keep track of all firstorder predicates in the
   shell.

   a. assert register_firstorder(functor/arity) into usermod.
   
   b. Check to see if functor/arity is already in main module
      (using current_predicate/1). If yes, do nothing. Otherwise,
      assert the rule:
	  functor(X,Y,...) :-
      storage_find_fact(main_module,functor(X,Y,...)).

   c. When a file is loaded into the module main, for each
      functor/arity in register_firstorder/1, do
      retractall(functor(X,Y,...)).

8. Implement  patch rules for firstorderall.
   Firstorderall is already implemented. We only need to add the patch
   rules.

   a. Take the intermediate results from the compiler.

   b. Collect all predicates in rule head and body in the form
      of functor/arity.

   c. Remove duplicates from Step b. Need to generate an error message
      if functor is not an atom.

   d. For each functor/arity, generate a rule like:
      functor(X,Y,...) :- storage_find_fact(current_module,functor(X,Y,...)).
      This rule should be represented in the intermediate format
      and submit to the coder.

   e. Need to dump the rules from Step d into the same file where
      program code is generated.

   There is another issue here when it comes to metaprogramming.
   When we do something like
	X ..=.. [flpred,mod,foo,5, ...]
   a patch rule for foo'mod/5 must be asserted, if it isn't already
   there.

9. If then else
    Right now if/then/else are defined in flroperator.P and syslib/flrcontrol.P
    However, the defs don't parse correctly some nested if-then-else
    expressions, such as if a then if b then c else f else g.
    Need to change the parser so that once it obtains the term constructed
    by the operators if/then/else, it would rearrange it to fix the
    associativity.

10. Add the contraints syntax {...}.


11. Implement convenient versions of I/O predicates and others, such as
    new_oid(X). This module should be automatically loaded into the module
    "flora". Maybe we should prevent users from loading lodules into
    the "flora" module.

12. Add the symbol _@, which will be handled by the tokenizer and passed
    along to the compiler so it would insert code to replace _@ with the
    preprocessor constant FLORA_MODULE.
    When compiling, the macro definition
    #define FLORA_MODULE  .....
    would be dumped into the .P file

13. Do dependency checking in the compiler to determine if a tabled
    predicate or an F-molecule depends on an update predicate.

14. Do smart reordering of arithmetic operations in rule bodies to minimize
    the possibility of errors due to unbound variables.

15. Figure out some workaround for the tabled stuff that depends on
    dynamically asserted and deleted facts.

16. Instead of compiling, load .fdb facts into the trie associated with the
    corresponding module. This way the facts specified as
    p(a).
    f[m->b].
    etc. can be deleted from the database.
    We also need to make sure that the coder puts predicates (first-order
    and hilog) into .fdb.

17. Provide primitives
    :- firstorder foo/1 in modname.
    :- hilog moo/2 in modname.
    (For symmetry, let us also have :- hilog moo/2. without the module.
    All this is supposed to do is to check if there is a conflicting
    declaration.)

    This will direct the compiler to make the right translation for things like

    ..., foo(X)@modname,...
    ..., moo(X,Y)@modname,...

    Also, the coder must dump apropriate code to preserve these
    declarations in the .P file. The result would be that these
    declarations will be global to the Flora runtime environment.
    Each declaration will specify whether a particular predicate symbol is
    supposed to be first order or hilog in some particular module.
    When the shell runs, it would know how to translate predicate literals
    that are entered on command line.

    The global declarations should be something like:

    FLORA_PREFIX'decl(symbol,firstorder/hilog,ownermodule,consumercount)

    When a new module is loaded, we should check if there are conflicts.
    (A conflict can be complex and involve default definitions, etc.)
    We should decide if we will allow a module to redefine the
    declarations it owns when the module is reloaded. But if we do allow
    this, this can be done only if there are no consumers for the symbol.
    
18. Add a call(X) meta predicate.
    The main point right now is that

    :- p(X), X.     (*)

    won't work correctly because in Flora terms and atomic (predicate)
    formulas belong to different sorts (domains). For instance, module name
    isn't attached to the apply-wrapper for terms, but it is for predicate
    formulas.  So, f(a) in p(f(a)) is  represented as apply(f,a), while
    when it occurs in a module foo as a predicate:

    f(a).            (**)

    it is represented as apply'foo(a).
    So, the free X in (*) won't match (**).

    One solution could be to add the call/1 predicate.
    call(f(a)) would change the outermost wrapper and attach module name.
    Also, call(p) should convert to call(apply(p)), because Flora treats
    propositional constants like p as p().
