1. Make :- table imply :- firstorder.
   Do variable analysis in delete{...}/insert{...}
   to avoid errors like in demo/aggregate.flr
   Move the decision about how to compile @prolog(module) from the compiler
   to the coder. Make the compilation different depending on whether it is
   in the shell or in the batch.


2. Implement undefined predicate/method handling infrastructure.

   a. Take the intermediate repesentation of the program from the compiler.

   b. Compute the skeletons for rule heads (including facts).
      A skeleton represents a generalization of the terms in the rule heads.
      For instance, for
	  p(X)(a,Z)(b,D) :- ...
      the skeleton is 
          flapply(flapply(flapply(p,_),_,_) _, _)
      for 
          Z(X)(c,Z)(c,D) :- ...
      it is 
          flapply(flapply(flapply(_,_),_,_) _, _)
      For F-logic molecules, say,

	T[Z(X)(c,Z)(c,D) -> ...] :- ...
	Q[p(X)(a,Z)(b,D) ->> ...] :- ...

      you put into the trie the following skeletons:

	fd(_, flapply(flapply(flapply(_,_),_,_) _, _), _)
	mvd(_, flapply(flapply(flapply(p,_),_,_) _, _), _)

   c. Remove duplicates from Step (b).

   d. For each skeleton, generate a rule like:
      For each skeleton, generate a query
      ?- storage_insert_fact(storagename,Skeleton).

      Skeleton :-
	       ( storage_check_fact(storagename,Skeleton) ->
	       fail
	       ;
	       print error message (undefined predicate...),
	       abort
	       )
      This rule should be represented in the intermediate format
      and submited to the coder.

      The idea behind this rule is that if the storage area doesn't have an
      appropriate skeleton, it means that the call doesn't have a 
      rule that can possibly match it. It is a generalization of the idea
      of undefined predicates in Prolog.

   e. Need to dump the rules from Step (c) into a separate file, F.
      Name of storage should be local to the module name.

      The above file F is to be generated and/or included  ONLY if the
	  :- flDebug 
      directive appears in the file.
      This is because such error checking is potentially expensive to do in
      "production" runs.

      This file (F) should be included before the rules of the
      program, if the debug option is on.
      Before loading this file, need to expunge whatever is
      in the storage. (Use storage_delete_all.)
      We can probably simply add the query 
	  ?- storage_delete_all(WORKSPACE)
      at the top of the file F.



3. Implement the debugger.

4. Encapsulation.

   GENERAL IDEA: 
       When referring to Flora predicates in another module, e.g., 
	   p(X)@foo
       translate as:
           ...,p'foo'exported(X)
       In module foo, p/1 must be declared as
           :- flExport p/1.

       Which would insert the rule

           p'foo'exported(X) :- p'foo(X).

       Same for methods.
       Should have something like:
           :- flExport method123/5 ->. (for all kinds of arrows)
	   :- flExport :.  (for membership)
	   :- flExport ::. (for subclass)

       For hilog predicates:
          p(a,Y)(X)@foo
       means:
          ...,flapply'foo'export(flapply(p,a,Y),X)
       and in foo we should have:

          :- flExport p(_,_)/1.

       which adds the fact
          foo'exported'hilog'registry(flapply(p,_,_)).
			              ^^^^^^^^^^ - hilog translation of p(_,_).
       There also will be a rule:
          flapply'foo'exported(HiLogPred,Arg) :-
			foo'exported'hilog'registry(HiLogPred),
			flapply'foo(HiLogPred,Arg).
    ISSUES:
       - What about meta programming?
         ..., X(...)@foo, ...
	 Here X shouldn't range over hilog predicates that aren't exported.
	 Likewise,
	 ..., a[ X(...) -> ...]@foo, ...
	 should not bind X to non-exported methods.
	 Probably the same HiLog's trick with registry will work.

      - What about asserting?
        ..., insert{p(a)@foo}, ...

	What if p/1 is not exported in foo?
	One solution: in debug mode insert should check the registry of
	exported things in the module foo.

    RESEARCH ISSUE: 
	  Is there another, more fine-grained design for the module system?
       

5. Asserting Flora rules.

   Proposal:
      - Allow assertion only into modules that are declared as 
        :- flDynamicModule
	(in the file loaded into that module).

      - The flDynamicModule directive should tell the compiler that only
	directives are allowed in that paticular file.

      - The rules connecting the storage tries (the patch rules)
        of the form

	  p(X) :- storage_find_fact(p(X),_).

	for flPredicates, hilog and F-logic wrappers must be asserted into
	the dynamic modules (but the trailer can be compiledand appended).

	For the Flora rules we don't need to change the translation much.
	We assert
	   derived_fd'foo(X,Y,Z) :- ....
	We should also add to the trailer (of the dynamic modules) the 
	appropriate declarations of the form
	   :- dynamic derived_fd'foo/3.
	   .....
	Since these predicates occur only in the rule bodies in the
	trailer, we are safe from clashes with static predicates.

	To enable the current parser parse the rules inside
	insert{...} correctly, we have to give the following argument
	definition for ':-'

	:- arguments ':-'(hform,bform).

	where "bform" is the existing argument type and "hform" needs to be
	added. The effect of "hform" is to force the compiler to compile
	the head of the rule as a list of formulas rather than an oid term.

6. Metaprogramming

     - Need to implement the @foreign module123 wrapper which should tell
       the coder to wrap F-molecule into one call:

         ..., (p(X), a[(m->Y, k->P); l->>123])@foreign foo,...

       should be wrapped as
         foo'foreign(and(p(X),
		         or(and(fd'foo(a,m,Y), fd'foo(a,k,P)),
			    mvd'foo(a,l,123))))

    - Need to implement the Flora analog of =.., which should work with
      different types of atomic formulas. Call it ..=.. for now (find a
      better name later). Format:

	     Atom ..=.. [Type, Module, Functor, Arity | Args]

      where Type: hlgpred, hlgterm, plgterm, flpred, ->, =>, ->>, etc.
            Module: the module of the predicate or method.
		    For hilog terms and prolog terms the module is '' (or a
		    var?).
	    Functor: the name of the predicate, functor, or method.

7. Implement the :- flPredicateAll directive.
   Should go over the entire file and collect all predicates that aren't
   declared as flHiLog or flProlog. For each of these, encode them as Flora
   predicates and create the patch rules to connect them to the storage
   area.

   There is another issue here when it comes to metaprogramming.
   When we do something like
	X ..=.. [flpred,mod,foo,5, ...]
   a patch rule for foo'mod/5 must be asserted, if it isn't already
   there.

8. Implement asserting the storage-linking rules (the patch rules) in the
   Flora shell, so that we'll be able to use insert/delete for flPredicates
   in the shell.

   The way to do this is to keep track of all flpredicates in the shell.

   a. assert register_flPredicate(functor/arity) into usermod.
   
   b. Check to see if functor/arity is already in main module
      (using current_predicate/1). If yes, do nothing. Otherwise,
      assert the rule:
	  functor(X,Y,...) :-
      storage_find_fact(main_module,functor(X,Y,...)).

   c. When a file is loaded into the module main, for each
      functor/arity in register_flPredicate/1, do
      retractall(functor(X,Y,...)).

9. Implement flPredicateAll.

   a. Take the intermediate results from the compiler.

   b. Collect all predicates in rule head and body in the form
      of functor/arity.

   c. Remove duplicates from Step b. Need to generate an error message
      if functor is not an atom.

   d. For each functor/arity, generate a rule like:
      functor(X,Y,...) :- storage_find_fact(current_module,functor(X,Y,...)).
      This rule should be represented in the intermediate format
      and submit to the coder.

   e. Need to dump the rules from Step d into the same file where
      program code is generated.

10. If then else
    Right now if/then/else are defined in flroperator.P and syslib/flrcontrol.P
    However, the defs don't parse correctly some nested if-then-else
    expressions, such as if a then if b then c else f else g.
    Need to change the parser so that once it obtains the term constructed
    by the operators if/then/else, it would rearrange it to fix the
    associativity.

11. Add the contraints syntax {...}.


12. Implement convenient versions of I/O predicates and others, such as
    new_oid(X). This module should be automatically loaded into the module
    "flora". Maybe we should prevent users from loading lodules into
    the "flora" module.

13. Add the symbol _@, which will be handled by the tokenizer and passed
    along to the compiler so it would insert code to replace _@ with the
    preprocessor constant FLORA_MODULE.
    When compiling, the macro definition
    #define FLORA_MODULE  .....
    would be dumped into the .P file
