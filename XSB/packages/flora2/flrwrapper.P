/* File:      flrwrapper.P
**
** Author(s): Guizhen Yang 
**
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) The Research Foundation of SUNY, 1999-2001
**
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
** 
** 
*/


:- compiler_options([xpp_on]).

#include "flora_terms.flh"


/*****************************************************************************
  flora_user_module_predicate(+Functor,+Args,+Workspace,-Predicate)

  It takes a predicate name (either F-logic or HiLog wrapper predicate), args,
  and workspace and returns a Florified call (with workspace attached) to a
  Flora user module.
*****************************************************************************/
flora_user_module_predicate(Functor,Args,WS,Predicate) :-
	fmt_write_string(PF,"%s'%s'%s",args(FLORA_USER_MODULE_PREFIX,WS,Functor)),
	Predicate =.. [PF|Args].


/*****************************************************************************
  flora_system_module_predicate(+Functor,+Args,+SysModID,-Predicate)

  It takes a predicate name (either F-logic or HiLog wrapper predicate), args,
  and Flora system module ID and returns a Florified call (with workspace attached)
  to a Flora system module.
*****************************************************************************/
flora_system_module_predicate(Functor,Args,SysModID,Predicate) :-
	fmt_write_string(PF,"%s'%s'%s",
                         args(FLORA_SYSTEM_MODULE_PREFIX,SysModID,Functor)),
	Predicate =.. [PF|Args].


/*****************************************************************************
  flora_module_predicate(+Functor,+Args,+ModuleName,-Predicate)

  The parameter "ModuleName" could be either the name of a Flora user module,
  or a Flora system module. In the latter case, it would be a structured term.

  It fails if the input is not a valid Flora module name. It is used for
  either F-logic or HiLog wrapper predicates.
*****************************************************************************/
flora_module_predicate(Functor,Args,ModuleName,Predicate) :-
	flora_module_name(ModuleName,Type,WS),
	!,
	( Type == usermodule ->
	    flora_user_module_predicate(Functor,Args,WS,Predicate)

	; Type == systemmodule ->
	    flora_system_module_predicate(Functor,Args,WS,Predicate)
	;
	  fail
	).


/*****************************************************************************
  flora_firstorder_user_module_predicate(+Functor,+Args,+Workspace,-Predicate)
*****************************************************************************/
flora_firstorder_user_module_predicate(Functor,Args,WS,Predicate) :-
	fmt_write_string(PF,"%s'%s'%s",args(FLORA_FO_USER_MODULE_PREFIX,WS,Functor)),
	Predicate =.. [PF|Args].


/*****************************************************************************
  flora_firstorder_system_module_predicate(+Functor,+Args,+SysModID,-Predicate)
*****************************************************************************/
flora_firstorder_system_module_predicate(Functor,Args,SysModID,Predicate) :-
	fmt_write_string(PF,"%s'%s'%s",
                         args(FLORA_FO_SYSTEM_MODULE_PREFIX,SysModID,Functor)),
	Predicate =.. [PF|Args].


/*****************************************************************************
  flora_firstorder_module_predicate(+Functor,+Args,+ModuleName,-Predicate)
*****************************************************************************/
flora_firstorder_module_predicate(Functor,Args,ModuleName,Predicate) :-
	flora_module_name(ModuleName,Type,WS),
	!,
	( Type == usermodule ->
	    flora_firstorder_user_module_predicate(Functor,Args,WS,Predicate)

	; Type == systemmodule ->
	    flora_firstorder_system_module_predicate(Functor,Args,WS,Predicate)
	;
	  fail
	).


/*****************************************************************************
  These procedures construct a predicate symbol for a Flora user/system module.

  flora_user_module_predicate_symbol(+Functor,+Workspace,-Predicate)
  flora_system_module_predicate_symbol(+Functor,+Workspace,-Predicate)
  flora_module_predicate_symbol(+Functor,+ModuleName,-Predicate)
*****************************************************************************/
flora_user_module_predicate_symbol(Functor,WS,Predicate) :-
	flora_user_module_predicate(Functor,[],WS,Predicate).

flora_system_module_predicate_symbol(Functor,WS,Predicate) :-
	flora_system_module_predicate(Functor,[],WS,Predicate).

flora_module_predicate_symbol(Functor,ModuleName,Predicate) :-
	flora_module_predicate(Functor,[],ModuleName,Predicate).


/*****************************************************************************
  These procedures return the HiLog wrapper for a Flora user/system module.

  flora_hilog_user_module_predicate_symbol(+Workspace,-Predicate)
  flora_hilog_system_module_predicate_symbol(+Workspace,-Predicate)
  flora_hilog_module_predicate_symbol(+ModuleName,-Predicate)
*****************************************************************************/
flora_hilog_user_module_predicate_symbol(WS,Predicate) :-
	flora_user_module_predicate(WRAP_HILOG,[],WS,Predicate).

flora_hilog_system_module_predicate_symbol(WS,Predicate) :-
	flora_system_module_predicate(WRAP_HILOG,[],WS,Predicate).

flora_hilog_module_predicate_symbol(ModuleName,Predicate) :-
	flora_module_predicate(WRAP_HILOG,[],ModuleName,Predicate).


/*****************************************************************************
  These procedures construct a first order predicate symbol for a Flora
  user/system module.

  flora_firstorder_user_module_predicate_symbol(+Functor,+Workspace,-Predicate)
  flora_firstorder_system_module_predicate_symbol(+Functor,+Workspace,-Predicate)
  flora_firstorder_module_predicate_symbol(+Functor,+ModuleName,-Predicate)
*****************************************************************************/
flora_firstorder_user_module_predicate_symbol(Functor,WS,Predicate) :-
	flora_firstorder_user_module_predicate(Functor,[],WS,Predicate).

flora_firstorder_system_module_predicate_symbol(Functor,WS,Predicate) :-
	flora_firstorder_system_module_predicate(Functor,[],WS,Predicate).

flora_firstorder_module_predicate_symbol(Functor,ModuleName,Predicate) :-
	flora_firstorder_module_predicate(Functor,[],ModuleName,Predicate).


/*****************************************************************************
  flora_module_name(+ModuleName,-Type,-Workspace)

  The parameter "ModuleName" could be either the name of a Flora user module,
  or a Flora system module. In the latter case, it would be a structured term.

  "Type" is either "usermodule" or "systemmodule". "Workspace" is its name.
  If the input is not a valid Flora module name, "Type" is set to "invalid".
*****************************************************************************/
flora_module_name(ModuleName,usermodule,ModuleName) :-
	atom(ModuleName),
	!.

flora_module_name(FL_FLORALIB(WS),systemmodule,WS) :-
	atom(WS),
	!.

flora_module_name(_ModuleName,invalid,_WS).


/*****************************************************************************
  flora_check_module_name(+ModuleName)
*****************************************************************************/
flora_check_module_name(ModuleName) :-
	flora_module_name(ModuleName,Type,_WS),
	!,
	(Type == invalid -> flora_module_name_error(ModuleName), fail; true).


/*****************************************************************************
  flora_module_name_error(+ModuleName)
*****************************************************************************/
flora_module_name_error(ModuleName) :-
	flora_error_line("invalid Flora module name `%S'",args(ModuleName)).


/***************************************************************************
  flora_user_storage_name(+Workspace,-StorageName)
***************************************************************************/
flora_user_storage_name(WS,StorageName) :-
	fmt_write_string(StorageName,"%s'%s",args(FLORA_USER_TRIE_PREFIX,WS)).


/***************************************************************************
  flora_system_storage_name(+Workspace,-StorageName)
***************************************************************************/
flora_system_storage_name(WS,StorageName) :-
	fmt_write_string(StorageName,"%s'%s",args(FLORA_SYSTEM_TRIE_PREFIX,WS)).


/*****************************************************************************
  flora_storage_name(+ModuleName,-StorageName)

  It takes a Flora module name as input and returns the name of the storage
  trie for this module.

  The parameter "ModuleName" could be either the name of a Flora user module,
  or a Flora system module. In the latter case, it would be a structured term.

  If the input is not a valid Flora module name, it fails.
*****************************************************************************/
flora_storage_name(ModuleName,StorageName) :-
	flora_module_name(ModuleName,Type,WS),
	!,
	( Type == usermodule ->
	    flora_user_storage_name(WS,StorageName)

	; Type == systemmodule ->
	    flora_system_storage_name(WS,StorageName)
	;
	  fail
	).


/*****************************************************************************
  flora_setup_flogic_fact_wrapper(+ModuleName)

  It sets up the wrapper predicate names for F-logic facts in a module. It
  can be a Flora user module, or a Flora system module. This procedure is
  called by the DB erase/eraseall operation.

  Note: An F-logic wrapper predicate name is encoded as follows:
        'FLORA_(USER/SYSTEM)_MODULE_PREFIX''workspace''wrapper'.
*****************************************************************************/
flora_setup_flogic_fact_wrapper(ModuleName) :-
	flora_current_flogic_module(ModuleName),
	!.

flora_setup_flogic_fact_wrapper(ModuleName) :-
	retractall(flora_current_flogic_module(_)),
	assert(flora_current_flogic_module(ModuleName)),
	flora_module_name(ModuleName,Type,WS),
	( Type == systemmodule ->
	    Prefix=FLORA_SYSTEM_MODULE_PREFIX
	;
	  Prefix=FLORA_USER_MODULE_PREFIX
	),
	fmt_write_string(WSBisa,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_ISA)),
	fmt_write_string(WSBsub,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_SUB)),
	fmt_write_string(WSBmeth,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_METH)),
	fmt_write_string(WSBimeth,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_IMETH)),
	fmt_write_string(WSBtran,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_TRAN)),
	fmt_write_string(WSBfd,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_FD)),
	fmt_write_string(WSBifd,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_IFD)),
	fmt_write_string(WSBfdsig,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_FDSIG)),
	fmt_write_string(WSBifdsig,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_IFDSIG)),
	fmt_write_string(WSBmvd,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_MVD)),
	fmt_write_string(WSBimvd,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_IMVD)),
	fmt_write_string(WSBmvdsig,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_MVDSIG)),
	fmt_write_string(WSBimvdsig,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_IMVDSIG)),
	fmt_write_string(WSBexists,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_EXISTS)),
	fmt_write_string(WSBmvddef,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_MVDDEF)),
	fmt_write_string(WSBimvddef,"%s'%s'%s%s",args(Prefix,WS,FLBODYPREFIX,WRAP_IMVDDEF)),
	retractall(flora_flogic_fact_wrapper(_,_)),
	assert(flora_flogic_fact_wrapper(WRAP_ISA,WSBisa)),
	assert(flora_flogic_fact_wrapper(WRAP_SUB,WSBsub)),
	assert(flora_flogic_fact_wrapper(WRAP_METH,WSBmeth)),
	assert(flora_flogic_fact_wrapper(WRAP_IMETH,WSBimeth)),
	assert(flora_flogic_fact_wrapper(WRAP_TRAN,WSBtran)),
	assert(flora_flogic_fact_wrapper(WRAP_FD,WSBfd)),
	assert(flora_flogic_fact_wrapper(WRAP_IFD,WSBifd)),
	assert(flora_flogic_fact_wrapper(WRAP_FDSIG,WSBfdsig)),
	assert(flora_flogic_fact_wrapper(WRAP_IFDSIG,WSBifdsig)),
	assert(flora_flogic_fact_wrapper(WRAP_MVD,WSBmvd)),
	assert(flora_flogic_fact_wrapper(WRAP_IMVD,WSBimvd)),
	assert(flora_flogic_fact_wrapper(WRAP_MVDSIG,WSBmvdsig)),
	assert(flora_flogic_fact_wrapper(WRAP_IMVDSIG,WSBimvdsig)),
	assert(flora_flogic_fact_wrapper(WRAP_EXISTS,WSBexists)),
	assert(flora_flogic_fact_wrapper(WRAP_MVDDEF,WSBmvddef)),
	assert(flora_flogic_fact_wrapper(WRAP_IMVDDEF,WSBimvddef)).


/*****************************************************************************
  flora_decode_module_prefix(+Funct,-ModuleType,-Flora_module_prefix_len_plus1)

  It decodes a predicate symbol and checks if it begins with
  FLORA_PREFIX'FLORA_(USER/SYSTEM)_MODULE', which indicates it is a Flora
  F-logic or HiLog module predicate.

  "ModuleType" is either "usermodule" or "systemmodule".
*****************************************************************************/
flora_decode_module_prefix(Funct,ModuleType,Flora_module_prefix_len_plus1) :-
	%% Check if the functor begins with FLORA_PREFIX followed by an '.
	str_sub(FLORA_PREFIX'',Funct,1),
	%% Check if it is followed by the type code of Flora module plus an '.
	( str_sub(FLORA_USER_MODULE'',Funct,FLORA_PREFIX_LEN_PLUS2) ->
	    ModuleType=usermodule,
	    Flora_module_prefix_len_plus1=FLORA_USER_MODULE_PREFIX_LEN_PLUS1
	;
	  str_sub(FLORA_SYSTEM_MODULE'',Funct,FLORA_PREFIX_LEN_PLUS2),
	  ModuleType=systemmodule,
	  Flora_module_prefix_len_plus1=FLORA_SYSTEM_MODULE_PREFIX_LEN_PLUS1
	),
	!.


/*****************************************************************************
  flora_decode_firstorder_module_prefix(+Funct,-ModuleType,
                                        -Flora_module_prefix_len_plus1)

  It decodes a predicate symbol and checks if it begines with
  FLORA_FO_PREFIX'FLORA_(USER/SYSTEM)_MODULE', which indicates it is a Flora
  first order module predicate.

  "ModuleType" is either "usermodule" or "systemmodule".
*****************************************************************************/
flora_decode_firstorder_module_prefix(Funct,ModuleType,Flora_module_prefix_len_plus1) :-
	%% Check if the functor begins with FLORA_FO_PREFIX followed by an '.
	str_sub(FLORA_FO_PREFIX'',Funct,1),
	%% Check if it is followed by the type code of Flora module plus an '.
	( str_sub(FLORA_USER_MODULE'',Funct,FLORA_FO_PREFIX_LEN_PLUS2) ->
	    ModuleType=usermodule,
	    Flora_module_prefix_len_plus1=FLORA_FO_USER_MODULE_PREFIX_LEN_PLUS1
	;
	  str_sub(FLORA_SYSTEM_MODULE'',Funct,FLORA_FO_PREFIX_LEN_PLUS2),
	  ModuleType=systemmodule,
	  Flora_module_prefix_len_plus1=FLORA_FO_SYSTEM_MODULE_PREFIX_LEN_PLUS1
	),
	!.


/*****************************************************************************
  flora_decode_flogic_wrapper(+Wrapper,-WrapPrefix,-BaseSymbol)

  It decodes an F-logic wrapper predicate.
*****************************************************************************/
flora_decode_flogic_wrapper(Wrapper,WrapPrefix,BaseSymbol) :-
	( str_sub(FLFACTPREFIX,Wrapper,1) ->
	    WrapPrefix=FLFACTPREFIX,
	    substring(Wrapper,FLFACTPREFIX_LEN,_,BaseSymbol)

	; str_sub(FLHEADPREFIX,Wrapper,1) ->
	    WrapPrefix=FLHEADPREFIX,
	    substring(Wrapper,FLHEADPREFIX_LEN,_,BaseSymbol)

	; str_sub(FLBODYPREFIX,Wrapper,1) ->
	    WrapPrefix=FLBODYPREFIX,
	    substring(Wrapper,FLBODYPREFIX_LEN,_,BaseSymbol)

	; str_sub(FLTRAILERPREFIX,Wrapper,1) ->
	    WrapPrefix=FLTRAILERPREFIX,
	    substring(Wrapper,FLTRAILERPREFIX_LEN,_,BaseSymbol)
	),
	flora_is_flogic_base(BaseSymbol),
	!.


/*****************************************************************************
  flora_is_flogic_base(+Base)
*****************************************************************************/
flora_is_flogic_base(WRAP_ISA)        :- !.
flora_is_flogic_base(WRAP_SUB)        :- !.
flora_is_flogic_base(WRAP_FD)         :- !.
flora_is_flogic_base(WRAP_MVD)        :- !.
flora_is_flogic_base(WRAP_IFD)        :- !.
flora_is_flogic_base(WRAP_IMVD)       :- !.
flora_is_flogic_base(WRAP_METH)       :- !.
flora_is_flogic_base(WRAP_IMETH)      :- !.
flora_is_flogic_base(WRAP_EXISTS)     :- !.
flora_is_flogic_base(WRAP_MVDDEF)     :- !.
flora_is_flogic_base(WRAP_IMVDDEF)    :- !.
flora_is_flogic_base(WRAP_TRAN)       :- !.
flora_is_flogic_base(WRAP_FDSIG)      :- !.
flora_is_flogic_base(WRAP_IFDSIG)     :- !.
flora_is_flogic_base(WRAP_MVDSIG)     :- !.
flora_is_flogic_base(WRAP_IMVDSIG)    :- !.
flora_is_flogic_base(WRAP_MVDINC)     :- !.
flora_is_flogic_base(WRAP_IMVDINC)    :- !.
flora_is_flogic_base(WRAP_MVDTOLIST)  :- !.
flora_is_flogic_base(WRAP_IMVDTOLIST) :- !.
flora_is_flogic_base(WRAP_FDDEF)      :- !.
flora_is_flogic_base(WRAP_IFDDEF)     :- !.
flora_is_flogic_base(WRAP_OBJEQL)     :- !.


/*****************************************************************************
  flora_decode_predicate(+Predicate,-PredicateType,-ModuleName,
                         -WrapPrefix,-PredicateSymbol,-ArgsList)

  This procedure decodes a predicate and returns answers as follows:

  (1) PredicateType=flogic, if the predicate is encoded as:
	'FLORA_PREFIX''FLORA_(USER/SYSTEM)_MODULE''workspace''flogic_wrapper'.
      ModuleName is the Flora user/system module name. WrapPrefix is the
      prefix of the wrapper (e.g., base_, derived_). PredicateSymbol specifies
      the type of the F-logic wrapper, e.g., fd, mvd, imvd, etc.


  (2) PredicateType=hilog, if the predicate is encoded as:
	'FLORA_PREFIX''FLORA_(USER/SYSTEM)_MODULE''workspace''WRAP_HILOG'.
      ModuleName is the Flora user/system module name. WrapPrefix is undefined.
      PredicateSymbol is the functor of the HiLog predicate.

  (3) PredicateType=prolog, if the predicate is encoded other than (1) and (2).
      ModuleName and WrapPrefix will be undefined.

  Note: This procedure can also be used to decode a predicate symbol (without
        any argument). In (1) and (3), PredicateSymbol is defined and
        ArgsList=[]. In (2), PredicateSymbol=[] and ArgsList=[].

*****************************************************************************/
flora_decode_predicate(Predicate,PredicateType,ModuleName,
	               WrapPrefix,PredicateSymbol,ArgsList) :-
	%% This branch is to decode either an F-logic or a HiLog predicate.
	Predicate =.. [Funct|Args],
	%% Check if it begins with a module predicate prefix.
	flora_decode_module_prefix(Funct,ModuleType,Flora_module_prefix_len_plus1),
	( ModuleType == usermodule ->
	    ModuleName=Workspace

	; ModuleType == usermodule ->
	    ModuleName=FL_FLORALIB(Workspace)
	),
	%% Locate the last ' and extract the following wrapper.
	atom_codes(Funct,FunctList),
	reverse(FunctList,RevFunctList),
	atom_codes(RevFunct,RevFunctList),
	str_sub('''',RevFunct,N),
	str_length(Funct,FunctLen),
	eval(FunctLen-N+1,S),
	substring(Funct,S,_,Wrapper),
	( Wrapper == WRAP_HILOG ->
	    PredicateType=hilog,
	    ( Args=[PredicateSymbol|ArgsList] ->
		true
	    ;
	      PredicateSymbol=[],
	      ArgsList=[]
	    )

	; flora_decode_flogic_wrapper(Wrapper,WrapPrefix,PredicateSymbol) ->
	    PredicateType=flogic,
	    ArgsList=Args
	),
	%% Extract the workspace name.
	eval(S-1,T),
	substring(Funct,Flora_module_prefix_len_plus1,T,Workspace),
	!.


flora_decode_predicate(Predicate,firstorder,ModuleName,
		       _WrapPrefix,PredicateSymbol,ArgsList) :-
	%% This branch is to decode a first order predicate.
	Predicate =.. [Funct|ArgsList],
	%% Check if it begins with a module predicate prefix.
	flora_decode_firstorder_module_prefix(Funct,ModuleType,
	                                      Flora_module_prefix_len_plus1),
	( ModuleType == usermodule ->
	    ModuleName=Workspace

	; ModuleType == usermodule ->
	    ModuleName=FL_FLORALIB(Workspace)
	),
	%% Locate the end of workspace name, assuming the next quote after
	%% the prefix marks the end of the workspace. This will not work
	%% correctly if the workspace contains the quote symbol.
	substring(Funct,Flora_module_prefix_len_plus1,_,RestFunct),
	str_sub('''',RestFunct,N),
	%% Extract the workspace name.
	eval(N-1,M),
	substring(RestFunct,0,M,Workspace),
	%% Extract the predicate name.
	substring(RestFunct,N,_,PredicateSymbol),
	!.

flora_decode_predicate(Predicate,prolog,_ModuleName,
		       _WrapPrefix,PredicateSymbol,ArgsList) :-
	%% prolog catches all other cases.
	Predicate =.. [PredicateSymbol|ArgsList],
	!.


/*****************************************************************************
  flora_decode_module_name(+Predicate,-ModuleName)

  It checks if the predicate symbol is a (first order) Flora user/system
  module predicate. If yes, it returns the name of the module; otherwise,
  it fails.
*****************************************************************************/
flora_decode_module_name(Predicate,ModuleName) :-
	flora_decode_predicate(Predicate,PredicateType,ModuleName,
			       _WrapPrefix,_PredicateSymbol,_ArgsList),
	( PredicateType == (flogic)
	; PredicateType == (hilog)
	; PredicateType == (firstorder)
	),
	!.


/*****************************************************************************
  flora_is_flogic_wrapper(+Predicate,-ModuleName,-Base)
*****************************************************************************/
flora_is_flogic_wrapper(Predicate,ModuleName,Base) :-
	flora_decode_predicate(Predicate,flogic,ModuleName,_WrapPrefix,Base,_ArgsList),
	!.
