/* File:      flrutils.P
**
** Author(s): Guizhen Yang
**
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) The Research Foundation of SUNY, 1999-2001
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: flrutils.P,v 1.47 2001-06-17 20:09:08 kifer Exp $
**
*/


:- compiler_options([xpp_on]).


#define FLORA_FILE_EXT		flr
#define FLORA_INCLUDE_EXT	fli
#define FLORA_HEADER_EXT	flh
#define FLORA_FDB_EXT		fdb
#define XSB_PFILE_EXT		'P'
#define XSB_OFILE_EXT		'O'
#define XSB_HFILE_EXT		'H'
#define FLORA_FAILURE		failure
#define FLORA_SUCCESS		success
#define FLORA_NOOP		noop
#define FLORA_ALL		all
#define FLORA_FILE		file
#define FLORA_COMMANDLINE	commandline

#include "char_defs.h"
#include "flag_defs_xsb.h"
#include "flora_terms.flh"


/*************************************************************************
  flora_compile_internal(+File)
*************************************************************************/
flora_compile_internal(File) :-
	flora_compile_internal(File,FLORA_DEFAULT_WORKSPACE).


/******************************************************************************
  flora_compile_internal(+File,+Workspace)
  The .O file is renamed using the module name
******************************************************************************/
flora_compile_internal(File,Workspace) :-
	flora_check_filename(File),
	flora_check_workspace(Workspace),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flcompile(FlrFile,Workspace)

	; parse_filename(File,_,_,Ext), Ext \== '', Ext \== FLORA_FILE_EXT,
          path_sysop(exists,File)
	->
	    flora_stderr_nl,
	    flora_error_line('%s: Filename extension must be %s!',
			     args(File,FLORA_FILE_EXT)),
	    fail
	;
	  flora_stderr_nl,
	  flora_error_line('File %s[.%s] does not exist!',
			   args(File,FLORA_FILE_EXT)),
          fail
        ),
	!.



/**********************************************************************
  flora_load_module_internal(+File,+Workspace)
  File must be a FLORA file.
**********************************************************************/
flora_load_module_internal(InFile,Workspace) :-
	flora_check_filename(InFile),
	flora_check_workspace(Workspace),
	flora_get_user_program_maybe(InFile,File),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flload(FlrFile,Workspace)

	; parse_filename(File,_,_,Ext), Ext \== '', Ext \== FLORA_FILE_EXT,
	  path_sysop(exists,File)
	->  flora_stderr_nl,
	    flora_error_line('%s: Filename extension must be %s!',
			     args(File,FLORA_FILE_EXT)),
	    fail
	;
	  flora_stderr_nl,
	  flora_error_line('File %s[.%s] does not exist!',
			   args(File,FLORA_FILE_EXT)),
          fail
        ),
	!.


/**********************************************************************
  flora_load_module_internal(+File)
  File may be a FLORA file, .P file, or .O file.
**********************************************************************/
flora_load_module_internal(InFile) :-
	flora_check_filename(InFile),
	flora_get_user_program_maybe(InFile,File),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flload(FlrFile,FLORA_DEFAULT_WORKSPACE)

	; flora_locate_file(File,XSB_PFILE_EXT,PFile) ->
	    flora_stdmsg_nl,
	    flora_message_line('consulting %s',args(PFile)),
	    consult(PFile)

	; flora_locate_file(File,XSB_OFILE_EXT,OFile) ->
	    flora_stdmsg_nl,
	    flora_message_line('consulting %s',args(OFile)),
	    consult(OFile)

	; parse_filename(File,_,_,Ext),
          Ext \== '', Ext \== XSB_OFILE_EXT, Ext \== XSB_PFILE_EXT, Ext \== FLORA_FILE_EXT,
	  path_sysop(exists,File)
	->
	    flora_stderr_nl,
	    flora_error_line('%s: Filename extension must be %s, %s or %s!',
	                     args(File,
				  FLORA_FILE_EXT,XSB_PFILE_EXT,XSB_OFILE_EXT)),
	    fail
	;
	  flora_stderr_nl,
	  flora_error_line('File %s[.{%s|%s|%s}] does not exist!',
			   args(File,
				FLORA_FILE_EXT,XSB_PFILE_EXT,XSB_OFILE_EXT)),
          fail
        ),
	!.



/**********************************************************************
  flloadtrailer(+TrailerName,+Workspace)
  TrailerName must be either NONE, or BASIC, or FLOGIC.
**********************************************************************/
flloadtrailer(TrailerName) :-
	flloadtrailer(TrailerName,FLORA_DEFAULT_WORKSPACE).

flloadtrailer(TrailerName,Workspace) :-
	( TrailerName \== NONE, TrailerName \== BASIC, TrailerName \== FLOGIC ->
	    flora_error_line('Equality directive must be %s, %s, or %s!',
                             args(NONE,BASIC,FLOGIC)),
	    fail
	;
	  %% Get the trailer file name in Flora package.
	  flora_check_workspace(Workspace),
	  package_configuration(dir(flora),FloraDir),
	  slash(S),
	  flora_trailer_filename(TrailerName,TrailerFileName),
	  fmt_write_string(TrailerFullName,'%s%strailer%s%s',
                           args(FloraDir,S,S,TrailerFileName)),
	  %% Get file names in user dir.
	  flora_user_flora_dir(UserFloraDir),
	  fmt_write_string(UserTrailerPFile,'%s%s%s',args(UserFloraDir,S,TrailerFileName)),
	  flora_mainO_filename(UserTrailerPFile,UserTrailerOFile),
	  flora_WSO_filename(UserTrailerPFile,Workspace,UserTrailerWSOFile),
	  %% Copy the main file to user directory.
	  ( flora_file_newerthan(UserTrailerPFile,TrailerFullName) ->
	      true
	  ;
	    path_sysop(copy,TrailerFullName,UserTrailerPFile)
	  ),
	  ( flora_file_newerthan(UserTrailerWSOFile,UserTrailerPFile) ->
	      true
	  ;
	    flora_set_xpp_options(Workspace),
	    compile(UserTrailerPFile,[optimize,spec_repr,ti_all]),
	    path_sysop(rename,UserTrailerOFile,UserTrailerWSOFile),
	    flora_clear_xpp_options
	  ),
	  consult(UserTrailerWSOFile),
	  !,
	  %% Check if the patch needs to be loaded.
	  flora_wspredicate(FLORA_THIS_MODULE,[],Workspace,Predicate),
	  (current_predicate(Predicate/1) -> true; flloadpatch(Workspace))
        ),
	!.


/**********************************************************************
  flsetuptrailer(+TrailerName)
  TrailerName must be either NONE, or BASIC, or FLOGIC.
  This predicate is called in the Makefile.
**********************************************************************/
flsetuptrailer(TrailerName) :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	flora_trailer_filename(TrailerName,TrailerFileName),
	fmt_write_string(TrailerFullName,'%s%strailer%s%s',
                         args(FloraDir,S,S,TrailerFileName)),
	telling(PreOutFile),
	tell(TrailerFullName),
	flora_trailer_include(TrailerName,TrailerInclude),
	flora_include_file([FLHEADER|TrailerInclude],HeaderStatus),
	told,
	tell(PreOutFile),
	!,
	( HeaderStatus == FLORA_FAILURE ->
	    fail
	;
	  flora_set_xpp_options(FLORA_DEFAULT_WORKSPACE),
	  compile(TrailerFullName,[optimize,spec_repr,ti_all]),
	  flora_clear_xpp_options
	),
	!.

flora_trailer_filename(NONE,'standard.P').
flora_trailer_filename(BASIC,'eqlbasic.P').
flora_trailer_filename(FLOGIC,'eqlflogic.P').

flora_trailer_include(NONE,[FLTRAILER]).
flora_trailer_include(BASIC,[FLEQLTRAILER]).
flora_trailer_include(FLOGIC,[FLEQLTRAILER,FLSCALAREQL]).


/**********************************************************************
  flloadpatch(+Workspace)
**********************************************************************/
flloadpatch(Workspace) :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	flora_patch_filename(PatchName),
	fmt_write_string(PatchFullName,'%s%strailer%s%s',args(FloraDir,S,S,PatchName)),
	%% Get file names in user dir.
	flora_user_flora_dir(UserFloraDir),
	fmt_write_string(UserPatchPFile,'%s%s%s',args(UserFloraDir,S,PatchName)),
	flora_mainO_filename(UserPatchPFile,UserPatchOFile),
	flora_WSO_filename(UserPatchPFile,Workspace,UserPatchWSOFile),
	%% Copy the main file to user directory.
	( flora_file_newerthan(UserPatchPFile,PatchFullName) ->
	    true
	;
	  path_sysop(copy,PatchFullName,UserPatchPFile)
	),
	( flora_file_newerthan(UserPatchWSOFile,UserPatchPFile) ->
	    true
	;
	  flora_set_xpp_options(Workspace),
	  compile(UserPatchPFile,[optimize,spec_repr,ti_all]),
	  path_sysop(rename,UserPatchOFile,UserPatchWSOFile),
	  flora_clear_xpp_options
        ),
	consult(UserPatchWSOFile),
	!.


/**********************************************************************
  flsetuppatch
**********************************************************************/
flsetuppatch :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	flora_patch_filename(PatchName),
	fmt_write_string(PatchFullName,'%s%strailer%s%s',args(FloraDir,S,S,PatchName)),
	telling(PreOutFile),
	tell(PatchFullName),
	flora_include_file([FLHEADER,FLDEFINITION,FLPATCH],HeaderStatus),
	told,
	tell(PreOutFile),
	!,
	( HeaderStatus == FLORA_FAILURE ->
	    fail
	;
	  flora_set_xpp_options(FLORA_DEFAULT_WORKSPACE),
	  compile(PatchFullName,[optimize,spec_repr,ti_all]),
	  flora_clear_xpp_options
	),
	!.


flora_patch_filename('patch.P').


/*************************************************************************
  flora_user_flora_dir(-Dir)
*************************************************************************/
flora_user_flora_dir(Dir) :-
	( package_configuration(user_dir(flora),Dir) ->
	    true
	;
	    xsb_configuration(user_home,UserHome),
	    slash(S),
	    fmt_write_string(Dir,'%s%s.xsb%sflora',args(UserHome,S,S)),
	    ( path_sysop(exists,Dir) ->
		true
	    ;
		( path_sysop(mkdir,Dir) ->
		    true
		;
		    flora_error_line('Cannot create directory %s!',args(Dir)),
		    abort
		)
	    ),
	    assert(package_configuration(user_dir(flora),Dir))
	),
	!.

flora_user_tmpfile(Filename) :-
	flora_user_flora_dir(Dir),
	slash(S),
	fmt_write_string(Filename, '%s%stmp$user', args(Dir,S)).


/*************************************************************************
  flora_flcompile(+FlrFile,+Workspace)
  Renames the .O file using the module name
*************************************************************************/
flora_flcompile(FlrFile,Workspace) :-
	flora_flcompile(FlrFile,Workspace,rename).

/*************************************************************************
  flora_flcompile(+FlrFile,+Workspace,+WhetherToRename)
  If WhetherToRename=rename, then the .O file is renamed
*************************************************************************/
flora_flcompile(FlrFile,Workspace,WhetherToRename) :-
	flora_mainP_filename(FlrFile,MPFile),
	flora_FDB_filename(FlrFile,FDBFile),
	flora_compile_file(FlrFile,MPFile,FDBFile,Status),
	( Status == FLORA_FAILURE ->
	    fail
	;
	    flora_mainO_filename(FlrFile,MOFile),
	    flora_message_line('calling XSB compiler'),
	    flora_set_xpp_options(Workspace),
	    compile(MPFile,[optimize,spec_repr,ti_all]),
	    flora_clear_xpp_options,
	    (WhetherToRename==rename
	    ->  flora_WSO_filename(FlrFile,Workspace,WSOFile),
		path_sysop(rename,MOFile,WSOFile)
	    ;   true
	    )
        ),
	!.


/******************************************************************************
   Compile a service in the lib/ directory. Since services are loaded
   into predefined modules, there is no need to rename the .O file.
   This is used only in the Makefile, so we don't do error checking
   for file existence, etc.
******************************************************************************/
flora_compile_service(File) :-
	path_sysop(basename,File,Basename),
	flora_service_file(Servicename,Basename,_), % get service's name
	flora_set_xpp_extra_options(' -D FLORA_COMPILING_SERVICE_LIBRARY '),
	(flora_locate_file(Basename,FLORA_FILE_EXT,FlrFile)
	-> flora_flcompile(FlrFile,Servicename,dontrename)
	;  flora_stderr_nl,
	    flora_error_line('File %s[.%s] does not exist!',
			     args(Basename,FLORA_FILE_EXT)),
	    fail
	).



/*************************************************************************
  flora_flload(+FlrFile,+Workspace)
*************************************************************************/
flora_flload(FlrFile,Workspace) :-
	flora_mainP_filename(FlrFile,MPFile),
	flora_mainO_filename(FlrFile,MOFile),
	flora_FDB_filename(FlrFile,FDBFile),
	flora_WSO_filename(FlrFile,Workspace,WSOFile),
	!,
        ( flora_file_newerthan(MPFile,FlrFile) ->
	    flora_stdmsg_nl,
	    true
	;
	  flora_compile_file(FlrFile,MPFile,FDBFile,Status),
	  (Status == FLORA_FAILURE -> fail; true)
	),
	!,
	flora_message_line('loading %s into module %s',args(FlrFile,Workspace)),
	flora_set_xpp_options(Workspace),
	( flora_file_newerthan(WSOFile,MPFile) ->
	    true
	;
	  compile(MPFile,[optimize,spec_repr,ti_all]),
	  path_sysop(rename,MOFile,WSOFile)
        ),
        consult(WSOFile),
	flora_clear_xpp_options,
	!.

/*****************************************************************************
  flora_save_user_clauses(+FlrFile)
  Read user input and save it in the given file
*****************************************************************************/
flora_save_user_clauses(FlrFile) :-
	flora_message_line('Enter FLORA program clauses. When done, type Ctl-D.'),
	file_open(FlrFile,w,Port),
	stat_flag(CURRENT_INPUT, InPort),
	copyIOport(InPort,Port),
	file_close(Port),
	flora_message_line('User program saved in file %s', arg(FlrFile)).


/*************************************************************************
  flora_get_user_program_maybe(+InFile,-File)
  If InFile = user assume the user wants to input the program from the shell.
  Retrun the name of the tempfile that has the program.
*************************************************************************/
flora_get_user_program_maybe(InFile,File) :-
	( InFile == user ->
	    %%path_sysop(tmpfilename,File),
	    flora_user_tmpfile(File),
	    fmt_write_string(FlrFile,'%s.%s', args(File,FLORA_FILE_EXT)),
	    flora_save_user_clauses(FlrFile)
	;
	  File=InFile
	).


/*************************************************************************
  flora_locate_file(+InFile,+ExtType,-ExtFile)

  InFile must have ExtType as extension or no extension (in this case,
  ExtType is appended).
*************************************************************************/
flora_locate_file(InFile,ExtType,ExtFile) :-
	parse_filename(InFile,_,_,Ext),
	( Ext == ExtType ->
	    ExtFileName=InFile
	;
	  fmt_write_string(ExtFileName,'%s.%s',args(InFile,ExtType))
	),
	flora_locate_file(ExtFileName,ExtFile),
	!.


/*************************************************************************
  flora_locate_file(+InFile,-LocatedFile)

  When it succeeds, it returns the absolute file name.
*************************************************************************/
flora_locate_file(In,In) :-
	path_sysop(isabsolute,In),
	!,
	path_sysop(exists,In).

flora_locate_file(In,Loc) :-
	flora_library_directory(LibDir),
	slash(S),
	fmt_write_string(File,'%s%s%s',args(LibDir,S,In)),
	path_sysop(expand,File,Loc),
	path_sysop(exists,Loc),
	!.


/*************************************************************************
  flora_file_newerthan(+File1,+File2)
  returns true iff File1 exists and is newer than File2. File2 already exists.
*************************************************************************/
flora_file_newerthan(File1,File2) :-
	path_sysop(exists,File1),
	path_sysop(newerthan,File1,File2).


/*************************************************************************
  flora_library_directory(-Dir)
  returns directories to search a FLORA file.
*************************************************************************/
flora_library_directory('.').
flora_library_directory(LibDir) :- library_directory(LibDir).
flora_library_directory(LibDir) :- xsb_configuration(libdir,LibDir).
flora_library_directory(LibDir) :- xsb_configuration(syslibdir,LibDir).
flora_library_directory(LibDir) :- xsb_configuration(cmplibdir,LibDir).


/*************************************************************************
  flora_mainP_filename(+File,-MPFile)
  flora_mainO_filename(+File,-MOFile)
  flora_FDB_filename(+File,-FDBFile)
  flora_FLH_filename(+File,-FLHFile)
  flora_WSP_filename(+File,+WS,-WSPFile)
  flora_WSO_filename(+File,+WS,-WSOFile)
*************************************************************************/
flora_mainP_filename(File,MPFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(MPFile,'%s%s.%s',args(Dir,Base,XSB_PFILE_EXT)).

flora_mainO_filename(File,MOFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(MOFile,'%s%s.%s',args(Dir,Base,XSB_OFILE_EXT)).

flora_FDB_filename(File,FDBFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(FDBFile,'%s%s.%s',args(Dir,Base,FLORA_FDB_EXT)).

flora_FLH_filename(File,FLHFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(FLHFile,'%s%s.%s',args(Dir,Base,FLORA_HEADER_EXT)).

%flora_WSP_filename(File,WS,WSPFile) :-
%	parse_filename(File,Dir,Base,_),
%	fmt_write_string(WSPFile,'%s%s_%s.%s',args(Dir,Base,WS,XSB_PFILE_EXT)).

flora_WSO_filename(File,WS,WSOFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(WSOFile,'%s%s_%s.%s',args(Dir,Base,WS,XSB_OFILE_EXT)).


/*************************************************************************
  utilities
*************************************************************************/
flora_check_filename(Name) :-
	( not atom(Name) ->
	    flora_error_line('invalid file name'),
	    fail
	;
	  true
	).


flora_check_workspace(Name) :-
	( var(Name) ->
	    flora_error_line('uninstantiated module name'),
	    fail
	; not (atom(Name), is_alphanumeric(Name)) ->
	    flora_error_heading,
	    flora_stderr_string('invalid module name (not alphanumeric): '),
	    flora_stderr_write(Name),
	    flora_stderr_nl,
	    fail
	; 
	  true
	).

is_alphanumeric(Name) :-
	atom_codes(Name,NameL),
	is_alphanumericL(NameL).
is_alphanumericChar(Ch) :-
	(CH_0 =< Ch, Ch =< CH_9
	; CH_a =< Ch, Ch =< CH_z
	; CH_A =< Ch, Ch =< CH_Z
	; Ch == 0'_).
is_alphanumericL([]).
is_alphanumericL([Ch|Rest]) :-
	is_alphanumericChar(Ch),
	is_alphanumericL(Rest).


/*************************************************************************
  gpp control utilities
*************************************************************************/
flora_set_xpp_options :-
	retractall(xpp_options(_)),
	assert(xpp_options('-P -m -nostdinc -curdirinclast')).

%% Looks in flora_xpp_extra_options/1 to see if needs to add more options
flora_set_xpp_options(WS) :-
	(flora_xpp_extra_options(ExtraOptions) -> true
	; ExtraOptions = ''
	),
	fmt_write_string(Opt,
                         '-P -m -nostdinc -curdirinclast %s -D FLORA_VAR_WORKSPACE=%s',
                         args(ExtraOptions,WS)),
	flora_clear_xpp_options,
	assert(xpp_options(Opt)).

%% Extra options for GPP
flora_set_xpp_extra_options(Opt) :-
	flora_clear_xpp_extra_options,
	assert(flora_xpp_extra_options(Opt)).

flora_clear_xpp_options :- retractall(xpp_options(_)).
flora_clear_xpp_extra_options :- retractall(flora_xpp_extra_options(_)).


/*************************************************************************
  flora_loaddyn_FDB_filename(+DBFileName)
*************************************************************************/
flora_loaddyn_FDB_filename(DBFileName) :-
	current_output_port(OutPort),
	fmt_write(OutPort,":- import flora_load_dyn/2 from flrutils.\n",_),
	fmt_write(OutPort,"?- flora_load_dyn('%s',%s).\n\n",
                  args(DBFileName,'FLORA_VAR_WORKSPACE')).


/*************************************************************************
  flora_include_file(+OptionList,-Status)
*************************************************************************/
flora_include_file([],FLORA_SUCCESS) :- !.

flora_include_file([Opt|OptList],Status) :-
	flora_include(Opt,File),
	!,
	package_configuration(dir(flora),FloraDir),
	slash(S),
	fmt_write_string(FullName,'%s%s%s',args(FloraDir,S,File)),
	( path_sysop(exists,FullName) ->
	    print_file_contents(FullName),
	    flora_include_file(OptList,Status)
	;
	  flora_error_line('The FLORA system file %s cannot be found!',
			   arg(FullName)),
          Status=FLORA_FAILURE
	).

flora_include_file(_OptList,FLORA_FAILURE) :-
	  flora_error_line('system file corrupted!').


/*************************************************************************
  flora_end_of_input(+Status)
  flora_not_end_of_input(+Status)
*************************************************************************/
flora_end_of_input(Status) :- member(FLORA_EOF,Status).
flora_not_end_of_input(Status) :- member(FLORA_NOT_EOF,Status).


/*************************************************************************
  flora_reset_modules_for_file/0
*************************************************************************/
flora_reset_modules_for_file :-
	flora_reset_lexer,
	flora_reset_operator,
	flora_reset_arguments,
	flora_reset_prolog,
	flora_reset_firstorder,
	flora_reset_compiler,
	conset(flora_shell_mode,0).


/*************************************************************************
  flora_reset_modules_for_shell/0
*************************************************************************/
flora_reset_modules_for_shell :-
	flora_reset_lexer,
	flora_reset_compiler,
	conset(flora_shell_mode,1).


/*************************************************************************
  flora_compile_file(+InputFile,+OutputPFile,+OutputDBFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
flora_compile_file(InputFile,PFile,DBFile,FileStatus) :-
	flora_maxerr(MaxErrNum),
	flora_stdmsg_nl,
	flora_message_line('compiling %s',args(InputFile)),
	cputime(T0),
	seeing(PreInFile),
	flora_reset_modules_for_file,
	flora_set_xpp_options,
	xpp_process_file(InputFile,XPP_process,IOportFromProc),
	stat_set_flag(CURRENT_INPUT,IOportFromProc),
	flora_rpc_file(MaxErrNum,0,0,CompiledRuleList,FileOptionList,CompileStatus),
	%% Wait, not to leave zombies.
	process_control(XPP_process,wait),
	%% Release the file descriptor used to read from cpp.
	file_close(IOportFromProc),
	flora_clear_xpp_options,
	see(PreInFile),
	( CompileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  flora_generate_file(CompiledRuleList,FileOptionList,PFile,DBFile,FileStatus)
        ),
	cputime(T1),
	( FileStatus == FLORA_FAILURE ->
	    true
	;
	  T is T1-T0,
	  flora_message_line('Done! CPU time used: %S seconds',args(T))
	),
	!.


/*************************************************************************
  flora_generate_file(+CompiledRuleList,+FileOptionList,+PFile,+DBFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
flora_generate_file(CompiledRuleList,FileOptionList,PFile,DBFile,FileStatus) :-
	flora_divide_program(CompiledRuleList,RuleList,FactList),
	sort(FileOptionList,FileOptions),
	flora_generate_Pfile(PFile,FileOptions,RuleList,FactList,DBFile,PFileStatus),
	( PFileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  ( FactList == [] ->
	      FileStatus=FLORA_SUCCESS
	  ;
	    flora_generate_DBfile(DBFile,FactList,FileStatus)
	  )
        ),
	!.


/*************************************************************************
  flora_generate_Pfile(+PFileName,+FileOptionList,+RuleList,+FactList,
                       +DBFile,-FileStatus)

  Things to do:
  (1) include .flh file directive.
  (2) output header file.
  (3) syslib loading instrucitons.
  (4) DB file loading instruction.
  (5) program.
  (6) trailer.
*************************************************************************/
flora_generate_Pfile(PFileName,FileOptionList,RuleList,FactList,DBFile,FileStatus) :-
	telling(PreOutFile),
	tell(PFileName),
	findall(LibOption,member(FLSYSLIB(LibOption),FileOptionList),LibOptionList),
	%% FLLIBCONTROL (sylibinc), (libinc) FLSERVPP, FLSERVIO
	%%  should be included by the compiler
	flora_include_file([FLHEADER,FLDEFINITION,FLPATCH,FLLIBCONTROL,FLSERVPP,FLSERVIO|LibOptionList],
                           HeaderStatus),
	( HeaderStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  (FactList == [] -> true; flora_loaddyn_FDB_filename(DBFile)),
	  flora_extern_code(RuleList,CoderStatus),
	  ( CoderStatus == [] ->
	      ( member(FLEQLFLOGIC,FileOptionList) ->
		  flora_message_line('including full F-logic equality maintenance'),
		  flora_include_file([FLEQLTRAILER,FLSCALAREQL],FileStatus)

	      ; member(FLEQLBASIC,FileOptionList) ->
	          flora_message_line('including basic equality maintenance'),
		  flora_include_file([FLEQLTRAILER],FileStatus)
	      ;
	        flora_include_file([FLTRAILER],FileStatus)
	      )
	  ;
	    flora_coder_error(CoderStatus),
	    FileStatus=FLORA_FAILURE
	  )
        ),
	told,
	tell(PreOutFile),
	!.


/*************************************************************************
  flora_generate_DBfile(+DBFileName,+FactList,-FileStatus)

  Things to do:
  (1) include .flh file directive.
  (2) output header file.
  (3) facts.
*************************************************************************/
flora_generate_DBfile(DBFileName,FactList,FileStatus) :-
	telling(PreOutFile),
	tell(DBFileName),
	%% Include the Macro definitions.
	writeln('#include "flrheader.flh"'),
	nl,
	flora_extern_code(FactList,CoderStatus),
	( CoderStatus == [] ->
	    FileStatus=FLORA_SUCCESS
	;
	  flora_coder_error(CoderStatus),
	  FileStatus=FLORA_FAILURE
	),
	told,
	tell(PreOutFile),
	!.


/*************************************************************************
  flora_load_dyn(+InDBFile,+Module)

  This procedure reads a Flora DB file that contains facts in canonical
  form and inserts them into the storage trie for the module.
*************************************************************************/
flora_load_dyn(InDBFile,Module) :-
	flora_check_filename(InDBFile),
	( flora_locate_file(InDBFile,DBFile) ->
	    flora_message_line('dynamically loading %s into storage trie',args(DBFile)),
	    cputime(T0),
	    seeing(PreInFile),
	    flora_set_xpp_options(Module),
	    xpp_process_file(DBFile,XPP_process,IOportFromProc),
	    stat_set_flag(CURRENT_INPUT,IOportFromProc),
	    flora_storage_name(Module,StorageName),
	    flora_read_canonical_and_insert(StorageName),
	    %% Wait, not to leave zombies.
	    process_control(XPP_process,wait),
	    %% Release the file descriptor used to read from cpp.
	    file_close(IOportFromProc),
	    flora_clear_xpp_options,
	    see(PreInFile),
	    cputime(T1),
	    T is T1-T0,
	    flora_message_line('Done! CPU time used: %S seconds',args(T))
	;
	  flora_error_line('File %s does not exist!',args(InDBFile)),
          fail
	),
	!.


/*************************************************************************
  flora_read_canonical_and_insert(+StorageName)

  It reads the current input in canonical form and inserts all facts
  into the storage trie.
*************************************************************************/
flora_read_canonical_and_insert(StorageName) :-
	repeat,
	read_canonical(Term),
	( Term == end_of_file ->
	    !
	;
	  storage_insert_fact(StorageName,Term,_Inserted),
	  fail
	).


/*************************************************************************
  flora_rpc_file(+MaxErr,+ErrNum,+WarnNum,-CompiledRuleList,-FileOptionList,-FileStatus)
*************************************************************************/
flora_tailappend(V,[],V) :- !.
flora_tailappend([H|V],[H|L],T) :- flora_tailappend(V,L,T).


%% Calls the compiler. This is used to wrap templates, like trailers, 
%% with the WORKSPACE macros.
flora_rpc_file(MaxErr,ErrNum,WarnNum,CompiledRuleList,FileOptionList,FileStatus) :-
	flora_read_parse_compile(FLORA_FILE,Tokens,FlattenedRules,RuleOptions,RuleStatus),
	member(error(EN),RuleStatus),
	member(warning(WN),RuleStatus),
	NewErrNum is ErrNum+EN,
	NewWarnNum is WarnNum+WN,
	( EN > 0 -> %% errors just found
	    ( MaxErr \== FLORA_ALL, NewErrNum >= MaxErr ->
		FileStatus=FLORA_FAILURE,
		flora_stderr_string("\n"),
		flora_errorwarn_count(NewErrNum,NewWarnNum),
		flora_stderr_string("\n++compilation aborted\n")

	    ; flora_rule_delimeter_struct(_,_,_,_,_,RuleDelimeterToken),
	      flora_not_end_of_input(RuleStatus), member(RuleDelimeterToken,Tokens) ->
	        flora_rpc_file(MaxErr,NewErrNum,NewWarnNum,
                               _CompiledRuleList,_FileOptionList,FileStatus)

	    ; flora_not_end_of_input(RuleStatus), flora_discard_tokens ->
	        flora_rpc_file(MaxErr,NewErrNum,NewWarnNum,
                               _CompiledRuleList,_FileOptionList,FileStatus)
	    ;
	      FileStatus=FLORA_FAILURE,
	      flora_stderr_string("\n"),
	      flora_errorwarn_count(NewErrNum,NewWarnNum),
	      flora_stderr_string("\n++compilation aborted\n")
	    )
	;
	  ( NewErrNum == 0 -> %% no error so far
	      flora_tailappend(CompiledRuleList,FlattenedRules,NewCompiledRuleList),
	      flora_tailappend(FileOptionList,RuleOptions,NewFileOptionList)
	  ;
	    true
	  ),
	  ( flora_not_end_of_input(RuleStatus) ->
	      flora_rpc_file(MaxErr,NewErrNum,NewWarnNum,
                             NewCompiledRuleList,NewFileOptionList,FileStatus)
	  ; %% end of file already
	    ( NewErrNum == 0 ->
		NewCompiledRuleList=[],
		NewFileOptionList=[],
		FileStatus=FLORA_SUCCESS,
		( NewWarnNum == 0 ->
		    true
		;
		  flora_stdwarn_string("\n"),
		  flora_errorwarn_count(NewErrNum,NewWarnNum)
		)
	    ;
	      FileStatus=FLORA_FAILURE,
	      flora_stderr_string("\n"),
	      flora_errorwarn_count(NewErrNum,NewWarnNum),
	      flora_stderr_string("\n++compilation aborted\n")
	    )
	  )
	),
	!.


/*************************************************************************
  flora_discard_tokens/0
  scans the input until a rule delimeter is found. It fails if eof.
*************************************************************************/
flora_discard_tokens :-
	flora_warning_line('discarding tokens (rule delimeter `.'' or EOF expected)'),
	repeat,
	flora_tokens(Tokens,Status),
	flora_rule_delimeter_struct(_Txt,_LN1,_CN1,_LN2,_CN2,RuleDelimeterToken),
	( flora_end_of_input(Status) ->
	    !,
	    fail
	
	; member(RuleDelimeterToken,Tokens) ->
	    !
	;
	  fail
        ).


/*************************************************************************
  flora_read_parse_compile(+Option,-Tokens,-FlattenedRuleList,-OptionList,-Status)

  Note: This procedure can be used to read both file and command line.
        For reading file, Option is FLORA_FILE. For reading command line,
        Option is FLORA_COMMANDLINE.
*************************************************************************/
flora_read_parse_compile(Option,Tokens,FlattenedRules,OptionList,Status) :-
	flora_tokens(InputTokens,LexerStatus),
	flora_lexer_error(InputTokens,LexerStatus,LexErrNum),
	( LexErrNum > 0 ->
	    Tokens=InputTokens,
	    FlattenedRules=[],
	    OptionList=[],
	    ErrNum=LexErrNum,
	    WarnNum=0

	; flora_blank_line(InputTokens) ->
	    Tokens=InputTokens,
	    FlattenedRules=[],
	    OptionList=[],
	    ErrNum=0,
	    WarnNum=0
	;
	  ( Option == FLORA_COMMANDLINE ->
	      flora_symbol_token_struct("?-",1,0,1,0,QueryOpToken),
	      Tokens=[QueryOpToken|InputTokens]
	  ;
	    Tokens=InputTokens
	  ),
	  flora_compose(Tokens,ComposerTerm,ComposerStatus),
	  flora_composer_errorwarn(Tokens,ComposerStatus,CompoErrNum,CompoWarnNum),
	  ( CompoErrNum > 0 ->
	      FlattenedRules=[],
	      OptionList=[],
	      ErrNum=CompoErrNum,
	      WarnNum=CompoWarnNum
	  ;
	    flora_parse(ComposerTerm,ParserTerm,ParserStatus),
	    flora_parser_error(Tokens,ParserStatus,ParErrNum),
	    ( ParErrNum > 0 ->
		FlattenedRules=[],
		OptionList=[],
		ErrNum=ParErrNum,
		WarnNum=CompoWarnNum
	    ;
	      flora_compile(ParserTerm,FlattenedRules,OptionList,CompilerStatus),
	      flora_compiler_errorwarn(Tokens,CompilerStatus,CompiErrNum,CompiWarnNum),
	      ErrNum=CompiErrNum,
	      WarnNum is CompoWarnNum+CompiWarnNum
	    )
	  )
        ),
	EWS=[error(ErrNum),warning(WarnNum)],
	( flora_end_of_input(LexerStatus) ->
	    Status=[FLORA_EOF|EWS]
	;
	  Status=[FLORA_NOT_EOF|EWS]
	).


/*************************************************************************
  flora_good_command(+Status)
  flora_bad_command(+Status)
  flora_noop_command(+Status)
*************************************************************************/
flora_good_command(Status) :- member(FLORA_SUCCESS,Status).
flora_bad_command(Status) :- member(FLORA_FAILURE,Status).
flora_noop_command(Status) :- member(FLORA_NOOP,Status).


/*************************************************************************
  flora_shell_command_line(-Code,-Options,-Status)
*************************************************************************/
flora_shell_command_line(Code,Options,Status) :-
	flora_reset_modules_for_shell,
	flora_read_parse_compile(FLORA_COMMANDLINE,Tokens,Rules,RuleOptions,RuleStatus),
	member(error(ErrNum),RuleStatus),
	( ErrNum > 0 ->
	    ( flora_end_of_input(RuleStatus) ->
		InputStatus=FLORA_EOF

	    ; flora_rule_delimeter_struct(_,_,_,_,_,RuleDelimeterToken),
	      member(RuleDelimeterToken,Tokens) ->
		InputStatus=FLORA_NOT_EOF

	    ; flora_discard_tokens ->
	        InputStatus=FLORA_NOT_EOF
	    ;
	      InputStatus=FLORA_EOF
	    ),
	    Status=[InputStatus,FLORA_FAILURE]
	;
	  ( Rules == [] ->
	      CommandStatus=FLORA_NOOP
	  ;
	    flora_intern_code(Rules,FLORA_DEFAULT_WORKSPACE,Code,CoderStatus),
	    ( CoderStatus == [] ->
		CommandStatus=FLORA_SUCCESS
	    ;
	      flora_coder_error(CoderStatus),
	      CommandStatus=FLORA_FAILURE
	    )
	  ),
	  sort(RuleOptions,Options),
	  ( flora_end_of_input(RuleStatus) ->
	      Status=[FLORA_EOF,CommandStatus]
	  ;
	    Status=[FLORA_NOT_EOF,CommandStatus]
	  )
	),
	!.


/*************************************************************************
  utilities
*************************************************************************/
flora_errorwarn_count(ErrNum,WarnNum) :-
	( ErrNum == 1 ->
	    flora_stderr_string("++1 error\n")

	; ErrNum > 1 ->
	    flora_stderr_string("++%d errors\n",args(ErrNum))
	;
	  true
        ),
	( WarnNum == 1 ->
	    flora_stdwarn_string("++1 warning\n")

	; WarnNum > 1 ->
	    flora_stdwarn_string("++%d warnings\n",args(WarnNum))
	;
	  true
        ),
	!.


flora_last_element([T],T).
flora_last_element([_|L],T) :- flora_last_element(L,T).


flora_nth_element([T|_],1,T) :- !.
flora_nth_element([_|L],N,T) :- M is N-1, flora_nth_element(L,M,T).


/*************************************************************************
  flora_lexer_error(+Tokens,+LexerStatus,-ErrNum)
*************************************************************************/
flora_lexer_error(Tokens,LexerStatus,ErrNum) :-
	( member(error(Msg),LexerStatus) ->
	    flora_last_element(Tokens,Tk),
	    flora_token_text(Tk,TextStr,_BLN,_BCN,ELN,ECN),
	    flora_error_line('[Lexer] near line(%d)/char(%d) `%s''',
	                     args(ELN,ECN,TextStr)),
	    flora_error_indentline,
	    flora_stderr_string("%s\n",args(Msg)),
	    ErrNum=1
	;
	  ErrNum=0
        ).


/*************************************************************************
  flora_composer_errorwarn(+Tokens,+ComposerStatus,-ErrNum,-WarnNum)
*************************************************************************/
flora_composer_errorwarn(_Tokens,[],0,0) :- !.

flora_composer_errorwarn(Tokens,[error(Indx,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_error_line('[Composer] near line(%d)/char(%d) `%s''',
                         args(BLN,BCN,TextStr)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_composer_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.

flora_composer_errorwarn(Tokens,[error(I1,I2,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,I1,Tk1),
	flora_nth_element(Tokens,I2,Tk2),
	flora_token_text(Tk1,TextStr1,BLN1,BCN1,_ELN1,_ECN1),
	flora_token_text(Tk2,TextStr2,BLN2,BCN2,_ELN2,_ECN2),
	flora_error_line('[Composer] near line(%d)/char(%d) `%s'' and near line(%d)/char(%d) `%s''',
	                 args(BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_composer_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.

flora_composer_errorwarn(Tokens,[warning(I1,I2,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,I1,Tk1),
	flora_nth_element(Tokens,I2,Tk2),
	flora_token_text(Tk1,TextStr1,BLN1,BCN1,_ELN1,_ECN1),
	flora_token_text(Tk2,TextStr2,BLN2,BCN2,_ELN2,_ECN2),
	flora_warning_line('[Composer] near line(%d)/char(%d) `%s'' and near line(%d)/char(%d) `%s''',
	                   args(BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2)),
	flora_warning_indentline,
	flora_stdwarn_string("%s\n",args(Msg)),
	flora_composer_errorwarn(Tokens,L,ErrNum,WN),
	WarnNum is WN+1.

flora_composer_errorwarn(Tokens,[error(Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_error_line('[Composer] %s',args(Msg)),
	flora_composer_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.


/*************************************************************************
  flora_parser_error(+Tokens,+ParserStatus,-ErrNum)
*************************************************************************/
flora_parser_error(_Tokens,[],0) :- !.

flora_parser_error(Tokens,[error(Indx,Msg)|L],ErrNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_error_line('[Parser] near line(%d)/char(%d) `%s''',
                         args(BLN,BCN,TextStr)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_parser_error(Tokens,L,EN),
	ErrNum is EN+1.

flora_parser_error(Tokens,[error(Msg)|L],ErrNum) :-
	!,
	flora_error_line('[Parser] %s',args(Msg)),
	flora_parser_error(Tokens,L,EN),
	ErrNum is EN+1.


/*************************************************************************
  flora_compiler_errorwarn(+Tokens,+CompilerStatus,-ErrNum,-WarnNum)
*************************************************************************/
flora_compiler_errorwarn(_Tokens,[],0,0) :- !.

flora_compiler_errorwarn(Tokens,[error(Indx,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_error_line('[Compiler] near line(%d)/char(%d) `%s''',
                         args(BLN,BCN,TextStr)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_compiler_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.

flora_compiler_errorwarn(Tokens,[warning(Indx,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_warning_line('[Compiler] near line(%d)/char(%d) `%s''',
                           args(BLN,BCN,TextStr)),
	flora_warning_indentline,
	flora_stdwarn_string("%s\n",args(Msg)),
	flora_compiler_errorwarn(Tokens,L,ErrNum,WN),
	WarnNum is WN+1.

flora_compiler_errorwarn(Tokens,[error(Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_error_line('[Compiler] %s',args(Msg)),
	flora_compiler_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.


/*************************************************************************
  flora_coder_error(+CoderStatus)
*************************************************************************/
flora_coder_error([]) :- !.

flora_coder_error([error(Msg)|L]) :-
	!,
	flora_error_line('[Coder] %s',args(Msg)),
	flora_coder_error(L).


/*****************************************************************************
  flora_list2conjunct(+List,-Goal)
*****************************************************************************/
flora_list2conjunct([G],G) :- !.

flora_list2conjunct([G|L],Goal) :-
	!,
	flora_list2conjunct(L,LG),
	Goal =.. [',',G,LG].


/*************************************************************************
  flMaxerr(+Num)
*************************************************************************/
:- flMaxerr(8).

flMaxerr(X) :-
	( var(X) ->
	    flora_maxerr(X)

	; X \== FLORA_ALL, (not integer(X); X < 1) ->
	    flora_error_line('invalid argument to maxerr'),
	    fail
	;
	  retractall(flora_maxerr(_)),
	  assert(flora_maxerr(X))
	).

flP2H(PrologTerm,HiLogTerm) :- plg2hlg(PrologTerm,HiLogTerm,WRAP_HILOG).


flHalt :- halt.

flDump(InFile>>Workspace) :-
	flora_dump_file(InFile,Workspace,dontsquash).
flDump(InFile) :-
	atom(InFile),
	flora_dump_file(InFile,FLORA_DEFAULT_WORKSPACE,squash).

%% If SquashingOption == squash, ignore Workspace in the final round 
%% of gpp pre-processing.
flora_dump_file(InFile,Workspace,SquashingOption) :-
	path_sysop(basename,InFile,Basename),
	(flora_locate_file(Basename,FLORA_FILE_EXT,File)
	-> flora_flcompile(File,Workspace,dontrename)
	;  flora_stderr_nl,
	    flora_error_line('File %s[.%s] does not exist!',
			     args(Basename,FLORA_FILE_EXT)),
	    fail
	),
	(SquashingOption == squash ->  NewWorkspace = ''
	;   %% Add '_' to the workspace: simplifies reading the predicates
	    str_cat(Workspace,'_',NewWorkspace)
	),
	(flora_gpp_dumpfile(Basename,NewWorkspace,XSB_PFILE_EXT)
	; flora_error_line('Failed to make a dump file for %s',args(Basename)),
	    fail
	),
	(flora_gpp_dumpfile(Basename,NewWorkspace,FLORA_FDB_EXT)
	;   true
	).

flora_gpp_dumpfile(Basename,Workspace,Extension) :-
	(flora_locate_file(Basename,Extension,ExtFile)
	->
	    flora_set_xpp_extra_options(' -D FLORA_DUMP '),
	    flora_set_xpp_options(Workspace),
	    fmt_write_string(Dumpfile, '%s_dump.%s', args(Basename,Extension)),
	    file_open(Dumpfile,w,DumpPort),
	    xpp_process_file(ExtFile,XPP_process,IOportFromGPP),
	    copyIOport(IOportFromGPP,DumpPort),
	    process_control(XPP_process, wait),
	    flora_clear_xpp_options,
	    file_close(DumpPort),
	    file_close(IOportFromGPP)
	).


/*************************************************************************
%%  flCompileInclude(+File)
%%  This is used only in the closure/Makefile
%%  It takes a trailer template and wraps it with the workspace and 
%%  flora prefixes. This way the trailer is easier to maintain and understand.
%%
%%  The included file is treated as a Flora program, so the compiler wraps it 
%%  with the appropriate macros (e.g., WORKSPACE), as it would any other
%%  Flora program.
*************************************************************************/
%%flCompileInclude(File) :-
%%	flora_check_filename(File),
%%	( flora_locate_file(File,FLORA_INCLUDE_EXT,FLIFile) ->
%%	    flora_FLH_filename(FLIFile,FLHFile),
%%	    flora_compile_incfile(FLIFile,FLHFile,Status),
%%	    (Status == FLORA_FAILURE -> fail; true)
%%
%%	; parse_filename(File,_,_,Ext), not member(Ext,['',FLORA_INCLUDE_EXT]),
%%	    path_sysop(exists,File)
%%	->
%%	    flora_stderr_nl,
%%	    flora_error_line('%s: Include filename extension must be %s!',
%%			     args(File,FLORA_INCLUDE_EXT)),
%%	    fail
%%	;
%%	  flora_stderr_nl,
%%	  flora_error_line('File %s[.%s] does not exist!',
%%			   args(File,FLORA_INCLUDE_EXT)),
%%          fail
%%        ),
%%	!.


/*************************************************************************
%%  flora_compile_incfile(+InputFile,+OutputFile,-FileStatus) :-
%%
%%  This compiles the include file (it is called from flCompileInclude/1)
%%  and adds the WORKSPACE and other macros to it.
%%
%%  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
%%flora_compile_incfile(InputFile,OutputFile,FileStatus) :-
%%	flora_stdmsg_nl,
%%	flora_message_line('compiling template include file %s',args(InputFile)),
%%	cputime(T0),
%%	seeing(PreInFile),
%%	flora_reset_modules_for_file,
%%	flora_set_xpp_options,
%%	xpp_process_file(InputFile,XPP_process,IOportFromProc),
%%	stat_set_flag(CURRENT_INPUT,IOportFromProc),
%%	flora_rpc_file(FLORA_ALL,0,0,CompiledRuleList,_FileOptionList,CompileStatus),
%%	%% Wait, not to leave zombies.
%%	process_control(XPP_process,wait),
%%	%% Release the file descriptor used to read from cpp.
%%	file_close(IOportFromProc),
%%	flora_clear_xpp_options,
%%	see(PreInFile),
%%	( CompileStatus == FLORA_FAILURE ->
%%	    FileStatus=FLORA_FAILURE
%%	;
%%	  telling(PreOutFile),
%%	  tell(OutputFile),
%%	  flora_extern_code(CompiledRuleList,CoderStatus),
%%	  ( CoderStatus == [] ->
%%	      FileStatus=FLORA_SUCCESS
%%	  ;
%%	    flora_coder_error(CoderStatus),
%%	    FileStatus=FLORA_FAILURE
%%	  ),
%%	  told,
%%	  tell(PreOutFile),
%%	  cputime(T1),
%%	  T is T1-T0,
%%	  flora_message_line('Done! CPU time used: %S seconds',args(T))
%%	),
%%	!.

