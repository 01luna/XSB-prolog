/* File:      flrutils.P
**
** Author(s): Guizhen Yang
**
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) The Research Foundation of SUNY, 1999-2001
** 
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: flrutils.P,v 1.40 2001-06-13 00:36:34 kifer Exp $
**
*/


:- compiler_options([xpp_on]).


#define FLORA_FILE_EXT		flr
#define FLORA_INCLUDE_EXT	fli
#define FLORA_HEADER_EXT	flh
#define FLORA_FDB_EXT		fdb
#define XSB_PFILE_EXT		'P'
#define XSB_OFILE_EXT		'O'
#define XSB_HFILE_EXT		'H'
#define FLORA_FAILURE		failure
#define FLORA_SUCCESS		success
#define FLORA_NOOP		noop
#define FLORA_ALL		all
#define FLORA_FILE		file
#define FLORA_COMMANDLINE	commandline

#include "char_defs.h"
#include "flag_defs_xsb.h"
#include "flora_terms.flh"


/*************************************************************************
  flora_compile_internal(+File)
*************************************************************************/
flora_compile_internal(File) :-
	flora_compile_internal(File,FLORA_DEFAULT_WORKSPACE).


/*************************************************************************
  flora_compile_internal(+File,+Workspace)
*************************************************************************/
flora_compile_internal(File,Workspace) :-
	flora_check_filename(File),
	flora_check_workspace(Workspace),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flcompile(FlrFile,Workspace)

	; parse_filename(File,_,_,Ext), Ext \== '', Ext \== FLORA_FILE_EXT,
          path_sysop(exists,File)
	->
	    flora_stderr_nl,
	    flora_error_line("%s: Filename extension must be %s!",
			     args(File,FLORA_FILE_EXT)),
	    fail
	;
	  flora_stderr_nl,
	  flora_error_line("File %s[.%s] does not exist!",
			   args(File,FLORA_FILE_EXT)),
          fail
        ),
	!.



/**********************************************************************
  flora_load_module_internal(+File,+Workspace)
  File must be a FLORA file.
**********************************************************************/
flora_load_module_internal(InFile,Workspace) :-
	flora_check_filename(InFile),
	flora_check_workspace(Workspace),
	(InFile == user
	->  path_sysop(tmpfilename,File),
	    str_cat(File,'.flr',FlrFile),
	    flora_save_user_clauses(FlrFile)
	;   InFile = File
	),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flload(FlrFile,Workspace)

	; parse_filename(File,_,_,Ext), not member(Ext,['',FLORA_FILE_EXT]),
	    path_sysop(exists,File)
	->  flora_stderr_nl,
	    flora_error_line("%s: Filename extension must be %s!",
			     args(File,FLORA_FILE_EXT)),
	    fail
	;
	  flora_stderr_nl,
	  flora_error_line("File %s[.%s] does not exist!",
			   args(File,FLORA_FILE_EXT)),
          fail
        ),
	!.


/**********************************************************************
  flora_load_module_internal(+File)
  File may be a FLORA file, .P file, or .O file.
**********************************************************************/
flora_load_module_internal(InFile) :-
	flora_check_filename(InFile),
	(InFile == user
	->  path_sysop(tmpfilename,File),
	    str_cat(File,'.flr',FlrFile),
	    flora_save_user_clauses(FlrFile)
	;   InFile = File
	),
	( flora_locate_file(File,FLORA_FILE_EXT,FlrFile) ->
	    flora_flload(FlrFile,FLORA_DEFAULT_WORKSPACE)

	; flora_locate_file(File,XSB_PFILE_EXT,PFile) ->
	    flora_stdmsg_nl,
	    flora_message_line("consulting %s",args(PFile)),
	    consult(PFile)

	; flora_locate_file(File,XSB_OFILE_EXT,OFile) ->
	    flora_stdmsg_nl,
	    flora_message_line("consulting %s",args(OFile)),
	    consult(OFile)

	; parse_filename(File,_,_,Ext),
	    not member(Ext,['',XSB_OFILE_EXT,XSB_PFILE_EXT,FLORA_FILE_EXT]),
	    path_sysop(exists,File)
	->
	    flora_stderr_nl,
	    flora_error_line("%s: Filename extension must be %s, %s or %s!",
	                     args(File,
				  FLORA_FILE_EXT,XSB_PFILE_EXT,XSB_OFILE_EXT)),
	    fail
	;
	  flora_stderr_nl,
	  flora_error_line("File %s[.{%s|%s|%s}] does not exist!",
			   args(File,
				FLORA_FILE_EXT,XSB_PFILE_EXT,XSB_OFILE_EXT)),
          fail
        ),
	!.



/**********************************************************************
  flloadtrailer(+TrailerName,+Workspace)
  TrailerName must be either NONE, or BASIC, or FLOGIC.
**********************************************************************/
flloadtrailer(TrailerName) :-
	flloadtrailer(TrailerName,FLORA_DEFAULT_WORKSPACE).

flloadtrailer(TrailerName,Workspace) :-
	( TrailerName \== NONE, TrailerName \== BASIC, TrailerName \== FLOGIC ->
	    flora_error_line("Equality must be `%s', or `%s', or `%s'!",args(NONE,BASIC,FLOGIC)),
	    fail
	;
	  %% Get the trailer file name in Flora package.
	  flora_check_workspace(Workspace),
	  package_configuration(dir(flora),FloraDir),
	  slash(S),
	  flora_trailer_filename(TrailerName,TrailerFileName),
	  fmt_write_string(TrailerFullName,"%s%strailer%s%s",args(FloraDir,S,S,TrailerFileName)),

	  %% Get file names in user dir.
	  flora_user_flora_dir(UserFloraDir),
	  fmt_write_string(UserTrailerName,"%s%s%s",args(UserFloraDir,S,TrailerFileName)),
	  flora_WSP_filename(UserTrailerName,Workspace,UserTrailerWSPFile),
	  flora_WSO_filename(UserTrailerName,Workspace,UserTrailerWSOFile),
	  %% Load the trailer.
	  ( flora_file_newerthan(UserTrailerWSOFile,TrailerFullName) ->
	      true
	  ;
	    flora_copy_file(TrailerFullName,UserTrailerWSPFile),
	    flora_set_xpp_options(Workspace),
	    compile(UserTrailerWSPFile,[optimize,spec_repr]),
	    flora_clear_xpp_options
	  ),
	  consult(UserTrailerWSOFile),
	  !,
	  %% Check if the patch needs to be loaded.
	  flora_wspredicate(FLORA_THIS_MODULE,[],Workspace,Predicate),
	  (current_predicate(Predicate/1) -> true; flloadpatch(Workspace))
        ),
	!.


/**********************************************************************
  flsetuptrailer(+TrailerName)
  TrailerName must be either NONE, or BASIC, or FLOGIC.
  This predicate is called in the Makefile.
**********************************************************************/
flsetuptrailer(TrailerName) :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	flora_trailer_filename(TrailerName,TrailerFileName),
	fmt_write_string(TrailerFullName,"%s%strailer%s%s",args(FloraDir,S,S,TrailerFileName)),
	telling(PreOutFile),
	tell(TrailerFullName),
	flora_trailer_include(TrailerName,TrailerInclude),
	flora_include_file([FLHEADER,FLDBDYN|TrailerInclude],HeaderStatus),
	told,
	tell(PreOutFile),
	!,
	( HeaderStatus == FLORA_FAILURE ->
	    fail
	;
	  flora_set_xpp_options(FLORA_DEFAULT_WORKSPACE),
	  compile(TrailerFullName,[optimize,spec_repr]),
	  flora_clear_xpp_options
	),
	!.

flora_trailer_filename(NONE,'standard.P').
flora_trailer_filename(BASIC,'eqlbasic.P').
flora_trailer_filename(FLOGIC,'eqlflogic.P').

flora_trailer_include(NONE,[FLTRAILER]).
flora_trailer_include(BASIC,[FLEQLTRAILER]).
flora_trailer_include(FLOGIC,[FLEQLTRAILER,FLSCALAREQL]).


/**********************************************************************
  flloadpatch(+Workspace)
**********************************************************************/
flloadpatch(Workspace) :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	flora_patch_filename(PatchName),
	fmt_write_string(PatchFullName,"%s%strailer%s%s",args(FloraDir,S,S,PatchName)),
	%% Get file names in user dir.
	flora_user_flora_dir(UserFloraDir),
	fmt_write_string(UserPatchName,"%s%s%s",args(UserFloraDir,S,PatchName)),
	flora_WSP_filename(UserPatchName,Workspace,UserPatchWSPFile),
	flora_WSO_filename(UserPatchName,Workspace,UserPatchWSOFile),
	%% Load the patch.
	( flora_file_newerthan(UserPatchWSOFile,PatchFullName) ->
	    true
	;
	  flora_copy_file(PatchFullName,UserPatchWSPFile),
	  flora_set_xpp_options(Workspace),
	  compile(UserPatchWSPFile,[optimize,spec_repr]),
	  flora_clear_xpp_options
        ),
	consult(UserPatchWSOFile),
	!.


/**********************************************************************
  flsetuppatch
**********************************************************************/
flsetuppatch :-
	package_configuration(dir(flora),FloraDir),
	slash(S),
	flora_patch_filename(PatchName),
	fmt_write_string(PatchFullName,"%s%strailer%s%s",args(FloraDir,S,S,PatchName)),
	telling(PreOutFile),
	tell(PatchFullName),
	flora_include_file([FLHEADER,FLDEFINITION,FLPATCH],HeaderStatus),
	told,
	tell(PreOutFile),
	!,
	( HeaderStatus == FLORA_FAILURE ->
	    fail
	;
	  flora_set_xpp_options(FLORA_DEFAULT_WORKSPACE),
	  compile(PatchFullName,[optimize,spec_repr]),
	  flora_clear_xpp_options
	),
	!.


flora_patch_filename('patch.P').


/*************************************************************************
  flora_user_flora_dir(-Dir)
*************************************************************************/
flora_user_flora_dir(Dir) :-
	( package_configuration(user_dir(flora),Dir) ->
	    true
	;
	    xsb_configuration(user_home,UserHome),
	    slash(S),
	    fmt_write_string(Dir,"%s%s.xsb%sflora",args(UserHome,S,S)),
	    ( file_exists(Dir) ->
		true
	    ;
		( path_sysop(mkdir,Dir) ->
		    true
		;
		    flora_error_line("Cannot create directory %s!",args(Dir)),
		    abort
		)
	    ),
	    assert(package_configuration(user_dir(flora),Dir))
	),
	!.


/*************************************************************************
  flora_flcompile(+FlrFile,+Workspace)
*************************************************************************/
flora_flcompile(FlrFile,Workspace) :-
	flora_mainP_filename(FlrFile,MPFile),
	flora_FDB_filename(FlrFile,FDBFile),
	flora_compile_file(FlrFile,MPFile,FDBFile,Status),
	( Status == FLORA_FAILURE ->
	    fail
	;
	  flora_WSP_filename(FlrFile,Workspace,WSPFile),
	  flora_copy_file(MPFile,WSPFile),
	  flora_message_line("calling XSB compiler"),
	  flora_set_xpp_options(Workspace),
	  compile(WSPFile,[optimize,spec_repr]),
	  flora_clear_xpp_options
        ),
	!.


/*************************************************************************
  flora_flload(+File,+Workspace)
*************************************************************************/
flora_flload(File,Workspace) :-
	flora_mainP_filename(File,MPFile),
	flora_FDB_filename(File,FDBFile),
	flora_WSP_filename(File,Workspace,WSPFile),
	flora_WSO_filename(File,Workspace,WSOFile),
	!,
        ( flora_file_newerthan(WSPFile,File) ->
	    flora_stdmsg_nl,
	    true
	;
	    ( flora_file_newerthan(MPFile,File) ->
		flora_stdmsg_nl,
		true
	    ;
		flora_compile_file(File,MPFile,FDBFile,Status),
		(Status == FLORA_FAILURE -> fail; true)
	    ),
	    flora_copy_file(MPFile,WSPFile)
        ),
	!,
	( flora_file_newerthan(WSOFile,WSPFile) ->
	    ConsultFile=WSOFile
	;
	    ConsultFile=WSPFile
        ),
	flora_message_line("loading %s into module %s", args(File,Workspace)),
	flora_set_xpp_options(Workspace),
        consult(ConsultFile),
	flora_clear_xpp_options,
	!.

/*****************************************************************************
  flora_save_user_clauses(+FlrFile)
  Read user input and save it in the given file
*****************************************************************************/
flora_save_user_clauses(FlrFile) :-
	flora_message_line('Enter FLORA program clauses. When done, type Ctl-D.'),
	file_open(FlrFile,w,Port),
	stat_flag(CURRENT_INPUT, InPort),
	copyIOport(InPort,Port),
	file_close(Port),
	flora_message_line('User program saved in file %s', arg(FlrFile)).


/*************************************************************************
  flora_locate_file(+InFile,+ExtType,-ExtFile)

  InFile must have ExtType as extension or no extension (in this case,
  ExtType is appended).
*************************************************************************/
flora_locate_file(InFile,ExtType,ExtFile) :-
	parse_filename(InFile,_,_,Ext),
	( Ext == ExtType ->
	    ExtFileName=InFile
	;
	    fmt_write_string(ExtFileName,"%s.%s",args(InFile,ExtType))
	),
	flora_locate_file(ExtFileName,ExtFile),
	!.


/*************************************************************************
  flora_locate_file(+InFile,-LocatedFile)
*************************************************************************/
flora_locate_file(In,In) :-
	is_absolute_filename(In),
	!,
	file_exists(In).

flora_locate_file(In,Loc) :-
	flora_library_directory(LibDir),
	slash(S),
	fmt_write_string(Loc,"%s%s%s",args(LibDir,S,In)),
	file_exists(Loc),
	!.


/*************************************************************************
  flora_file_newerthan(+File1,+File2)
  returns true iff File1 exists and is newer than File2. File2 already exists.
*************************************************************************/
flora_file_newerthan(File1,File2) :-
	file_exists(File1),
	file_time(File1,time(F1Time1,F1Time2)),
	file_time(File2,time(F2Time1,F2Time2)),
	time(F1Time1,F1Time2) @> time(F2Time1,F2Time2).


/*************************************************************************
  flora_library_directory(-Dir)
  returns directories to search a FLORA file.
*************************************************************************/
flora_library_directory('.').
flora_library_directory(LibDir) :- library_directory(LibDir).
flora_library_directory(LibDir) :- xsb_configuration(libdir,LibDir).
flora_library_directory(LibDir) :- xsb_configuration(syslibdir,LibDir).
flora_library_directory(LibDir) :- xsb_configuration(cmplibdir,LibDir).


/*************************************************************************
  flora_mainP_filename(+File,-MPFile)
  flora_FDB_filename(+File,-FDBFile)
  flora_FLH_filename(+File,-FLHFile)
  flora_WSP_filename(+File,+WS,-WSPFile)
  flora_WSO_filename(+File,+WS,-WSOFile)
*************************************************************************/
flora_mainP_filename(File,MPFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(MPFile,"%s%s.%s",args(Dir,Base,XSB_PFILE_EXT)).

flora_FDB_filename(File,FDBFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(FDBFile,"%s%s.%s",args(Dir,Base,FLORA_FDB_EXT)).

flora_FLH_filename(File,FLHFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(FLHFile,"%s%s.%s",args(Dir,Base,FLORA_HEADER_EXT)).

flora_WSP_filename(File,WS,WSPFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(WSPFile,"%s%s_%s.%s",args(Dir,Base,WS,XSB_PFILE_EXT)).

flora_WSO_filename(File,WS,WSOFile) :-
	parse_filename(File,Dir,Base,_),
	fmt_write_string(WSOFile,"%s%s_%s.%s",args(Dir,Base,WS,XSB_OFILE_EXT)).


/*************************************************************************
  utilities
*************************************************************************/
flora_check_filename(Name) :-
	( not atom(Name) ->
	    flora_error_line("invalid file name"),
	    fail
	;
	  true
	).


flora_check_workspace(Name) :-
	( var(Name) ->
	    flora_error_line('uninstantiated module name'),
	    fail
	; not atom(Name) ->
	    flora_error_heading,
	    flora_stderr_string('invalid module name: '),
	    flora_stderr_write(Name),
	    flora_stderr_nl,
	    fail
	;
	  true
	).


flora_copy_file(Source,Dest) :-
	path_sysop(copy,Source,Dest).


/*************************************************************************
  gpp control utilities
*************************************************************************/
flora_set_xpp_options :-
	retractall(xpp_options(_)),
	assert(xpp_options('-P -m -nostdinc -curdirinclast')).


flora_set_xpp_options(WS) :-
	fmt_write_string(Opt,'-P -m -nostdinc -curdirinclast -D FLORA_VAR_WORKSPACE=%s',args(WS)),
	retractall(xpp_options(_)),
	assert(xpp_options(Opt)).


flora_clear_xpp_options :- retractall(xpp_options(_)).


/*************************************************************************
  flora_loaddyn_FDB_filename(+FileName)
*************************************************************************/
flora_loaddyn_FDB_filename(FileName) :-
	parse_filename(FileName,_,Base,_),
	fmt_write_string(FDBFileName,"%s.%s",args(Base,FLORA_FDB_EXT)),
	current_output_port(OutPort),
	fmt_write(OutPort,":- import load_dyn/1 from consult.\n",_),
	fmt_write(OutPort,"?- load_dyn('%s').\n\n",args(FDBFileName)).


/*************************************************************************
  flora_include_file(+OptionList,-Status)
*************************************************************************/
flora_include_file([],FLORA_SUCCESS) :- !.

flora_include_file([Opt|OptList],Status) :-
	flora_include(Opt,File),
	!,
	package_configuration(dir(flora),FloraDir),
	slash(S),
	fmt_write_string(FullName,"%s%s%s",args(FloraDir,S,File)),
	( file_exists(FullName) ->
	    print_file_contents(FullName),
	    flora_include_file(OptList,Status)
	;
	  flora_error_line("The FLORA system file %s cannot be found!",args(FullName)),
          Status=FLORA_FAILURE
	).

flora_include_file(_OptList,FLORA_FAILURE) :-
	  flora_error_line("system file corrupted!").


/*************************************************************************
  flora_end_of_input(+Status)
  flora_not_end_of_input(+Status)
*************************************************************************/
flora_end_of_input(Status) :- member(FLORA_EOF,Status).
flora_not_end_of_input(Status) :- member(FLORA_NOT_EOF,Status).


/*************************************************************************
  flora_reset_modules_for_file/0
*************************************************************************/
flora_reset_modules_for_file :-
	flora_reset_lexer,
	flora_reset_operator,
	flora_reset_arguments,
	flora_reset_prolog,
	flora_reset_firstorder,
	flora_reset_compiler,
	conset(flora_shell_mode,0).


/*************************************************************************
  flora_reset_modules_for_shell/0
*************************************************************************/
flora_reset_modules_for_shell :-
	flora_reset_lexer,
	flora_reset_compiler,
	conset(flora_shell_mode,1).


/*************************************************************************
  flora_compile_file(+InputFile,+OutputPFile,+OutputDBFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
flora_compile_file(InputFile,PFile,DBFile,FileStatus) :-
	flora_maxerr(MaxErrNum),
	flora_stdmsg_nl,
	flora_message_line("compiling %s",args(InputFile)),
	cputime(T0),
	seeing(PreInFile),
	flora_reset_modules_for_file,
	flora_set_xpp_options,
	xpp_process_file(InputFile,XPP_process,IOportFromProc),
	stat_set_flag(CURRENT_INPUT,IOportFromProc),
	flora_rpc_file(MaxErrNum,0,0,CompiledRuleList,FileOptionList,CompileStatus),
	%% Wait, not to leave zombies.
	process_control(XPP_process,wait),
	%% Release the file descriptor used to read from cpp.
	file_close(IOportFromProc),
	flora_clear_xpp_options,
	see(PreInFile),
	( CompileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  flora_generate_file(CompiledRuleList,FileOptionList,PFile,DBFile,FileStatus)
        ),
	cputime(T1),
	( FileStatus == FLORA_FAILURE ->
	    true
	;
	  T is T1-T0,
	  flora_message_line("Done! CPU time used: %S seconds",args(T))
	),
	!.


/*************************************************************************
  flora_generate_file(+CompiledRuleList,+FileOptionList,+PFile,+DBFile,-FileStatus)

  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
flora_generate_file(CompiledRuleList,FileOptionList,PFile,DBFile,FileStatus) :-
	flora_divide_program(CompiledRuleList,RuleList,FlogicFactList),
	sort(FileOptionList,FileOptions),
	flora_generate_Pfile(PFile,FileOptions,RuleList,FlogicFactList,PFileStatus),
	( PFileStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  ( FlogicFactList == [] ->
	      FileStatus=FLORA_SUCCESS
	  ;
	    flora_generate_DBfile(DBFile,FlogicFactList,FileStatus)
	  )
        ),
	!.


/*************************************************************************
  flora_generate_Pfile(+PFileName,+FileOptionList,+RuleList,+FlogicFactList,-FileStatus)

  Things to do:
  (1) include .flh file directive.
  (2) output header file.
  (3) syslib loading instrucitons.
  (4) DB file loading instruction.
  (5) program.
  (6) trailer.
*************************************************************************/
flora_generate_Pfile(PFileName,FileOptionList,RuleList,FlogicFactList,FileStatus) :-
	telling(PreOutFile),
	tell(PFileName),
	findall(LibOption,member(FLSYSLIB(LibOption),FileOptionList),LibOptionList),
	%% FLLIBCONTROL (sylibinc/flrcontrol_inc.flh) should probably 
	%% be included by the compiler
	flora_include_file([FLHEADER,FLDBDYN,FLDEFINITION,FLPATCH,FLLIBCONTROL|LibOptionList],HeaderStatus),
	( HeaderStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  (FlogicFactList == [] -> true; flora_loaddyn_FDB_filename(PFileName)),
	  flora_extern_code(RuleList,CoderStatus),
	  ( CoderStatus == [] ->
	      ( member(FLEQLFLOGIC,FileOptionList) ->
		  flora_message_line('including full F-logic equality maintenance'),
		  flora_include_file([FLEQLTRAILER,FLSCALAREQL],FileStatus)

	      ; member(FLEQLBASIC,FileOptionList) ->
	          flora_message_line('including basic equality maintenance'),
		  flora_include_file([FLEQLTRAILER],FileStatus)
	      ;
	        flora_include_file([FLTRAILER],FileStatus)
	      )
	  ;
	    flora_coder_error(CoderStatus),
	    FileStatus=FLORA_FAILURE
	  )
        ),
	told,
	tell(PreOutFile),
	!.


/*************************************************************************
  flora_generate_DBfile(+DBFileName,+FlogicFactList,-FileStatus)

  Things to do:
  (1) include .flh file directive.
  (2) output header file.
  (3) F-logic facts.
*************************************************************************/
flora_generate_DBfile(DBFileName,FlogicFactList,FileStatus) :-
	telling(PreOutFile),
	tell(DBFileName),
	flora_include_file([FLHEADER,FLDBDYN],HeaderStatus),
	( HeaderStatus == FLORA_FAILURE ->
	    FileStatus=FLORA_FAILURE
	;
	  flora_extern_code(FlogicFactList,CoderStatus),
	  ( CoderStatus == [] ->
	      FileStatus=FLORA_SUCCESS
	  ;
	    flora_coder_error(CoderStatus),
	    FileStatus=FLORA_FAILURE
	  )
        ),
	told,
	tell(PreOutFile),
	!.



/*************************************************************************
  flora_rpc_file(+MaxErr,+ErrNum,+WarnNum,-CompiledRuleList,-FileOptionList,-FileStatus)
*************************************************************************/
flora_tailappend(V,[],V) :- !.
flora_tailappend([H|V],[H|L],T) :- flora_tailappend(V,L,T).


%% Calls the compiler. This is used to wrap templates, like trailers, 
%% with the WORKSPACE macros.
flora_rpc_file(MaxErr,ErrNum,WarnNum,CompiledRuleList,FileOptionList,FileStatus) :-
	flora_read_parse_compile(FLORA_FILE,Tokens,FlattenedRules,RuleOptions,RuleStatus),
	member(error(EN),RuleStatus),
	member(warning(WN),RuleStatus),
	NewErrNum is ErrNum+EN,
	NewWarnNum is WarnNum+WN,
	( EN > 0 -> %% errors just found
	    ( MaxErr \== FLORA_ALL, NewErrNum >= MaxErr ->
		FileStatus=FLORA_FAILURE,
		flora_stderr_string("\n"),
		flora_errorwarn_count(NewErrNum,NewWarnNum),
		flora_stderr_string("\n++compilation aborted\n")

	    ; flora_rule_delimeter_struct(_,_,_,_,_,RuleDelimeterToken),
	      flora_not_end_of_input(RuleStatus), member(RuleDelimeterToken,Tokens) ->
	        flora_rpc_file(MaxErr,NewErrNum,NewWarnNum,
                               _CompiledRuleList,_FileOptionList,FileStatus)

	    ; flora_not_end_of_input(RuleStatus), flora_discard_tokens ->
	        flora_rpc_file(MaxErr,NewErrNum,NewWarnNum,
                               _CompiledRuleList,_FileOptionList,FileStatus)
	    ;
	      FileStatus=FLORA_FAILURE,
	      flora_stderr_string("\n"),
	      flora_errorwarn_count(NewErrNum,NewWarnNum),
	      flora_stderr_string("\n++compilation aborted\n")
	    )
	;
	  ( NewErrNum == 0 -> %% no error so far
	      flora_tailappend(CompiledRuleList,FlattenedRules,NewCompiledRuleList),
	      flora_tailappend(FileOptionList,RuleOptions,NewFileOptionList)
	  ;
	    true
	  ),
	  ( flora_not_end_of_input(RuleStatus) ->
	      flora_rpc_file(MaxErr,NewErrNum,NewWarnNum,
                             NewCompiledRuleList,NewFileOptionList,FileStatus)
	  ; %% end of file already
	    ( NewErrNum == 0 ->
		NewCompiledRuleList=[],
		NewFileOptionList=[],
		FileStatus=FLORA_SUCCESS,
		( NewWarnNum == 0 ->
		    true
		;
		  flora_stdwarn_string("\n"),
		  flora_errorwarn_count(NewErrNum,NewWarnNum)
		)
	    ;
	      FileStatus=FLORA_FAILURE,
	      flora_stderr_string("\n"),
	      flora_errorwarn_count(NewErrNum,NewWarnNum),
	      flora_stderr_string("\n++compilation aborted\n")
	    )
	  )
	),
	!.


/*************************************************************************
  flora_discard_tokens/0
  scans the input until a rule delimeter is found. It fails if eof.
*************************************************************************/
flora_discard_tokens :-
	flora_warning_line("discarding tokens (rule delimeter `.' or EOF expected)"),
	repeat,
	flora_tokens(Tokens,Status),
	flora_rule_delimeter_struct(_Txt,_LN1,_CN1,_LN2,_CN2,RuleDelimeterToken),
	( flora_end_of_input(Status) ->
	    !,
	    fail
	
	; member(RuleDelimeterToken,Tokens) ->
	    !
	;
	  fail
        ).


/*************************************************************************
  flora_read_parse_compile(+Option,-Tokens,-FlattenedRuleList,-OptionList,-Status)

  Note: This procedure can be used to read both file and command line.
        For reading file, Option is FLORA_FILE. For reading command line,
        Option is FLORA_COMMANDLINE.
*************************************************************************/
flora_read_parse_compile(Option,Tokens,FlattenedRules,OptionList,Status) :-
	flora_tokens(InputTokens,LexerStatus),
	flora_lexer_error(InputTokens,LexerStatus,LexErrNum),
	( LexErrNum > 0 ->
	    Tokens=InputTokens,
	    FlattenedRules=[],
	    OptionList=[],
	    ErrNum=LexErrNum,
	    WarnNum=0

	; flora_blank_line(InputTokens) ->
	    Tokens=InputTokens,
	    FlattenedRules=[],
	    OptionList=[],
	    ErrNum=0,
	    WarnNum=0
	;
	  ( Option == FLORA_COMMANDLINE ->
	      flora_symbol_token_struct("?-",1,0,1,0,QueryOpToken),
	      Tokens=[QueryOpToken|InputTokens]
	  ;
	    Tokens=InputTokens
	  ),
	  flora_compose(Tokens,ComposerTerm,ComposerStatus),
	  flora_composer_errorwarn(Tokens,ComposerStatus,CompoErrNum,CompoWarnNum),
	  ( CompoErrNum > 0 ->
	      FlattenedRules=[],
	      OptionList=[],
	      ErrNum=CompoErrNum,
	      WarnNum=CompoWarnNum
	  ;
	    flora_parse(ComposerTerm,ParserTerm,ParserStatus),
	    flora_parser_error(Tokens,ParserStatus,ParErrNum),
	    ( ParErrNum > 0 ->
		FlattenedRules=[],
		OptionList=[],
		ErrNum=ParErrNum,
		WarnNum=CompoWarnNum
	    ;
	      flora_compile(ParserTerm,FlattenedRules,OptionList,CompilerStatus),
	      flora_compiler_errorwarn(Tokens,CompilerStatus,CompiErrNum,CompiWarnNum),
	      ErrNum=CompiErrNum,
	      WarnNum is CompoWarnNum+CompiWarnNum
	    )
	  )
        ),
	EWS=[error(ErrNum),warning(WarnNum)],
	(flora_end_of_input(LexerStatus) -> Status=[FLORA_EOF|EWS]; Status=[FLORA_NOT_EOF|EWS]).


/*************************************************************************
  flora_good_command(+Status)
  flora_bad_command(+Status)
  flora_noop_command(+Status)
*************************************************************************/
flora_good_command(Status) :- member(FLORA_SUCCESS,Status).
flora_bad_command(Status) :- member(FLORA_FAILURE,Status).
flora_noop_command(Status) :- member(FLORA_NOOP,Status).


/*************************************************************************
  flora_shell_command_line(-Code,-Options,-Status)
*************************************************************************/
flora_shell_command_line(Code,Options,Status) :-
	flora_reset_modules_for_shell,
	flora_read_parse_compile(FLORA_COMMANDLINE,Tokens,Rules,RuleOptions,RuleStatus),
	member(error(ErrNum),RuleStatus),
	( ErrNum > 0 ->
	    ( flora_end_of_input(RuleStatus) ->
		InputStatus=FLORA_EOF

	    ; flora_rule_delimeter_struct(_,_,_,_,_,RuleDelimeterToken),
	      member(RuleDelimeterToken,Tokens) ->
		InputStatus=FLORA_NOT_EOF

	    ; flora_discard_tokens ->
	        InputStatus=FLORA_NOT_EOF
	    ;
	      InputStatus=FLORA_EOF
	    ),
	    Status=[InputStatus,FLORA_FAILURE]
	;
	  ( Rules == [] ->
	      CommandStatus=FLORA_NOOP
	  ;
	    flora_intern_code(Rules,FLORA_DEFAULT_WORKSPACE,Code,CoderStatus),
	    ( CoderStatus == [] ->
		CommandStatus=FLORA_SUCCESS
	    ;
	      flora_coder_error(CoderStatus),
	      CommandStatus=FLORA_FAILURE
	    )
	  ),
	  sort(RuleOptions,Options),
	  ( flora_end_of_input(RuleStatus) ->
	      Status=[FLORA_EOF,CommandStatus]
	  ;
	    Status=[FLORA_NOT_EOF,CommandStatus]
	  )
	),
	!.


/*************************************************************************
  utilities
*************************************************************************/
flora_errorwarn_count(ErrNum,WarnNum) :-
	( ErrNum == 1 ->
	    flora_stderr_string("++1 error\n")

	; ErrNum > 1 ->
	    flora_stderr_string("++%d errors\n",args(ErrNum))
	;
	  true
        ),
	( WarnNum == 1 ->
	    flora_stdwarn_string("++1 warning\n")

	; WarnNum > 1 ->
	    flora_stdwarn_string("++%d warnings\n",args(WarnNum))
	;
	  true
        ),
	!.


flora_last_element([T],T).
flora_last_element([_|L],T) :- flora_last_element(L,T).


flora_nth_element([T|_],1,T) :- !.
flora_nth_element([_|L],N,T) :- M is N-1, flora_nth_element(L,M,T).


/*************************************************************************
  flora_lexer_error(+Tokens,+LexerStatus,-ErrNum)
*************************************************************************/
flora_lexer_error(Tokens,LexerStatus,ErrNum) :-
	( member(error(Msg),LexerStatus) ->
	    flora_last_element(Tokens,Tk),
	    flora_token_text(Tk,TextStr,_BLN,_BCN,ELN,ECN),
	    flora_error_line("[Lexer] near line(%d)/char(%d) `%s'",
	                     args(ELN,ECN,TextStr)),
	    flora_error_indentline,
	    flora_stderr_string("%s\n",args(Msg)),
	    ErrNum=1
	;
	  ErrNum=0
        ).


/*************************************************************************
  flora_composer_errorwarn(+Tokens,+ComposerStatus,-ErrNum,-WarnNum)
*************************************************************************/
flora_composer_errorwarn(_Tokens,[],0,0) :- !.

flora_composer_errorwarn(Tokens,[error(Indx,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_error_line("[Composer] near line(%d)/char(%d) `%s'",
                         args(BLN,BCN,TextStr)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_composer_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.

flora_composer_errorwarn(Tokens,[error(I1,I2,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,I1,Tk1),
	flora_nth_element(Tokens,I2,Tk2),
	flora_token_text(Tk1,TextStr1,BLN1,BCN1,_ELN1,_ECN1),
	flora_token_text(Tk2,TextStr2,BLN2,BCN2,_ELN2,_ECN2),
	flora_error_line("[Composer] near line(%d)/char(%d) `%s' and near line(%d)/char(%d) `%s'",
	                 args(BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_composer_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.

flora_composer_errorwarn(Tokens,[warning(I1,I2,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,I1,Tk1),
	flora_nth_element(Tokens,I2,Tk2),
	flora_token_text(Tk1,TextStr1,BLN1,BCN1,_ELN1,_ECN1),
	flora_token_text(Tk2,TextStr2,BLN2,BCN2,_ELN2,_ECN2),
	flora_warning_line("[Composer] near line(%d)/char(%d) `%s' and near line(%d)/char(%d) `%s'",
	                   args(BLN1,BCN1,TextStr1,BLN2,BCN2,TextStr2)),
	flora_warning_indentline,
	flora_stdwarn_string("%s\n",args(Msg)),
	flora_composer_errorwarn(Tokens,L,ErrNum,WN),
	WarnNum is WN+1.

flora_composer_errorwarn(Tokens,[error(Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_error_line("[Composer] %s",args(Msg)),
	flora_composer_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.


/*************************************************************************
  flora_parser_error(+Tokens,+ParserStatus,-ErrNum)
*************************************************************************/
flora_parser_error(_Tokens,[],0) :- !.

flora_parser_error(Tokens,[error(Indx,Msg)|L],ErrNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_error_line("[Parser] near line(%d)/char(%d) `%s'",
                         args(BLN,BCN,TextStr)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_parser_error(Tokens,L,EN),
	ErrNum is EN+1.

flora_parser_error(Tokens,[error(Msg)|L],ErrNum) :-
	!,
	flora_error_line("[Parser] %s",args(Msg)),
	flora_parser_error(Tokens,L,EN),
	ErrNum is EN+1.


/*************************************************************************
  flora_compiler_errorwarn(+Tokens,+CompilerStatus,-ErrNum,-WarnNum)
*************************************************************************/
flora_compiler_errorwarn(_Tokens,[],0,0) :- !.

flora_compiler_errorwarn(Tokens,[error(Indx,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_error_line("[Compiler] near line(%d)/char(%d) `%s'",
                         args(BLN,BCN,TextStr)),
	flora_error_indentline,
	flora_stderr_string("%s\n",args(Msg)),
	flora_compiler_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.

flora_compiler_errorwarn(Tokens,[warning(Indx,Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_nth_element(Tokens,Indx,Tk),
	flora_token_text(Tk,TextStr,BLN,BCN,_ELN,_ECN),
	flora_warning_line("[Compiler] near line(%d)/char(%d) `%s'",
                           args(BLN,BCN,TextStr)),
	flora_warning_indentline,
	flora_stdwarn_string("%s\n",args(Msg)),
	flora_compiler_errorwarn(Tokens,L,ErrNum,WN),
	WarnNum is WN+1.

flora_compiler_errorwarn(Tokens,[error(Msg)|L],ErrNum,WarnNum) :-
	!,
	flora_error_line("[Compiler] %s",args(Msg)),
	flora_compiler_errorwarn(Tokens,L,EN,WarnNum),
	ErrNum is EN+1.


/*************************************************************************
  flora_coder_error(+CoderStatus)
*************************************************************************/
flora_coder_error([]) :- !.

flora_coder_error([error(Msg)|L]) :-
	!,
	flora_error_line("[Coder] %s",args(Msg)),
	flora_coder_error(L).


/*****************************************************************************
  flora_list2conjunct(+List,-Goal)
*****************************************************************************/
flora_list2conjunct([G],G) :- !.

flora_list2conjunct([G|L],Goal) :-
	!,
	flora_list2conjunct(L,LG),
	Goal =.. [',',G,LG].


/*************************************************************************
  flMaxerr(+Num)
*************************************************************************/
:- flMaxerr(8).

flMaxerr(X) :-
	( var(X) ->
	    flora_maxerr(X)

	; X \== FLORA_ALL, (not integer(X); X < 1) ->
	    flora_error_line("invalid argument to maxerr"),
	    fail
	;
	  retractall(flora_maxerr(_)),
	  assert(flora_maxerr(X))
	).

flP2H(PrologTerm,HiLogTerm) :- plg2hlg(PrologTerm,HiLogTerm,WRAP_HILOG).


flHalt :- halt.


/*************************************************************************
%%  flCompileInclude(+File)
%%  This is used only in the closure/Makefile
%%  It takes a trailer template and wraps it with the workspace and 
%%  flora prefixes. This way the trailer is easier to maintain and understand.
%%
%%  The included file is treated as a Flora program, so the compiler wraps it 
%%  with the appropriate macros (e.g., WORKSPACE), as it would any other
%%  Flora program.
*************************************************************************/
%%flCompileInclude(File) :-
%%	flora_check_filename(File),
%%	( flora_locate_file(File,FLORA_INCLUDE_EXT,FLIFile) ->
%%	    flora_FLH_filename(FLIFile,FLHFile),
%%	    flora_compile_incfile(FLIFile,FLHFile,Status),
%%	    (Status == FLORA_FAILURE -> fail; true)
%%
%%	; parse_filename(File,_,_,Ext), not member(Ext,['',FLORA_INCLUDE_EXT]),
%%	    path_sysop(exists,File)
%%	->
%%	    flora_stderr_nl,
%%	    flora_error_line("%s: Include filename extension must be %s!",
%%			     args(File,FLORA_INCLUDE_EXT)),
%%	    fail
%%	;
%%	  flora_stderr_nl,
%%	  flora_error_line("File %s[.%s] does not exist!",
%%			   args(File,FLORA_INCLUDE_EXT)),
%%          fail
%%        ),
%%	!.


/*************************************************************************
%%  flora_compile_incfile(+InputFile,+OutputFile,-FileStatus) :-
%%
%%  This compiles the include file (it is called from flCompileInclude/1)
%%  and adds the WORKSPACE and other macros to it.
%%
%%  Note: FileStatus returns either FLORA_FAILURE or FLORA_SUCCESS.
*************************************************************************/
%%flora_compile_incfile(InputFile,OutputFile,FileStatus) :-
%%	flora_stdmsg_nl,
%%	flora_message_line("compiling template include file %s",args(InputFile)),
%%	cputime(T0),
%%	seeing(PreInFile),
%%	flora_reset_modules_for_file,
%%	flora_set_xpp_options,
%%	xpp_process_file(InputFile,XPP_process,IOportFromProc),
%%	stat_set_flag(CURRENT_INPUT,IOportFromProc),
%%	flora_rpc_file(FLORA_ALL,0,0,CompiledRuleList,_FileOptionList,CompileStatus),
%%	%% Wait, not to leave zombies.
%%	process_control(XPP_process,wait),
%%	%% Release the file descriptor used to read from cpp.
%%	file_close(IOportFromProc),
%%	flora_clear_xpp_options,
%%	see(PreInFile),
%%	( CompileStatus == FLORA_FAILURE ->
%%	    FileStatus=FLORA_FAILURE
%%	;
%%	  telling(PreOutFile),
%%	  tell(OutputFile),
%%	  flora_extern_code(CompiledRuleList,CoderStatus),
%%	  ( CoderStatus == [] ->
%%	      FileStatus=FLORA_SUCCESS
%%	  ;
%%	    flora_coder_error(CoderStatus),
%%	    FileStatus=FLORA_FAILURE
%%	  ),
%%	  told,
%%	  tell(PreOutFile),
%%	  cputime(T1),
%%	  T is T1-T0,
%%	  flora_message_line("Done! CPU time used: %S seconds",args(T))
%%	),
%%	!.

