\documentclass[11pt]{article}

\usepackage{epsf,epsfig,subfigure,latexsym,makeidx,latexsym,xspace,amssymb,alltt}
\usepackage{hyperref}

\pagestyle{headings}
\bibliographystyle{plain}

%%\setlength{\topmargin}{-0.25in}
\setlength{\headheight}{10pt}
\setlength{\headsep}{30pt}
\setlength{\oddsidemargin}{0.0in}
\setlength{\evensidemargin}{0.0in}
\setlength{\textheight}{8.5in}
\setlength{\textwidth}{6.5in}
\setlength{\footskip}{50pt}


\setlength{\parskip}{2mm}               % space between paragraphs

\def\cut{\mbox{\tt '!'/0}}

\newtheorem{example}{Example}[section]

\newenvironment{Prog}{\begin{tt}\begin{tabular}[c]{l}}{\end{tabular}\end{tt}}

\newcommand{\comment}[1]{}

\newcommand{\demo}[1]{\hspace*{1.5cm}{\tt #1}}
\newcommand{\desc}[1]{\item[{\tt #1}]\hspace*{1mm}\newline}
\newcommand{\desce}[1]{\item[{\tt #1}]}
\newcommand{\ourrepeatitem}[1]{\item[{\mbox{\tt #1}}]\ \\ \vspace*{-.35in}}
\newcommand{\ouritem}[1]{\item[{\mbox{\tt #1}}]\ \\}
\newcommand{\ournewitem}[2]{\item[{\mbox{\tt #1}}]\hspace*{\fill}{\mbox{\tt #2}}\ \\}

\newcommand{\stuff}[1]{
        \begin{minipage}{4in}
        {\tt \samepage
        \begin{tabbing}
        \hspace{8mm} \= \hspace{6mm} \= \hspace{10mm} \= \hspace{55mm} \= \kill
        #1 \hfill
        \end{tabbing}
        }
        \end{minipage}
}

\newcommand{\longline}{\noindent\rule{\textwidth}{.01in}}


\newenvironment{qrules}{\begin{quote}\tt\begin{tabular}[t]{l}}%
{\end{tabular}\end{quote}}


\newcommand{\obj}{\textit{obj}\xspace}
\newcommand{\db}[1]{\ensuremath{\mathcal{#1}}}

\newcommand{\xany}{\textsf{any}}

\newcommand{\xplus}{\ensuremath{^+}}
\newcommand{\xstar}{\ensuremath{^*}}
\newcommand{\xinv}{\ensuremath{^{-1}}}
\newcommand{\xopt}{\ensuremath{^{?}}}

\newcommand{\xto}[1]{\ensuremath{^{#1}}}
\newcommand{\xcond}[1]{\ensuremath{\textsf{if}(#1)}}
\newcommand{\xif}[1]{\ensuremath{\textsf{if}(#1)}}
\newcommand{\xmu}[1]{\ensuremath{\tcmu(#1)}}
\newcommand{\xmuif}[2]{\ensuremath{\tcmu(#1,#2)}}


\newcommand{\xconc}{\ensuremath{{\cdot}}}
\newcommand{\xor}{\ensuremath{|}}

\newcommand{\nnot}{\mbox{$\neg$}}                           % negation
\newcommand{\query}{\mbox{$\, ?\! - \, $}}                  % query
\newcommand{\impl}                                          % implication
  {\mbox{\Large $\; {\bf \leftarrow} \;$}}  
\newcommand{\isa}{\,{\bf{:}}\,}
\newcommand{\subcl}{\,{\bf{::}}\,}
\newcommand{\eq}{\ensuremath{\doteq}}                           % equation

% f-logic arrows

\newcommand{\fd}{\ensuremath{{\rightarrow}}}                   % scalar
\newcommand{\bfd}{\ensuremath{{\bullet\!\!\!\fd}}}            % " + inheritable
\newcommand{\mvd}{\ensuremath{{\rightarrow\!\!\!\!\rightarrow}}}  % multivalued
\newcommand{\bmvd}{\ensuremath{{\bullet\!\!\!\mvd}}}              % " + inheritable
\newcommand{\Fd}{\ensuremath{{\Rightarrow}}}                      % scalar signature
\newcommand{\Mvd}{\ensuremath{{\Rightarrow\!\!\!\!\Rightarrow}}}  % multiv signature



% curved f-logic arrows

\newcommand{\anyd}{\ensuremath{\leadsto}}                       % noninheritable
\newcommand{\bleadsto}{\ensuremath{\bullet\!\!\!\leadsto}}     % inheritable
\newcommand{\banyd}{\bleadsto}                              % "
\newcommand{\Leadsto}{\ensuremath{\approx}\!\!{>}}            % signature
\newcommand{\Anyd}{\Leadsto}                                % "

\newcommand{\FdConstr}{\ensuremath{\stackrel{constr}{\Fd}}}
\newcommand{\MvdConstr}{\ensuremath{\stackrel{constr}{\Mvd}}}

\newlength{\flogicindent}


\newlength{\flength}
\newlength{\counterlength}


\newcommand{\la}{\ensuremath{\,\leftarrow\,}}

\newcommand{\anon}{\_}

\newcommand{\note}[1]{\textit{[[#1]]}}
\newcommand{\nterm}[1]{\ensuremath{\langle}\textit{#1}\ensuremath{\rangle}}



\newcommand{\bs}{\ensuremath{\backslash}}
\newcommand{\FLIP}{{\mbox{\sc Flip}}\xspace}
\newcommand{\FLORA}{{\mbox{${\cal F}${\small\it LORA}\rm\emph{-2}}}\xspace}
\newcommand{\FLORAone}{{\mbox{${\cal F}${\sc lora}}}\xspace}
\newcommand{\FLORID}{{\mbox{\sc Florid}}\xspace}
\newcommand{\fl}{\mbox{F-logic}\xspace}
\newcommand{\NAF}{{$\tt\backslash +$}\xspace}


\newcommand{\consts}{\ensuremath{\mathcal{C}}}
\newcommand{\funcs}{\ensuremath{\mathcal{F}}}
\newcommand{\preds}{\ensuremath{\mathcal{P}}}
\newcommand{\vars}{\ensuremath{\mathcal{V}}}

\newcommand{\HU}{\ensuremath{U}}
\newcommand{\HB}{\ensuremath{\mathcal{HB}}}
\newcommand{\ext}{\ensuremath{^{\star}}}

\newcommand{\bksl}{\symbol{92}}
\newcommand{\dq}{\symbol{34}}


\title{\FLORA User's Manual}

\author{
  {Guizhen Yang
  \hspace{3cm}
  Michael Kifer}
  \\\\
  Department of Computer Science\\
  University at Stony Brook\\
  Stony Brook, NY 11794-4400
  }
  
\makeindex
\begin{document}

\maketitle
\thispagestyle{empty}

\newpage
\pagenumbering{roman}
\setcounter{page}{1}

\tableofcontents

\newpage

\pagenumbering{arabic}
\setcounter{page}{1}


\section{Introduction}

\FLORA is a sophisticated compiler and application development platform
that translates a unified language of \fl \cite{KLW95}, HiLog
\cite{hilog-jlp}, and Transaction Logic \cite{trans-tcs94} into XSB. It
takes a program written in the \fl language with HiLog and Transaction
Logic extensions (which must be in a file with extension {\tt .flr}, {\it
  e.g.}, {\tt file.flr}) and outputs a regular XSB program (with extension
{\tt .P}).  This program is then passed to XSB for compilation (which
produces {\tt file.O}) and execution.

\index{FLIP}
\index{FLORID}
%%
\FLORA was implemented by Guizhen Yang, but its origins trace back to the
\FLIP compiler developed by Bertram Lud\"aescher.  The programming language
supported by \FLORA is a dialect of \fl with numerous extensions.  Some
extensions are borrowed from \FLORID, a C++-based \fl system developed at
Freiburg University.\footnote{
  %%
  See {\tt http://www.informatik.uni-freiburg.de/$\sim$dbis/florid/} for more
  details.
  %%
  }
%%
In particular, \FLORA fully supports the versatile syntax of \FLORID path
expressions. Other important extensions are motivated by the need to
support a flexible module system (and enable modular software development
in \fl) and in order to support HiLog \cite{hilog-jlp} and Transaction
Logic \cite{trans-dbpl93,trans-iclp93,trans-tcs94}, both of which are
smoothly integrated with \fl. Extensions aside, the syntax of \FLORA also
differs in some important ways from \FLORID, from the original version of
\fl, as described in \cite{KLW95}, and from an earlier implementation
of \FLORAone. These syntactic changes were needed in order to bring the
syntax of \FLORA closer to that of Prolog and make it possible to include
typical Prolog programs into \FLORA programs without choking the compiler.
Other syntactic deviations from the original F-logic syntax are a direct
consequence of the added support for HiLog, which obviates the need for the
``@'' sign in method invocations (this sign is now used to denote calls to
other modules).

\FLORA is part of the official distribution of XSB beginning with version
2.4. It is organized as an XSB package and lives in the directory
%%
\begin{quote}
 \verb|<xsb-installation-directory>/packages/flora2/|  
\end{quote}
%%
\FLORA is fully integrated into the XSB system, including its module
system. In particular, \FLORA modules can invoke predicates defined in
other XSB modules, and regular XSB modules can query the objects defined in
\FLORA modules. At present, XSB is the only platform where \FLORA can run,
because it heavily relies on tabling and the well-founded semantics for
negation, both of which are available only in XSB.

Due to certain problems with XSB, \FLORA runs best when XSB is configured
with SLG-WAM and local scheduling. This problem will be fixed in a future
release of XSB. Under the default XSB configuration, certain \fl programs might
run 30 times slower than under the suggested configuration. Some \FLORA
programs might also give errors when run under the default configuration.
To configure XSB for optimal \FLORA performance, build XSB as follows:
%%
{\tt
\begin{quote}
 configure --with-local-scheduling --enable-slg-wam --config-tag=\\
 makexsb
\end{quote}
}
%%
In the current release of \FLORA, it does not come pre-built, so you must
build it after installing and compiling XSB:
%%
\begin{verbatim}
   cd <xsb-installation-directory>/packages/flora2/
   make clean
   make
\end{verbatim}
%%

The fastest and easiest way to get a feel of the system
is to start \FLORA shell and begin to enter queries interactively.  To
this end, you must first invoke XSB and then load the {\tt flora2}
package:
%%
\begin{quote}
  \tt
foo>~~xsb  \\
\tt
... XSB loading messages omitted ...\\
\tt
| ?- [flora2].\\
\tt
[flora2 loaded]\\
\tt
| ?-
\end{quote}
%%
At this point, it is possible to use a limited number of \FLORA
commands, but to run queries you must enter the \FLORA command loop:
%%
\begin{quote}
  \tt
| ?- flora\_shell.  \\
 \tt
... FLORA messages omitted ... \\
 \tt
flora2 ?-
\end{quote}
%%

At this point, \FLORA takes over and \fl syntax becomes the
norm. To get back to the XSB command loop, type {\tt Control-D} or 
%%
\begin{quote}
  \tt
| ?- end.  
\end{quote}
%%

If you are using \FLORA shell frequently, it pays to define an alias, say,
%%
\begin{quote}
 {\tt
   alias flora2='xsb -e "[flora2], flora\_shell."'
   }
\end{quote}
%%
\FLORA can then be invoked directly from the shell prompt by typing
\begin{quote}
  \tt
foo>~~flora2
\end{quote}
%%
It is even possible to tell it to execute commands on start-up.
For instance, 
%%
\begin{quote}
 \tt
 foo>~~flora2 -e "flHelp."
\end{quote}
%%
will cause the system to execute the help command right after the start.
Then the usual \FLORA shell prompt is displayed.

\noindent
\FLORA comes with a number of demo programs that live in
%%
\begin{quote}
 \verb|<xsb-installation-directory>/packages/flora2/demos/|  
\end{quote}
%%
The demos can be run by issuing the command
``\verb|flDemo(demo-filename).|''
at the \FLORA prompt, {\it e.g.},
%%
\begin{quote}
 \verb|flora2 ?- flDemo(flogic_basics).|
\end{quote}
%%
There is no need to change to the demo directory, as {\tt flDemo} knows
where to find the demos.


\section{\FLORA Shell Commands} \label{sec-shell-commands}

The most common shell command you might need to execute is loading and
compiling a program:
%%
\begin{quote}
  flora2 ?-  {\tt [programfile].}
\end{quote}
%%
or 
%%
\begin{quote}
  flora2 ?- {\tt flLoad programfile.}
\end{quote}
%%
Here {\tt program-file} can contain a \FLORA program or an XSB program. If
{\tt program-file.flr} exists, it is assumed to be a \FLORA program. The
system will compile the program, if necessary, and then load it. The
compilation process is two-stage: first, the program is compiled into a
Prolog program (one or more files with extensions {\tt .P} and {\tt .fdb})
and then into an executable byte-code, which has the extension {\tt .O}.

If there is no {\tt program-file.flr} file, the file is assumed to contain
an XSB program and the system will look for the file named {\tt
  program-file.P}. This file then is compiled into {\tt program-file.O} and
loaded.

By default, all \FLORA programs are loaded into the module {\tt main}, but
you can also load them into other modules using the following syntax:
%%
{\tt
\begin{quote}
 flora2 ?-  [file>>modulename].
\end{quote}
}
%%
Understanding \FLORA modules is very important in order to be able to take
full advantage of the system; we will discuss the module system in \FLORA
in Section~\ref{sec:flora-modules}.  Once the program is loaded, you can
pose queries and invoke methods for the objects defined in the program.

There is an important special of the {\tt flLoad} and {\tt [...]} command
when the file name is {\tt user}. In that case, instead of looking for the
program file {\tt user.flr}, \FLORA starts reading user input. At this
point, the user can start typing in program clauses, which the system saves
in a temporary file. When the user is done and types {\tt Control-D} (end
of file), the file is compiled and loaded. It is also possible to load such
a program into a designated module, rather than the default one,
using one of the following commands:
%%
{\tt
\begin{quote}
  flora2 ?- [file>>module].\\
  flora2 ?- flLoad file>>module.
\end{quote}
}
%%

\index{don't care variable}
\index{anonymous variable}
\index{variable!don't care}
\index{variable!anonymous}
%%
When the user types in a query to the shell, the query is evaluated and the
results are returned. A result is a tuple of values for each variable
mentioned in the query, except for the \emph{anonymous variables}
represented as ``{\tt \_}'' and named {\rm don't care variables}, which are
preceded with the underscore, {\it e.g.}, {\tt \_abc}.

By default, \FLORA prints out all answers. If only one is desired, type in
the following command: {\tt flOne}. You can revert back to the all-answers
mode by typing {\tt flAll}.

\FLORA shell includes many more commands beyond those mentioned above.
These commands are listed below. However, at this point the purpose of some
of these commands might seem a bit cryptic, so it is a good idea to come
back here after you become more familiar with the various concepts
underlying the system.

In the following command list, the suffixes {\tt .flr} {\tt .P}, {\tt .O}
are optional. If the file suffix is specified explicitly, the system uses
the file with the given name without any modification. The {\tt .flr}
suffix denotes a \FLORA program, the {\tt .P} suffix indicates that it is an
XSB program, and {\tt .O} means that it is a bytecode file, which can be
executed by XSB.  If no suffix is given, the system assumes it is dealing
with a \FLORA program and adds the suffix {\tt .flr}. If the file with such a
name does not exist, it assumes that the file contains an XSB program and
tries the suffix {\tt .P}. Otherwise, it tries {\tt .O} in the hope that an
executable XSB bytecode exists. If none of these tries are successful, an
error is reported.
%
\begin{itemize}
\item {\tt flHelp}:
    Show the help info.
\item {\tt flCompile FILE}:
    Compile FILE.flr for the default module `main'.
\item {\tt flCompile FILE>>Module}:
    Compile FILE.flr for the module `{\tt Module}'.
\item {\tt flLoad FILE>>Module}:
    Load FILE.flr into the module `{\tt Module}'. If you specify 'FILE.P'
    or 'FILE.O' then will load these files.
\item {\tt flLoad FILE}:
    Load FILE.flr into the default module `main'. If you specify 'FILE.P'
    or 'FILE.O' then will load these files.
\item {\tt [FILE.\{P$|$O$|$flr\} $>>$ Module,...]}:
    Load the files in the specified list into the module `{\tt Module}'.
\item {\tt flDemo(FILE)}:
    Consult a demo from \FLORA demos directory.
\item {\tt equality \{none$|$basic$|$flogic\}}:
    Set the level of support for the equality predicate {\tt :=:} in the
    shell module `main'.
    {\tt none}  means that {\tt :=:} is treated as a regular
    predicate; {\tt basic} means that only standard first-order equality is
    supported ({\it i.e.}, the usual congruence rules); {\tt flogic} means
    that F-logic style equality is supported ({\it i.e.}, congruence plus
    the axiom for scalar methods).
\item {\tt abolish\_all\_tables}:
    Flush all tabled data. This is sometimes needed when XSB's tabling 
    gets in the way. We describe tabling (as it pertains to \FLORA) in
    Section~\ref{sec-tabling-flora}.
\item {\tt firstorder Functor/Arity}:
    Define Functor/Arity as non-HiLog in shell mode.
\item {\tt arguments Functor(\{oid$|$form\}, ...)}:
    Define the predicate meta signature in shell mode.
\item {\tt op(Precedence,Associativity,Operator)}:
    Define an operator in shell mode.
\item {\tt flReset(\{firstorder|arguments|op\})}:
    Clear all dynamic {\tt firstorder/arguments/op}  definitions in the
    \FLORA shell.
\item {\tt flAll}:
    Show all solutions (default).
\item {\tt flOne}:
    Show solutions one by one.
\item {\tt flMaxerr(all$|$N)}:
    Set/show the maximum number of errors \FLORA reports.
\item {\tt flTrace/flNoTrace}:
    Turn on/off \FLORA trace.
\item {\tt flChatter/flNoChatter}:
    Turn on/off the display of the number of solutons at the end of query
    evaluation.
\item {\tt flEnd}:
    Say Ciao to \FLORA, stay in XSB.
\item {\tt flHalt}:
    Quit both \FLORA and XSB.
\end{itemize}
%

All commands with a FILE argument passed to them use the XSB
{\tt library\_directory} predicate to search for the file, except that the
command {\tt flDemo(FILE)} first looks for {\tt FILE} in the \FLORA demo
directory. The search path typically includes the standard system's
directories used by XSB followed by the current directory. 

All XSB commands can be executed from \FLORA shell, if the corresponding
XSB library has already been loaded.

After a syntax, parsing, or compilation error, \FLORA shell will
discard tokens read from the current input stream until the end of file or a
rule delimiter (``.'') is encountered. If \FLORA shell seems to be hanging
after the message
\begin{quote}
\begin{verbatim}
++FLORA Warning: discarding tokens (rule delimeter `.' or EOF expected)
\end{verbatim}
\end{quote}
%%
hit the {\tt Enter} key once, type ``.'', and then {\tt Enter} again.  This
should reset the current input buffer and you should see the \FLORA command
prompt:
\begin{quote}
\begin{verbatim}
flora2 ?-
\end{verbatim}
\end{quote}

 
\section{\fl and \FLORA by Example}


In the future, this section will contain a number of small
introductory examples illustrating the use of \fl and \FLORA. Meanwhile, the
reader is referred to the excellent tutorial written by the members of the
\FLORID project.\footnote{
  %%
  See {\tt http://www.informatik.uni-freiburg.de/$\sim$dbis/florid/} for more
  details.
  %%
  }
%%
Since \FLORA and \FLORID share much of the same syntax, most examples in that
tutorial can be made into valid \FLORA programs by changing the separator
``;'' used in F-molecules into ``,'' and by eliminating the ``@''
sign in method invocations.



\section{Basic \FLORA Syntax}

In this section we describe the basic syntactic structures used to build
\FLORA programs. Subsequent sections describe the various advanced features
that are needed to build practical applications.


\subsection{\fl Vocabulary}\label{sec-basic-flogic}


\begin{itemize}
\item \emph{Symbols}: The \fl alphabet of \emph{object constructors}
  \index{object constructor}
  consists of the sets \funcs (function symbols), \preds (predicate symbols
  including $=$), and \vars (variables).  Variables begin with a
  capitalized letter or an underscore, followed by zero or more letters
  and/or digits and/or underscores (e.g., $\tt X, Name, \_, \_v\_5$).
  All other symbols, including the constants (which are 0-ary object
  constructors), are symbols that start with a lowercase letter (e.g., {\tt a,
  john}). Constants can also be any string of symbols enclosed in single
  quotes (e.g., {\tt 'AB@*c'}). 
  In addition to the usual first-order connectives and symbols, there is a
  number of special symbols:
  ], [, \}, \{, ``,'', ``;'', \#, \_\#, \fd, \mvd, \Fd,
  \Mvd, \isa, \subcl. Later we will explain other symbols introduced by
  the inheritance mechanism.
  
\item \emph{Variables}: The variable ``\_'' is called \emph{anonymous}
  variable. It is used whenever a \emph{unique} new variable is needed.
  In particular, two different occurrences of ``\_'' in the same clause are
  treated as different variables. The variables that start with an
  underscore, e.g., {\tt \_foo}, are \emph{not} anonymous and two
  different occurrences of such a variable in the same clause refer to the
  same variable. Nevertheless, such variables have special status as far as
  error checking is concerned. The practice of logic programming shows that
  a singleton occurrence of a variable in a clause is often a mistake
  due to misspelling. Therefore, \FLORA issues a warning when
  it finds that some variable is mentioned only once in a clause. If such
  an occurrence is truly intended, it must be replaced by an anonymous
  variable or a variable that begins with the underscore to avoid the
  warning message from \FLORA.

  %%
  \index{id-term}
  \index{oid}
  \index{object identifier}
\item \emph{Id-Terms/Oids}:
    First-order terms over \funcs\ and \vars\ are called \emph{id-terms},
    and are used to name objects, methods, and classes.  Ground id-terms
    (i.e., terms with no variables) correspond to \emph{logical
      object identifiers} (\emph{oid}s), also called object \emph{names}.
    Numbers (including integers and floats) can also be used as id-terms,
    but such use might be confusing and is not recommended.
  \index{atomic formula!in \fl}
\item \emph{Atomic formulas}: Let $\tt O,M,R_{i},X_{i},C,D,T$ be id-terms.  In
  addition to the usual first-order atomic formulas, like
  $p(X_1,\dots,X_n)$, there are the following basic types of formulas:
  \medskip

  \begin{enumerate}
    \item \label{eq-scalar-atom} $\tt O[M\fd V]$
    \item $\tt O[M\mvd \{V_1,\dots,V_n\}]$
    \item $\tt C[M\Fd T]$
    \item $\tt C[M\Mvd \{T_1,\dots,T_m\}]$
  \end{enumerate}
  
  \index{data atom}
  \index{atom!data}
  \index{method}
  \index{method!single-valued}
  \index{method!scalar}
  \index{method!multi-valued}
  %
  In all of the above cases, {\tt O}, {\tt C}, {\tt M}, ${\tt V_i}$, and
  ${\tt T_i}$ are HiLog terms, {\it i.e.}, expressions of the form, $\tt a$,
  $\tt f(X)$, $\tt X(s,Y)$, $\tt X(f,Y)(X,g(k))$, etc., where $\tt X$
  and $\tt Y$ are variables and lowercase letters $\tt f$, $\tt s$, etc., are
  constants.
  
  Expressions (1) and (2) above are \emph{data atoms}, which specify that a
  \emph{method expression} $\tt M$ applied to an object $\tt O$ yields the
  result object $\tt V$ in case (1), or a set of objects, $\tt V_1$, ...,
  $\tt V_n$, in case (2). Thus, in (1), $\tt M$ is said to be a
  \emph{single-valued} (or \emph{scalar}) method expression, i.e., there is
  at most one $\tt V$ such that $\tt O[M\fd V]$ holds.  In contrast, in (2),
  $\tt M$ is \emph{multi-valued}, so the result contains several objects,
  which \emph{includes} $\tt V_1$, $\tt V_2$, ..., $\tt V_n$. Note that we
  emphasized ``includes'' rather than ``equals'', because other facts and
  rules in the program can specify additional objects that must be
  considered part of the method result.
  
  When $n=1$ in set-valued data atoms, the curly braces can be omitted. For
  instance, $\tt O[M\mvd V_1]$. In fact, the single expression (2) is
  equivalent to a the following set of expressions, where the result set is
  split into singletons:
  %%
  \begin{quote}
  $\tt O[M\mvd V_1]$    \\
  $\tt O[M\mvd V_2]$    \\
  $~~~\dots$\\
  $\tt O[M\mvd V_n]$
  \end{quote}
  %%
  
  When $\tt M$ is a constant, {\it e.g.}, {\tt abc}, then we say that it is
  an \emph{attribute}; for example, {\tt john[name\fd 'John']}. When $\tt
  M$ has the form {\tt f(X,Y,Z)} then we refer to it as a method, {\tt f},
  with arguments {\tt X}, {\tt Y}, and {\tt Z}; for example, {\tt
  john[salary(1998)\fd 50000]}.  However, as we saw
  earlier, method expressions can be much more general than these two
  possibilities, as they can be arbitrary HiLog terms.


  \medskip

  \index{atom!signature}
  \index{signature!in \fl}
  %%
  Expressions (3) and (4) above denote \emph{signature atoms}. They specify
  that the method expression, $\tt M$, when applied to objects that belong
  to class $\tt C$, must yield objects that belong to class $\tt T$.  In (3),
  $M$ is declared as single-valued, while in (4) it is set-valued. In a
  set-valued signature, the intention is that the method expression $\tt M$
  must return objects that belong \emph{simultaneously} to the classes
  $\tt T_1$, ..., $\tt T_m$. As with data atoms, a single set-valued
  signature expression of the form (4) is equivalent to the set of
  signature expressions
  %%
  \begin{quote}
      $\tt O[M\Mvd T_1]$    \\
      $\tt O[M\Mvd T_2]$    \\
      $~~~\dots$\\
      $\tt O[M\Mvd T_m]$
  \end{quote}
  %%
  and the curly braces \{ and \} can be omitted when only one class appears
  on the right of $\Mvd$.

  Note that it is allowed for the same method to have both a single-valued
  signature and a set-valued one. The single-valued signature controls the
  data atoms that use $\fd$, and the set-valued signatures control data
  atoms that use $\mvd$.
  
  \medskip

  \index{atom!isa}
  %%
  Objects are grouped into classes using \emph{ISA-atoms}:
  \medskip

  \begin{enumerate}
  \item[5.] $\tt O\isa C$
  \item[6.] \label{eq-subclass} $\tt C\subcl D$
  \end{enumerate}

  \index{class}
  \index{subclass}
  \index{class!subclass}
  \index{class!instance}
  %%
  The expression (5) states that $\tt O$ is an \emph{instance} of class $\tt C$,
  while (6) states that $\tt C$ is a \emph{subclass} of $D$.
\item
  \index{F-molecule}
  \emph{F-molecules} provide a convenient way to shortcut specifications
  related to the same object. For instance, the conjunction of the atoms
  {\tt john{\isa}person}, {\tt john[age{\fd}31]}, {\tt
  john[children\mvd\{bob,mary\}]}, and {\tt john[children\mvd john]}
  is equivalent to the following single F-molecule:
  %%
  \begin{quote}
    {\tt john{\isa}person[age{\fd}31, children\mvd\{bob,mary,john\}]} 
  \end{quote}
  %%
  Note the use of the ``,'' that separates the expression for the {\tt age}
  attribute from the expression for the {\tt children} attribute. This is a
  departure from the original \fl syntax in \cite{KLW95}, which uses ``;'' 
  to separate such expressions.
  
\item \emph{Rules} are, as usual, the constructs of the form $head :-
  body$, where $head$ is an F-molecule and \emph{body} is a conjunction of
  F-molecules or negated F-molecules. (Negation is specified using {\NAF}
    or {\tt tnot} --- the difference will be explained later.)
  Each rule must be terminated with a ``.''.
  
  Conjunction is specified as in Prolog, using the ``,'' symbol. Like in
  Prolog, \FLORA also allows disjunction in the rule body, which is denoted
  using ``;''. As usual in logic languages, a single rule of the form
  %%
  \begin{equation}\label{eq-disjunction}
  {\tt
    {\it head}~:-~john[age{\fd}31],~(john[children\mvd\{bob,mary\}]~;~
    john[children\mvd john]).
    }
  \end{equation}
  %%
  is equivalent to the following pair of rules:
  %%
  \begin{quote}
  {\tt
    {\it head}~:-~john[age{\fd}31],~john[children\mvd\{bob,mary\}].
    }
  \\
  {\tt
    {\it head}~:-~john[age{\fd}31],~john[children\mvd john].
    }
  \end{quote}
  %%
  Disjunction is also allowed inside F-molecules. For instance, the rule
  (\ref{eq-disjunction}) can be equivalently rewritten as:
  %%
  \begin{quote}
 {\tt
   {\it head}~:-~john[age{\fd}31,~(children\mvd\{bob,mary\}~;~children\mvd john)].
   }
  \end{quote}
  %%
  Note that conjunction ``,'' binds stronger than disjunction ``;'', so the
  parentheses in the above example are essential.
  
\item \emph{Programs and queries}: A \emph{program} is a set of rules. A
  \emph{query} is a rule without the head. In \FLORA, such headless rules
  use {\tt ?-} instead of {\tt :-}, {\it e.g.}, 
  %%
  \begin{quote}
    {\tt 
    ?-~john[age->X].    
    }
  \end{quote}
  %%
  The symbol {\tt :-} in headless \FLORA expressions is used for various
  directives, which are plenty and will be introduced in due course.
\end{itemize}



\begin{example}
  {\bf (Publications Database)} \rm Figure~\ref{fig-flogic-model} depicts
  a fragment of a \FLORA program that represents a database of scientific
  publications.
\end{example}


\begin{figure}[htb]
\begin{tabular}{c}
  \begin{tabular}{l}
    {\bf Schema:}\\
    conf\_p\subcl paper. \\
    journal\_p\subcl paper.\\
    paper[authors\Mvd  person, title\Fd string].\\
    journal\_p[in\_vol\Fd volume]. \\
    conf\_p[at\_conf\Fd conf\_proc].\\
    journal\_vol[of \Fd journal, volume\Fd integer, 
               number\Fd integer, year\Fd integer].\\  
    journal[name\Fd string, publisher\Fd string,
            editors\Mvd person]. \\
    conf\_proc[of\_conf\Fd conf\_series, year\Fd integer,
               editors\Mvd person]. \\
    conf\_series[name\Fd string]. \\
    publisher[name\Fd string].\\
    person[name\Fd string, affil(integer)\Fd institution]. \\
    institution[name\Fd string, address\Fd string].\smallskip\\

    {\bf Objects:}\\
    $o_{j1}$\isa journal\_p[%
      title\fd 'Records, Relations, Sets, Entities, and Things',
      authors\mvd$\{o_{mes}\}$, in\_vol\fd $o_{i11}$]. \\
    $o_{di}$\isa conf\_p[
      title\fd 'DIAM II and Levels of Abstraction',
      authors\mvd$\{o_{mes},o_{eba}\}$, at\_conf\fd $o_{v76}$]. \\
    $o_{i11}$\isa journal\_vol[of\fd $o_{is}$, number\fd 1, volume\fd 1, year\fd1975]. \\
    $o_{is}$\isa journal[name\fd'Information Systems', editors\mvd $\{o_{mj}\}$]. \\
    $o_{v76}$\isa conf\_proc[of\fd vldb, year\fd 1976, editors\mvd $\{o_{pcl},o_{ejn}\}$].\\
    $o_{vldb}$\isa conf\_series[name\fd'Very Large Databases']. \\
    $o_{mes}$\isa person[name\fd'Michael E. Senko']. \\
    $o_{mj}$\isa person[name\fd'Matthias Jarke', affil(1976)\fd $o_{rwt}$]. \\
    $o_{rwt}$\isa institution[name\fd'RWTH\_Aachen'].
\end{tabular}
\end{tabular}
\caption{A Publications Object Base and its Schema in \FLORA}
  \label{fig-flogic-model}
\end{figure}



\subsection{Symbols, Strings, and Comments}


\index{symbol}
%%
\paragraph{Symbols.}
\FLORA symbols (that are used for the names of constants, predicates, and
object constructors) begin with a lowercase letter followed by zero or more
letters ($\tt A \ldots Z, a \ldots z$), digits ($\tt 0 \ldots 9$), or underscores
(\_), e.g., \texttt{student}, \texttt{apple\_pie}. Symbols can also be
\emph{any} sequence of characters enclosed in a pair of single quotes,
e.g., \texttt{'JOHN SMITH'},\texttt{'default.flr'}.  Internally, \FLORA
symbols are represented as \emph{XSB symbols},\footnote{
  %%
  Symbols are called ``atoms'' in XSB, which contravenes the use of this
  term for atomic formulas in classical logic and \fl.
  We avoid the use of the term ``atom'' in reference to symbols.
  %%
  }
%%
which are used there as names of predicates and function symbols.

\begin{table}[htb]
\center
\texttt{ \small
\begin{tabular}{|c|r@{\hspace{1.5cm}}|@{\hspace{5mm}}l@{\hspace{5mm}}|}
\hline
Escaped String &
  \multicolumn{1}{c|@{\hspace{5mm}}}{ASCII (decimal)} &
  \multicolumn{1}{c|}{Symbol} \\ \hline
{\bksl}{\bksl} &  92 & {\bksl} \\ \hline
{\bksl}n &  10 &		 NewLine \\ \hline
{\bksl}N &  10 &		 NewLine \\ \hline
{\bksl}t &   9 &		 Tab \\ \hline
{\bksl}T &   9 &		 Tab \\ \hline
{\bksl}r &  13 &		 Return \\ \hline
{\bksl}R &  13 &		 Return \\ \hline
{\bksl}v &  11 &		 Vertical Tab \\ \hline
{\bksl}V &  11 &		 Vertical Tab \\ \hline
{\bksl}b &   8 &		 Backspace \\ \hline
{\bksl}B &   8 &		 Backspace \\ \hline
{\bksl}f &  12 &		 Form Feed \\ \hline
{\bksl}F &  12 &		 Form Feed \\ \hline
{\bksl}e &  27 &		 Escape \\ \hline
{\bksl}E &  27 &		 Escape \\ \hline
{\bksl}d & 127 &		 Delete \\ \hline
{\bksl}D & 127 &		 Delete \\ \hline
{\bksl}s &  32 &		 Whitespace \\ \hline
{\bksl}S &  32 &		 Whitespace \\
\hline
\end{tabular}
}
\caption{Escaped Character Strings and Their Corresponding Symbols}
\label{tab:tab-esc-str}
\end{table}

\index{escaped character}
\FLORA also recognizes escaped characters inside single quotes
(\texttt{'}).  An escaped character normally begins with a backslash
(\texttt{\bksl}).  Table~\ref{tab:tab-esc-str} lists the special escaped
character strings and their corresponding special symbols. An escaped
character may also be any ASCII character. Such a character is preceded
with a backslash together with a lowercase \texttt{x} (or an uppercase
\texttt{X}) followed by one or two hexadecimal symbols representing its
ASCII value. For example, \texttt{{\bksl}xd} is the ASCII character
Carriage Return, whereas \texttt{{\bksl}x3A} represents the semicolon. In
other cases, a backslash is recognized as itself.

One exception is that inside a quoted symbol, a single quote character is
escaped by another single quote, e.g., \texttt{'isn''t'}.

\paragraph{Strings (character lists).}

\index{string}
\index{character list}
%
Like XSB strings, \FLORA strings are enclosed in a pair of double quotes
(\texttt{\dq}).  These strings are represented internally as lists of
ASCII characters. For instance, \mbox{\texttt{[102,111,111]}} is the same
as \texttt{{\dq}foo{\dq}}.

Escape characters are recognized inside \FLORA strings similarly to
\FLORA symbols.  However, inside a string, a single quote character does
not need to be escaped. A double quote character, however, needs to be
escaped by another double quote, e.g.,
\texttt{{\dq}{\dq}{\dq}foo{\dq}{\dq}{\dq}}.

\paragraph{Numbers.}

\index{number}
%%
\index{integer}
%%
\index{floating number}
%%
Normal \FLORA integers are decimals represented by a sequence of digits,
e.g., \texttt{892, 12}.  \FLORA also recognizes integers in other bases (2 through
36). The base is specified by a decimal integer followed by a single quote
(\texttt{'}). The digit string immediately follows the single quote. The
letters $\tt A \ldots Z$ or $\tt a \ldots z$ are used to represent digits greater
than 9.  Table~\ref{tab:tab-int-rep} lists a few example integers.
%%
\begin{table}[htb]
\center
\texttt{ \small
\begin{tabular}{|r@{'}l|r@{\hspace{1.5cm}}|c|}
\hline
  \multicolumn{2}{|c|}{Integer} &
  \multicolumn{1}{c|}{Base (decimal)} &
  \multicolumn{1}{c|}{Value (decimal)} \\ \hline
\multicolumn{1}{|r}{} & \multicolumn{1}{@{}l|}{1023} &  10 & 1023 \\ \hline
2 & 1111111111 & 2 & 1023 \\ \hline
8 & 1777 & 8 & 1023 \\ \hline
16 & 3FF &  16 & 1023 \\ \hline
32 & vv & 32 & 1023 \\
\hline
\end{tabular}
}
\caption{Representation of Integers}
\label{tab:tab-int-rep}
\end{table}

Underscore (\texttt{\_}) can be put inside any sequence of digits as
delimiters. It is used to partition some long numbers. For instance,
$\texttt{2'11\_1111\_1111}$ is the same as $\texttt{2'1111111111}$.
However, ``\texttt{\_}'' cannot be the first symbol of an integer, since
variables can start with an underscore. For example, $1\_2\_3$ represents
the number $123$ whereas $\_12\_3$ represents a variable named $\_12\_3$.

Floating numbers normally look like {\tt 24.38}. The decimal point
must be preceded by an integral part, even if it is 0, e.g., {\tt 0.3}
must be entered as {\tt 0.3}, but not as {\tt .3}. Each floating
number may also have an optional exponent. It begins with a lowercase
{\tt e} or an uppercase {\tt E} followed by an optional minus sign
({\tt -}) or plus sign ({\tt +}) and an integer. This exponent is
recognized as in base 10. For example,
\mbox{\tt 2.43E2 is 243} whereas
\mbox{\tt 2.43e-2 is 0.0243}.

\paragraph{Comments.}

\index{comment}
%
\FLORA supports three kinds of comments: (1) all characters following
{\tt \%} until the end of the line; (2) all characters following
{\tt //} until the end of the line; (3) all characters inside a pair of
{\tt /*} and {\tt */}. Note that only (3) can span multiple lines.

Comments are recognized like whitespaces by the compiler.  Therefore,
tokens can also be delimited by comments.


\subsection{Operators}


\index{operators}
%%
As in Prolog, \FLORA allows the user to define operators, to liven up the
otherwise boring syntax.  There are three kinds of operators: infix,
prefix, and postfix. An infix operator appears between its two arguments,
while a prefix operator before its single argument and a postfix operator
after its single argument. For instance, if {\tt foo} is defined as an
infix operator, then {\tt X foo a} will be parsed as {\tt foo(X,a)} and if
{\tt bar} is a postfix operator then {\tt X bar} is parsed as {\tt bar(X)}. 

\index{operators!precedence level}
\index{operators!type}
%
Each operator has a \emph{precedence level}, which is a positive integer.
Each operator also has a \emph{type}. The possible types for infix operatos
are: {\tt xfx}, {\tt xfy}, {\tt yfx}; the possible types for prefix
operators are: {\tt fx}, {\tt fy}; and the possible types for postfix
operators are: {\tt xf}, {\tt yf}. In each of these type expressions, {\tt
  f} stands for the operator, and {\tt x} and {\tt y} stand for the
arguments.  The symbol {\tt x} in a type expression means that the
precedence level of the corresponding argument should be \emph{smaller}
than that of the operator, while {\tt y} means that the precedence level of
the corresponding argument should be \emph{less or equal} than that of the
operator.

The precedence level and the type together determine the way the operators
are parsed. The general rule is that precedence of a constant or a functor
symbol that has not been defined as an operator is zero. Precedence of a
Prolog term is the same as the precedence of its main functor. 
An expression that contains several operators is parsed in such a way that
the operator with the highest precedence level becomes the main functor of
the parsed term, the operator with the next-highest precedence
level becomes the main functor of one of the arguments, and so on.
If an expression cannot be parsed according to this rule, a parse error is
reported.

It is not our goal to cover the use of operators in any detail, since this
information can be found in any book on Prolog. Here we just give an
example that illustrates the main points.  For example, in \FLORA, {\tt -}
has precedence level {\tt 800} and type {\tt yfx}, {\tt *} has precedence
level {\tt 700} and type {\tt yfx}, {\tt ->} has precedence level 1100 and
type {\tt xfx}.  Therefore, {\tt 8-2-3*4} is the same as {\tt
  -(-(8,2),*(3,4))} in prefix notation, and {\tt a -> b -> c} will generate
a parsing error.


\index{compiler directive!{\tt op}}
%
Any symbol can be defined as an operator. The general syntax is
\begin{qrules}
{\tt :- op(\emph{Precedence},\emph{Type},\emph{Name}).}
\end{qrules}
%%
For instance, 
%%
\begin{quote}
 {\tt
   :- op(800, xfx, foo)
   }
\end{quote}
%%
As a notational convenience, the argument {\tt Name} can also be a list of
operator names of the same type and precedence level, for instance,
\begin{qrules}
{\tt :- op(800,yfx,[+,-]).}
\end{qrules}
%%
It is possible to have more than one operator with the same name provided
they have different use ({\it e.g.}, one infix and the other postfix).
However, the \FLORA built-in operators are not allowed to be redefined.
In particular, any symbol that is part of \fl syntax, such as ``,', ``.'',
``[``, ``:'', etc., as well as any name that begins with {\tt flora} or
{\tt fl} followed by a capital letter should be considered as reserved for
internal use.

Although this simple rule is sufficient, in most cases, to keep you out of
trouble, you should be aware of the fact that symbols such as ``{\tt ,}'',
``{\tt ;}'', ``{\tt +}'', ``{\tt .}'', ``{\tt ->}'', ``{\tt ::}'', and many
other parts of \FLORA syntax are operators. Therefore, there is a chance
that precedence levels chosen for the user-defined operators conflict with
those of \FLORA and, as a result, your program might not parse. If in
doubt, check the declarations in the file {\tt flroperator.P} in the \FLORA
source code.


\subsection{Logical Expressions}


\index{logical expressions}
%
In a \FLORA program, any combination of conjunction, disjunction, and
negation of literals can appear wherever a logical formula is allowed,
e.g., in a rule body.

Conjunction is represented through the infix operator ``{\tt ,}'' and
disjunction is made using the infix operator ``{\tt ;}''.  Negation is made
through the prefix operators ``\NAF'' and ``{\tt
  tnot}''.\footnote{
  %%
  In brief, ``{\tt $\backslash$+}'' represents negation as
  failure and can be applied only to non-tabled Prolog, \FLORA, or HiLog
  predicates. ``{\tt tnot}'', on the other hand, is negation that
  implements the well-founded semantics.  Refer to
  Section~\ref{sec:negation} for more information on the difference between
  negation operators. 
  %%
  }
%%
When parentheses are omitted, conjunction binds stronger than disjunction
and the negation operators bind their arguments stronger than the other
logical operators.  For example, in \FLORA the following expression:
\verb|a, b; c, not d|, is equivalent to the the logical formula: $\tt (a
\wedge b) \vee (c \wedge (\neg d))$.

\index{molecule!logic expressions}
%
Logical formulas can also appear inside the specification of an object. For
instance, the following F-molecule:
\begin{qrules}
o[tnot att1{\fd}val1, att2{\mvd}val2; meth{\fd}res]
\end{qrules}
is equivalent to the following formula:
\begin{qrules}
(tnot o[att1{\fd}val1], o[att2{\mvd}val2]) ; o[meth{\fd}res]
\end{qrules}


\subsection{Arithmetic Expressions}


\index{arithmetic expression}
%%
In \FLORA arithmetic expressions are \emph{not} always evaluated. As in
XSB, the arithmetic operators such as {\tt +}, {\tt -}, {\tt /}, and {\tt
  *}, are defined as normal binary functors. However, to evaluate
arithmetic expressions, \FLORA provides two operators: {\tt is} and {\tt
  :=}, which synonymous.  For example, {\tt X := 3+4} will bind {\tt X} to
the value {\tt 7}.

When dealing with arithmetic expressions, the order of literals is
important.  In particular, all variables appearing in an arithmetic
expression must be instantiated at the time of evaluation. Otherwise, a
runtime error will occur. For instance, 
%%
\begin{qrules}
  \tt
?- X > 1, X := 1+1.
\end{qrules}
%%
will produce an error, while
%%
\begin{qrules}
  \tt
?- X := 1+1, X > 1.
\end{qrules}
%%
will evaluate to true.

As in Prolog, the operands of an arithmetic expression can be any variable
or a constant. However, in \FLORA, an operand can also be a \emph{path
  expression}. For the purpose of this discussion, a path expression of the
form $\tt p.q$ should be understood as a shortcut for {\tt p[q$\fd$X]}, where
$\tt X$ is a new variable, and $\tt p.q.r$ is a shortcut for {\tt p[q$\fd$X],
  X[r$\fd$Y]}. For set-valued formulas, the notation ``..'' is used. For
instance, {\tt p..q} stands for {\tt p[q$\mvd$X]}. More detailed discussion
of path expressions appears in Section~\ref{sec-pathexpr}.

Both single-valued and multi-valued path expressions are allowed in
arithmetic expressions, and all variables are considered to be
existentially quantified. For example, the following query
%%
\begin{qrules}
?- john..bonus $+$ mary..bonus $>$ 1000.
\end{qrules}
%%
should be understood as
%%
\begin{qrules}
?- john[bonus{\mvd}{\tt \_V1}], mary[bonus{\mvd}{\tt \_V2}], ${\tt \_V1}+{\tt \_V2} > 1000$.
\end{qrules}
%%
Note that in first query does not have any variables, so after the
evaluation the system would print either yes or no. To achieve the same
behavior, we use \emph{semi-anonymous variables}, {\tt \_V1} and {\tt
  \_V2}. If we used {\tt V1} and {\tt V2} instead, the values of these
variables would have been printed out.

\FLORA recognizes numbers as oids and, thus, it is perfectly normal to have
allows arithmetic expressions inside path expressions such as this:
{\tt 1.2.(3+4*2).7}. When parentheses are omitted, this might lead to
ambiguity.
For instance, is the meaning of
%%
\begin{qrules}
1.m+2.n.k
\end{qrules}
%%
represented by
the arithmetic expression {\tt (1.m)+(2.n.k)}, or by
the path expressions {\tt (1.m+2.n).k}, by {\tt (1.m + 2).n.k}, or by {\tt
  1.(m+2).n.k}? To disambiguate such expressions, we must remember that the
operators ``.'' and ``..'' used in path expressions bind stronger than the
arithmetic operators $+$, $-$, etc.

Even more interesting is the following example: {\tt 2.3.4}. Does it
represent the path expression {\tt (2).(3).(4)}, or {\tt (2.3).4}, or {\tt
  2.(3.4)} (where in the latter two cases 2.3 and 3.4 are interpreted as
decimal numbers)? The answer to this puzzle is {\tt (2.3).4}: when
tokenizing, \FLORA first tries to classify tokens into meaningful
categories. Thus, when 2.3 is first found, it is identified as a
decimal. Thus, the parser receives the expression (2.3).4, which it
identifies as a path expression that consists of two components, the oids
2.3 and 4.

Another ambiguous situation arises when the symbols {\tt -} and {\tt +} are
used as minus and plus
signs, respectively. \FLORA follows the common arithmetic interpretation of
such expressions, where the {\tt +/-} signs bind stronger than the infix
operators and thus
{\tt 4--7} and {\tt 4-+7} are interpreted as {\tt 4-(-7)} and {\tt 4-(+7)},
respectively.

%%
\begin{table}[tb]
\center
\texttt{ \small
\begin{tabular}{|c|c|c|c|c|}
\hline
%%
Precedence  & Operator & Use & Associativity & Arity \\ \hline
not applicable & () & parentheses & not applicable & not applicable\\ \hline
not applicable & . & decimal point & not applicable & not applicable \\ \hline
            & .   & single-valued object reference & left & binary \\ \cline{2-5}
300         & ..   & multi-valued object reference & left & binary \\ \cline{2-5}
            & :    & ISA specification & left & binary \\ \cline{2-5}
            & ::   & subclass specification & left & binary \\ \hline
600         & - & minus sign & right & unary \\ \cline{2-5}
            & + & plus sign & right & unary \\ \hline
700         & * & multiplication & left & binary \\ \cline{2-5}
            & / & division & left & binary \\ \hline
800         & - & subtraction & left & binary \\ \cline{2-5}
            & + & addition & left & binary \\ \hline
            & =< & less than or equals to & not applicable & binary \\ \cline{2-5}
            & >= & greater than or equals to & not applicable & binary \\ \cline{2-5}
1000        & =:= & equals to & not applicable & binary \\ \cline{2-5}
            & ={\bksl}= & unequal to & not applicable & binary \\ \cline{2-5}
            & := & assignment & not applicable & binary \\ \cline{2-5}
            &is & \multicolumn{3}{c|}{same as :=} \\
\hline
\end{tabular}
}
\caption{Operators in Non-Increasing Precedence Order and Their Associativity and Arity}
\label{tab:tab-op-pre}
\end{table}

Table~\ref{tab:tab-op-pre} lists various operators in decreasing precedence
order, their associativity, and arity.  When in doubt, use parentheses.
Here are some more examples of valid arithmetic expressions:
{\tt
\begin{quote}
o1.m1+o2.m2.m3~~~~~~~~~{\rm same as} (o1.m1)+(o2.m2)\\
2.(3.4)~~~~~~~~~~~~~~~~{\rm the value of the attribute} 3.4 {\rm on object} 2\\
3 + - - 2~~~~~~~~~~~~~~{\rm same as} 3+(-(-2))\\
5 * - 6~~~~~~~~~~~~~~~~{\rm same as} 5*(-6)\\
5.(-6)~~~~~~~~~~~~~~~~~{\rm the value of the attribute} -6 {\rm on object} 5
\end{quote}
}
%%
Note that the parentheses in {\tt 5.(-6)} are needed,
because otherwise ``{\tt .-}'' would be recognized as a single token.
Similarly, the whitespace around ``{\tt +}'', ``{\tt -}'', and ``{\tt *}''
are also needed in these examples to avoid {\tt *-} and {\tt +--} being
interpreted as distinct token.


\section{Multifile Programs}

\FLORA supports many ways in which a program can be modularized.  First, an
\fl program can be split into many files with separate namespaces. Each
such file can be considered an independent library, and the different
libraries can call each other. In particular, the same method name (or a
predicate) can be used in different files and the definitions will not
clash.  Second, a program file can be split of several files, and these
files can be included by the preprocessor prior to the compilation. In this
case, all files share the same namespace in the sense that the different
rules that define the same method name (or a predicate) in different files
are assumed to be part of one definition. Third, \FLORA programs can call
XSB modules and vice versa. In this way, a large system can be built partly
in Prolog and partly in \FLORA.

We discuss each of the aforesaid modularization methods in turn.


\subsection{\FLORA Modules} \label{sec:flora-modules}

\index{module}
%%
A \emph{\FLORA module} is a programming abstraction that allows a large
program to be split into separate libraries that can be reused in multiple
ways in the same program. Formally, a module is a pair that consists of a
\emph{name} and a \emph{contents}. The name is just an alphanumeric symbol,
and the contents consists of the program code that is typically loaded from
some file (but it can also be constructed dynamically by inserting
facts\footnote{
  %%
  Dynamic insertion of rules will be implemented in the future.
  %%
  }
%%
into another module).

The basic idea behind \FLORA modularization is that reusable code libraries
are to be placed in separate files.  To use a library, it must be
\emph{loaded into a module}. Other parts of the program can then invoke
this library's methods by providing the name of the module (and the
method/predicate names, of course).  There is no need to export anything
from a library --- any public method or predicate can be called by other
parts of the program.\footnote{
  %%
  At present, all methods are public, but encapsulation will be implemented
  in the future.
  %%
  }
%%
In this way, the library loaded into a module becomes that module's content.

Note that there is no a priori association between files and modules.  Any
file can be loaded into any module and one program file can even be loaded
into two different modules at the same time. The same module can be reused
during the same program run by loading another file into that module. In
this case, the old contents is erased and the module gets new contents from
the second file.

In \FLORA, modules are completely decoupled from file
names. A \FLORA program knows only the module names it needs to call, but
not the file names. Specific files can be loaded into modules by another,
unrelated bootstrapping program. Moreover, a program can be written in such
a way that it calls a method of some module without knowing that module's
name. The name of the module can be passed as a parameter or in some other
way and the concrete binding of the method to the module will be done at
runtime.

This dynamic nature of \FLORA modules stands in sharp contrast to the module
system of XSB, which is static and associates modules with files at compile
time. Moreover, to call a predicate from another module, that predicate
must be imported explicitly and referred to by the same name.


\subsection{Calling Methods and Predicates Defined in Other Modules}


\index{module!reference}
%
If \emph{literal} is an F-molecule or a predicate defined in another
module, it can be called using the following syntax:
%%
\begin{quote}
\emph{literal} @ \emph{module} 
\end{quote}
%%
The name of the module can be any alphanumeric symbol.\footnote{
  %%
  In fact, any symbol is allowed. However, it cannot contain the quote
  symbol, ``{\tt '}''.
  %%
  }
%%
For instance, \verb|foo(a) @ foomod| tests whether {\tt foo(a)} is true in
the module named {\tt foomod}, and {\tt mary[children\mvd X]@genealogy}
queries the information on {\tt mary}'s children available in the module
{\tt genealogy}. More interestingly, the module specifier can be a variable
that gets bound to a module name at run time. For instance, 
%%
\begin{quote}
 {\tt
   ..., Agent=zagat, ..., newyork[dinner(italian) \mvd X]@Agent.
   }
\end{quote}
%%
A call to a literal with an unbound module specification or one that is not
bound to a symbol will result in a runtime error.

\index{module!rules}
%%
When calling the literals defined in the same module, the {\tt @{\it
    module}} notation is not needed, of course. (In fact, since a program
does not know where it will be loaded, using the @-notation to call a
literal in the same module is hard. However, it is possible with the help
of the special predicate {\tt flThisModule/1}, described later, and is left
as an exercise.)

The following rules apply when calling a literal defined in another module:
%%
\begin{enumerate}
\item Literal reference cannot appear in a rule head or be specified as
  a fact. For example, the following program will generate
  a parsing error
  %%
  \begin{quote}
    \verb|john[father->smith] @ foomod.| \\
    \verb|foo(X) @ foomod :- goo(X).|
  \end{quote}
  %%
  because defining a literal that belongs to another module does not make
  sense.
  
\item Module specification is distributive over logical connectives,
  including the conjunction operator, ``\verb|,|'', the disjunction,
  ``\verb|;|'', and the negation operators, ``\NAF'' and
  ``\verb|tnot|''. For example, the formula below:
  %%
  \begin{quote}
    \verb|(john[father->smith], tnot smith[spouse->mary]) @ foomod|
  \end{quote}
  is equivalent to the following formula:
  \begin{quote}
    \verb|john[father->smith] @ foomod, tnot (smith[spouse->mary] @ foomod)|
  \end{quote}

\item Module specifications can be nested. The one closest to a literal
  takes effect. For example,
  \begin{quote}
    \verb|(foo(a), goo(b) @ goomod, hoo(c)) @ foomod|
  \end{quote}
  is equivalent to
  \begin{quote}
    \verb|foo(X) @ foomod, goo(b) @ goomod, hoo(c) @ foomod|
  \end{quote}
  
\item The module specification propogates to any F-molecule appearing
  in the argument of a predicate for which the module is
  specified. For example,
  \begin{quote}
    \verb|foo(a.b[c->d]) @ foomod|
  \end{quote}
  %%
  is equivalent to
  %%
  \begin{quote}
    \verb|a[b->X] @ foomod, X[c->d] @ foomod, foo(X) @ foomod|
  \end{quote}
  
\item Module specifications do not affect function terms that are not
  predicates or method names, unless such a specification is explicitly
  attached to such a term. For instance, in
  %%
  \begin{quote}
    \verb|?- foo(goo(a)) @ foomod.|
  \end{quote}
  %%
  {\tt goo/1} refers to the same functor both in module {\tt foomod} and in
  the calling module. However, if the module is attched explicitly, as in
  \begin{quote}
    \verb|?- foo(goo(a) @ goomod) @ foomod.|
  \end{quote}
  %%
  then {\tt foo/1} is assumed to be a meta-predicate that receives the
  predicate {\tt goo/1}  as a parameter.
\end{enumerate}


\subsection{Finding the Current Module Name}

\index{module!{\tt flThisModule}}
%
Since a \FLORA program can be loaded into any module, the program does not
have a priori knowledge of the module it will be executing in. However, the
program can determine its module at runtime using the special predicate
{\tt flThisModule/1}.  This predicate accepts a variable argument and binds
it to the name of the \FLORA module into which the program was loaded.




\subsection{Loading Files into Modules}\label{sec-loading-mods}

%

\index{module!compilation}
%%
\FLORA provides commands for compiling and loading program files into
specified modules.
The
command 
%%
\begin{quote}
  {\tt ?- flCompile({\it file}>>{\it module}).}
\end{quote}
%%
generates the byte code for the program to be loaded into the module named
{\tt module}. The name of the byte code for the program in \emph{file}.flr,
which can later be loaded into the specified module. In practice this means
that the compiler generates files named \emph{file\_module.P} and
\emph{file\_module.O} with symbols appropriately renamed to avoid clashes.

If no module is specified, the command
%%
\begin{quote}
 \tt
 ?- flCompile({\it file}).
\end{quote}
%%
compiles {\it file}.flr for the default module {\tt main}.


\index{loading files}
%
Like XSB, \FLORA also allows the user to compile and load program files at
the same time: If the file was not compiled before (or if the program file
is newer), the program is compiled before being loaded.
For instance, the following command:
\begin{quote}
\verb|[myprog1, myprog2]|
\end{quote}
will loads both {\tt myprog1} and {\tt myprog2} into the default module
{\tt main}. If either {\tt myprog1.flr} or {\tt myprog2.flr} is stale, it
is compiled first.

Both XSB files and \FLORA files can appear in the list. Note
that the names of XSB source files have {\tt .P} as extension,
while XSB byte code files have {\tt .O}, and \FLORA source files
have {\tt .flr}. If a file name is not specified with an extension,
\FLORA will search the follwing files in order until one is found
or none: \FLORA source files, XSB source files, and XSB byte code
files.

An optional module name can be used to load the program into a specified
module:
\begin{quote}
  \tt
[..., {\it program\/} >> {\it module}, ...]
\end{quote}
%%
For instance, the following command:
%%
\begin{quote}
\verb|[myprog >> foomod]|
\end{quote}
%%
loads the \FLORA program {\tt myprog.flr} into the module named {\tt
  foomod}, compiling it if necessary.

Mixed module specifications are also possible. For instance, 
\begin{quote}
\verb|['myprog.flr', mydb >> foomod]|
\end{quote}
loads {\tt myprog.flr} into module {\tt main} and
{\tt mydb.flr} into module {\tt foomod}.

Note that the {\tt [...]} command can also load and compile XSB programs.
The overall algorithm is as follows. If the file suffix is specified
explicitly, the corresponding file is assumed to be a \FLORA file, an XSB
file, or a byte code depending on the suffix: {\tt .flr}, {\tt .P}, or {\tt
  .O}. If the suffix is not given explicitly, the compiler first checks if
{\it file}.{\tt flr} exists. If so, the file assumed to be a \FLORA program
and is compiled as such. If {\it file}.{\tt flr} is not found, but {\it
  file}.{\tt P} or {\it file}.{\tt O} is, the file is passed to XSB for
compilation.


\subsection{Calling XSB from \FLORA}

XSB predicates can be called from \FLORA through the \FLORA module system
\FLORA models XSB programs as collections of static modules, {\it i.e.},
from \FLORA's point of view, XSB modules are always available
and do not need to be loaded. The syntax to call XSB predicates is
%%
\index{module!{\tt @prolog(module)}}
%%
\begin{quote}
  \tt
  ?- {\it predicate}@prolog({\it module})  
\end{quote}
%%
For instance, since the predicate {\tt member/2} is defined in the XSB
module {\tt basics}, we can call it as follows:
%%
\begin{quote}
 \tt
 ?- member(abc,[cde,abc,pqr])@prolog(basics).
\end{quote}
%%
To use this mechanism, you must know which module the particular predicate
is defined in. Some predicates are defined by programs that do not belong
to any module. When such an XSB program is loaded, the corresponding
predicates become available in the special module called {\tt usermod} and
\FLORA can call such predicates as follows:
%%
\begin{quote}
 \tt
 ?- foo(X)@prolog(usermod).
\end{quote}
%%
Note that variables are not allowed in the module specifications of XSB
predicates, {\it i.e.},
%%
\begin{quote}
 \tt
 ?- M=usermod, foo(X)@prolog(M).
\end{quote}
%%
will cause a compilation error.

Some XSB predicates are considered ``well-known'' and, even though they are
defined in various obscure modules, the user can just use those predicates
without remembering the corresponding XSB module names. These predicates
(that are listed in the XSb manual) can be called from \FLORA with
particular ease:
%%
\begin{quote}
 \tt
 ?- writeln('Hello')@prolog()
\end{quote}
%%
{\it i.e.}, we can simply omit the XSB module name (but parentheses must be
preserved). 




\subsection{Calling \FLORA from XSB}

Since XSB does not understand object-oriented syntax, it can call only use
predicates defined in \FLORA programs. These predicates can be HiLog or
first-order predicates (See Section~\ref{sec:hilog}). To call predicates
defined in \FLORA programs, they must be imported by the XSB program.
To do this, the XSB program must execute the query
%%
\begin{quote}
 ?- bootstrap\_flora.  
\end{quote}
%%
somewhere near the top of the file and then include the appropriate
{\tt flImport} statements described below:
%%
\begin{quote}
  \tt
   ?- flImport \{hilog|firstorder\} {\it flora-predicate/arity} as {\it
     xsb-name}(\_,\_,...,\_)\\
   \hspace*{5cm}from {\it filename} >> {\it flora-module-name}
   \\
   ?- flImport \{hilog|firstorder\} {\it flora-predicate/arity} as {\it 
     xsb-name}(\_,\_,...,\_)\\
   \hspace*{5cm}from {\it flora-module-name}
\end{quote}
%%
The first syntax is used to both import the predicate and also load the
program file defining it into a given module. The second syntax is used
when the flora program is already loaded and we only need to import the
corresponding predicate.

In both cases, the option {\tt hilog} is used to import a HiLog predicate
and {\tt firstorder} is used to import first-order predicates. The imported
predicate must be given a name by which the imported predicate will be
known in XSB.  (This name can be the same as the name used in \FLORA.)  It
is important, however, that the XSB name be specified as shown, {\it i.e.},
as a predicate skeleton with the same number of arguments as in the
first-order predicate. For instance, {\tt foo(\_,\_,\_)} will do, but {\tt
  foo/3} will not.

Once the predicate is imported, it can be used under its XSB name as a
regular predicate.

XSB programs can also load and compile \FLORA programs using the following
queries: 
%%
\begin{quote}
 \tt
 :- import flLoad/1, flCompile/1 from flora2.\\
 ?- flLoad  {\it flora-file} >> {\it flora-module}.\\
 ?- flLoad  {\it flora-file}\\
 ?- flCompile {\it flora-file} >> {\it flora-module}.\\
 ?- flCompile  {\it flora-file}
\end{quote}
%%
The first query loads the file {\it flora-file\/} into the given module and
compiles it, if necessary. The second query loads the program into the
default module {\tt main}. The last two queries compile the file for
loading into the module {\it flora-module} and {\tt main}, respectively,
but do not load it.

Finally, an XSB program can check if a certain \FLORA module has been
loaded using the following call:
%%
\begin{quote}
 \tt
 :- import flModule/1 from flora2.\\
 ?- flModule({\it flora-module-name}).
\end{quote}
%%


\subsection{Including Files into \FLORA Programs}

The last and the simplest way to construct multi-file \FLORA 
programs is by using the {\tt \#include} preprocessing directive.
For instance if file {\tt foo.flr} contains the following instructions:
%%
\begin{quote}
  \#include file1 \\
  \#include file2\\
  \#include file3
\end{quote}
%%
the effect is the same as if the above three files were concatenated
together and stored in {\tt foo.flr}.



\section{Path Expressions}\label{sec-pathexpr}

\subsection{Path Expressions in the Rule Body}


\index{path expression}
\index{path expression!in rule body}
%%
In addition to the basic \fl syntax, the \FLORA  system also supports
\emph{path expressions} to simplify object navigation along
single-valued and multi-valued method applications, and to avoid
explicit join conditions \cite{frohn-lausen-uphoff-VLDB-94}.  The
basic idea is to allow the following \emph{path expressions} wherever
id-terms are allowed:
%%

  \medskip

\begin{enumerate} 
\item[7.]\label{eq-path-fun} ~~ {\tt O.M}
\item[8.]\label{eq-path-set} ~~ {\tt O..M} 
\end{enumerate} \medskip

\noindent
The path expression in (7) is \emph{single-valued}; it refers to the unique
object $\tt R_0$ for which $\tt O[M\fd R_0]$ holds; (8) is a
\emph{multi-valued} path expression; it refers to each $R_i$ for which $\tt
O[M\mvd\{R_i\}]$ holds.  The symbols $\tt O$ and $\tt M$ stand for an id-term
or path a expression.  Moreover, $\tt M$ can be a method that takes arguments,
i.e., $\tt O..M(P_1,\dots,P_k)$ is a valid path expression.
  
In order to obtain a unique syntax and to specify different orders of
method applications, parentheses can be used. By default, path expressions
associate to the left, so $\tt a.b.c$ is equivalent to $\tt (a.b).c$ and
specifies the unique object $\tt o$ such that $\tt a[b\fd x] \land x[c\fd
o]$ holds (note that $\tt x=a.b$). In contrast, $\tt a.(b.c)$ is the object
$\tt o1$ such that $b[c\fd x1] \land a[x1\fd o1]$ holds (here, $\tt
x1=b.c$). In general, these can be different objects. Note that in $\tt
(a.b).c$, $\tt b$ is a method name, whereas in $\tt a.(b.c)$ it is used as
an object name.  Observe that function symbols can also be applied to path
expressions, since path expressions (like id-terms) are used to refer
objects. Thus, $\tt f(a.b)$ is valid.

As path expressions and F-molecules can be arbitrarily nested, this leads
to a concise and very flexible specification language for object
properties, as illustrated in the following example.

\begin{example}[Path Expressions]\label{Ex:PathExpr}
  \rm
  Consider again the schema given in Figure~\ref{fig-flogic-model}.
  Given the name $n$ of a person, the following path expression
  references all editors of conferences in which $n$ had a
  paper:\footnote{Each occurrence of ``\_'' denotes a distinct
    don't-care variable (existentially quantified at the
    innermost level).}
\begin{qrules}
  \anon\isa conf\_p[authors\mvd\{\anon [name\fd $n$]\}].at\_conf..editors
\end{qrules}
Therefore, the answer to the \emph{query}
\begin{qrules}
  ?- P\isa conf\_p[authors\mvd\{\anon [name\fd
  $n$]\}].at\_conf[editors\mvd\{E\}].
\end{qrules}
is the set of all pairs (\textsf{P},\textsf{E}) such that \textsf{P}
is (the logical oid of) a paper written by $n$, and \textsf{E} is the
corresponding proceedings editor.  If one is also interested in the
affiliations of the above editors when the papers were published, we only
need to slightly modify our query:
\begin{qrules}
  ?- P\isa conf\_p[authors\mvd\{\anon [name\fd
  $n$]\}].at\_conf[year\fd Y]..editors[affil(Y)\fd A].
\end{qrules}
\end{example}
Thus, \FLORA path expressions support navigation 
along the method application dimension using the operators
``.''  and
``..''. In addition, intermediate objects through which such navigation
takes place can be selected by specifying the properties of such objects
inside square brackets.

\index{method!self}
To access intermediate objects that arise implicitly in the middle
of a path expression, one can define the method \textsf{self} as
{\tt X[self{\fd}X]} and then simply
write $\dots${\tt [self{\fd}O]}$\dots$ anywhere in a complex
path expression. This would bind the id of the current object to the
variable {\tt O}.\footnote{
  %%
  A similar feature is used in other languages, e.g., XSQL \cite{xsql-92}.
  %%
  }
%%

\begin{example}[Path Expressions with \textsf{self}]\label{ex-path-self}
  \rm
  Recall the second query in Example~\ref{Ex:PathExpr}. If the user is
  also interested in the respective conferences, the query can be
  reformulated as follows:
\begin{qrules}
  X[self\fd X].\\
   ?- P\isa conf\_p[authors\mvd\anon [name\fd
   $n$]].at\_conf[self\fd C, year\fd Y]..editors[affil(Y)\fd A]. 
\end{qrules}
\end{example}


\subsection{Path Expressions in the Rule Head}


Only single-valued path expressions are allowed in a rule head. Set-valued
path expressions are not allowed because the semantics is not always clear
in such cases.

\index{path expression!in rule head}
The following is an example of a path expression in rule head. For any
person X, this rule defines the grand children for X's mother.
\begin{qrules}
X.mother[grandson{\mvd}Y] :- X{\isa}person[son{\mvd}Y].
\end{qrules}
%%
Complications arise if we specify the following facts later on:
%%
\begin{qrules}
john[mother{\fd}mary]. \\
john[son{\mvd}david].
\end{qrules}
and ask the following query:
\begin{qrules}
?- mary[grandson{\mvd}S].
\end{qrules}

Here, we should be able to identify ${\tt mary}$ and ${\tt john.mother}$,
since the attribute {\tt mother} is scalar. To deal with single-valued path
expressions in rule heads, \FLORA \emph{skolemizes} ${\tt john.mother}$ and
derives the requisite equalities.  All this is done by the \FLORA compiler
transparently to the user: if a path expression in rule head is detected,
\FLORA replaces this expression with a Skolem function.  The problem here
is that maintenance of such equalities is costly (sometimes causing a
slowdown by the factor of 2--10 times). Since the user often
knows that equations of the above kind will never be derived, \FLORA leaves
it to the user to tell the compiler whether equality maintenance is needed.
Equality maintenance is discussed in Section~\ref{sec-eqmaintain}.


\section{Truth Values, Object Values, and Predicate Meta Signatures}
\label{sec-references}


Id-terms, \fl atoms, and path expressions can all be used as objects. This
is obvious for id-terms and path expressions of the form (7) and (8),
page~\pageref{eq-path-fun}. The \fl atoms (1) through (6) on
pages~\pageref{eq-scalar-atom} through~\pageref{eq-subclass} are typically
viewed as formulas and, thus, they are assumed to have a truth value only.
However, there also is a natural way to assign them object values.  For
example, {\tt o{\isa}c[m{\fd}r]} has object value {\tt o} and a truth
value.  The latter depends on whether {\tt o} belongs to class {\tt c} and
on the value of the attribute {\tt m}.

Consequently, all F-molecules of the form (1) through (8) have dual
reading. Given an intended model, \db I, of an \fl program an expression has:
%%
\begin{itemize}
  \index{molecule!object value}
\item An \emph{object value}, which yields the name(s) of the object(s)
  reachable in \db I by the corresponding expression, and 
  \index{molecule!truth value}
\item A \emph{truth value}, like any other literal or molecule of the
  language. In particular, a molecule $r$ evaluates to \emph{false} if
  \db I has no object corresponding to $r$.
\end{itemize}
%%
Thus, a path expression can be viewed as a logical formula (\emph{the
  deductive perspective}), or as an expression that represents one or more
objects (\emph{the object-oriented perspective}).

Consider the following path expression and an equivalent, decomposed
expression:

\begin{equation}\label{eq-decomp}
\tt
a..b[c\mvd\{d.e\}] \quad\ \Leftrightarrow \quad\  a[b\mvd X_{ab}]
\land d[e\fd X_{de}] \land X_{ab}[c\mvd X_{de}]. 
\end{equation}

\noindent
Such decomposition is used to determine the truth value of arbitrarily complex
path expressions in the \emph{body} of a rule.  Let $\tt \obj(path)$ denote
the Ids of all objects represented by the path expression. Then, for
(\ref{eq-decomp}) above, we have:

\begin{displaymath} \tt
\obj(a..b) = \{x_{ab} \mid \db I \models a[b\mvd x_{ab} ]\}
\qquad\textrm{ and }\qquad \obj(d.e) = \{x_{de} \mid \db I \models d[e\fd 
x_{de}]\} 
\end{displaymath}
%
where $\db I \models \varphi$ means that $\varphi$ holds in \db I.  Observe
that $\tt \obj(d.e)$ contains at most one element because the
\emph{single-valued} method $\tt e$ is applied to a single oid $\tt d$.
Thus, two formulas might be equivalent logically, but their values as
objects might be different!

In general, for an \fl\ database \db I, the object values of ground
path expressions are given by the following mapping \obj from ground molecules
to sets of ground oids:
%
\begin{displaymath}
  \begin{array}{cll@{\hspace{4em}}c}
    \obj(t) & := & \{t \mid  \db I\models t[] \}, 
     \textrm{ for a ground id-term $t$}  \\   
                                %
    \obj(o[\dots]) & := & \{o1 \mid o1\in\obj(o), \db I \models o1[\dots]
    \} \\  
                                %
    \obj(o\isa c) & := & \{o1 \mid o1\in\obj(o), \db I \models o1\isa c\}
     \\ 
                                %
    \obj(c\subcl d) & := & \{c1 \mid c1\in\obj(c), \db I \models c1\subcl
    d\} \\ 
                                %
    \obj(o.m) & :=  & \{r1 \mid r1\in\obj(r), \db I \models o[m\fd
    r]\} \\ 
                                %
    \obj(o..m) & := &  \{r1 \mid  r1\in\obj(r), \db I \models
    o[m{\mvd}\{r\}] \}
  \end{array}
\end{displaymath}

Observe that if $\tt t[]$ does not occur in \db{I}, then $\obj(t)$ is
$\emptyset$.  Conversely, a ground molecule $r$ is called \emph{active} if
$\obj(r)$ is not empty. A molecule, $r$, can be 
single-valued or multi-valued:
%%
\begin{itemize}
\item $r$ is called \emph{multi-valued} if
 \begin{itemize}
  \item it has the form $o..m$, or 
  \item it has one of the forms $\underline{o}[\dots]$,
    $\underline{o}\isa c$, $\underline{c}\subcl d$, or
    $\underline{o}.\underline{m}$, and any of the underlined
    subexpressions is multi-valued;
 \end{itemize}
\item in all other cases, $r$ is \emph{single-valued}.
\end{itemize}

In \FLORA, path expressions can appear wherever id-terms are
allowed. Consequently, the question arises whether a path expression
is intended to indicate a truth value or an object value. For
instance, we may want to call the XSB aggregate predicate {\tt findall/3}
to retrieve the oids of the managers who like to play tennis:
%%
\begin{qrules}
findall(P,P{\isa}manager[hobbies{\mvd}tennis],L)
\end{qrules}
%%
If all arguments are treated as objects, then this expression would be
translated as
%%
\begin{quote}
 \tt
 P{\isa}manager[hobbies{\mvd}tennis], findall(P,P,L)
\end{quote}
%%
and a meaningless result will be returned --- the list of all instances of
{\tt P} that evaluate to true. Since, due to the first F-molecule, these
instances of {\tt P} must be the oids of the tennis-playing managers, such
as {\tt john}, the list {\tt L} would contain those oids that happen to be
true as 0-ary facts. (For example, {\tt john} would end up on such a list if
the fact {\tt john} is true as a 0-ary predicate).

The upshot of this problem is that the default interpretation of
\fl expressions as objects is not always suitable. In our example, we need
to indicate to the compiler that the middle argument of {\tt findall/3}
ought to be translated into XSB as follows:
%%
\begin{quote}
 \tt
 findall(P,F(P),L)
\end{quote}
%%
where {\tt F(P)} is an formula into which {\tt
  P{\isa}manager[hobbies{\mvd}tennis]} is translated by the \FLORA
compiler.\footnote{
  %%
  Something like {\tt isa(P,manager),mvd(P,hobbies,tennis)}.
  %%
  }
%%
Under this translation, findall/3 will find all instances of {\tt
  P} that make {\tt F(P)} true and return a list of such instances in the
list {\tt L}. This feat is accomplished using the {\tt arguments} compiler
instruction.

\index{predicate meta signature}
\index{meta signature of a predicate}
\index{compiler directive!{\tt arguments}}
%
By default, when a truth-valued expression, $E$, such as an \fl molecule or
a path expression, appears as an argument to a predicate or function
symbol, {\it p}, the \FLORA compiler will pass the object value of the
expression to {\it p}. In order to tell the compiler that the entire
formula obtained by translating $E$ into Prolog is to be passed to $p$, we
need to define the \emph{meta signature} of $p$ using the compiler
directive {\tt arguments}.  For instance, the following directive will make
{\tt findall/3} function as intended:
%%
\begin{qrules}
:- arguments findall(oid,bform,oid).
\end{qrules}
%%
This signature declaration tells \FLORA that the first and the third
arguments to {\tt findall/3} should be translated as oids, while the second
argument of {\tt findall/3} into a formula.



\section{HiLog and Related Issues} \label{sec:hilog}


\index{HiLog}
%
HiLog \cite{hilog-jlp} is the default syntax that \FLORA uses to represent
functor terms (including object Ids) and predicates.  In HiLog, complex
terms can appear wherever a function symbol is allowed, e.g., {\tt
  group(X)(Y,Z)}, where the functor is the complex term {\tt group(X)}. In
\FLORA, any id-term, including function symbols, predicate symbols, and
their arguments, can be a HiLog term.

\index{HiLog!translation}
%
In fact, HiLog has a higher order syntax but a first order semantics
\cite{hilog-jlp}. Any HiLog term can be consistently translated into
a Prolog term. For instance, {\tt group(X)(Y,Z)} can be represented
by the Prolog term {\tt flapply(flapply(group,X),Y,Z)}. The translation
scheme is pretty straightforward and described in \cite{hilog-jlp}.

In \FLORA any term is considered as a HiLog term and therefore subject
to translation. That is, even a normal Prolog term will by default be
represented using the HiLog translaiton, e.g., {\tt foo(a)} will be
represented as {\tt flapply(foo,a)}. This is to guarantee that no
extra translation will be needed for unification to work correctly at
runtime. For instance, {\tt foo(a)} will unify with {\tt F(a)} and
bind the variable {\tt F} to {\tt foo}.


\index{HiLog!unification}
%
The following problem arises as far as unificatoin is concerned:
Should {\tt foo} unify with {\tt foo()}, which both seem like 0-ary
terms? Moreover, if the answer is yes, then should {\tt foo} unify
with {\tt foo()()}, which is also a valid HiLog term?  In \FLORA, the
answers depend on whether these 0-ary terms appear as predicate calls
in rule heads and bodies, or just as id-terms, i.e., arguments.

In general, the presence of a pair of parentheses in a term would imply
one application of the HiLog translation during
compilation. Therefore, {\tt foo()} would be represented as
{\tt flapply(foo)}, {\tt foo()()} as {\tt flapply(flapply(foo))},
and {\tt foo} as it is, i.e, {\tt foo}.  So {\tt foo} does not unify
with {\tt foo()} or {\tt foo()()} while they all act as id-terms. One
of the advantages of keeping them differently is to make a \FLORA module
communicate easily with normal XSB modules, which do not fully support
HiLog. Refer to Section~\ref{sec:flora-modules} for more information
on \FLORA modules.

However, to make programming easy in the higher order fashion, 0-ary
Prolog terms are translated like 0-ary HiLog terms when they appear
as predicate calls in rule heads and bodies. For instance, the
following two rules are equivalent in \FLORA:
\begin{quote}
\begin{verbatim}
foo :- body.
foo() :- body.
\end{verbatim}
\end{quote}
and can be invoked in a rule body by either {\tt foo}, {\tt foo()},
or more fancily, {\tt X()}, where {\tt X} is a variable to be bound
to {\tt foo} when the call succeeds.

{\tt foo} never unifies with {\tt foo()()} in \FLORA.


\subsection{Meta-programming}


\index{meta-programming}
%
\fl enhanced with HiLog lends itself naturally to meta-programming. For
instance, it is easy to examine the methods and types defined for the
various classes.  Here are some simle examples:
%%
\begin{quote}
\begin{verbatim}
// all unary scalar methods defined for John
?- john[M(_) -> _].

// all unary scalar methods that apply to John,
// for which a signature was declared
?- john[M(_) => _].

// all method signatures that apply to John,
// which are either declared explicitly or inherited
?- john[M => _].

// all method invocations defined for John
?- john[M -> _].
\end{verbatim}
\end{quote}
%%

However, a number of meta-programming primitives are still needed
since they cannot be directly expressed in \fl. Many such features are
provided by the underlying XSB system and \FLORA simply takes advantage of
them: 
%%
\begin{quote}
\begin{verbatim}
?- functor(X,f,3).
X = f(_h455,_h456,_h457)
Yes.

?- compound(f(X)).
X = _h472
Yes.

?- X =.. [f,a,b].
X = f(a,b)
Yes.
\end{verbatim}
\end{quote}
%%
Note that these primitives are used for Prolog terms only and
described in the XSB manual. Meta-programming support for HiLog terms
and F-molecules will be provided through future enhancement.



\subsection{First-Order Predicates and HiLog Predicates}
\label{sec:flora-modules-predicates}

\index{predicate!first-order}
\index{predicate!HiLog}
%%
\FLORA is an object-relational language in the sense that it supports both
the object-oriented syntax of \fl and the predicate-based ({\it i.e.},
relational) syntax of Prolog. Incorporation of predicates is conceptually
simple, but is somewhat burdened by pragmatic considerations, namely,
integration with HiLog. As a result, \FLORA has two types of predicates,
first-order {\tt predicates} and \emph{HiLog predicates}. 

The native syntax for predicates in \FLORA is that of HiLog, as explained
in Section~\ref{sec:hilog}, due to HiLog's support for meta-programming.
In particular, the query 
%%
\begin{quote}
 \tt
 ?- X(a,b).
\end{quote}
%%
would return all names of binary predicates that contain
the tuple {\tt a,b}. However, it is sometimes useful to exclude certain
predicates from the domain of the meta-variables, such as {\tt X} above.
For instance, if {\tt write/2}  is an I/O predicates, should the above
query return the binding {\tt X=write}? If so, if {\tt a} happens to be the
name of a file and {\tt b} a string, should this string be written out to
that file as a side effect of the evaluation of this query?

To avoid these semantic problems, \FLORA supports the {\tt firstorder}
declaration, which defines certain symbols as first-order predicates. For
instance,
%%
\index{compiler directive!{\tt firstorder}}
%%
\begin{quote}
 \tt
 :- firstorder foo/1, moo/3.
\end{quote}
%%
Predicates defined in this way are outside of the range of HiLog variables.
If you want all predicates to be shielded from meta programming, you can use
the following compiler directive:
%%
\index{compiler directive!{\tt firstorderall}}
%%
\begin{quote}
  \tt
  :- firstorderall.
\end{quote}

First-order predicates are module-aware. This means that the predicates defined
in different modules are treated as unrelated entities.

There is one other reason why we might sometimes use first-order predicates
over HiLog predicates, which has to do with tabling. This issue is
discussed in Section~\ref{sec-tabling-flora}.



\subsection{Abolishing \FLORA Predicates}


\index{module!{\tt expunge}}
%
To expunge a predicate of the form {\tt functor/arity} from the module that
a program is loaded into, the following compiler directive can be used:
\begin{quote}
\verb!:- expunge functor/arity.!
\end{quote}

{\tt expunge} can also be called like a normal predicate,
either from the shell or from within a rule body, to expunge
predicates in one specific module. The syntax is shown below:
\begin{quote}
\verb!:- expunge functor/arity, ..., functor/arity in module.!
\end{quote}
where {\tt in} is a special keyword, and {\tt module} stands for the
name of the module from which to expunge the list of predicates.

Note that when {\tt expunge functor/arity} is used as a normal predicate
(not as a compiler directive), it will expunge the predicate for the
default module.




\section{Equality Maintenance}\label{sec-eqmaintain}


Equality of object identities (oids) stems in the first place from the
closure axioms stupilated on scalar methods in \fl. For instance, consider
the following \fl facts:
%%
\begin{quote}
mary[spouse{\fd}john]. \\
mary[spouse{\fd}joe]. \\
john[son{\mvd}frank].
\end{quote}
%%
Because ``{\tt spouse}'' is a scalar method, i.e., single-valued method,
we know that the oids ``{\tt john}'' and ``{\tt joe}'' represent
the same object. Therefore, whatever is true about ``{\tt john}'' should
be also true about ``{\tt joe}'', and vice versa. Thus we can derive
that {\tt joe[son{\mvd}frank]}.

What is illustrated above is just a very simple scenario of equality
maintenance. Moreover, users can define equalities in a source program
using the predicate {\tt :=:}, e.g.,
\begin{quote}
\verb|john:=:batman.|
\end{quote}

Once oids are identified, it may need to propogate to all
\fl structures, including the subclass hierarchy, the ISA hierarchy, etc.,
depending on the application domain. By default, \FLORA does not use
the trailer with equality maintenance, since equality maintenance
consumes more resources.  However, users do not have to worry about
the various aspects of equality maintenance. The equality maintenance
rules are already implemented by \FLORA and the level of support for
equalitycan maintenance can be specified by using one of the following
three compiler directives:
%%
\index{equality}
\index{compiler directive!equality}
%%
{\tt
\begin{quote}
:- equality none.\\
:- equality basic.\\
:- equality flogic.
\end{quote}
}

To be more specific, \mbox{\tt equality none} does not use any feature of
equality maintenance while \mbox{\tt equality basic} guarantees the
congruence relation among object equalities, i.e., transivity, reflexity,
and symmetry. Besides the properties of equality stipulated by
\mbox{\tt equality basic}, \mbox{\tt equality floigc} will enforce the full
equality implied by \fl, including the scalar axiom.

Note that {\tt equality} can also be used as a normal predicate. When it
is called from the shell or from within a rule body, it will set equality
support for the default module. Moreover, it can also set equality level
for one specific module. The syntax is as follows:
\begin{quote}
\verb!equality {none|basic|flogic} in module!
\end{quote}
where {\tt in} is a special keyword, and {\tt module} stands for the name of
the module.


\section{Inheritance}


\index{inheritance!structural}
\index{inheritance!behavioral}
\fl identifies two types of inheritance: \emph{structural} and
\emph{behavioral}.  Structural inheritance applies to signatures only. For
instance, if {\tt student::person} and a program defines the signature
{\tt person[name{\Fd}string]} then the query {\tt ?- student[name{\Fd}X]}
succeeds with {\tt X=string}.

\index{inheritance!non-monotonic}
Behavioral inheritance is much more complicated. The problem  is that it is
\emph{non-monotonic}. That is, the addition of new facts might obviate previously
established inferences.

\index{attribute!inheritable}
\index{attribute!non-inheritable}
\fl (and \FLORA) distinguishes between attributes and methods that can
inherit values from superclasses and those that do not. The syntax that we
have seen so far applies to \emph{non-inheritable} attributes only.
\emph{Inheritable attributes} are declared using the {\tt *=>} and {\tt *=>>}
style arrows and defined using the {\tt *->} and {\tt *->>} style arrows. For
instance, the following is a \FLORA program for the classical {\tt Royal
Elephant} example:
%%
\begin{quote}
\begin{verbatim}
elephant[color*=>color].
royal_elephant::elephant.
clyde:elephant.
elephant[color*->gray].
\end{verbatim}
\end{quote}
%%
The question is what is the color of {\tt clyde}?
{\tt clyde}'s color has not been defined in the above program. However, since
{\tt clyde} is an elephant and the default color for elephants is gray,
{\tt clyde}
must be gray. Thus, we can derive:
%%
\begin{quote}
\begin{verbatim}
clyde[color->gray].  
\end{verbatim}
\end{quote}
%%
Observe that when inheritable methods are inherited from a class by its
members, the attribute becomes non-inheritable. On the other hand, when
such a method is inherited by a subclass from its superclass, then the
method is still inheritable, so it can be further inherited by the members
of that subclass or by its subclasses. For instance, if we have
%%
\begin{quote}
\begin{verbatim}
circus_elephant::elephant.
\end{verbatim}
\end{quote}
%%
then we can derive 
%%
\begin{quote}
\begin{verbatim}
circus_elephant[color*->gray].  
\end{verbatim}
\end{quote}
%%

Non-monotonicity of behavioral inheritance becomes apparent when certain new
information gets added to the knowledge base. For instance, suppose we
learn that
%%
\begin{quote}
\begin{verbatim}
royal_elephant[color*->white].  
\end{verbatim}
\end{quote}
%%
Although we have previously established that {\tt clyde} is gray, this
new information renders our earlier conclusion invalid. Indeed, Since
{\tt clyde} is a royal elephant, he must be white, while being an
elephant he must be gray.  The conventional wisdom in object-oriented
languages, however, is that inheritance from more specific classes
must take precedence. Thus, we must withdraw our earlier conclusion
that {\tt clyde} is gray and infer that he is white:
%%
\begin{quote}
\begin{verbatim}
clyde[color->white].    
\end{verbatim}
\end{quote}
%%

Behavioral inheritance in \fl is discussed at length in \cite{KLW95}.
The above problem of non-monotonicity is just a tip of the iceberg. Much
more difficult problems arise when inheritance interacts with the regular
deduction. To illustrate, consider the following program:
%%
\begin{quote}
\begin{verbatim}
b[m*->>c].
a:b.
a[m->>d] :- a[m->>c].
\end{verbatim}
\end{quote}
%%
In the beginning, it seems that \verb|a[m->>c]| should be derived by
inheritance, and so we can derive \verb|a[m->>d]|. Now, however, we can
reason in two different ways:
%%
\begin{enumerate}
\item \verb|a[m->>c]| was derived based on the belief that attribute {\tt
    m} is not defined for the object {\tt a}. However, once inherited,
  necessarily we must have \verb|a[m->>{c,d}]|. So, the value of
  attribute {\tt m} is not really that produced by inheritance. In other
  words, inheritance of \verb|a[m->>c]| negates the very premise on which
  the original inheritance was based, so we must undo the operation and the
  ensuing rule application.
\item We did derive \verb|a[m->>d]| as a result of inheritance, but
  that's OK --- we should not really be looking back and undo previously
  made inheritance inferences. Thus, the result must be \verb|a[m->>{c,d}]|.
\end{enumerate}
%%
A semantics that favors the second interpretation was proposed in
\cite{KLW95}. This approach is based on a fixpoint computation of
non-monotonic behavioral inheritance.  However, this semantics is very hard
to implement efficiently, especially using a top-down deductive engine
provided by XSB. Thus, \FLORA uses a different, more cautious semantics for
inheritance, which favors the first interpretation above.  The idea can be
summarized using the following rules, which define how class instances
inherit from the classes they belong to:
%%
\begin{quote}
\begin{verbatim}
// inheritance rules for scalar attributes
:- table defined/2, overwritten/3, conflict/3.

Obj[A->V] <- Obj:Class, Class[A*->V], tnot defined(Obj,A),
             tnot overwritten(Obj,Class,A), tnot conflict(Obj,Class,A).

defined(Obj,A) <- Obj[A->V].

overwritten(Obj,Class,A) <- Obj:Class1, Class1::Class,
                            Class1[A*->W], Class1 \= Class.

conflict(Obj,Class,A) <- Obj:Super, Super[A*->V],
                         tnot Super::Class, tnot Class::Super.

// inheritance rules for multi-valued attributes
:- table definedSet/2, overwrittenSet/3, conflictSet/3.

Obj[A->>V] <- Obj:Class, Class[A*->>V], tnot definedSet(Obj,A),
              tnot overwrittenSet(Obj,Class,A),
              tnot conflictSet(Obj,Class,A).

definedSet(Obj,A) <- Obj[A->>V].

overwrittenSet(Obj,Class,A) <- Obj:Class1, Class1::Class,
                               Class1[A*->>W], Class1 \= Class

conflictSet(Obj,Class,A) <- Obj:Super, Super[A*->V],
                            tnot Super::Class, tnot Class::Super.
\end{verbatim}
\end{quote}
%%
\index{well-founded semantics}
Negation here is implemented using the {\em well-founded semantics}
for negation \cite{gelder-alternating-89,gelder-ross-schlipf-91} (as
indicated by the {\tt tnot} operator).  Similar rules are needed to
describe how classes inherit from superclasses.

In the examples that we have seen so far, path expressions use only
non-inheritable attributes. Clearly, there is no reason to disallow
inheritable attributes in such expressions. To distinguish inheritable
attributes from non-inheritable ones in path expressions, \FLORA uses
``{\tt !}'' and ``{\tt !!}''. For instance,
%%
\begin{quote}
\begin{verbatim}
clyde!color           means: some X, such that clyde[color*->X]}.
obj!!attr             means: some Y, such that obj[attr*->>Y].
\end{verbatim}
\end{quote}
%%



\section{Aggregates}


The syntax for aggregates in \FLORA is similar to that in \FLORID. An
aggregate has the following form:
%%
\begin{qrules}
agg\{X[Gs] $|$ {\it body}\}
\end{qrules}
%%
\index{aggregation!aggregate operator}
\index{aggregation!grouping}
%
where {\tt agg} represents the aggregate operator, {\tt X} is called the
aggregation variable, {\tt Gs} is a list of comma-separated grouping
variables, and {\it body} is a logical formula that specifies the
query conditions. The grouping variables, {\tt Gs}, are optional. {\it body}
can be any combinaiton of conjunction, disjunction, and negation of literals.

All the variables appearing in {\it body} but not in {\tt X} or {\tt Gs} are
considered to be existentially quantified. Furthermore, the syntax of an
aggregate must satisfy the following conditions:
\begin{enumerate}
\item All the variable names in both {\tt X} and {\tt Gs} must
appear in {\it body};
\item {\tt Gs} should not contain {\tt X}.
\end{enumerate}

Aggregates are evaluated as follows: First, the query
conditions specified by {\it body} are evaluated to obtain all the bindings
for the tuple of the form {\tt \texttt{<}X, Gs\texttt{>}}; Then, these
tuples are grouped according to each distinct binding for
{\tt \texttt{<}Gs\texttt{>}}; Finally, for each group the aggregate operator
is applied the list of bindings for the aggregate variable.


\index{aggregates!min}
\index{aggregates!max}
\index{aggregates!count}
\index{aggregates!sum}
\index{aggregates!avg}
\index{aggregates!collectset}
\index{aggregates!collectbag}
%
The following aggregate operators are supported in \FLORA: {\tt min}, {\tt max},
{\tt count}, {\tt sum}, {\tt avg}, {\tt collectset} and {\tt collectbag}.

The operators {\tt min} and {\tt max} can apply to any list of
terms. The order among terms is defined by the XSB operator {\tt @=<}.  In
contrast, the operators {\tt sum} and {\tt avg} can take numbers only. If
the aggregate variable is instantiated to something other than a
number, {\tt sum} and {\tt avg} will discard it and generate a runtime
warning message.

For each group, the operator {\tt collectbag} collects all the bindings of
the aggregation variable into a list. The operator {\tt collectset} works
similarly to {\tt collectbag}, except that all the duplicates are removed
from the result list.

In general, aggregates can appear wherever a number or a list is
allowed. Therefore, aggregates can be nested. The following examples
illustrate the use of aggregates (some borrowed from the \FLORID manual):
%%
\begin{quote}
\begin{verbatim}
?- Z = min{S|john[salary(Year)->S]}.
?- Z = count{Year|john.salary(Year) < max{S|john[salary(Y)->S], Y < Year}}.
?- avg{S[Who]|Who:employee[salary(Year)->S]} > 20000. 
\end{verbatim}
\end{quote}
%%
If an aggregate contains grouping variables that are \emph{not} bound
by a preceding subgoal, then this aggregate would backtrack over such
grouping variables (In other words, they are considered to be
existentially quantified). For instance, in the last query above, the
aggregate will backtrack over the variable {\tt Who}. Thus, if
{\tt john}'s and {\tt mary}'s average salary is greater than {\tt 20000},
this query will backtrack and return both {\tt john} and {\tt mary}.

The following example is a query that for each employee asks for a list of
years when this employee had salary less than 60. This illustrates the use
of the {\tt collectset} aggregate.
%%
\begin{quote}
\begin{verbatim}
?- Z = collectset{Year[Who]|Who[salary(Year)->X], X < 60}.
Z = [1990,1991]
Who = mary

Z = [1990,1991,1997]
Who = john
\end{verbatim}
\end{quote}
%%

\index{aggregates!multi-valued methods}
\index{multi-valued methods!aggregation}
%
To retrieve all the return values of multi-valued methods, \FLORA provides
two new operators, {\tt ->->} and {\tt *->->}, for non-inheritable and
inheritable multi-value methods, respectively. 

In fact, {\tt ->->} and {\tt *->->} are just syntactic sugars and can be
defined using the {\tt collectset} aggregate, as follows:
\begin{quote}
\begin{verbatim}
O[M->->L] :- L=collectset{V|O[M->>V]}

O[M*->->L] :- L=collectset{V|O[M*->>V]}
\end{verbatim}
\end{quote}

The only restriction is that {\tt ->->} and {\tt *->->} cannot appear in
the head of a rule.


\subsection{Boolean Methods}


\index{method!boolean}
%
As a syntactic sugar, \FLORA introduces boolean methods, which can be
considered as scalar methods that return some fixed value, e.g.,
{\tt true}. For example, the following facts:
\begin{quote}
\verb|john[is_tall -> true].| \\
\verb|john[loves(tennis) -> true].|
\end{quote}
can be rewritten using boolean methods as follows:
\begin{quote}
\verb|john[is_tall].| \\
\verb|john[loves(tennis)].|
\end{quote}

Conceptually, boolean methods represent statements about objects whose
truth value is of primary concern. However, boolean methods are not
completely interchangeable with scalar methods in that boolean methods
do not return any value (not even the value {\tt true}). Therefore,
boolean methods can only appear inside the specification part for an
object, not as part of a path navigation like
\mbox{\tt john.is\_vegetarian}.

Like inheritable scalar methods, there are also inheritable boolean
methods. To make a boolean method inheritable, a ``\verb|*|'' sign
needs to be added before it. For instance, the following facts:
\begin{quote}
\begin{verbatim}
buddhist[*is_vegetarian].
john:buddhist.
\end{verbatim}
\end{quote}
say that all Buddhists are vegetarian and John (the object with oid {\tt
  john}) is a Buddhist. Since \verb|is_vegetarian| is inheritable, it
follows that John is also a vegetarian, i.e.,
\verb|john[is_vegetarian]|.


\subsection {Sets vs. Lists}


\index{multi-valued methods!set notation}
%
As mentioned in Section~\ref{sec-basic-flogic}, \fl uses the set
notation, \{$\ldots$\}, to specify a subset of the return values of a
multi-valued method, e.g.,
\begin{quote}
\verb|mary[children->>{john,frank}].|
\end{quote}
%%
says that the children of Mary (the object with oid {\tt mary})
\emph{include} John and Frank (the objects with oids {\tt john} and {\tt
  frank}).

However, since \fl does not support any operator to compose or
decompose a set, and Prolog does not support the set notation either,
breaking down of a set is done by the \FLORA compiler. This drawback
leads to less flexibility in programing style.

\index{multi-valued methods!list notation}
%
But in Prolog there is a data structure very close to sets --- lists.
Note that lists are indeed complex terms and potentially can also be
used as oids. To avoid this ambiguity, \FLORA introduces a new
operator, {\tt +>>}, to specify that all members of a list constitute
a subset of the return values of a multi-valued method. For example,
the following query tests whether all Mary's children are also
John's children:
\begin{quote}
\begin{verbatim}
?- mary[children->->L], john[children+>>L].
\end{verbatim}
\end{quote}

Corresponding to inheritable multi-valued methods, \FLORA introduces
another new operator, {\tt *+>>}, for use in the list notation.

The only limitation to the use of {\tt +>>} and {\tt *+>>} is that
they cannot appear in a fact or the head of a rule.



\subsection{Anonymous Oid}


\index{anonymous oid}
%
For applications where oids are not important, \FLORA provides the
compiler directive \verb|_#| to automatically generate a new
oid. \verb|_#| can be used wherever an id-term is allowed. Like the
anonymous variable \verb|_|, each occurrence of \verb|_#| represents
an anonymous oid. The difference is that such an oid is not only
``unique'' in each rule, but in the source program as well.

However, ``unique'' is just the approximate saying. The \FLORA
compiler does not really check for uniqueness of those newly generated
oids.  When \FLORA compiles a source program, it first initiates a
sequential counter.  Each occurrence of \verb|_#| causes the counter
to be incremented by one, and a new oid to be generated by
concatenating a fixed prefix, e.g, \verb|_$_$_flora'newoid|, and the
content of the counter.

For example, the following program:
\begin{quote}
\begin{verbatim}
_#[ssn->123, father->_#[name->john, spouse->_#[name->mary]]].
foo[_#(X)->Y] :- foo(X,Y).
\end{verbatim}
\end{quote}
is the same as the following one, where the anonymous oids are explicitly
replaced by the corresponding encrypted strings that would be generated
by the \FLORA compiler:
\begin{quote}
\begin{verbatim}
'_$_$_flora''newoid1'[ssn->123, father->'_$_$_flora''newoid2'].
'_$_$_flora''newoid2'[name->john, spouse->'_$_$_flora''newoid3'].
'_$_$_flora''newoid3'[name->mary].
foo['_$_$_flora''newoid4'(X)->Y] :- foo(X,Y).
\end{verbatim}
\end{quote}



\section{\FLORA and Tabling}\label{sec-tabling-flora}


\subsection{Tabling in a Nutshell}


\index{tabling}
%
Tabling is a technique that enhances top-down evaluation with a mechanism
that remembers the calls previously made during query evaluation.
This technique is known to be essentially equivalent to the Magic Sets
method for bottom-up evaluation. However, tabling combined with top-down
evaluation has the advantage of being able to utilize highly optimized
compilation techniques developed for Prolog. The result is a very efficient
deductive engine.

XSB lets the user specify which predicates must be tabled.  The \FLORA
compiler automatically tables the predicates used to flatten F-molecules.
However, the user is responsible for telling the system which other
predicates must be tabled. (Normally, these are predicates defined by the
user.)  \FLORA accepts the same tabling directives as XSB does
(Section~\ref{sec-comp-directives} lists all the compiler directives).

\index{table}
\index{compiler directive!{\tt table}}
%
Due to the current implementation of HiLog and module system in \FLORA, a
HiLog predicate cannot be tabled directly (without hacking into the \FLORA
implementation). To table a predicate, it must be declared as a first-order
predicate using the \mbox{\tt firstorder functor/arity} compiler directive
(refer to Section~\ref{sec:hilog} and
Section~\ref{sec:flora-modules-predicates} for more information on these
compiler directives). For instance, the following \FLORA program:
\begin{quote}
\begin{verbatim}
:- firstorder tc/2.
:- table tc/2.

tc(X,Y) :- edge(X,Y).
tc(X,Y) :- edge(X,Y), tc(Y,Z).
\end{verbatim}
\end{quote}
%%
renders {\tt tc/2}  as a tabled first-order predicate.

\index{hilogtable}
\index{compiler directive!{\tt hilogtable}}
%%
It is also possible to table HiLog predicates, but the granularity of 
tabling is coarse: \FLORA tables \emph{all} HiLog predicates of the given
arity at once. For instance, 
%%
\begin{quote}
 \tt
 :- hilogtable 3.
\end{quote}
%%
tables all HiLog predicates of arity 3.

It is important to keep in mind that XSB does not do reordering of
objects and predicates during joins. Instead, all joins are performed
left-to-right.  Thus, program clauses must be written in such a way as
to ensure that smaller predicates and classes appear early on in the
join. Also, even though XSB tables the results obtained from previous
queries, the current tabling engine has several limitations. In
particular, when a new query comes in, XSB tries to determine if this
query is ``similar'' to one that already has been answered (or is in
the process of being evaluated).  Unfortunately, the current notion of
similarity used by XSB is fairly weak, and many unnecessary
recomputations might result. This problem will be corrected in a
future release.

\index{abolish\_all\_tables}
%%
It is also important to be aware that when XSB (and \FLORA) evaluate a program,
all tabled predicates are partially materialized and all the computed
tuples are stored in XSB tables. Thus, if you change the set of facts, the
existing tables must be discarded in order to allow XSB to recompute the
results. This is accomplished by issuing the predicate
{\tt abolish\_all\_tables/0} described in the XSB manual.


\subsection{Procedural Methods}


\index{method!procedural}
%
Unfortunately, tabling sometimes has undesirable effects in
``real-world'' programming, especially on those predicates with
non-logical ``side effects'' (e.g., writing or reading a file).  If a
tabled predicate has such side effects, then the first time the predicate
is called the side effect will be performed, but the second time the call
simply returns with success or failure (depending on the outcome of the
first call).  Thus, if the predicate is intended to perform the side
effect each time it is called, it will not operate correctly.

In the object-oriented programming style, people tend to define
methods with side effects and attach them to objects. These methods
are \emph{procedural} in nature and should be performed each time they
are called. Because by default \FLORA tables everything that comes
from F-molecules, these procedural methods are potentially subject to
the same problem as described above.

To solve this program, \FLORA introduces a new syntax to identify
procedural methods --- simply put a ``\verb|#|'' sign in front of a
procedural method. For instance, the following rule defines an
output method that for every object writes out its oid in canonical
form:
\begin{quote}
\verb|O[# output] :- write_canonical(O).|
\end{quote}

Like boolean methods in \FLORA, procedural methods do not return any
value but can take any number of arguments. The only difference is that
procedural methods are \emph{not} tabled, while boolean methods are.


\subsection{Cuts}


\index{cuts in \FLORA}
\index{cutting across tables}
%%
No discussion of a logic programming language is complete without a few
words about the infamous Prolog cut (!). Although Prolog cut has been
(mostly rightfully) excommunicated by as far as Database Query Languages
are concerned, it is sometimes indispensable when doing ``real work'', like
pretty-printing \FLORA programs or implementing a pattern matching
algorithm.  To facilitate this kind of tasks, \FLORA lets the programmer
use cuts.  However, the current implementation of XSB has a limitation that
Prolog cuts cannot ``cut across tabled predicates.''  Without trying to
pretend to be experts, we refer the reader to the XSB manual for details on
this obscure problem. The XSB team is considering correcting this problem
in a future release.

For now, enjoy your cut.  If you get an error message telling something
about cutting across the tables --- you know that you may have cut too much.
The basic rule that can keep you out of trouble is: do not put a cut
in the body of a rule \emph{after} any F-molecule. However, it is (usually)
OK to to put a cut before any F-molecule. It is even OK to have a cut in
the body of a rule that \emph{defines} an F-molecule (again, provided that
the body has no F-molecule to the left of that cut).


\section{Updates}


\index{update}
%
\FLORA provides the users with several predicates to update the runtime
database. The first note about these predicates is that they operate
on \emph{base} facts only, but not on derived facts. That is, an
insertion predicate only inserts facts into the database, while a
deletion predicate never remove derived facts from the database.

These update predicates can be categorized into two different groups,
based on their effects upon backtracking: non-backtrackable and
backtrackable.


\subsection{Non-backtrackable Updates} \label{sec:non-backtrackable-updates}


\index{update!non-backtrackable}
%
The effects of non-backtrackable updates persist once the operations are
executed, even when a later failure causes the system to backtrack.

\FLORA supports the following non-backtrackable update predicates:
{\tt insert}, {\tt insertall}, {\tt delete}, {\tt deleteall},
{\tt erase}, {\tt eraseall}.

\index{non-backtrackable update!insert}
\index{non-backtrackable update!insertall}
%
\paragraph{Insertion.} The syntax of an insertion predicate is as follows:
\begin{quote}
\begin{verbatim}
insop{literals [| formula]}
\end{verbatim}
\end{quote}
where {\tt insop} stands for either {\tt insert} or {\tt insertall},
{\tt literals} stands for any number of comma separated literals,
including predicates and \mbox{F-molecules}, and {\tt [| formula]}
stands for an optional logic formula following the vertical bar
(``{\tt |}'') to specify additional quantifying conditions for the
literals that will be inserted. For instance,
\begin{quote}
\begin{verbatim}
insert{p(a),mary[spouse->smith,children->>frank]}
insertall{P[spouse->S] | S[spouse->P]}
\end{verbatim}
\end{quote}

While {\tt insert} inserts only one instance of the literals that
satisfy the formula, {\tt insertall} inserts \emph{all} instances
of the literals that satisfy the formula.

Note that each literal appearing inside the insertion predicate is
treated as a separate fact. Thus these literals should follow the
syntactic rules for facts and literals in the rule head (e.g,
multi-valued path expressions are not allowed), except that module
names can be specified for them, which means it is allowed to update
the facts for other modules. Moreover, module name specification here
is distributive over multiple literals enclosed by a pair of
parentheses. For example, the insertion predicate below:
\begin{quote}
\begin{verbatim}
insert{(mary[children->>frank], john[father->smith]) @ foomod}
\end{verbatim}
\end{quote}
is equivalent to the following one:
\begin{quote}
\verb|insert{mary[children->>frank] @ foomod, john[father->smith] @ foomod}|
\end{quote}


\index{non-backtrackable update!delete}
\index{non-backtrackable update!deleteall}
\index{non-backtrackable update!erase}
\index{non-backtrackable update!eraseall}
%
\paragraph{Deletion.} The syntax of a deletion predicate is as follows:
\begin{quote}
\begin{verbatim}
delop{literals [| formula]}
\end{verbatim}
\end{quote}
where {\tt delop} stands for any of the following four deletion
operations: {\tt delete}, {\tt deleteall}, {\tt erase}, and
{\tt eraseall}, {\tt literals} stands for any number of comma
separated literals, including predicates and \mbox{F-molecules},
and {\tt [| formula]} stands for an optional logic formula following
the vertical bar (``{\tt |}'') to specify additional quantifying
conditions for the literals that will be deleted.

For instance, the following predicate:
\begin{quote}
\begin{verbatim}
deleteall{john[Year(Semester)->>Course] | Year < 2000}
\end{verbatim}
\end{quote}
will delete John's course selection history before the year
2000.

Note that the comma separated literals are actually in conjunctive
form specifying the conditions that the literals should hold jointly
to be deleted. That is, if variables in these literals have the same
name, then they should share the same binding. For example, suppose
the database contains the following facts:
\begin{quote}
\begin{verbatim}
p(a). p(b). q(a). q(c).
\end{verbatim}
\end{quote}
then the predicate below:
\begin{quote}
\begin{verbatim}
delete{p(X),q(X)}
\end{verbatim}
\end{quote}
will succeed with the variable {\tt X} bound to {\tt a}.  However, if
the database contains only the facts {\tt p(b)} and {\tt q(c)}, then
the above predicate will fail.

\FLORA supports four different deletion operations, {\tt delete},
{\tt deleteall}, {\tt erase}, and {\tt eraseall}:
\begin{enumerate}
\item If there are serveral bindings or matches for
      the literals to be deleted, then {\tt delete} will choose only
      one of them and delete it. The choice is nondeterministic.
      For instance, suppose the database contains the following facts:
      \begin{quote}
      \verb|p(a). p(b). q(a). q(b).|
      \end{quote}
      then
      \begin{quote}
      \verb|delete{p(X),q(X)}|
      \end{quote}
      will succeed with {\tt X} bound to either {\tt a} or {\tt b},
      depending on the ordering of facts in the database at runtime.

\item On the other hand, {\tt deleteall} will try to delete ``all''
      bindings or matches. However, the meaning of ``all'' here is
      limited to some ``minimum'' semantics. The problem arises when
      a fact appears in several bindings or matches for the literals.
      For instance, suppose the database contains the following facts:
      \begin{quote}
      \verb|p(a). q(b). q(c).|
      \end{quote}
      then both \verb|<p(a),q(b)>| and \verb|<p(a),q(c)>| are good
      bindings for \verb|<p(a),q(X)>|. But the question is: What will
      \verb|deleteall{p(a),q(X)}| do? Should it delete both or just one?

      \smallskip

      In fact, \FLORA will randomly choose one of them and delete it.
      The idea is to remove the \emph{minimum} amount of facts to
      \emph{invalidate} the literals taken together as a conjunctive
      query. For the above example, after the two facts {\tt p(a)} and
      {\tt q(b)} (or {\tt q(c)}) are deleted, there will be no binding for
      \verb|<p(a),q(X)>|. Therefore, further deleting {\tt q(c)}
      (or {\tt q(b)}) seems like an overkill.

      \smallskip

      Unlike the {\tt delete} predicate, {\tt deleteall} \emph{always}
      succeeds. However, when it succeeds, {\tt deleteall} will leave
      all variables unbound.

\item {\tt erase} works like {\tt delete}, but with extra functionalities
      built for \fl facts. While deleting an \fl fact, {\tt erase}
      will traverse the object tree starting from the object of
      interest specified in this fact, and delete \emph{all} \fl facts
      related those objects encountered on its path.

\item {\tt eraseall} is the full version of {\tt erase}, just like {\tt deleteall}
      is the full version of {\tt delete}. {\tt eraseall} will try to erase
      ``all'' bindings or matches. It always succeeds and will leave all
      variables unbound when it returns.
\end{enumerate}


\subsection{Backtrackable Updates}


\index{update!backtrackable}
%
The effects of backtrackable updates are undone upon backtracking,
i.e., a previous inserted item will be removed from the database, and
a previous deleted item will be put back into the database when the
system backtracks.

\index{backtrackable update!btinsert}
\index{backtrackable update!btinsertall}
\index{backtrackable update!btdelete}
\index{backtrackable update!btdeleteall}
\index{backtrackable update!bterase}
\index{backtrackable update!bteraseall}
%
In \FLORA, the syntax of backtrackable update predicates is similar
to that of non-backtrackable update predicates, except that the
predicate names are different. The syntax of a backtrackable insertion
predicate is:
\begin{quote}
\begin{verbatim}
btinsop{literals [| formula]}
\end{verbatim}
\end{quote}
while the syntax of a backtrackable deletion predicate is:
\begin{quote}
\begin{verbatim}
btdelop{literals [| formula]}
\end{verbatim}
\end{quote}
where {\tt btinsop} stands for either {\tt btinsert} or {\tt btinsertall},
{\tt btdelop} stands for any of the following four backtrackable
deletion operations: {\tt btdelete}, {\tt btdeleteall}, {\tt bterase}, and
{\tt bteraseall}. The meanings of {\tt literals} and {\tt [| formula]} are
explained in Section~\ref{sec:non-backtrackable-updates}.

{\tt btinsert}, {\tt btinsertall}, {\tt btdelete}, {\tt btdeleteall},
{\tt bterase}, and {\tt bteraseall} work similarly to {\tt insert},
{\tt delete}, {\tt deleteall}, {\tt erase}, and {\tt eraseall},
respectively, except that the former is backtrackable while the latter
is not. Refer to Section~\ref{sec:non-backtrackable-updates} for
details of these operations.

To illustrate the difference between backtrackable and
non-backtrackable updates, consider the following execution trace
immediately after the \FLORA system starts:
\begin{quote}
\begin{verbatim}
flora2 ?- insert{p(a)}, fail.

No.

flora2 ?- p(a).

Yes.

flora2 ?- btinsert{q(a)}, fail.

No.

flora2 ?- q(a).

No.
\end{verbatim}
\end{quote}
In the above example, when the first \verb|fail| executes, the system
backtracks to {\tt insert\{p(a)\}} and does nothing. Thus the insertion
of {\tt p(a)} persists and the following query \verb|p(a)| returns
with {\tt Yes}. However, when the second \verb|fail| executes, the
system backtracks to {\tt btinsert\{q(a)\}} and removes {\tt q(a)} that
was previously inserted into the database. Thus the next query
\verb|q(a)| returns with {\tt No}.


\subsection{Updates and Tabling}


To implement object properties, \FLORA relies on a feature of XSB called
\emph{tabling} (see Section~\ref{sec-tabling-flora} for more details).
Unfortunately, tabling and database updates do not mix well.
The problem is that the results from previous queries are stored in
XSB tables, and database updates do not modify XSB tables.

Thus, a user might get the following counterintuitive result:
\begin{quote}
\begin{verbatim}
flora2 ?- insert{o[m->v]}.

Yes.

flora2 ?- o[m->v].

Yes.

flora2 ?- delete{o[m->v]}, o[m->v].

Yes.
\end{verbatim}
\end{quote}
The reason for the last positive answer here is that XSB tables remember
that the query {\tt o[m->v]} is true. So, when the same query is asked
after {\tt delete}, a ``wrong'' result is returned from the tables. Similarly,
tabling might interact poorly with {\tt insert}:
\begin{quote}
\begin{verbatim}
flora2 ?- o[m->v].

No.

flora2 ?- insert{o[m->v]}, o[m->v].

No.
\end{verbatim}
\end{quote}
The reason for the last result here is, again, that XSB tables
remember that {\tt o[m->v]} is false. However, this is no longer
correct after the insertion operation.

\index{abolish\_all\_tables}
%%
In a future release, \FLORA will provide a workaround for these
problems (and it is even possible that a future release of XSB will
start doing the right thing in these situations). For now, the only
remedy is to use a call to {\tt abolish\_all\_tables}, which will
clear all tables.  However, at present, the only safe way to do this
is by executing {\tt abolish\_all\_tables} as a separate query.

Because of the way a tabled predicate is executed, it is a bad
programming practice to define a tabled predicate that depends on
database updates and/or procedural methods. For now, the \FLORA
compiler does not automatically check this kind of dependency. Such
a feature will be supported in a future release.


\section{Negation} \label{sec:negation}


\FLORA supports two kinds of negation: negation based on SLD resolution,
and negation based on well-founded semantics, which relies on the
underlying XSB tabling system.

For negation based on SLD resolution, it is specified using the operators
\NAF and {\tt not}.

For negation based on well-founded semantics, it is specified using the
operator {\tt tnot}. Usually, {\tt tnot} is applied to predicates that
are tabled. Note that except procedural methods, all \fl methods are
tabled, thus {\tt tnot} can be applied to them.

All tabled predicates should use {\tt tnot} for negation. The
semantics is not clear when negation based on SLD resolution is
applied to a tabled predicate.

In \FLORA, {\tt tnot} can also be specified for a non-tabled
predicate, or a logic formula. The effect is such that the system will
first generate a new tabled predicate to hold the results from the
non-tabled predicate or the logic formula, then apply {\tt tnot} to
this new predicate.

In fact, {\tt tnot} in \FLORA is implemented using the XSB operator
\verb|sk_not|. Refer to the XSB manual for more information on
negation, well-founded semantics, and the XSB operators {\tt tnot} and
\verb|sk_not|.



\section{Control Constructs}

For user convenience, \FLORA provides a number of control structures
borrowed from other languages. One often used such construct is
{\tt if-then-else}. For instance, 
%%
\begin{quote}
 \tt
 ?- if (foo(a),foo2(b)) then (abc(X),cde(Y)) else (qpr(X),rts(Y)).
\end{quote}
%%
Here the system first evaluates {\tt foo(a),foo2(b)} and, if true,
evaluates {\tt abc(X),cde(Y)}. Otherwise, it evaluates {\tt qpr(X),rts(Y)}.
The entire clause succeeds or fails depending on whether the {\tt
  then}-part or the {\tt else}-part succeeds or fails (whichever applies).
The {\tt if-then} version (without the {\tt else}-part) is also provided.
In this case, when the {\tt if}-condition succeeds, the {\tt then}-part is
evaluated. The entire clause is then succeeds or fails depending on the
{\tt then}-part. When the {\tt if}-condition is false, the entire clause fails.

Note that {\tt if}, {\tt then}, and {\tt else} are implemented as
operators, and they bind stronger than the conjunction ``,'', the
disjunction ``;'', etc. This is why the parentheses are needed in the above
example.

In the current version, the \FLORA parser does not yet handle all the
syntax errors associated with the use of {\tt if-then-else} and nested
clauses are not always parsed the way one would expect (say, as in C).
Therefore, explicit parentheses are recommended around the entire clause. 



\section{Type Checking}


\index{type checking}
%%
Although \FLORA allows specification of object types through signatures,
type correctness is not being checked automatically. So, what are the
signatures good for then? One answer is that future versions of \FLORA
might support some forms of type checking. However, because \fl can
naturally support powerful meta-programming, even the current level
of support for signatures is useful. For instance, users can write
simple queries to check the types of methods that might look suspicious.
Here is one way to construct such a type-checking query:
%%
\begin{verbatim}
scalar_type_incorrect(O,M,R) :- O[X->R], O:C, C[X=>D], tnot R:D.
?- scalar_type_incorrect(obj,meth,Result).
\end{verbatim}
%%
Here, we define what it means to violate type checking using the usual
\fl semantics. The corresponding predicate can then be queried. A
``no'' answer means that the corresponding attribute \emph{does not}
violate the typing rules.

In this way, one can easily consruct special purpose type checkers.  This
feature is particularly important when dealing with \emph{semistructured}
data. (Semistructured data has object-like structure but normally does not
need to conform to any type; or if it does, the type would normally cover
only certain portions of the object structure.)


\section{Summary of \FLORA Compiler Directives} \label{sec-comp-directives}

\index{compiler directive}
%
\index{compiler directive!{\tt index}}
\index{compiler directive!{\tt firstorder}}
\index{compiler directive!{\tt firstorderall}}
\index{compiler directive!{\tt expunge}}
\index{compiler directive!{\tt equality}}
\index{compiler directive!{\tt arguments}}
\index{compiler directive!{\tt op}}
%
Like XSB compiler, \FLORA compiler can take compiler directives. All
such directives must begin with {\tt :-} (while all queries must begin with
{\tt ?-}). The following is a list of all the compiler directives supported
by \FLORA:
\begin{itemize}
\item {\tt expunge} {\em functor/arity}, ..., {\em functor/arity}
  \\
  Abolishes the listed first-order predicates in the current program's module,
  {\it i.e.}, deletes the contents as well as the definition of the
  corresponding predicate. By program's module we mean the module into
  which the program that contains this particular {\tt expunge} directive
  is loaded.
\item {\tt expunge} {\em functor/arity}, ..., {\em functor/arity} {\tt
    in} \emph{module}\\
  Same as above, except the predicates are expunged in the specified
    module rather than in the current program's module.
  \item {\tt equality none|basic|flogic}
    \\
    Sets the equality maintenance level in the current program's module.
    With {\tt none}, equality is not maintained, and the symbol {\tt :=:}
    works like an ordinary predicate.  With {\tt basic}, the predicate {\tt
      :=:} is treated as the equality, but only the usual congruence axioms
    for equality are enforced. With {\tt flogic}, the usual congruence
    axioms are maintained \emph{plus} the additional equality axiom for
    single-valued methods in \fl.
\item {\tt equality none|basic|flogic} {\tt in}  \emph{module}
  \\
  Same as above, except that equality maintenance is set for the specified
  module.
\item {\tt firstorder} {\em functor/arity}, ..., {\em functor/arity}
  \\
  Declare the listed predicates as first-order predicates (as opposed to HiLog
  predicates).
\item {\tt firstorderall}
  Makes all predicates into first-order predicates. (The default for predicates
  is HiLog.)
\item {\tt arguments} \emph{functor}(\emph{type}, ..., \emph{type}), where
  \emph{type} is either {\tt oid} {\tt bform}
  \\
  Specifies the meta signature to the given predicate, which tells how the
  arguments of the predicate are to be compiled. {\tt oid} means that the
  oid of the corresponding argument is computed and passed to the predicate
  as an argument. {\tt bform} means the argument is compiled as a body
  subgoal and passed to the predicate as such. This type of compilation is
  useful in meta-predicates, such as {\tt findall/3}, which need to
  consider the truth value of some of their arguments rather their oid.
\item {\tt import {\it functor/arity}, ..., {\it functor/arity} from
    {\it module}}
  \\
  Imports the given predicate from the specified XSB module.
\item {\tt index {\it functor/arity-argNumber}}
  \\
  Specifies that the given predicate must be indexed on the specified
  argument.
\item {\tt op({\it precedence},{\it type},{\it operator})}
  \\
  Defines \emph{operator} as a \FLORA operator with the given precedence
  and type. The \emph{type} is the same as in Prolog operators, {\it i.e.},
  {\tt fx}, {\tt xf}, {\tt xfy}, etc.
\item {\tt op({\it precedence},{\it type},[{\it operator}, ..., {\it operator}])}
  \\
  Same as above, except that this directive defines a list of operators
  with the same precedence and type.
\item {\tt table {\it functor/arity}, ..., {\it functor/arity}}
\end{itemize}


\section{\FLORA Libraries}

\FLORA provides a number of useful libraries that other programs can
use. We describe the functionality of these libraries below.

\paragraph{Pretty printing.}


\section{\FLORA Debugger}
\index{debugging}


*********** Must be fixed when the debugger is adapted **********


\FLORA debugger is essentially a presentation layer on top of the XSB
debugger, so familiarity with the latter is highly recommended (XSB Manual,
Part I). Here we sketch only a few basics.

The debugger has two facilities: tracing and spying. Tracing allows the
user to watch the program being executed step by step, and spying allows
one to tell \FLORA that it must pose when execution reaches certain 
predicates or object methods. The user can trace the execution from then
on. At present, only the tracing facility has been implemented.

\index{tracing}
To start tracing, you must issue the command {\tt flora\_trace} at the
\FLORA prompt. It is also possible to put the subgoal {\tt flora\_trace} in
the middle of the program. In tat case, tracing will start after this
subgoal gets executed. This is useful when you know where exactly you want
to start tracing the program. To stop tracing, type {\tt flora\_notrace}.

During tracing, the user is normally prompted at the four ports of subgoal
execution: {\tt Call} (when a subgoal is first called), {\tt Exit} (when
the call exits), {\tt Redo} (when the subgoal is tried with a different
binding on backtracking), and {\tt Fail} (when a subgoal fails).
At each of the prompts, the user can issue a number of commands. The most
common ones are listed below. See the XSB manual for more.
%%
\begin{itemize}
  \item {\tt carriage return (creep)}:  to go to the next step  
  \item {\tt s (skip)}: execute this subgoal non-interactively; prompt
    again when the call exits (or fails)
  \item {\tt S (verbose skip)}: like {\tt s}, but also show the trace
    generated by this execution
  \item {\tt l (leap)}: stop tracing and execute the remainder of the
    program
\end{itemize}
%%
The behavior of the debugger is controled by the predicate {\tt
  debug\_ctl}. For instance, executing {\tt debug\_ctl(profile, on)} at the
\FLORA prompt tells XSB to measure the CPU time it takes to execute each
call. This is useful for tuning your program for performance. Other useful
controls are: {\tt debug\_ctl(prompt, off)}, which causes the trace to be
generated without user intervention; and {\tt debug\_ctl(redirect,
  foobar)}, which redirects debugger output to the file named {\tt foobar}.
The latter feature is usually useful only in conjunction with the
  aforesaid prompt-off mode. See the XSB manual for additional information
  on debugger control.


\section{Emacs Support}

Editing and debugging \FLORA programs can be greatly simplified with the
help of \emph{flora-mode}, a special Emacs editing mode designed
specifically for \FLORA programs. Flora-mode provides support for syntactic
highlighting, automatic indentation, and the ability to run \FLORA programs
right out of the Emacs buffer.


\subsection{Instalation}


To install \emph{flora-mode}, you must perform the following steps. Put the
file
%%
\begin{quote}
  {\tt XSB/packages/flora2/emacs/flora.el} 
\end{quote}
%%
found in your XSB distribution on the load path of Emacs or XEmacs
(whichever you are using). The best way to work with Emacs is to make a
separate directory for Emacs libraries (if you do not have one), and put
{\tt flora.el} there. Such a directory can be added to emacs search path by
putting the following command in the file \verb|~/.emacs| (or
\verb|~/.xemacs|, if you are running one of the newer versions of XEmacs):
%%
\begin{quote}
  \tt
   (setq load-path (cons "your-directory" load-path)) 
\end{quote}
%%
It is also a good idea to compile emacs libraries. To compile flora.el,
use this:
%%
\begin{quote}
  \tt
   emacs -batch -f batch-byte-compile flora.el 
\end{quote}
%%
If you are using XEmacs, use {\tt xemacs} instead of {\tt emacs} above ---
the two emacsen often use incompatible byte code.

Finally, you must tell X/Emacs how to recognize \FLORA program files, so
Emacs will be able to invoke the Flora major mode automatically when you
are editing such files:
%%
\begin{verbatim}
(setq auto-mode-alist (cons '("\\.flr$" . flora-mode) auto-mode-alist))
(autoload 'flora-mode "flora" "Major mode for editing Flora programs." t)
\end{verbatim}
%%$

To enable syntactic highlighting of Emacs buffers (not just for \FLORA
programs), you can do the following:
%%
\begin{itemize}
  \item  {\sf In Emacs:} select {\tt Help.Options.Global Font Lock} on
    the menubar.  To enable highlingting permanently, put 
    %%
    \begin{quote}
      \tt
      (global-font-lock-mode t)
    \end{quote}
    %%
    in \verb|~/.emacs|.
  \item {\sf In XEmacs:} select {\tt Options.Syntax
        Highlighting.Automatic} in the menubar. To enable this permanently, put
      %%
      \begin{quote}
        \tt
        (add-hook 'find-file-hooks 'turn-on-font-lock)
      \end{quote}
      %%
      in \verb|~/.emacs| or \verb|~/.xemacs| (whichever is used by your
      XEmacs).
\end{itemize}
%%


\subsection{Functionality}


\paragraph{Menubar menu.}
Once flora editing mode is installed, it provides a number of functions.
First, whenever you edit a \FLORA program, you will see the ``Flora'' menu
in the menubar. This menu provides commands for controlling the Flora
process (i.e., XSB with the \FLORA shell). You can start and stop
this process, type queries to it, and you can tell it to consult regions of
the buffer you are editing, the entire buffer, or some other file.

Because Emacs provides automatic file completion and allows you to edit
what you typed, performing these functions right out of the buffer takes
much less effort than typing the corresponding commands on XSB command
line.

\paragraph{Keyboard functions.}
In addition to the menu, \emph{flora-mode} lets you execute most of the
menu commands using the keyboard. Once you get the hang of it, keyboard
commands are much faster to invoke:
%%
\begin{verbatim}
Consult file:                 Ctl-c Ctl-f
Consult file dynamically:     Ctl-u Ctl-c Ctl-f
Consult buffer:               Ctl-c Ctl-b
Consult buffer dynamically:   Ctl-u Ctl-c Ctl-b
Consult region:               Ctl-c Ctl-r
Consult region dynamically:   Ctl-u Ctl-c Ctl-r
\end{verbatim}
%%
When you invoke any of the above commands, a \FLORA process is started,
unless it is already running. However, if you want to invoke this process
explicitly, type
%%
\begin{verbatim}
ESC x run-flora  
\end{verbatim}
%%
You can control the \FLORA process using the following commands:
%%
\begin{verbatim}
Interrupt Flora Process:      Ctl-c Ctl-c
Quit Flora Process:           Ctl-c Ctl-d
Restart Flora Process:        Ctl-c Ctl-s
\end{verbatim}
%%
Interrupting \FLORA is equivalent to typing {\tt Ctl-c} at the \FLORA
prompt, quitting the process stops XSB, and restarting the process shuts
down the old XSB process and starts a new one with \FLORA shell running.

\paragraph{Indentation.}
Flora editing mode understands some aspects of the \FLORA syntax, which
enables it to provide correct indentation of program lines (in many cases).
In the future, flora mode will know more about the syntax, which will let
it provide even better support for indentation.

The most common use of \FLORA indentation facility is by typing the {\tt
  TAB}-key. If \emph{flora-mode} manages to understand where the cursor is,
it will indent the line accordingly. Another way is to put the following in
your emacs startup file (\verb|~/.emacs| or \verb|~/.xemacs|):
%%
\begin{verbatim}
    (setq flora-electric t)  
\end{verbatim}
%%
In this case, whenever you type the return key, the next line will be
indented automatically.



\appendix

\section{Inside \FLORA}


\subsection{The File Structure}

\FLORA consists of the following modules:
\begin{itemize}
\item \texttt{flrshell.P}: The top level module that provides the \FLORA shell
  commands for compiling and consulting \FLORA programs, for setting the
  output mode, and -- last but not the least -- for directly issuing
  queries against the loaded database/program (see
  Section~\ref{sec-shell-commands} for a full description of shell
  commands).
\item \texttt{flrlexer.P}: The \FLORA lexer.
\item \texttt{flrcomposer.P}: The \FLORA composer that parses tokens 
  according to the operator grammar (converts operator syntax into Prolog
  terms) and also does other magic.
\item \texttt{flrparser.P}: The \FLORA parser.
\item \texttt{flrcompiler.P}: The \FLORA compiler that translates \fl to XSB.
\item \texttt{flrcoder.P}: The \FLORA coder that generates XSB code.
\item \texttt{flrutils.P}: Miscellaneous utility predicates.
\end{itemize}
%%
Additional system libraries are located in the {\tt syslib/} subdirectory.
The sbudirectory {\tt trailer/} contains trailers that implement the
various axioms implied by \FLORA semantics.  There is also a number of
files in the {\tt closure/} subdirectory that serve as headers and trailers
that are automatically included into the {\tt .P} files by the \FLORA
compiler (explained later).

There are several subdirectories that hold the various files that contain
definitions included at compile time. These will be described in a
technical document.


\subsection{How It Works}


As an \fl-to-XSB compiler, \FLORA first parses its source file,
compiles it into XSB syntax and then outputs XSB code. For instance the command
\begin{quote}
\verb|flora ?- flLoad(myprog).|
\end{quote}
would compile the \FLORA program ``{\tt myprog.flr}'' and generate the
following files: ``{\tt myprog.flh}'', ``{\tt myprog.P}'',
``{\tt myprog\_main.P}'', and ``{\tt myprog.fdb}'' (if ``{\tt myprog.flr}''
contains \fl facts).  By default, {\tt flLoad(myprog)} loads the
program into the default module named ``main''. ``{\tt myprog.flh}''
contains this module name definition.  If ``{\tt myprog.flr}''
contains \fl facts, all these facts will be compiled separately into
the XSB file ``{\tt myprog.fdb}'' that is to be dynamically loaded at
runtime. When the compilation process continues, the file ``{\tt
myprog\_main.P}'' will be generated and passed to the XSB compiler,
yielding byte code ``{\tt myprog\_main.O}'', which is then loaded and
executed.  If ``{\tt myprog.flr}'' contains queries, they are
immediately executed by XSB (provided there are no errors).

In the module system of \FLORA, a program can be loaded into any
arbitrarily named module. Even the same program can loaded into
different modules at the same time. For each module, a different byte
code will be generated (module name is appended to the source file
name to generate the name of the file containing the byte code). This
is achieved by encoding the name of the module into all predicates
(not function symbols) appearing in the program. Take a look at
``{\tt myprog\_main.P}'' to see what has become of your \FLORA program!

The main purpose of the \FLORA shell, however, is to allow the evaluation
of ad-hoc \fl queries. For example, after having consulted the
the \texttt{'default.flr'} file from the demo directory by launching
the command \texttt{flora2~?-~flDemo(default).}, you may ask
\begin{verbatim}
    flora2 ?-  X..kids[                 % Whose kids
                 self -> K,             % ... (list them by name)
                 hobbies ->>            % ... have hobbies
                   H:dangerous_hobby    % ... that are dangerous?
    ]. 
\end{verbatim}
\FLORA will parse, flatten, and evaluate this query in the same way as
those queries in a source program.


\paragraph{\FLORA compilation.}
The basic idea behind the implementation of \fl by translating it into
predicate calculus is described in \cite{KLW95}. It consists of two parts:
translation of F-molecules into various kinds of Prolog predicates, and
addition of appropriate ``closure rules'' that implement the
object-oriented semantics of the logic.

Consider, for instance, the following complex F-molecule, representing
facts about the object \texttt{mary} (the syntax of \fl is given in
Section \ref{sec-basic-flogic}):

\begin{quote}
{\small\begin{verbatim}
mary:employee[age->29, kids->>{tim,leo}, salary(1998)->a_lot].
\end{verbatim}}
\end{quote}

As described in \cite{KLW95}, any complex F-molecule can be
decomposed into a conjunction of simpler \fl atomic formulas. These
latter atoms can be directly represented using Prolog syntax.  For
different kinds of \fl atoms we use different Prolog predicates. For
instance, the result of translating the above F-molecule might be:

\begin{quote}
{\small
\begin{verbatim}
isa(mary,employee).           % mary:employee.
fd(mary,age,29).              % mary[age->29].
mvd(mary,kids,tim).           % mary[kids->>{tim}].
mvd(mary,kids,leo).           % mary[kids->>{leo}].
fd(mary,salary(1998),a_lot).  % mary[salary(1998)->a_lot].
\end{verbatim}
  }
\end{quote}
%%

\index{closure axioms}
The closure axioms are intended to provide the following semantic features:
%%
\begin{itemize}
\item Compute transitive closure of ``\subcl'' (the subclass relationship).  A
  runtime check warns about cycles in the subclass hierarchy.
\item Compute closure of ``\isa'' with respect to ``\subcl'', i.e., if $X\isa C,
  C\subcl D$ then $X\isa D$.
\item Perform monotonic and non-monotonic inheritance.
\item Make sure that scalar methods are, indeed, scalar.
\end{itemize}
%%
Templates for these axioms reside in the subdirectory \texttt{closure/}.

The above is a much simplified picture of the inner-workings of \FLORA. The
actual translation into Prolog and the form of the closure rules is very
complex.  Some of this complexity exists to ensure good performance.  Other
complications come from the need to provide a module system of \FLORA and
integrate it into the XSB system.  The module system serves two purposes.
First, it promotes modular design for \FLORA programs, making it possible
to split the code into separate files and import objects defined in other
modules. Second, it allows \FLORA programs to communicate with XSB by using
the predicates defined in XSB programs and letting XSB programs use \FLORA
objects.  Some of these implementation issues are described in
\cite{guiz-flora-00}.



\bibliography{../../../docs/userman/manual}

\printindex

\end{document}
