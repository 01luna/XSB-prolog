/* File:      flrcanon.P
**
** Author(s): Michael Kifer
**            Chang Zhao
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) The Research Foundation of SUNY, 2003
**
** FLORA-2 is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** FLORA-2 is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with FLORA-2; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
** 
** 
*/



:- compiler_options([xpp_on]).

#include "flora_terms.flh"

:- dynamic 
        flora_rule_signature(_,_,_,_,_).

:- dynamic
	flora_body_to_head_conversion_cache(_,_),
	flora_head_to_body_conversion_cache(_,_).

:- import
	is_flora_callable_literal/1,
        flora_module_predicate/4,
        flora_decode_predicate/7,
        flora_decode_predicate/6
   from flrwrapper.

:- import append/3 from basics.

:- import
	flora_generalize_last/2,
        flora_trim_last/2
   from flrtrim.

:- import
	length/2
   from basics.

:- import
        flora_concat_atoms/2
   from flrporting.

:- export
	get_canonical_form/2,
	convert_to_body_literal/2,
	convert_to_head_literal/2,
        flora_rule_signature/5,
        flora_build_pred_signature/2,
        flora_restore_from_signature/2,
        flora_preprocess_headlist/2,
        flora_reset_rule_signature/1.

/******************************************************************************
  get_canonical_form(+Term,-Canon)
  get the canonical form Canon of the given Term. Canon is in the form
  of FLCANON(Wrap,Args,Module,Callable)
******************************************************************************/
%% Case of Var
get_canonical_form(Term,FLCANON(_,_,_,Term)) :-
       var(Term),
       !.

%% Case of Var@...
get_canonical_form(FLLIBMODLIT(FL_LIBMOD,Term,Mod,_Caller),Canon) :-
	var(Term),
	!,
        Canon = FLCANON(_,_,Mod,Term).

%% Case of #Var@... where Var is unbound
get_canonical_form(FLLIBMODLIT(WRAP_HILOG,[FL_TRAN,Term,_TC],Mod,_Caller),Canon) :-
	var(Term),
	!,
        Canon = FLCANON(WRAP_HILOG,_,Mod,Term).

%% Case of #Var@... where Var is bound to a predicate
get_canonical_form(FLLIBMODLIT(WRAP_HILOG,[FL_TRAN,Term,_TC],Mod,_Caller),Canon) :-
        !,
        ( atom(Term) ->
            ArgsOut=[Term,_],
	    (var(Mod) -> 
	        Canon = FLCANON(WRAP_HILOG,ArgsOut,Mod,_)
	    ;
	        flora_module_predicate(WRAP_HILOG,ArgsOut,Mod,Callable),
	        Canon = FLCANON(WRAP_HILOG,ArgsOut,Mod,Callable)
            )
        ; is_flora_callable_literal(Term) ->
            get_canonical_form(Term,Canon)
        ; Term = FLLIBMODLIT(_W,_A,_M,_C) ->
            get_canonical_form(Term,Canon),
            Canon = FLCANON(_NW,_NA,NM,_NC),
            ( var(NM) -> NM=Mod; true) 
        ; Term =.. [WRAP_HILOG|As] ->
            append(As,[_],ArgsOut),
	    (var(Mod) -> 
	        Canon = FLCANON(WRAP_HILOG,ArgsOut,Mod,_)
	    ;
	        flora_module_predicate(WRAP_HILOG,ArgsOut,Mod,Callable),
	        Canon = FLCANON(WRAP_HILOG,ArgsOut,Mod,Callable)
            )
        ).

get_canonical_form(FLLIBMODLIT(FL_LIBMOD,Term,Mod,Caller), Canon) :-
	!,
        ( atom(Term) ->
            ArgsOut=[Term,_],
	    (var(Mod) -> 
	        Canon = FLCANON(WRAP_TABLED_HILOG,ArgsOut,Mod,_)
	    ;
	        flora_module_predicate(WRAP_TABLED_HILOG,ArgsOut,Mod,Callable),
	        Canon = FLCANON(WRAP_TABLED_HILOG,ArgsOut,Mod,Callable)
            )
        ; is_flora_callable_literal(Term) ->
            get_canonical_form(Term,Canon)
        ; Term = FLLIBMODLIT(_W,_A,_M,_C) ->
            get_canonical_form(Term,Canon),
            Canon = FLCANON(_NW,_NA,NM,_NC),
            ( var(NM) -> NM=Mod; true) 
        ; Term = WRAP_HILOG(FL_TRAN,NewTerm) ->
            get_canonical_form(FLLIBMODLIT(WRAP_HILOG,[FL_TRAN,NewTerm,_TC],Mod,Caller),Canon)
        ; Term =.. [WRAP_HILOG|As] ->
            append(As,[_],ArgsOut),
	    (var(Mod) -> 
	        Canon = FLCANON(WRAP_TABLED_HILOG,ArgsOut,Mod,_)
	    ;
	        flora_module_predicate(WRAP_TABLED_HILOG,ArgsOut,Mod,Callable),
	        Canon = FLCANON(WRAP_TABLED_HILOG,ArgsOut,Mod,Callable)
            )
        ).

%% Case of nonvar@Var
get_canonical_form(FLLIBMODLIT(Wrap,Args,Mod,_Caller), Canon) :-
	!,
	flora_generalize_last(Args,ArgsOut),
	(var(Mod) -> 
	    Canon = FLCANON(Wrap,ArgsOut,Mod,_)
	;
	    flora_module_predicate(Wrap,ArgsOut,Mod,Callable),
	    Canon = FLCANON(Wrap,ArgsOut,Mod,Callable)
	).

get_canonical_form(Term, Canon) :-
	flora_decode_predicate(Term,Type,TermModuleName,Wrapper,WPrefix,PSym,ArgL),
        ( ((Type==hilog);(Type==flogic);(Wrapper==WRAP_HILOG)) ->
	    flora_generalize_last(ArgL,ArgLout),
	    flora_generalize_last(Term,TermOut)
        ;
            ArgLout=ArgL,
            TermOut=Term
        ),
	(Type == (hilog) % hilog predicate
	->
            flora_concat_atoms([WPrefix,WRAP_HILOG],PF),
	    flora_module_predicate(PF,[PSym|ArgLout],TermModuleName,
				   CallableHiLog),
	    Canon = FLCANON(PF,[PSym|ArgLout],TermModuleName,
			    CallableHiLog)
	; 
	    Canon = FLCANON(Wrapper,ArgLout,TermModuleName,TermOut)
	).

/****************************************************************************
**       convert_to_head_literal(+Body,-Head)
** Converts body form of Flora predicates to their head form;
** if already head then leaves intact.
** Caches its result for faster processing
****************************************************************************/
convert_to_head_literal(Body,Head) :-
	var(Body),
	!,
	Head = Body.
convert_to_head_literal(Body,Head) :-
	flora_body_to_head_conversion_cache(Body,Head),
	!.
convert_to_head_literal(Body,Head) :-
	flora_decode_predicate(Body,Type,ModuleName,_Prefix,MainWrapper,ArgL),
	(Type == (hilog) -> Head = Body
	;
	    flora_module_predicate(MainWrapper,ArgL,ModuleName,Head)
	),
	functor(Body,BodyF,Arity),
	functor(Head,HeadF,_),
	length(NewArgs,Arity),
	HeadTempl =.. [HeadF|NewArgs],
	BodyTempl =.. [BodyF|NewArgs],
	assert(flora_body_to_head_conversion_cache(BodyTempl,HeadTempl)).

/****************************************************************************
**       convert_to_body_literal(+Body,-Head)
** Converts head form of Flora predicates to their body form;
** if already head then leaves intact.
** Caches its result for faster processing
****************************************************************************/
convert_to_body_literal(Head,Body) :-
	var(Head),
	!,
	Body = Head.
convert_to_body_literal(FLLIBMODLIT(Wrap,Args,Mod,_Caller),FLLIBMODLIT(Wrap,Args,Mod,_NewCaller)) :-
	!.

convert_to_body_literal(Head,Body) :-
	flora_head_to_body_conversion_cache(Head,Body),
	!.
convert_to_body_literal(Head,Body) :-
	flora_decode_predicate(Head,Type,ModuleName,_Prefix,MainWrapper,ArgL),
	(Type == (hilog) -> Body = Head
	;
            (( Type == (flogic) ; Head =.. [WRAP_HILOG|_Args]) ->
	        flora_concat_atoms([FLDEBUGPREFIX,MainWrapper],BodyWrapper),
	        flora_module_predicate(BodyWrapper,ArgL,ModuleName,Body)
            ;
                Body = Head
            )
	),
	functor(Head,HeadF,Arity),
	functor(Body,BodyF,_),
	length(NewArgs,Arity),
	HeadTempl =.. [HeadF|NewArgs],
	BodyTempl =.. [BodyF|NewArgs],
	assert(flora_head_to_body_conversion_cache(HeadTempl,BodyTempl)).



/***********************************************************************
 flora_build_pred_signature(+Body,-BodySig)
 translate into fllibmodlit canonical form
************************************************************************/ 
flora_build_pred_signature(B,B) :-
        atomic(B),
        !.

flora_build_pred_signature(B,B) :-
        var(B),
        !.

flora_build_pred_signature(','(B1,B2),','(NB1,NB2)) :-
	!,
	flora_build_pred_signature(B1,NB1),
	flora_build_pred_signature(B2,NB2).

flora_build_pred_signature(';'(B1,B2),';'(NB1,NB2)) :-
	!,
	flora_build_pred_signature(B1,NB1),
	flora_build_pred_signature(B2,NB2).

flora_build_pred_signature(not(B),not(NB)) :-
	!,
	flora_build_pred_signature(B,NB).

flora_build_pred_signature(tnot(B),tnot(NB)) :-
	!,
	flora_build_pred_signature(B,NB).

flora_build_pred_signature(Body,NB) :-
        is_list(Body),
        !,
        build_list(Body,NB).

flora_build_pred_signature(FLSYSDBUPDATE(P,_Storage,_Module),PSig) :-
        !,
        flora_build_pred_signature(P,PSig).

flora_build_pred_signature(Body,BodySig) :-
        is_flora_callable_literal(Body),
        !,
        get_canonical_form(Body,BodySig).

flora_build_pred_signature(FLLIBMODLIT(Wrap,Args,Mod,Caller),BodySig) :-
        !,
        get_canonical_form(FLLIBMODLIT(Wrap,Args,Mod,Caller),BodySig).

flora_build_pred_signature(Body,NB) :-
        Body =.. [Op|Args],
        !,
        build_list(Args,NArgs),
        NB =.. [Op|NArgs].

	
build_list([],[]) :- !.
build_list([H|L],[NH|NL]) :-
	flora_build_pred_signature(H,NH),
	build_list(L,NL).

/***********************************************************************
 flora_preprocess_headlist(+HeadList,-NewHeadList)
 One element in the HeadList may actually correspond to a list of atoms,
 for example, X ~ ${a[b->V1,c->V2]}, insertrule_a{X :- something}.
 We have similar situation for deleterule and clause.
 flora_preprocess_headlist expands such rule head to the corresponding list
************************************************************************/ 
flora_preprocess_headlist([],[]) :- !.

flora_preprocess_headlist([H|L],[H|LList]) :-
        var(H),
        !,
        flora_preprocess_headlist(L,LList).
        
flora_preprocess_headlist([FLLIBMODLIT(FL_LIBMOD,A1,MName,Caller)|L],NewHeadList) :-
        !,
        (var(A1) ->
            HList = [FLLIBMODLIT(FL_LIBMOD,A1,MName,Caller)]
        ; A1 = (First,Rest) ->
            (First = FLLIBMODOBJ(_FF,_FA,_FM,_FC,_FO) ->
                First,
                flora_preprocess_headlist([FLLIBMODLIT(FL_LIBMOD,Rest,MName,Caller)],HList)
            ;
                flora_preprocess_headlist([FLLIBMODLIT(FL_LIBMOD,First,MName,Caller)],HFList),
                flora_preprocess_headlist([FLLIBMODLIT(FL_LIBMOD,Rest,MName,Caller)],HRList),
                append(HFList,HRList,HList)
            )
        ; HList = [FLLIBMODLIT(FL_LIBMOD,A1,MName,Caller)]
        ),
        flora_preprocess_headlist(L,LList),
        append(HList,LList,NewHeadList).

flora_preprocess_headlist([H|L],[H|LList]) :-
        flora_preprocess_headlist(L,LList).
        

/***********************************************************************
 flora_reset_rule_signature(+Module)
 retract all rule signature for the Module
***********************************************************************/
flora_reset_rule_signature(Module) :-
        retractall(flora_rule_signature(_Prefix,FLCANON(_,_,Module,_),_BodySig,_RuleList,_BridgeRule)).

/***********************************************************************
 flora_restore_from_signature(+Signature,-Pred)
************************************************************************/ 
flora_restore_from_signature(PredSig,PredSig) :-
        atomic(PredSig),
        !.

flora_restore_from_signature(PredSig,Pred) :-
        var(PredSig),
        !,
        (var(Pred) -> Pred=PredSig; true).

flora_restore_from_signature(','(B1,B2), ','(NB1,NB2)) :-
        !,
        flora_restore_from_signature(B1,NB1),
        flora_restore_from_signature(B2,NB2).

flora_restore_from_signature(';'(B1,B2), ';'(NB1,NB2)) :-
        !,
        flora_restore_from_signature(B1,NB1),
        flora_restore_from_signature(B2,NB2).

flora_restore_from_signature(not(B), not(NB)) :-
        !,
        flora_restore_from_signature(B,NB).

flora_restore_from_signature(tnot(B), tnot(NB)) :-
        !,
        flora_restore_from_signature(B,NB).

flora_restore_from_signature(B,NB) :-
        is_list(B),
        !,
        restore_list(B,NB).

flora_restore_from_signature(FLCANON(_Wrap,_Args,_Mod,Callable),Pred) :-
        nonvar(Callable),
        Pred=Callable,
        !. 

flora_restore_from_signature(FLCANON(_Wrap,_Args,_Mod,Callable),FLSYSDBUPDATE(Callable,_Storage,_Mod)) :-
        nonvar(Callable),
        !. 

flora_restore_from_signature(FLCANON(Wrap,Args,Mod,Callable),Pred) :-
        var(Pred),
        !,
        ( var(Wrap) ->
            Pred = FLLIBMODLIT(FL_LIBMOD,Callable,Mod,_Caller)
        ;
            ( Wrap == WRAP_HILOG ->
                %% non-tabled hilog
                ( var(Args) ->
                    Pred = FLLIBMODLIT(Wrap,[FL_TRAN,Callable,_Caller],Mod,_Caller)
                ;
                    flora_trim_last(Args,TArgs),
                    Term =.. [WRAP_HILOG|TArgs],
                    Pred = FLLIBMODLIT(Wrap,[FL_TRAN,Term,_Caller],Mod,_Caller)
                )
            ;
                Pred = FLLIBMODLIT(Wrap,Args,Mod,_Caller)
            )
        ).

flora_restore_from_signature(FLCANON(Wrap,Args,Mod,Callable),FLLIBMODLIT(FL_LIBMOD,Callable,Mod,_Caller)) :-
        (var(Callable), nonvar(Wrap) ->
            ( Wrap == WRAP_HILOG ->
                ( var(Args) ->
                    true
                ;
                    flora_trim_last(Args,TArgs),
                    Term =.. [WRAP_HILOG|TArgs],
                    Callable = FLLIBMODLIT(Wrap,[FL_TRAN,Term,_Caller],Mod,_Caller)
                )
            ;
                Callable = FLLIBMODLIT(Wrap,Args,Mod,_Caller)
            )
        ;
            true
        ),
        !.

flora_restore_from_signature(FLCANON(WRAP_HILOG,Args,Mod,Callable),FLLIBMODLIT(WRAP_HILOG,[FL_TRAN,Term,Caller],Mod,Caller)) :-
        !,
        ( var(Args) ->
            Term=Callable
        ;
            flora_trim_last(Args,TArgs),
            Term =.. [WRAP_HILOG|TArgs]
        ).

flora_restore_from_signature(FLCANON(Wrap,Args,Mod,_Callable),FLLIBMODLIT(Wrap,Args,Mod,_Caller)) :-
        !. 

flora_restore_from_signature(B,NB) :-
        B =.. [Op|Args],
        !,
        ( var(NB) ->
            restore_list(Args,NArgs),
            NB =.. [Op|NArgs]
        ;
            NB =.. [Op|NArgs],
            restore_list(Args,NArgs)
        ).

restore_list([],[]) :- !.
restore_list([H|L],[NH|NL]) :-
	flora_restore_from_signature(H,NH),
	restore_list(L,NL).
