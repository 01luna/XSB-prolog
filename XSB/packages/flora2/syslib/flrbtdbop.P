/* File:      flrbtdbop.P
**
** Author(s): Guizhen Yang 
**
** Contact:   xsb-contact@cs.sunysb.edu
**
** Copyright (C) The Research Foundation of SUNY, 1999-2001
**
** XSB is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** XSB is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with XSB; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
** 
** 
*/


:- compiler_options([xpp_on]).

#include "flora_terms.flh"


:- import var/1, call/1 from standard.

:- import
	storage_find_fact/2,
	storage_insert_fact_bt/3,
	storage_delete_fact_bt/3
   from storage.

:- import findall/3, sort/2 from setof.

:- import append/3 from basics.

:- import flora_register_syslib/1 from flrlibman.

:- import flora_error_line/1 from flrprint.

:- import
	flora_setup_flogic_bswrapper/1,
	flora_flogic_bswrapper/2,
	flora_flogic_predicate/4,
	flora_wspredicate/4
   from flrwrapper.

:- import flora_list2conjunct/2 from flrutils.


/*********************************************************************
  This file is for the following backtrackable FLORA database operations:
  btinsert, btinsertall, btdelete, btdeleteall, bterase, bteraseall.
*********************************************************************/
?- flora_register_syslib(FLLIBBTDBOP).


/*********************************************************************
  system library registration
*********************************************************************/
?- flora_register_syslib(FLLIBBTINSERT).


/*****************************************************************************
  fllibbtinsert(+List)
*****************************************************************************/
fllibbtinsert(List) :- fllibbtinsert(List,true).


/*****************************************************************************
  fllibbtinsert(+List,+Condition)
*****************************************************************************/
fllibbtinsert(List,Condition) :-
	call(Condition),
	flora_storage_insertfacts_bt(List).


/*****************************************************************************
  flora_storage_insertfacts_bt(+List)
*****************************************************************************/
flora_storage_insertfacts_bt([]) :- !.

flora_storage_insertfacts_bt([H|_T]) :-
	var(H),
	!,
	flora_error_line('uninstantiated argument of btinsert operation'),
	abort.

flora_storage_insertfacts_bt([FLLIBMODLIT(P,Args,WS)|T]) :-
	!,
	flora_wspredicate(P,Args,WS,H),
	storage_insert_fact_bt(FLORA_STORAGE_NAME,H,_Inserted),
	flora_storage_insertfacts_bt(T).

flora_storage_insertfacts_bt([FLLIBMODOBJ(P,Args,WS,O)|T]) :-
	!,
	flora_wspredicate(P,Args,WS,O),
	flora_storage_insertfacts_bt(T).

flora_storage_insertfacts_bt([H|T]) :-
	storage_insert_fact_bt(FLORA_STORAGE_NAME,H,_Inserted),
	flora_storage_insertfacts_bt(T).


/*********************************************************************
  system library registration
*********************************************************************/
?- flora_register_syslib(FLLIBBTINSERTALL).


/*****************************************************************************
  fllibbtinsertall(+List)
*****************************************************************************/
fllibbtinsertall(List) :- fllibbtinsert(List).


/*****************************************************************************
  fllibbtinsertall(+List,+Condition)
*****************************************************************************/
fllibbtinsertall(List,Condition) :-
	findall(List,Condition,FsList),
	!,
	flora_btinsertall_facts(FsList).


/*****************************************************************************
  flora_btinsertall_facts(+FactsList)

  Note: This predicate always succeeds.
*****************************************************************************/
flora_btinsertall_facts([]) :- !.

flora_btinsertall_facts([Fs|FL]) :-
	flora_storage_insertfacts_bt(Fs),
	flora_btinsertall_facts(FL).


/*********************************************************************
  system library registration
*********************************************************************/
?- flora_register_syslib(FLLIBBTDELETE).


/*****************************************************************************
  fllibbtdelete(+List)
*****************************************************************************/
fllibbtdelete(List) :- fllibbtdelete(List,true).


/*****************************************************************************
  fllibbtdelete(+List,+Condition)

  The semantics is such that all the literals in "List" must be base facts
  in the storage to be deleted.
*****************************************************************************/
fllibbtdelete([P],true) :-
	var(P),
	!,
	flora_error_line('uninstantiated argument of delete operation'),
	abort.

fllibbtdelete([P],true) :-
	!,
	( P = FLLIBMODLIT(F,Args,WS) ->
	    flora_wspredicate(F,Args,WS,X)
	;
	  X=P
	),
	storage_delete_fact_bt(FLORA_STORAGE_NAME,X,_Deleted).

fllibbtdelete(List,Condition) :-
	flora_storage_convertlist(List,CallList,FactList),
	flora_list2conjunct([Condition|CallList],Goal),
	call(Goal),
	flora_storage_deletelist_bt(FactList).


/*****************************************************************************
  flora_storage_convertlist(+List,-CallList,-FactList)
*****************************************************************************/
flora_storage_convertlist([],[],[]) :- !.

flora_storage_convertlist([FLLIBMODLIT(P,Args,WS)|Fs],
                          [flora_wspredicate(P,Args,WS,F),storage_find_fact(FLORA_STORAGE_NAME,F)|CL],
			  [F|FL]) :-
	!,
	flora_storage_convertlist(Fs,CL,FL).

flora_storage_convertlist([FLLIBMODOBJ(P,Args,WS,Obj)|Fs],
                          [flora_wspredicate(P,Args,WS,Obj)|CL],
			  FL) :-
	!,
	flora_storage_convertlist(Fs,CL,FL).

flora_storage_convertlist([F|Fs],[storage_find_fact(FLORA_STORAGE_NAME,F)|CL],FL) :-
	!,
	flora_storage_convertlist(Fs,CL,FL).


/*****************************************************************************
  flora_storage_deletelist_bt(+List)
*****************************************************************************/
flora_storage_deletelist_bt([]) :- !.

flora_storage_deletelist_bt([P|L]) :-
	!,
	storage_delete_fact_bt(FLORA_STORAGE_NAME,P,_Deleted),
	flora_storage_deletelist_bt(L).


/*****************************************************************************
  flora_storage_insertlist_bt(+List)
*****************************************************************************/
flora_storage_insertlist_bt([]) :- !.

flora_storage_insertlist_bt([P|L]) :-
	!,
	storage_insert_fact_bt(FLORA_STORAGE_NAME,P,_Inserted),
	flora_storage_insertlist_bt(L).


/*********************************************************************
  system library registration
*********************************************************************/
?- flora_register_syslib(FLLIBBTDELETEALL).


/*****************************************************************************
  flora_storage_deleteall_bt(+Predicate)

  Note: This predicate always succeeds.
*****************************************************************************/
flora_storage_deleteall_bt(P) :-
	findall(P,storage_find_fact(FLORA_STORAGE_NAME,P),L),
	!,
	flora_storage_deletelist_bt(L).


/*****************************************************************************
  fllibbtdeleteall(+List)
*****************************************************************************/
fllibbtdeleteall(List) :- fllibbtdeleteall(List,true).


/*****************************************************************************
  fllibbtdeleteall(+List,+Condition)

  The semantics is such that all the literals in "List" must be base facts
  in the storage to be deleted. This call always succeeds.
*****************************************************************************/
fllibbtdeleteall([P],true) :-
	var(P),
	!,
	flora_error_line('uninstantiated argument of btdeleteall operation'),
	abort.

fllibbtdeleteall([P],true) :-
	!,
	( P = FLLIBMODLIT(F,Args,WS) ->
	    flora_wspredicate(F,Args,WS,X)
	;
	  X=P
	),
	!,
	flora_storage_deleteall_bt(X).

fllibbtdeleteall(List,Condition) :-
	flora_storage_convertlist(List,CallList,FactList),
	flora_list2conjunct([Condition|CallList],Goal),
	findall(FactList,Goal,FsList),
	!,
	flora_btdeleteall_facts(FsList,_DeletedFsList).


/*****************************************************************************
  flora_btdeleteall_facts(+FactList,-DeletedFactList)

  Note: This predicate always succeeds.
*****************************************************************************/
flora_btdeleteall_facts([],[]) :- !.

flora_btdeleteall_facts([Fs|FL],[Fs|DFL]) :-
	flora_storage_deletelist_bt(Fs),
	!,
	%% Make this predicate backtrackable.
	flora_storage_insertlist_bt(Fs),
	!,
	flora_storage_deletelist_bt(Fs),
	flora_btdeleteall_facts(FL,DFL).

flora_btdeleteall_facts([_Fs|FL],DFL) :-
	flora_btdeleteall_facts(FL,DFL).


/*********************************************************************
  system library registration
*********************************************************************/
?- flora_register_syslib(FLLIBBTERASE).


/*****************************************************************************
  fllibbterase(+List)
*****************************************************************************/
fllibbterase(List) :- fllibbterase(List,true).


/*****************************************************************************
  fllibbterase(+List,+Condition)
*****************************************************************************/
fllibbterase(List,Condition) :-
	flora_storage_convertlist(List,CallList,FactList),
	flora_list2conjunct([Condition|CallList],Goal),
	call(Goal),
	flora_storage_deletelist_bt(FactList),
	flora_bterase_facts(FactList).


/*****************************************************************************
  flora_bterase_facts(+List)
*****************************************************************************/
flora_bterase_facts([]) :- !.

flora_bterase_facts([F|Fs]) :-
	!,
	flora_bterase_one_fact(F),
	flora_bterase_facts(Fs).


/*****************************************************************************
  flora_bterase_one_fact(+Fact)

  Note: For an F-logic fact this predicate continues to trace links and
        delete other F-logic facts. It always succeeds.
*****************************************************************************/
flora_bterase_one_fact(Fact) :-
	Fact =.. [Funct|Args],
	( flora_flogic_predicate(Funct,Workspace,_Position,Base) ->
	    ( Base == WRAP_ISA     -> Args=[O,_C]
	    ; Base == WRAP_SUB     -> Args=[O,_C]
	    ; Base == WRAP_FD      -> Args=[_S,_A,O]
	    ; Base == WRAP_MVD     -> Args=[_S,_A,O]
	    ; Base == WRAP_IFD     -> Args=[_S,_IA,O]
	    ; Base == WRAP_IMVD    -> Args=[_S,_IA,O]
	    ; Base == WRAP_METH    -> Args=[O,_M]
	    ; Base == WRAP_IMETH   -> Args=[O,_IM]
	    ; Base == WRAP_EXISTS  -> Args=[O]
	    ; Base == WRAP_MVDDEF  -> Args=[O,_A]
	    ; Base == WRAP_IMVDDEF -> Args=[O,_IA]
	    ; Base == WRAP_TRAN    -> Args=[O,_T]
	    ; Base == WRAP_FDSIG   -> Args=[_S,_AS,O]
	    ; Base == WRAP_IFDSIG  -> Args=[_S,_IAS,O]
	    ; Base == WRAP_MVDSIG  -> Args=[_S,_AS,O]
	    ; Base == WRAP_IMVDSIG -> Args=[_S,_IAS,O]
	    )
	;
	  true
        ),
	!,
	( var(O) ->
	    true
	;
	  flora_setup_flogic_bswrapper(Workspace),
	  flora_bterase_objects([O])
	).


/*****************************************************************************
  flora_bterase_objects(+ObjectList)
*****************************************************************************/
flora_bterase_objects([]) :- !.

flora_bterase_objects([O|OList]) :-
	!,
	flora_flogic_bswrapper(WRAP_ISA,WSBisa),
	flora_flogic_bswrapper(WRAP_SUB,WSBsub),
	flora_flogic_bswrapper(WRAP_METH,WSBmeth),
	flora_flogic_bswrapper(WRAP_IMETH,WSBimeth),
	flora_flogic_bswrapper(WRAP_TRAN,WSBtran),
	flora_flogic_bswrapper(WRAP_FD,WSBfd),
	flora_flogic_bswrapper(WRAP_IFD,WSBifd),
	flora_flogic_bswrapper(WRAP_FDSIG,WSBfdsig),
	flora_flogic_bswrapper(WRAP_IFDSIG,WSBifdsig),
	flora_flogic_bswrapper(WRAP_MVD,WSBmvd),
	flora_flogic_bswrapper(WRAP_IMVD,WSBimvd),
	flora_flogic_bswrapper(WRAP_MVDSIG,WSBmvdsig),
	flora_flogic_bswrapper(WRAP_IMVDSIG,WSBimvdsig),
	flora_flogic_bswrapper(WRAP_EXISTS,WSBexists),
	flora_flogic_bswrapper(WRAP_MVDDEF,WSBmvddef),
	flora_flogic_bswrapper(WRAP_IMVDDEF,WSBimvddef),
	Wfd =.. [WSBfd,O,_,X],
	Wifd =.. [WSBifd,O,_,X],
	Wfdsig =.. [WSBfdsig,O,_,X],
	Wifdsig =.. [WSBifdsig,O,_,X],
	Wmvd =.. [WSBmvd,O,_,X],
	Wimvd =.. [WSBimvd,O,_,X],
	Wmvdsig =.. [WSBmvdsig,O,_,X],
	Wimvdsig =.. [WSBimvdsig,O,_,X],
	findall(X,( storage_find_fact(FLORA_STORAGE_NAME,Wfd)
                  ; storage_find_fact(FLORA_STORAGE_NAME,Wifd)
	          ; storage_find_fact(FLORA_STORAGE_NAME,Wfdsig)
                  ; storage_find_fact(FLORA_STORAGE_NAME,Wifdsig)
                  ; storage_find_fact(FLORA_STORAGE_NAME,Wmvd)
                  ; storage_find_fact(FLORA_STORAGE_NAME,Wimvd)
                  ; storage_find_fact(FLORA_STORAGE_NAME,Wmvdsig)
                  ; storage_find_fact(FLORA_STORAGE_NAME,Wimvdsig)
	          ),
                AddedOList
               ),
	append(OList,AddedOList,NewOList),
	sort(NewOList,NextOList),
	Pisa =.. [WSBisa,O,_],
	Psub =.. [WSBsub,O,_],
	Pmeth =.. [WSBmeth,O,_],
	Pimeth =.. [WSBimeth,O,_],
	Ptran =.. [WSBtran,O,_],
	Pfd =.. [WSBfd,O,_,_],
	Pifd =.. [WSBifd,O,_,_],
	Pfdsig =.. [WSBfdsig,O,_,_],
	Pifdsig =.. [WSBifdsig,O,_,_],
	Pmvd =.. [WSBmvd,O,_,_],
	Pimvd =.. [WSBimvd,O,_,_],
	Pmvdsig =.. [WSBmvdsig,O,_,_],
	Pimvdsig =.. [WSBimvdsig,O,_,_],
	Pexists =.. [WSBexists,O],
	Pmvddef =.. [WSBmvddef,O,_],
	Pimvddef =.. [WSBimvddef,O,_],
	!,
	flora_storage_deleteall_bt(Pisa),
	flora_storage_deleteall_bt(Psub),
	flora_storage_deleteall_bt(Pmeth),
	flora_storage_deleteall_bt(Pimeth),
	flora_storage_deleteall_bt(Ptran),
	flora_storage_deleteall_bt(Pfd),
	flora_storage_deleteall_bt(Pifd),
	flora_storage_deleteall_bt(Pfdsig),
	flora_storage_deleteall_bt(Pifdsig),
	flora_storage_deleteall_bt(Pmvd),
	flora_storage_deleteall_bt(Pimvd),
	flora_storage_deleteall_bt(Pmvdsig),
	flora_storage_deleteall_bt(Pimvdsig),
	flora_storage_deleteall_bt(Pexists),
	flora_storage_deleteall_bt(Pmvddef),
	flora_storage_deleteall_bt(Pimvddef),
	flora_bterase_objects(NextOList).


/*********************************************************************
  system library registration
*********************************************************************/
?- flora_register_syslib(FLLIBBTERASEALL).


/*****************************************************************************
  fllibbteraseall(+List)
*****************************************************************************/
fllibbteraseall(List) :- fllibbteraseall(List,true).


/*****************************************************************************
  fllibbteraseall(+List,+Condition)
*****************************************************************************/
fllibbteraseall(List,Condition) :-
	flora_storage_convertlist(List,CallList,FactList),
	flora_list2conjunct([Condition|CallList],Goal),
	findall(FactList,Goal,FsList),
	!,
	flora_btdeleteall_facts(FsList,DeletedFsList),
	flora_bteraseall_facts(DeletedFsList).


/*****************************************************************************
  flora_bteraseall_facts(+FactList)

  Note: This predicate always succeeds.
*****************************************************************************/
flora_bteraseall_facts([]) :- !.

flora_bteraseall_facts([Fs|FL]) :-
	!,
	flora_bterase_facts(Fs),
	flora_bteraseall_facts(FL).
