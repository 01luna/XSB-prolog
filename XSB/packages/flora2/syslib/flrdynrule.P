/* File:      flrdynrule.P
**
** Author(s): Chang Zhao
**
** Contact:   flora-users@lists.sourceforge.net
**
** Copyright (C) The Research Foundation of SUNY, 1999-2002
**
** FLORA-2 is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** FLORA-2 is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with FLORA-2; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
** 
** 
*/


:- compiler_options([xpp_on]).

#include "flora_terms.flh"
#include "flora_exceptions.flh"

:- import conset/2,conget/2 from gensym.
:- import append/3,length/2 from basics.
:- import
	flora_module_registry/1
   from flrregistry.
:- import
        flora_warning_line/1
   from flrprint.
:- import
        flora_concat_items/2,
        flora_concat_atoms/2
   from flrporting.
:- import 
	flora_patch_full_filename/1,
	flora_set_xpp_options_for_compile/1,
	flora_add_xpp_options/1,
	flora_clear_xpp_options/0,
	flloadtrailer/2,
        flora_abort/0,
        flora_abort/1
   from flrutils.

:- import
	flora_module_predicate/4,
	flora_decode_predicate/6
   from flrwrapper.
:- import
	flora_define_predicate/1
   from flrundefined.
:- import is_control/3 from flrdependency.
:- import
	flora_storage_check_module_name/1
   from flrstorageutils.
:- import flora_refresh_tables/1 from flrtables.
:- import
        get_canonical_form/2
   from flrcanon.

:- import flora_decode_goal_as_atom/2 from flrdecode.

:- dynamic flora_rule_signature(_,_,_,_,_).

/***********************************************************************
 FLLIBNEWMODULE(+ThisModuleName,+Module)
 for each module in the list, makes sure that it is bound and no module
 with the same module name exists, then load patch rules for the module.
 Loads the default trailer into the new module.
************************************************************************/ 

FLLIBNEWMODULE(_ThisModuleName,Module) :-
	var(Module),
	!,
	flora_abort('uninstantiated module name').

FLLIBNEWMODULE(_ThisModuleName,Module) :-
	flora_module_registry(Module),
	!,
	flora_abort([Module,': Module already loaded']).

FLLIBNEWMODULE(_ThisModuleName,Module) :-
	flloadtrailer([],Module).
	
/***********************************************************************
 FLLIBINSERTRULE_A(+CallerModule,+RuleList)
 FLLIBINSERTRULE_Z(+CallerModule,+RuleList)
************************************************************************/ 
FLLIBINSERTRULE_A(_ThisModuleName,RuleList) :- 
	flora_insert_rules(FLLIBINSERTRULE_A,RuleList).
FLLIBINSERTRULE_Z(_ThisModuleName,RuleList) :-
	flora_insert_rules(FLLIBINSERTRULE_Z,RuleList).

/***********************************************************************
 flora_insert_rules(+InsOp,+RuleList)
 InsOp is FLLIBINSERTRULE_A or FLLIBINSERTRULE_Z
 process each element ([HeadList] :- Body) in the rule list
************************************************************************/ 
flora_insert_rules(_InsOp,[]) :- !.
flora_insert_rules(_InsOp,[H|_Tail]) :-
	var(H),
	!,
	flora_abort('uninstantiated element in the rule list of insertrule{...}').
flora_insert_rules(InsOp,[FLSYSRULEUPDATE(HeadList,Body,HVars,BVars)|L]) :-
	!,
        flora_build_pred_signature(Body,BodySig),
	inst_body(Body,InstBody),
        check_vars(HeadList,Body,HVars,BVars,Warns),
        sort(Warns,SortedWarns),
        show_warnings(SortedWarns),
	flora_expand_and_ins_rules(InsOp,HeadList,InstBody,BodySig),
	flora_insert_rules(InsOp,L).

%% conjunct of rules - convert to list
flora_insert_rules(InsOp,[(R,L)|Rules]) :-
	!,
	conjunct_to_list((R,L),RuleList),
	flora_insert_rules(InsOp,RuleList),
	flora_insert_rules(InsOp,Rules).
flora_insert_rules(_InsOp,[H|_Tail]) :-
	!,
	flora_decode_goal_as_atom(H,AtomH),
	flora_abort(['non-rule element in the rule list of insertrule{...}, ',
		     AtomH]).

/***********************************************************************
 flora_expand_and_ins_rules(+InsOp,+HeadList,+Body)
 If there are more than one elements in the HeadList, create a new 
 predicate with all vars in the body as the arguments, and assert
 a rule with the new predicate as the head and Body as the body
************************************************************************/ 
flora_expand_and_ins_rules(_InsOp,[],_Body,_BodySig) :- !.
flora_expand_and_ins_rules(InsOp,[Head],Body,BodySig) :-
	!,
	flora_insert_rule(InsOp,Head,Body,BodySig,[]).
flora_expand_and_ins_rules(InsOp,HeadList,Body,BodySig) :-
	HeadList=[H|_L],
        ( var(H) ->
            flora_abort('uninstantiated rule head')
        ;
	    ( H=FLLIBMODLIT(_F,_Args1,MName,_Caller) ->
	        true
	    ;
	        flora_decode_predicate(H,Type,MName,_Prefix,_Pred,_Args),
                (((Type==hilog);(Type==flogic)) ->
		%% This is no good. Should really be checking
		%% for dynamic rule heads
                    true
                ;
                    flora_abort('invalid head in a dynamically inserted rule')
                )
	    )
        ),
	flora_storage_check_module_name(MName),
	new_dynpredicate(NewF),
	collect_vars(Body,BodyVars),
	sort(BodyVars,SortedBodyVars),
	flora_module_predicate(NewF,SortedBodyVars,MName,NewPred),
	Bridge =.. [FL_IMPLYOP,NewPred,Body],
	assert(Bridge),
	flora_insert_rulelist(InsOp,HeadList,NewPred,BodySig,[Bridge]).

/***********************************************************************
 flora_insert_rulelist(+Op,+HeadList,+Body,+BodySig,+BridgeRules)
 For each element E in the HeadList, call flora_insert_rule(Op,E,Body)
************************************************************************/ 
flora_insert_rulelist(_InsOp,[],_Body,_BodySig,_Bridge) :- !.
flora_insert_rulelist(InsOp,[H|L],Body,BodySig,Bridge) :-
	flora_insert_rule(InsOp,H,Body,BodySig,Bridge),
	flora_insert_rulelist(InsOp,L,Body,BodySig,Bridge).

/***********************************************************************
 flora_insert_rules(+InsOp,+Head,+Body,+BodySignature,,+BridgeRules)
 Assert a rule with the given Head and Body and define the head for
 undefinedness checking.  If the head is a hilog predicate, wrap it
 appropriately with WRAP_DYNA_HILOG, WRAP_DYNZ_HILOG, WRAP_TDYNA_HILOG,
 or WRAP_TDYNZ_HILOG, and update flora_not_tabled_registry if the head
 is not tabled
 InsOp is FLLIBINSERTRULE_A or FLLIBINSERTRULE_Z
************************************************************************/ 
flora_insert_rule(InsOp,Head,Body,BodySig,BridgeRule) :-
        ( var(Head) ->
            flora_abort('uninstantiated rule head')
        ;
	    ( Head=FLLIBMODLIT(_F,_A1,MName,_Caller) ->
                get_canonical_form(Head,FLCANON(Wrap,_A2,MName,InstHead)),
                ( var(Wrap) ->
                    flora_abort('uninstantiated rule head')
                ;
                    true
                ),
	        flora_storage_check_module_name(MName)
	    ;
	        InstHead=Head
	    ),
	    flora_decode_predicate(InstHead,Type,Module,Prefix,Pred,Args),
            ( (Type == hilog) ->
                ( InsOp == FLLIBINSERTRULE_A ->
                    flora_concat_atoms([FLDYNAPREFIX,Prefix,WRAP_HILOG],Wrapper)
                ;
                    flora_concat_atoms([FLDYNZPREFIX,Prefix,WRAP_HILOG],Wrapper)
                ),
                flora_concat_atoms([Prefix,WRAP_HILOG],RefWrap),
                flora_module_predicate(RefWrap,[Pred|Args],Module,RefPred),
                flora_module_predicate(Wrapper,[Pred|Args],Module,NewHead)

            ; Type == flogic ->
                ( is_invalid_flogic_head(Pred) ->
                    flora_abort('invalid rule head')
                ;
                    true
                ),
                ( InsOp == FLLIBINSERTRULE_A ->
                    flora_concat_atoms([FLDYNAPREFIX,Pred],Wrapper)
                ;
                    flora_concat_atoms([FLDYNZPREFIX,Pred],Wrapper)
                ),
                flora_module_predicate(Pred,Args,Module,RefPred),
                flora_module_predicate(Wrapper,Args,Module,NewHead)
            ;
                flora_abort('invalid rule head')
            ),
	    flora_storage_check_module_name(Module),
	    NewRule =.. [FL_IMPLYOP,NewHead,Body],
            flora_build_pred_signature(RefPred,HeadSig),         
            ( InsOp == FLLIBINSERTRULE_A ->
                assert(flora_rule_signature(FLDYNAPREFIX,HeadSig,BodySig,[NewRule],BridgeRule))
            ;
                assert(flora_rule_signature(FLDYNZPREFIX,HeadSig,BodySig,[NewRule],BridgeRule))
            ),
	    assert(NewRule),
            flora_refresh_tables(RefPred),
	    (Pred==WRAP_OBJEQL ->
		( flloadtrailer([FLOBJEQLDEF],Module), !
		;
		    flora_abort
		)
	    ;
		true
	    ),
	    flora_define_predicate(InstHead)
        ).
       

/***********************************************************************
 FLLIBDELETERULE_A(+CallerModule,+RuleList)
 FLLIBDELETERULE_Z(+CallerModule,+RuleList)
 FLLIBDELETERULE(+CallerModule,+RuleList)
************************************************************************/ 
FLLIBDELETERULE_A(_ThisModuleName,RuleList) :-
	flora_delete_rules(FLLIBDELETERULE_A,RuleList).
FLLIBDELETERULE_Z(_ThisModuleName,RuleList) :-
	flora_delete_rules(FLLIBDELETERULE_Z,RuleList).
FLLIBDELETERULE(_ThisModuleName,RuleList) :-
        flora_delete_rules(FLLIBDELETERULE_A,RuleList).
FLLIBDELETERULE(_ThisModuleName,RuleList) :-
        flora_delete_rules(FLLIBDELETERULE_Z,RuleList).

/***********************************************************************
 flora_delete_rules(+DelOp,+RuleList)
 InsOp is FLLIBDELETERULE_A or FLLIBDELETERULE_Z
 process each element ([HeadList] :- Body) in the rule list
************************************************************************/ 
flora_delete_rules(_DelOp,[]) :- !.
flora_delete_rules(_InsOp,[H|_Tail]) :-
	var(H),
	!,
	flora_abort('uninstantiated element in the rule list of deleterule{...}').
flora_delete_rules(DelOp,[FLSYSRULEUPDATE(HeadList,Body,_HV,_BV)|L]) :-
	!,
        flora_build_pred_signature(Body,BodySig),         
	flora_delete_rulelist(DelOp,HeadList,BodySig),
	flora_delete_rules(DelOp,L).
%% conjunct of rules - convert to list
flora_delete_rules(InsOp,[(R,L)|Rules]) :-
	!,
	conjunct_to_list((R,L),RuleList),
	flora_delete_rules(InsOp,RuleList),
	flora_delete_rules(InsOp,Rules).
flora_delete_rules(_InsOp,[H|_Tail]) :-
	!,
	flora_decode_goal_as_atom(H,AtomH),
	flora_abort(['non-rule element in the rule list of deleterule{...}, ',
		     AtomH]).

/***********************************************************************
  flora_delete_rulelist/3
***********************************************************************/

flora_delete_rulelist(_DelOp,[],_BodySig) :- !.
flora_delete_rulelist(DelOp,[H|L],BodySig) :-
        flora_delete_rule(DelOp,H,BodySig),
        flora_delete_rulelist(DelOp,L,BodySig).

flora_delete_rule(DelOp,Head,BodySig) :-
        flora_build_pred_signature(Head,HeadSig),         
        ( DelOp == FLLIBDELETERULE_A ->
            flora_match_and_delete_rule(FLDYNAPREFIX,HeadSig,BodySig)
        ;
            flora_match_and_delete_rule(FLDYNZPREFIX,HeadSig,BodySig)
        ).

flora_match_and_delete_rule(DynPrefix,HeadSig,BodySig) :-
        flora_rule_signature(DynPrefix,HeadSig,BodySig,RuleList,BridgeRule),
        !,
        flora_retract_rulelist(RuleList),
        retract(flora_rule_signature(DynPrefix,HeadSig,BodySig,RuleList,BridgeRule)),
        ( BridgeRule==[] ->
            true
        ;
            ( flora_rule_signature(DynPrefix,_H,_BS,_RL,BridgeRule) ->
                true
            ;
                flora_retract_rulelist(BridgeRule)
            )
        ).

flora_retract_rulelist([]) :- !.
flora_retract_rulelist([H|L]) :-
        retract(H),
        flora_retract_rulelist(L).

/***********************************************************************
 inst_body(+Body,-InstBody)
 get rid of fllibmodlit with module name already bound
************************************************************************/ 
inst_body(B,B) :-
        var(B),
        !.

inst_body(','(B1,B2),','(NB1,NB2)) :-
	!,
	inst_body(B1,NB1),
	inst_body(B2,NB2).

inst_body(';'(B1,B2),';'(NB1,NB2)) :-
	!,
	inst_body(B1,NB1),
	inst_body(B2,NB2).

inst_body(not(B),not(NB)) :-
	!,
	inst_body(B,NB).

inst_body(tnot(B),tnot(NB)) :-
	!,
	inst_body(B,NB).

inst_body(Body,NB) :-
	is_control(Body,Ctl,Branches),
	!,
	inst_list(Branches,InstBranches),
	NB =.. [Ctl|InstBranches].

inst_body(FLLIBMODLIT(F,Args,MName,Caller),Inst) :-
        !,
        get_canonical_form(FLLIBMODLIT(F,Args,MName,Caller),FLCANON(_W,_A,_M,Callable)),
        (var(Callable) ->
            Inst = FLLIBMODLIT(F,Args,MName,Caller)
        ;
            Inst = Callable
        ).

inst_body(Body,Body).
	
inst_list([],[]) :- !.
inst_list([H|L],[NH|NL]) :-
	inst_body(H,NH),
	inst_list(L,NL).

/***********************************************************************
 flora_build_pred_signature(+Body,-BodySig)
 translate into fllibmodlit canonical form
************************************************************************/ 
flora_build_pred_signature(B,B) :-
        var(B),
        !.

flora_build_pred_signature(','(B1,B2),','(NB1,NB2)) :-
	!,
	flora_build_pred_signature(B1,NB1),
	flora_build_pred_signature(B2,NB2).

flora_build_pred_signature(';'(B1,B2),';'(NB1,NB2)) :-
	!,
	flora_build_pred_signature(B1,NB1),
	flora_build_pred_signature(B2,NB2).

flora_build_pred_signature(not(B),not(NB)) :-
	!,
	flora_build_pred_signature(B,NB).

flora_build_pred_signature(tnot(B),tnot(NB)) :-
	!,
	flora_build_pred_signature(B,NB).

flora_build_pred_signature(Body,NB) :-
	is_control(Body,Ctl,Branches),
	!,
	build_list(Branches,InstBranches),
	NB =.. [Ctl|InstBranches].

flora_build_pred_signature(Body,BodySig) :-
        get_canonical_form(Body,BodySig).
	
build_list([],[]) :- !.
build_list([H|L],[NH|NL]) :-
	flora_build_pred_signature(H,NH),
	build_list(L,NL).

/***********************************************************************
 new_predicate(-NewPred)
************************************************************************/ 
new_dynpredicate(NewPred) :-
	conget(flora_global_dynnewpredicate, N),
	M is N+1,
	conset(flora_global_dynnewpredicate, M),
	flora_concat_items([dyn_newpredicate,N], NewPred).

/***********************************************************************
 collect_vars(+Term,-Vars)
************************************************************************/ 
collect_vars(Atom,[]) :- 
	atomic(Atom),
	!.

collect_vars(Var,[Var]) :- 
	var(Var),
	!.

collect_vars(Body,BodyVars) :-
	Body =.. [_F|Args],
	collect_var_list(Args,BodyVars).

collect_var_list([],[]) :- !.
collect_var_list([H|L], Vars) :-
	collect_var_list(L,LV),
	( atomic(H) ->
	    Vars = LV
	;
	    ( var(H) ->
		Vars = [H|LV]
	    ;
		H =.. [_F|Args],
		collect_var_list(Args,HV),
		append(HV,LV,Vars)
	    )
	).

/***********************************************************************
 check_vars(+HeadList,+Body,+NamedHeadVars,+NamedBodyVars,-Warnings)
************************************************************************/ 
check_vars(HeadList,Body,NamedHVars,NamedBVars,Warnings) :-
        collect_var_list(HeadList,HVars),
        collect_vars(Body,BVars),
        append(HVars,BVars,Vars),
        singleton_vars(Vars,Vars,SingletonVars),
        singleton_warning(SingletonVars,NamedHVars,NamedBVars,SWarnings),
        subtract_vars(HVars,BVars,UnboundVars),
        unbound_warning(UnboundVars,NamedHVars,UWarnings),
        append(SWarnings,UWarnings,Warnings).

singleton_vars(_AllVars,[],[]) :- !.
singleton_vars(AllVars,[H|L], [H|SL]) :-
        is_singleton(AllVars,H,0),
        !,
        singleton_vars(AllVars,L,SL).
singleton_vars(AllVars,[_H|L],SL) :-
        singleton_vars(AllVars,L,SL).

is_singleton([],_V,_Cnt) :- !.
is_singleton([H|L],V,Cnt) :-
        (H==V ->
            (Cnt==1 ->
                fail
            ;
                is_singleton(L,V,1)
            )
        ;
            is_singleton(L,V,Cnt)
        ).

singleton_warning([],_NamedHVars,_NamedBVars,[]) :- !.
singleton_warning([H|L],NamedHVars,NamedBVars,Warns) :-
        ( get_var_name(H,NamedHVars,Name) ->
            fmt_write_string(WarningStr,"Singleton variable `%s' in the head of dynamically inserted rule", args(Name)),
            Warns=[WarningStr|RestWarns]
        ;
            ( get_var_name(H,NamedBVars,Name) ->
                fmt_write_string(WarningStr,"Singleton variable `%s' in the body of dynamically inserted rule", args(Name)),
                Warns=[WarningStr|RestWarns]
            ;
                Warns=RestWarns
            )
        ),
        singleton_warning(L,NamedHVars,NamedBVars,RestWarns).

get_var_name(H,[N=V|NVs],Name) :-
        ( H==V ->
            Name=N
        ;
            get_var_name(H,NVs,Name)
        ).

subtract_vars([],_BVars,[]) :- !.
subtract_vars([H|L],BVars,LUV) :-
        in_list(H,BVars),
        !,
        subtract_vars(L,BVars,LUV).
subtract_vars([H|L],BVars,[H|LUV]) :-
        subtract_vars(L,BVars,LUV).

in_list(V,[H|L]) :-
        ( H==V ->
            true
        ;
            in_list(V,L)
        ).

unbound_warning([],_NamedHVars,[]) :- !.
unbound_warning([H|L],NamedHVars,Warns) :-
        ( get_var_name(H,NamedHVars,Name) ->
            fmt_write_string(WarningStr,"Unbound variable `%s' in the head of dynamically inserted rule", args(Name)),
            unbound_warning(L,NamedHVars,RestWarns),
            Warns=[WarningStr|RestWarns]
        ;
            unbound_warning(L,NamedHVars,Warns)
        ).

/***********************************************************************
 is_invalid_flogic_head(+Pred)
************************************************************************/ 
is_invalid_flogic_head(WRAP_MVDINC) :- !.
is_invalid_flogic_head(WRAP_IMVDINC) :- !.
is_invalid_flogic_head(WRAP_MVDTOLIST) :- !.
is_invalid_flogic_head(WRAP_IMVDTOLIST) :- !.
is_invalid_flogic_head(WRAP_FDDEF) :- !.
is_invalid_flogic_head(WRAP_IFDDEF) :- !.


/***********************************************************************
 show_warnings(+WarningList)
 Returns the last argument, which is the caller.
************************************************************************/ 
show_warnings([]) :- !.
show_warnings([H|L]) :-
        flora_warning_line(H),
        show_warnings(L).

/***********************************************************************
  conjunct_to_list(+Conjunct, -List)
************************************************************************/

conjunct_to_list((A,B), [A|BL]) :-
	!,
	conjunct_to_list(B,BL).
conjunct_to_list(A, [A]).
