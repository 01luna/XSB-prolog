/*  File:      packages/flora2/flrprettyprint.P
**
** Author(s): Bin Tang
**
** Contact:   xsb-contact@cs.sunysb.edu
** 
** Copyright (C) The Research Foundation of SUNY, 2002
** 
** FLORA-2 is free software; you can redistribute it and/or modify it under the
** terms of the GNU Library General Public License as published by the Free
** Software Foundation; either version 2 of the License, or (at your option)
** any later version.
** 
** FLORA-2 is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
** FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for
** more details.
** 
** You should have received a copy of the GNU Library General Public License
** along with FLORA-2; if not, write to the Free Software Foundation,
** Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
**
** $Id: flrprettyprint.P,v 1.4 2002-03-24 09:08:06 kifer Exp $
** 
*/

/***************************************************************************
 Pretty-printer for Prolog. Used for dumping Flora code for easier reading

 prettyprint_file/2 reads from file and dumps into file
 prettyprint_stdin/0 reads from stdin and dumps to stdout
****************************************************************************/

:- export prettyprint_file/2, prettyprint_stdin/0.

:- compiler_options([xpp_on]).
:- import '_$op'/3 from file_op.
:- import file_read/3, vv/2 from xsb_read.
:- import length/2 from basics.
:- import str_len/2 from machine.
:- import conset/2, conget/2 from gensym.
:- import catch/3, throw/1 from standard.

%% If the term is longer than  MAX_LINE_LEN chars, use indentation/newline
#define MAX_LINE_LEN 77

%% indentation number for infix opertor
#define INFIX_INDENT 8

%% indentation number for prefix operator
#define PREFIX_INDENT 4


%%%%%%%%%%% Top level calls %%%%%%%%%%%%%%%%%%

/*******************************************************************
  prettyprint(+InputFileName,+OutputFileName)
  Pretty prints file
*******************************************************************/
prettyprint_file(InputFileName,OutputFileName) :-
	see(InputFileName),
	tell(OutputFileName), 
        prettyprint_stdin,
	seen, 
	told.

/******************************************************************
  prettyprint_stdin/0
  Pretty prints from standard input
******************************************************************/
prettyprint_stdin :-
	current_input_port(IOport),
  	file_read(IOport,Term,Vars), 
        ( Term == end_of_file 
          -> true
          ;  prettyprint_with_indent(0,Term,false,Vars), %See comments below
	     writeln('.'), nl,
             prettyprint_stdin
        ). 

%%%%%% Some utilities %%%%%%%%%%%%%%

/************************************************************************
  newline(+Flag_nl)
  outputs new line when Flag_nl is true.
************************************************************************/
newline(Flag_nl) :-
   	Flag_nl == true -> nl; true.

/************************************************************************
  indent(+Flag_indent,+Num)
  indents Num of spaces when Flag_indent is true.
************************************************************************/
indent(Flag_indent,Num) :-
	Flag_indent == true -> tab(Num); true.

/************************************************************************
  all_less_than(+List1, +List2)
  True if all the elements of List1 are smaller than those of List2.
************************************************************************/
all_less_than(List1, List2) :-
	sort(List2, [First_ele|_]),
	less_than(List1, First_ele).

less_than([], _).
less_than([Head|Tail], A) :-
        Head < A, less_than(Tail, A).
	
/***********************************************************************
  infix_op(-Priority,-Associativity,+Op): 
      True is Op is an infix op.
  infix_term(+Term):
      True if principal functor of Term is an infix operator.
***********************************************************************/
infix_op(Priority,Assoc,Op) :-
	'_$op'(Priority,Assoc,Op), (Assoc == xfx; Assoc == xfy; Assoc == yfx).
infix_term(Term) :-
        functor(Term,Op,_), 
	infix_op(_,_,Op).

/***********************************************************************
  prefix_op(-Priority, -Assoc, +Op):
      True if Op is a prefix op
  prefix_term(+Term):
      True if principal functor of Term is a prefix operator.
***********************************************************************/
prefix_op(Priority,Assoc,Op) :-
	'_$op'(Priority,Assoc,Op), (Assoc == fx; Assoc == fy).
prefix_term(Term) :-
	functor(Term,Op,_),
	prefix_op(_,_,Op).
	
/***********************************************************************
  postfix_op(-Priority,-Assoc,+Op):
      True if Op is a postfix op
  postfix_term(+Term):
      True if principal functor of Term is a postfix operator.
***********************************************************************/
postfix_op(Priority,Assoc,Op) :-
	'_$op'(Priority,Assoc,Op), (Assoc == xf; Assoc == yf).
postfix_term(Term) :-
        functor(Term,Op,_), 
	postfix_op(_,_,Op).

/***********************************************************************
 arith_exp(+Term)
 Checks if Term is an arithmetic expression (so we will consider 
 striping '()' if the arithmetic expression is a top level predicate).
***********************************************************************/
/*
arith_exp(is(_,_)) :- !.
arith_exp(eval(_,_)) :- !.
arith_exp('<'(_,_)) :- !.
arith_exp('=<'(_,_)) :- !.
arith_exp('>'(_,_)) :- !.
arith_exp('>='(_,_)) :- !.
arith_exp('=:='(_,_)) :- !.
arith_exp('=\='(_,_)) :- !.
*/

%% We need to do extra indentation for long query '?- a,b.' , to make
%% the output be like  ?- a,  instead of  ?- a,
%%                        b.              b.
indentation('?-', 3).

/***********************************************************************
  find_var_name(+Var, +Vars, -Name)
  finds the Name(an atom) of variable Var
  in the mapping Vars=[vv(Name,Var),...].
***********************************************************************/
find_var_name(_,Vars,_) :- var(Vars), !, fail. 
find_var_name(Var,[vv(Name,Variable)|_],Name) :- Var==Variable, !.
find_var_name(Var,[_|Vars_tail],Name) :- find_var_name(Var,Vars_tail,Name).

/**********************************************************************
  atom_len(+Atom,-Length)
  Returns the Length of an Atom.
**********************************************************************/
atom_len(Atom,Length) :-
	str_len(Atom, Length).

/*********************************************************************
  num_len(+Num,-Length)
  Returns the Length of an Atom.
*********************************************************************/
num_len(Num,Length) :-
	number_codes(Num,List),
	length(List,Length).

/*********************************************************************
  term_len(+Term,-Length,+Vars)
  Returns the Length of a Term, Vars is a mapping between variable names
  and variables themselves.
*********************************************************************/
%% Length of variable.
term_len(Term,Length,Vars) :-
	var(Term),
	find_var_name(Term,Vars,Name), !,
	atom_len(Name,Length).
	
%% Length of anonymous var '_'.
term_len(Anon_var,1,_) :-
	var(Anon_var), !.

%% Length of atom.
term_len(Term,Length,_) :-
        atom(Term), !,
	atom_len(Term,Len),
	Length is Len + 2. % 2 for possible single quotes ''

%% Length of number.
term_len(Term,Length,_) :-
	number(Term), !,
	num_len(Term,Length).
	
%% Length of non-empty list and empty/non-empty string.
term_len(Term,Length,Vars) :-
        is_list_term(Term), !,
        (
         is_charlist(Term,LenOfString) 
         -> Length is LenOfString + 2 		% +2 is due to quotes
         ;  list_len(Term,LenOfList,Vars), 
	    Length is LenOfList + 2	        % +2 is due to brackets
        ).

%% Length of term whose principal functor is infix operator.
term_len(Term,Length,Vars) :-
	infix_term(Term), 
	Term =.. [Op,Lhs,Rhs], !,
	term_len(Op,LenOfOp,Vars), 
	term_len(Lhs,LenOfLhs,Vars), 
	term_len(Rhs,LenOfRhs,Vars),
	%% 2 is due to the empty space on either side of operator.
	Length is LenOfOp + LenOfLhs + LenOfRhs + 2.

%% length of term whose principal functor is prefix functor
%% prefix operators don't parenthesize their arguments, while
%% prefix non-operator functors parethesize their arguments.
term_len(Term,Length,Vars) :-
	Term =.. [Op|Args],
	term_len(Op,LenOfOp,Vars),
	list_len(Args,LenOfArgs,Vars),
	
        ('_$op'(_,Opa,Op), (Opa==fx; Opa==fy) 
         -> Length is LenOfOp + LenOfArgs + 1  % +1 due to empty space after op
	 ;  Length is LenOfOp + LenOfArgs + 2  % +2 due to '()'
        ).

/*********************************************************************
  list_len(+List,-Length,+Vars)
  returns the Length of List.
*********************************************************************/

%% The regular is_list/1 doesn't recognize [X|Y], so we use our own
is_list_term([_|_]) :- !.
is_list_term([]).

%% List is in the form of [Head|Tail], ex, [A|B].
list_len(List,Length,Vars) :- 
	var(List), !,
	term_len(List,Length,Vars).

%% There is no ',' after the last element of the list. However, this ',' 
%% has been added into Length below. So, we need deduct 1 from Length.
list_len([], -1, _) :- !. 

list_len([Head|Tail], Length, Vars) :-
	term_len(Head, LenOfHead, Vars),
	list_len(Tail,LenOfTail, Vars), 
	Length is LenOfHead + LenOfTail + 1. % 1 is due to ',' or '|'

/*******************************************************************
  write_string(+String)
  Prints a character string represented as a list.
  Assumes that the argument is a list of characters.
*******************************************************************/
write_string(S) :- write('"'), write_string1(S), write('"').
write_string1([]) :- !.
write_string1([Head|Tail]) :- put(Head), write_string1(Tail).

/*******************************************************************
  write_list(+List,+Vars)
  prints List, Vars is the mapping between variables and their names.
*******************************************************************/
write_list(Head,Vars) :- write('['), write_list1(Head,Vars), write(']').

write_list1(Head,Vars) :- 
        var(Head), !, 
    	prettyprint_with_indent(0, Head, false, Vars).

write_list1([],_) :- !.

write_list1([Head|Tail],Vars):-
        prettyprint_with_indent(0,Head, false,Vars),
	(
	  var(Tail) 
	 -> write('|')
	 ;  Tail == []
	    -> true
	    ;  write(',')
	),
	write_list1(Tail,Vars).


%%%%%%%%%%%%% Main program %%%%%%%%%%%%%%%%%%%%%%

/******************************************************************
  prettyprint_with_indent(+Indent,+Term,+Flag_indent,+Vars)

  Pretty prints Term and indents it with Indent number of spaces, if
  Flag_indent=true.
  
  Flag_indent:  true means indent; fail means don't
				   
  Depending on the term length, prettyprint_with_indent_newline/5 
  is called with parameters, in which Flag_newline and 

  Flag_indent is set to true if Term has more than MAX_LINE_LEN 
  characters; otherwise Flag_indent is passed down as is.
  This accounts for program clauses with long lines.

******************************************************************/
prettyprint_with_indent(Indent,Term,Flag_indent,Vars) :-
        term_len(Term,Length,Vars), 
        (  Length > MAX_LINE_LEN 
	-> % Put each subgoal on a separate line
	    prettyprint_with_indent_newline(Indent,Term,true,true,Vars)
	;  % Put all subgoals on one line
	    prettyprint_with_indent_newline(Indent,Term,false,Flag_indent,Vars)
        ).

/**************************************************************************
  prettyprint_with_indent_newline(+Indent,+Term,+Flag_nl,+Flag_indent,+Vars)
  pretty prints a Term and indents it with Indent number of spaces, if 
  Flag_indent =true; changes to new line if Flag_nl=true.

**************************************************************************/
%%  Handle simple objects (constants, atoms, numbers, variables).
prettyprint_with_indent_newline(Indent,Term, _Flag_nl,Flag_indent,Vars) :-
        (atomic(Term); var(Term)), !,
	indent(Flag_indent, Indent),
        (
           find_var_name(Term,Vars,Name) 
	-> write(Name)  		         % Term is a named variable
	;  var(Term) 
	-> write('_') 			         % Term is anonymous var
	;  '_$op'(_,_,Term)            	         % Term is an operator  
        -> write(''''), write(Term), write('''') % Term is an atom
        ;  write_canonical(Term)    	
	).
%% Handle lists and character strings. 
prettyprint_with_indent_newline(Indent, Term, _Flag_nl, Flag_indent, Vars) :- 
      	is_list_term(Term), !, 
        indent(Flag_indent, Indent),
        (
	 is_charlist(Term) 
	 ->  write_string(Term)
          ;  write_list(Term, Vars)
        ).

/*****************************************************************************
  Handle terms whose principal functor is an infix operator.
  
  To pretty print a term, the algorithm recursively pretty prints
  its lhs, then the infix operator, then recursively pretty print its rhs.
  
  To pretty print '...->...;...' structure, we introduce two global variables
  (manipulated using conget/conset):
  
  a. if_then_else_struct = 1 indicates the term is a '...->...;...' structure.
  b. if_then_else_long = 1 indicates it's a long '..->...;...' structure,
     so that we should use the following style:
   
     p(X,Y) :-
              Cond1, Cond2
              ->
              Act1,Act2 
              ;
              Act3;Act4.
 
  The third global variable (also manipulated by conget/conset) is: query_flag,
  query_flag = 1 indicates  the term is a query like: ?- a, b, so that 
  when the query is a long term, we need to do extra indentation for '?-'
  to make the output be : ?- a,   instead of ?- a,
                             b.              b.
  
****************************************************************************/ 

prettyprint_with_indent_newline(Indent, Term, Flag_nl, Flag_indent, Vars) :-
   	infix_term(Term), 
   	Term =.. [Op, Lhs, Rhs], !, 
   	( var(Lhs) -> true;
   	  functor(Lhs, OpLhs, _),
   	  ( Op == ';' , OpLhs == '->'
   	  -> conset(if_then_else_struct, 1), 
	      (Flag_nl == true  -> conset(if_then_else_long,1); true) 
   	  ;  true 
  	  )
  	),
   
   	%% print left hand side.
  	prettyprint_lhs(Indent, Op, Lhs, Flag_nl, Flag_indent, Vars),

   	%% if the operator is the '->' of '..->...;..', check  if  
	%% new line and indentation are needed, then print '->'
  	( Op == '->', conget(if_then_else_struct, 1)
	-> ( conget(if_then_else_long, 1)  
	   -> nl,indent(Flag_indent, Indent), 
	       conset(if_then_else_long,0) % reset flag
	   ;  true
	   ),
	    %% check if we need to do indentation for '?-'
	    ( conget(query_flag, 1)
	    -> indentation('?-', Ind), IndentForQuery is Indent + Ind,
		indent(Flag_indent, IndentForQuery) 
	    ;  true
	    ) 
	; true
        ),

        %% if the operator is the ';' inside '...->...;...', check if 
        %% new line and indentation are needed, then print ';'
        %% Also, need to check if we need to do extra indentation for '?-'
        ( Op == ';', OpLhs == '->' 
        -> (Flag_nl ==true -> nl, indent(Flag_indent, Indent); true),
           (conget(query_flag, 1)
	   -> indentation('?-', Ind), IndentForQuery is Indent + Ind,
               indent(Flag_indent, IndentForQuery)
	   ;  true 
           ),  
           conset(if_then_else_struct,0)
	; true
        ),

   	%% Print the infix-operator.
   	%% No empty space between ',', ';', '->', and its Lhs.
   	%% Put an empty space between ',', ';', '->', and the Rhs.
   
   	((Op == ','; Op == ';'; Op == '->')-> true; tab(1)),
   	write(Op), 
   	tab(1),
  
   	%% Before printing Rhs, check if need to change to new line.
   	%% We don't put newline for 'from' even though it is an infix operator,
   	%% because it would be unatural to go to a new line and do 
   	%% indentation in this case.
     
   	(Op == from -> true; newline(Flag_nl)),
   
   	%% Decides indentation before printing Rhs.
	%% If it is a long term and the infix operator is ';' or ',',
	%% then Rhs and Lhs have the same size of indentation;
	%% otherwise, the Rhs will indent INFIX_INDENT(8) more chars than Lhs.
	%% For short terms, there is no indentation between Lhs and Rhs
   	%% The global variable query_flag is used to decide whether
	%% it is a query (?- a,b.) or a rule body.
   
   	((Op == from; Flag_nl ==false)
  	-> NewIndent is 0
   	;  ( Op == ';'
   	   ; Op == ','
   	   ; conget(if_then_else_struct, 1), (Op == '->'; Op ==';')
   	   ) 
   	-> ( Op == ';', conget(query_flag, 1)
   	   -> indentation('?-', Ind), IndentForQuery is Indent + Ind,
       	      NewIndent is IndentForQuery,
              conset(query_flag, 0)
           ;  NewIndent is Indent
           )   
        ;  NewIndent is INFIX_INDENT+Indent
        ),

        %% print the right hand side of the operator.
	prettyprint_rhs(NewIndent, Op, Rhs, Flag_nl, Flag_indent, Vars).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%i%%%%%%%%
%%  Handle terms whose principal functor is postfix operator 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
prettyprint_with_indent_newline(Indent, Term, _Flag_nl, Flag_indent, Vars) :- 
	postfix_term(Term),
	Term =.. [Op, Arg],
	var(Arg), !,  % case: X Op
	prettyprint_with_indent(Indent, Arg, Flag_indent, Vars),
	tab(1),
	write(Op).

prettyprint_with_indent_newline(Indent, Term, _Flag_nl, Flag_indent, Vars) :- 
	postfix_term(Term),
        Term =.. [Op, Arg],
	functor(Arg, OpArg, _), % case: (...OpArg...) Op
        (  '_$op'(_,_,OpArg) 
	-> ( can_strip_parens_post(Op, OpArg)
	     ->  prettyprint_with_indent(Indent,Arg,Flag_indent,Vars), 
	     	 tab(1), write(Op)
	     ;   write('('),
	         prettyprint_with_indent(Indent,Arg,Flag_indent,Vars),
	         write(')'),
	         write(Op)
           )
	;  prettyprint_with_indent(Indent,Arg,Flag_indent,Vars),
	   tab(1),
	   write(Op)
	).   


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Handle terms whose principal functor is a prefix operator
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
prettyprint_with_indent_newline(Indent, Term, _Flag_nl, Flag_indent, Vars) :- 
	prefix_term(Term),
	Term =.. ['+', Arg], !,
        prettyprint_with_indent(Indent,Arg,Flag_indent,Vars).

prettyprint_with_indent_newline(Indent, Term, _Flag_nl, Flag_indent, Vars) :- 
	prefix_term(Term),
	Term =.. [Op, Arg],
	var(Arg), !,  	      % case:  Op X
        write(Op),tab(1),
	prettyprint_with_indent(Indent,Arg,Flag_indent,Vars).
	
prettyprint_with_indent_newline(Indent, Term, Flag_nl, Flag_indent, Vars) :- 
        prefix_term(Term),
	Term =.. [Op, Arg],
	functor(Arg, OpArg, _),  % case:  Op (...OpArg...)
	write(Op), tab(1),
	
	%% Set query_flag to 1 if the term is a query, for later use.
	( Op == ('?-') -> conset(query_flag, 1); true), 
	
	( (Op == (':-'); Op == ('?-'))
	-> NewIndent is 0
	;  newline(Flag_nl),
	    (  Flag_nl == true 
	    -> NewIndent is Indent + PREFIX_INDENT
	    ;  NewIndent is 0
	    )
	),
	
        (  '_$op'(_,_,OpArg) 
	-> ( can_strip_parens_prefix(Op, OpArg)
	   -> prettyprint_with_indent(NewIndent,Arg,Flag_indent,Vars) 
	   ;  write('('),
	      prettyprint_with_indent(NewIndent,Arg,Flag_indent,Vars),
	      write(')')
           )
	;  prettyprint_with_indent(NewIndent,Arg,Flag_indent,Vars) 
	),
        conset(query_flag, 0).   

/****************************************************************************
  Handle terms whose principal functor is NOT an operator.
****************************************************************************/
prettyprint_with_indent_newline(Indent, Term, Flag_nl, Flag_indent, Vars) :- 
	Term =.. [Op|ArgsList],
	indent(Flag_indent,Indent), 
	write_canonical(Op), 
	write('('), 
	newline(Flag_nl),

	( Flag_nl == true 
	-> NewIndent is Indent + PREFIX_INDENT 
	;  NewIndent is 0
	),
	
	%% print the arguments list 
	print_argslist(NewIndent,ArgsList,Flag_nl,Flag_indent,Vars),
	write(')').


/*****************************************************************************
  prettyprint_lhs(+Indent,+Op,+Lhs,+Flag_nl,+Flag_indent,+Vars)

  Print the left hand side of an infix operator Op.

  Case:  Lhs Op ..., where Lhs has OpLhs as its main functor.

  If OpLhs is an operator, the cases where we strip '()' are : 

  1. syntatic consideration: 
	 a. precedence number of OpLhs is lower than that of Op
         b. if Op and OpLhs have the same level of precedence,
	    we check unparsability, ambiguity, etc.

     This is determined by the predicate can_strip_parens_binary_left/2.

  2. Semantic consideration: ',' and ';' are both right and left associative 

  The  pretty-printing style of (a;b),c (if its a long term) is:
  				( 
				 a;
				 b
				),
				c
*****************************************************************************/
%% Lhs is a variable.
prettyprint_lhs(Indent, _, Lhs, _, Flag_indent, Vars) :- 
	var(Lhs), !, 
        prettyprint_with_indent(Indent, Lhs, Flag_indent, Vars).

%% Lhs has its own operator. 
prettyprint_lhs(Indent, Op, Lhs, Flag_nl, Flag_indent, Vars) :-
	functor(Lhs,OpLhs,_),
        (  '_$op'(_,_,OpLhs)
	-> (  %% Cases we can strip '()'.
            ( can_strip_parens_binary_left(Op,OpLhs); % syntactic consideration
              Op = ',' , OpLhs = ',';                 % semantic considerations
              Op = ';' , OpLhs = ';' )  
	   ->  prettyprint_with_indent(Indent, Lhs, Flag_indent, Vars)
	   ; %% Other cases, output the '()'
	       prettyprint_with_parens(Indent,Lhs,Flag_nl,Flag_indent,Vars) 
           )
	; % For non-operator functors, don't need to consider striping '()'
	   prettyprint_with_indent(Indent, Lhs, Flag_indent, Vars) 
	).

/******************************************************************************
  prettyprint_rhs(+Indent,+Op,+Rhs,+Flag_nl,+Flag_indent,+Vars)

  Print the right hand side of an infix operator Op.

  Case:  ... Op  Rhs, where Rhs has OpRhs as its main functor.

  If OpRhs is an operator, the cases where we strip '()' are : 

  1. syntatic consideration: 
	 a. precedence number of OpRhs is lower than that of Op
         b. if Op and OpRhs have the same level of precedence,
	    we check unparsabiliy, ambiguity, etc.

     This is determined by the predicate can_strip_parens_binary_right/2.

  2. Semantic consideration: 
	    Op = +, OpRhs = +,
	    Op = +, OpRhs = -,
	    Op = *, OpRhs = *,
	    Op = *, OpRhs = /.
	    
******************************************************************************/

%% Rhs is a variable.
prettyprint_rhs(Indent, _, Rhs, _, Flag_indent, Vars) :-
	var(Rhs), !, 
     	prettyprint_with_indent(Indent, Rhs, Flag_indent, Vars).

%% Rhs is a 0-ary term which is an operator by itself.
%% We need to put parens around so XSB won't issue a syntax error
prettyprint_rhs(Indent, _, Rhs, _, Flag_indent, Vars) :-
     	functor(Rhs,OpRhs,0),  
     	'_$op'(_,_,OpRhs), !,
     	write('('), 
     	prettyprint_with_indent(Indent, Rhs, Flag_indent, Vars),
     	write(')').

%% Rhs has its own operator.
prettyprint_rhs(Indent, Op, Rhs, Flag_nl, Flag_indent, Vars) :-
    	functor(Rhs,OpRhs,_),
   	( '_$op'(_,_,OpRhs) 
	-> ( ( can_strip_parens_binary_right(Op,OpRhs); % syntax consideration
               Op = ('+') , OpRhs = ('+');   % semantic considerations
               Op = ('+') , OpRhs = ('-');
               Op = ('*') , OpRhs = ('*');
               Op = ('*') , OpRhs = ('/') )
            -> prettyprint_with_indent(Indent, Rhs, Flag_indent, Vars)
            ;  %% Otherwise, keep the '()'
	       prettyprint_with_parens(Indent,Rhs,Flag_nl,Flag_indent,Vars)
          )
	; prettyprint_with_indent(Indent,Rhs,Flag_indent,Vars)
  	).


prettyprint_with_parens(Indent,Term,Flag_nl,Flag_indent,Vars) :-
        indent(Flag_indent, Indent),
        write('('),newline(Flag_nl),
        ( Flag_nl == true
        -> prettyprint_with_indent(Indent,Term,Flag_indent,Vars)
        ;  prettyprint_with_indent(0,Term,Flag_indent,Vars)
        ),
        newline(Flag_nl),
        ( Flag_nl == true
        -> indent(Flag_indent,Indent)
         ; true
        ),
        write(')').


/*****************************************************************************
  print_argslist(+Indent,+ArgsList,+Flag_nl,+Flag_indent,+Vars)

  Print the argument list, ArgsList, of a functor.
  
  Pretty printing of a(b,c) should be a(b,c) because the ',' is delimiter,
  while pretty printing of a(','(b,c)) should be a((b,c)) because the ',' is 
  a conjuction. Similarly for ';'.

  Also, the case of a(_,A,_,...) is considered (argument could be '_').
*****************************************************************************/
print_argslist(Indent,[],Flag_nl,Flag_indent,_Vars) :- 
	 newline(Flag_nl),
	 indent(Flag_indent,Indent),
	 !.

print_argslist(Indent,[Head|Tail],Flag_nl,Flag_indent,Vars) :- 
   	( var(Head)
   	-> true
   	;  ( functor(Head, ',', _); functor(Head, ';', _)),
   	   Head \== ',', Head \== ';'
  	-> indent(Flag_indent, Indent), 
   	   write('('), newline(Flag_nl)	                          
        ;  true
   	),
 
   	prettyprint_with_indent(Indent,Head,Flag_indent,Vars),

   	( var(Head) 
   	-> true
   	;  ( functor(Head, ',', _); functor(Head, ';', _)),
   	   Head \== ',', Head \== ';'
   	-> newline(Flag_nl),
           indent(Flag_indent, Indent), write(')')	
   	;  true 
   	),
  
   	( Tail == []
   	-> true
   	;  write(','), tab(1), newline(Flag_nl)
   	),
   	print_argslist(Indent,Tail,Flag_nl,Flag_indent,Vars).


/*****************************************************************************
  can_strip_parens_binary_left(+Op1,+Op2)
  
  For binary operator and its left argument:
         (a Op2 b) Op1 c, (Op2 a) Op1 b, (a Op2) Op1 b
  returns true if parens can be stripped; false otherwise.

  Global variable
      can_strip_parens = 1 means it can strip parentheses, 
		       = 0 means it can't.

  Considering mutiple definitions for both operators, if in all cases:
  
  1. Priorities(Op2) = Priorities(Op1), call strip_parens_binary_left/2
					to set can_strip_parens, accordingly.
  2. Priority(Op2) < Priority(Op1), can_strip_parens = 1,
  3. Other cases, can_strip_parens = 0,

  setof/3 is to delete duplicates.
*****************************************************************************/
can_strip_parens_binary_left(Op1,Op2) :-  
	conset(can_strip_parens,0),
	setof(Opp1, Opa1 ^ infix_op(Opp1,Opa1,Op1), Pre_Op1),
	setof(Opp2, Opa2 ^ '_$op'(Opp2,Opa2,Op2), Pre_Op2),
	
	( Pre_Op1 = [A], Pre_Op2 = [A]  % All priorities of Op1,Op2 are equal
	-> findall([Opp1,Opa1,Op1], infix_op(Opp1,Opa1,Op1), Def_Op1),
	    findall([Opp2,Opa2,Op2], '_$op'(Opp2,Opa2,Op2), Def_Op2),
	    %% The list version of same function
	    catch(strip_parens_binary_left(Def_Op1,Def_Op2),
		  quit(_),
		  true)
	;  all_less_than(Pre_Op2,Pre_Op1)
	-> conset(can_strip_parens,1) % can strip
	;  conset(can_strip_parens,0) % can't
	),
	(conget(can_strip_parens,1)-> true; !, fail).

/****************************************************************************
  strip_parens_binary_left(+ListOfOpDefs1,+ListOfOpDefs2)

  Given ListOfOp1 and ListOfOp1, which are two lists of different definitions 
  of two operators, where
  
      (a Op2 b) Op1 c, (Op2 a) Op1 b, (a Op2) Op1 b
	      Op1, Op2 have same priorities

  consets can_strip_parens based on following algorithm:
      
      if  unparsable -> can_strip_parens=0,continue
      else  if  ambiguous -> can_strip_paren=0,fail and exit
      else  can_strip_paren=1.
****************************************************************************/
strip_parens_binary_left([],_) :- !.
strip_parens_binary_left(_,[]) :- !.

strip_parens_binary_left(L1,L2) :-
	L1 = [L1H|L1T], L2 = [L2H|L2T],   
	L1H = [_,Opa1,_], L2H = [_,Opa2,_], 
	( (Opa1 == xfy; Opa1 == xfx) % unparsable
	-> conset(can_strip_parens,0),
	    strip_parens_binary_left(L1T,L2)
	;  Opa1 == yfx, (Opa2 == xfy; Opa2 == fy)  % ambiguous
	-> conset(can_strip_parens,0), throw(quit(a))
	;  conset(can_strip_parens,1)
	), 
	strip_parens_binary_left(L1, L2T). %% next iteration

/***************************************************************************
  can_strip_parens_binary_right(+Op1,+Op2)
  
  For binary operator and its right argument
           a Op1 (b Op2 c), a Op1 (Op2 b), a Op1 (b Op2)
  returns true if it can strip parentheses; false otherwise.

  Set can_strip_parens to 1 if it can strip parentheses; 0 otherwise.
  
  Considering mutiple definitions for both operators, in all the cases:
  
  1. Priorities(Op2) = Priorities(Op1), call strip_parenns_binary_right/2
     				    to set can_strip_parens, accordingly.
  2. Priority(Op2) < Priority(Op1), can_strip_parens = 1,
  3. Other cases, can_strip_parens = 0,
     
***************************************************************************/
can_strip_parens_binary_right(Op1,Op2) :-  
	conset(can_strip_parens,0),
	setof(Opp1, Opa1 ^ infix_op(Opp1,Opa1,Op1), Pre_Op1),
	setof(Opp2, Opa2 ^ '_$op'(Opp2,Opa2,Op2), Pre_Op2),
	
	( Pre_Op1 = [A], Pre_Op2 = [A]  % all priorities are equal
	-> findall([Opp1,Opa1,Op1], infix_op(Opp1,Opa1,Op1), Def_Op1),
	   findall([Opp2,Opa2,Op2], '_$op'(Opp2,Opa2,Op2), Def_Op2),
	   catch(strip_parens_binary_right(Def_Op1,Def_Op2),
		 quit(_),
		 true)
	; all_less_than(Pre_Op2,Pre_Op1)
	-> conset(can_strip_parens,1) % can strip
	; conset(can_strip_parens,0)  % can't
	),
	(conget(can_strip_parens,1)-> true; !, fail).


/***************************************************************************
  strip_parens_binary_right(+ListOfOp1,+ListOfOp2)

  Given ListOfOp1 and ListOfOp1, which are two lists of different definitions 
  for two operators, where
  
       a Op1 (b Op2 c), a Op1 (Op2 b), a Op1 (b Op2)
              priorities of Op1,Op2 are same

  consets can_strip_parens based on following algorithm:
      
      if  unparsable -> can_strip_parens=0,continue
      else if  ambiguous -> can_strip_paren=0,fail and exit
      else  can_strip_paren=1.
***************************************************************************/
strip_parens_binary_right([],_) :- !.
strip_parens_binary_right(_,[]) :- !.

strip_parens_binary_right(L1,L2) :-
	L1 = [L1H|L1T], L2 = [L2H|L2T],
	L1H = [_,Opa1,_], L2H = [_,Opa2,_],
	(Opa1 == yfx; Opa1 == xfx; Opa1 == xfy),
	( (Opa1 == yfx; Opa1 == xfx)   % unparsable
	-> conset(can_strip_parens,0),
	    strip_parens_binary_right(L1T,L2)
	;  Opa1 == xfy, (Opa2 == yfx; Opa2 == yf)   % ambiguous
	-> conset(can_strip_parens,0),throw(quit(a))
	;  conset(can_strip_parens,1) 
	),
	strip_parens_binary_right(L1, L2T).

/***************************************************************************
  can_strip_parens_prefix(+Op1,+Op2)
  For prefix operator: Op1 (a Op2 b), Op1 (Op2 b), Op1 (b Op2),
  returns true if it can strip parentheses; false otherwise.

  Set can_strip_parens to 1 if it can strip parentheses; 0 otherwise.
  
  Considering mutiple definitions for both operators:
  
  1. Priority(Op2) = Priority(Op1), call strip_parenns_prefix/2
     				    to set can_strip_parens, accordingly.
  2. Priority(Op2) < Priority(Op1), can_strip_parens = 1,
  3. Other cases, can_strip_parens = 0,
     
***************************************************************************/
can_strip_parens_prefix(Op1,Op2) :-  
	conset(can_strip_parens,0),
	setof(Opp1, Opa1 ^ prefix_op(Opp1,Opa1,Op1), Pre_Op1),
	setof(Opp2, Opa2 ^ '_$op'(Opp2,Opa2,Op2), Pre_Op2),
	
	( Pre_Op1 = [A], Pre_Op2 = [A]  % all priorities are equal
	-> findall([Opp1,Opa1,Op1], prefix_op(Opp1,Opa1,Op1), Def_Op1),
	   findall([Opp2,Opa2,Op2], '_$op'(Opp2,Opa2,Op2), Def_Op2),
	   catch(strip_parens_prefix(Def_Op1,Def_Op2),
		 quit(_),
		 true)
	; all_less_than(Pre_Op2,Pre_Op1) % can strip
	-> conset(can_strip_parens,1)
	; conset(can_strip_parens,0)     % can't
	),
	(conget(can_strip_parens,1)-> true; !, fail).


/***************************************************************************
  strip_parens_prefix(+ListOfOp1,+ListOfOp2)
  
  Given ListOfOp1 and ListOfOp1, which are two lists of different definitions 
  for two operators, where

      Op1 (a Op2 b), Op1 (Op2 b), Op1 (b Op2),  Priorities of Op1, Op2 are same

  consets can_strip_parens based on following algorithm:
      
      if unparsable -> can_strip_parens=0,continue
      else if  ambiguous -> can_strip_paren=0,fail and exit
      else  can_strip_paren=1.
***************************************************************************/
strip_parens_prefix([],_) :- !.
strip_parens_prefix(_,[]) :- !.
     
strip_parens_prefix(L1,L2) :-
	L1 = [L1H|L1T], L2 = [L2H|L2T],
	L1H = [_,Opa1,_], L2H = [_,Opa2,_], 
	(Opa1 == fx; Opa1== fy),
	( Opa1 == fx    % unparsable
	-> conset(can_strip_parens,0),strip_parens_prefix(L1T,L2)
	;  Opa1 == fy, (Opa2 == yfx; Opa2 == yf)  % ambiguous
	-> conset(can_strip_parens,0),throw(quit(a))
	;  conset(can_strip_parens,1) 
	),
        strip_parens_prefix(L1, L2T).

/*************************************************************************
  can_strip_parens_post(+Op1,+Op2)
  For postfix operator: (a Op2 b) Op1 , (Op2 b) Op1, ( b Op2) Op1,
  returns true if it can strip parentheses; false otherwise.

  Set can_strip_parens to 1 if it can strip parentheses; 0 otherwise.
  
  Considering mutiple definitions for both operators:
  
  1. Priority(Op2) = Priority(Op1), call strip_parenns_post/2
     				    to set can_strip_parens, accordingly.
  2. Priority(Op2) < Priority(Op1), can_strip_parens = 1,
  3. Other cases, can_strip_parens = 0,
     
**************************************************************************/
can_strip_parens_post(Op1,Op2) :-  
	conset(can_strip_parens,0),
	setof(Opp1, Opa1 ^ postfix_op(Opp1,Opa1,Op1), Pre_Op1),
	setof(Opp2, Opa2 ^ '_$op'(Opp2,Opa2,Op2), Pre_Op2),
	
	( Pre_Op1 = [A], Pre_Op2 = [A]  % all priorities equal
	-> findall([Opp1,Opa1,Op1], postfix_op(Opp1,Opa1,Op1), Def_Op1),
	   findall([Opp2,Opa2,Op2], '_$op'(Opp2,Opa2,Op2), Def_Op2),
	   catch(strip_parens_post(Def_Op1,Def_Op2),
		 quit(_),
		 true)
	; all_less_than(Pre_Op2,Pre_Op1)  % can strip
	-> conset(can_strip_parens,1)
	; conset(can_strip_parens,0)      % can't
	),
	(conget(can_strip_parens,1)-> true; !, fail).

/*************************************************************************
  strip_parens_post(+ListOfOp1,+ListOfOp2)
  
  Given ListOfOp1 and ListOfOp1, which are two lists of different definitions 
  for two operators, where

      (a Op2 b) Op1 , (Op2 b) Op1, ( b Op2) Op1,  priorities equal

  consets can_strip_parens based on following algorithm:
      
     if unparsable -> can_strip_parens=0,continue
     else if  ambiguous -> can_strip_paren=0,fail and exit
     else  can_strip_paren=1.

**************************************************************************/
strip_parens_post([],_) :- !.
strip_parens_post(_,[]) :- !.

strip_parens_post(L1,L2) :-
	L1 = [L1H|L1T], L2 = [L2H|L2T],
	L1H = [_,Opa1,_], L2H = [_,Opa2,_], 
	(Opa1 == xf; Opa1 == yf),
	( Opa1 == xf      % unparsable
	-> conset(can_strip_parens,0),strip_parens_post(L1T,L2) 
	; Opa1 == yf, (Opa2 == xfy; Opa2 == fy)  % ambiguous
	-> conset(can_strip_parens,0),throw(quit(a))
	;  conset(can_strip_parens,1)
	),
	strip_parens_post(L1, L2T).

