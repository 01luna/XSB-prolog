/***************************************************************************
  file: closure/flrnoeqltrailer.fli

  Author(s): Guizhen Yang

  Contact:   flora-users@lists.sourceforge.net

  Copyright (C) The Research Foundation of SUNY, 1999-2001

  This is a template file to generate the FLORA trailer that has no
  equality maintenance.

  The actual include file, flrnoeqltrailer.flh,
   is generated by the predicate flWrapAround/1 in
  flrwraparound.P. It is invoked by the makefile when Flora is built.
***************************************************************************/


#include "flora_wspredicates.flh"
#include "flora_porting.flh"

:- import flora_warning_line/1 from flrprint.
:- import flora_funct_arity/2 from flrwrapper.


/***************************************************************************
  Note that all programs rules are translated with with a 'derived_' prefix.
  These rules are bridged to the trailer using wrapper predicates with a
  'inferred_' prefix.
***************************************************************************/


/***************************************************************************
  closure rules for X::Y
***************************************************************************/
sub(X,Y,CallerInfo) :-
	inferred_sub(X,Y,CallerInfo),
	(X=Y, flora_warning_line('cycle in class hierarchy'); true).

sub(X,Y,CallerInfo) :-
	silent_sub(X,Z,CallerInfo),
	inferred_sub(Z,Y,CallerInfo),
	(X=Y, flora_warning_line('cycle in class hierarchy'); true).


/***************************************************************************
  closure rules for O:C
***************************************************************************/
isa(O,C,CallerInfo) :-
	inferred_isa(O,C,CallerInfo).

isa(O,C,CallerInfo) :-
	silent_sub(S,C,CallerInfo),
	inferred_isa(O,S,CallerInfo).


/*****************************************************************************
  inheritable methods that are locally defined

  The argument "MethSign" is in the form of Funct/Arity/Type.
*****************************************************************************/
%% local_ifd/2
local_ifd(S,MethSign,CallerInfo) :-
	var(MethSign),
	!,
	inferred_ifd(S,M,_V,CallerInfo),
	%% Should have a cut here when XSB will allow
	flora_funct_arity(M,MethSign).

local_ifd(S,MethSign,CallerInfo) :-
	nonvar(MethSign), % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	inferred_ifd(S,M,_V,CallerInfo).
	%% Should have a cut here when XSB will allow


%% local_fd/2
local_fd(S,MethSign,CallerInfo) :-
	var(MethSign),
	!,
	inferred_fd(S,M,_V,CallerInfo),
	%% Should have a cut here when XSB will allow
	flora_funct_arity(M,MethSign).

local_fd(S,MethSign,CallerInfo) :-
	nonvar(MethSign), % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	inferred_fd(S,M,_V,CallerInfo).
	%% Should have a cut here when XSB will allow


%% local_imvd/2
local_imvd(S,MethSign,CallerInfo) :-
	var(MethSign),
	inferred_imvd(S,M,_V,CallerInfo),
	%% Should have a cut here when XSB will allow
	flora_funct_arity(M,MethSign).

local_imvd(S,MethSign,CallerInfo) :-
	var(MethSign),
	!,
	inferred_imvddef(S,M,CallerInfo),
	flora_funct_arity(M,MethSign).

local_imvd(S,MethSign,CallerInfo) :-
	nonvar(MethSign), % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	inferred_imvd(S,M,_V,CallerInfo).
	%% Should have a cut here when XSB will allow

local_imvd(S,MethSign,CallerInfo) :-
	nonvar(MethSign), % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	inferred_imvddef(S,M,CallerInfo).


%% local_mvd/2
local_mvd(S,MethSign,CallerInfo) :-
	var(MethSign),
	inferred_mvd(S,M,_V,CallerInfo),
	%% Should have a cut here when XSB will allow
	flora_funct_arity(M,MethSign).

local_mvd(S,MethSign,CallerInfo) :-
	var(MethSign),
	!,
	inferred_mvddef(S,M,CallerInfo),
	flora_funct_arity(M,MethSign).

local_mvd(S,MethSign,CallerInfo) :-
	nonvar(MethSign), % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	inferred_mvd(S,M,_V,CallerInfo).
	%% Should have a cut here when XSB will allow

local_mvd(S,MethSign,CallerInfo) :-
	nonvar(MethSign), % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	inferred_mvddef(S,M,CallerInfo).


/*****************************************************************************
  nonmonotonic multiple inheritance of scalar attributes
  from superclasses to subclasses
*****************************************************************************/
ifd(C,M,V,CallerInfo) :-
	inferred_ifd(C,M,V,CallerInfo).

ifd(C,M,V,CallerInfo) :-
	var(M),
	!,
	inheritance_ifd(Super,M,V,CallerInfo),
	flora_funct_arity(M,MethSign),
	candidate_class_ifd(Super,MethSign,C,CallerInfo),
	FLORA_TNOT(local_ifd(C,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_class_ifd(Super,MethSign,C,CallerInfo)).

ifd(C,M,V,CallerInfo) :-
	nonvar(M),  % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	candidate_class_ifd(Super,MethSign,C,CallerInfo),
	inheritance_ifd(Super,M,V,CallerInfo),
	FLORA_TNOT(local_ifd(C,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_class_ifd(Super,MethSign,C,CallerInfo)).


/*****************************************************************************
  nonmonotonic multiple inheritance of scalar attributes
  from superclasses to instances/members
*****************************************************************************/
fd(O,M,V,CallerInfo) :-
	inferred_fd(O,M,V,CallerInfo).

fd(O,M,V,CallerInfo) :-
	var(M),
	!,
	inheritance_ifd(Super,M,V,CallerInfo),
	flora_funct_arity(M,MethSign),
	candidate_object_ifd(Super,MethSign,O,CallerInfo),
	FLORA_TNOT(local_fd(O,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_object_ifd(Super,MethSign,O,CallerInfo)).

fd(O,M,V,CallerInfo) :-
	nonvar(M),  % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	candidate_object_ifd(Super,MethSign,O,CallerInfo),
	inheritance_ifd(Super,M,V,CallerInfo),
	FLORA_TNOT(local_fd(O,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_object_ifd(Super,MethSign,O,CallerInfo)).


/*****************************************************************************
  nonmonotonic multiple inheritance of multivalued attributes
  from superclasses to subclasses
*****************************************************************************/
imvd(C,M,V,CallerInfo) :-
	inferred_imvd(C,M,V,CallerInfo).

imvd(C,M,V,CallerInfo) :-
	var(M),
	!,
	inheritance_imvd(Super,M,V,CallerInfo),
	flora_funct_arity(M,MethSign),
	candidate_class_imvd(Super,MethSign,C,CallerInfo),
	FLORA_TNOT(local_imvd(C,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_class_imvd(Super,MethSign,C,CallerInfo)).

imvd(C,M,V,CallerInfo) :-
	nonvar(M),  % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	candidate_class_imvd(Super,MethSign,C,CallerInfo),
	inheritance_imvd(Super,M,V,CallerInfo),
	FLORA_TNOT(local_imvd(C,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_class_imvd(Super,MethSign,C,CallerInfo)).


imvddef(C,M,CallerInfo) :-
	inferred_imvddef(C,M,CallerInfo).

imvddef(C,M,CallerInfo) :-
	var(M),
	!,
	inheritance_imvddef(Super,M,CallerInfo),
	flora_funct_arity(M,MethSign),
	candidate_class_imvd(Super,MethSign,C,CallerInfo),
	FLORA_TNOT(local_imvd(C,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_class_imvd(Super,MethSign,C,CallerInfo)).

imvddef(C,M,CallerInfo) :-
	nonvar(M),  % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	candidate_class_imvd(Super,MethSign,C,CallerInfo),
	inheritance_imvddef(Super,M,CallerInfo),
	FLORA_TNOT(local_imvd(C,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_class_imvd(Super,MethSign,C,CallerInfo)).

imvddef(C,M,CallerInfo) :-
	imvd(C,M,_V,CallerInfo).
	%% Should have a cut here when XSB will allow


/*****************************************************************************
  nonmonotonic multiple inheritance of multivalued attributes
  from superclasses to instances/members
*****************************************************************************/
mvd(O,M,V,CallerInfo) :-
	inferred_mvd(O,M,V,CallerInfo).

mvd(O,M,V,CallerInfo) :-
	var(M),
	!,
	inheritance_imvd(Super,M,V,CallerInfo),
	flora_funct_arity(M,MethSign),
	candidate_object_imvd(Super,MethSign,O,CallerInfo),
	FLORA_TNOT(local_mvd(O,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_object_imvd(Super,MethSign,O,CallerInfo)).

mvd(O,M,V,CallerInfo) :-
	nonvar(M),  % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	candidate_object_imvd(Super,MethSign,O,CallerInfo),
	inheritance_imvd(Super,M,V,CallerInfo),
	FLORA_TNOT(local_mvd(O,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_object_imvd(Super,MethSign,O,CallerInfo)).


mvddef(O,M,CallerInfo) :-
	inferred_mvddef(O,M,CallerInfo).

mvddef(O,M,CallerInfo) :-
	var(M),
	!,
	inheritance_imvddef(Super,M,CallerInfo),
	flora_funct_arity(M,MethSign),
	candidate_object_imvd(Super,MethSign,O,CallerInfo),
	FLORA_TNOT(local_mvd(O,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_object_imvd(Super,MethSign,O,CallerInfo)).

mvddef(O,M,CallerInfo) :-
	nonvar(M),  % the cut above might not work under local scheduling
	flora_funct_arity(M,MethSign),
	candidate_object_imvd(Super,MethSign,O,CallerInfo),
	inheritance_imvddef(Super,M,CallerInfo),
	FLORA_TNOT(local_mvd(O,MethSign,CallerInfo)),
	FLORA_TNOT(multiple_object_imvd(Super,MethSign,O,CallerInfo)).

mvddef(O,M,CallerInfo) :-
	nonvar(M),  % the cut above might not work under local scheduling
	mvd(O,M,_V,CallerInfo).
	%% Should have a cut here when XSB will allow


/*****************************************************************************
  monotonic inheritance of binary attributes (tabled methods)
*****************************************************************************/
meth(O,M,CallerInfo) :-
	inferred_meth(O,M,CallerInfo).

meth(O,M,CallerInfo) :-
	isa(O,C,CallerInfo),
	imeth(C,M,CallerInfo).


imeth(C,M,CallerInfo) :-
	inferred_imeth(C,M,CallerInfo).

imeth(C,M,CallerInfo) :-
	inheritance_sub(C,S,CallerInfo),
	imeth(S,M,CallerInfo).


/*****************************************************************************
  nontabled methods (transactions)
*****************************************************************************/
tran(O,T,CallerInfo) :-
	inferred_tran(O,T,CallerInfo).


/*****************************************************************************
  monotonic inheritance of signatures
*****************************************************************************/
fdsig(O,M,R,CallerInfo) :-
	inferred_fdsig(O,M,R,CallerInfo).

fdsig(O,M,R,CallerInfo) :-
	isa(O,C,CallerInfo),
	ifdsig(C,M,R,CallerInfo).


fdsigdef(O,M,CallerInfo) :-
	inferred_fdsigdef(O,M,CallerInfo).

fdsigdef(O,M,CallerInfo) :-
	isa(O,C,CallerInfo),
	ifdsigdef(C,M,CallerInfo).

fdsigdef(O,M,CallerInfo) :-
	fdsig(O,M,_V,CallerInfo).
	%% Should have a cut here when XSB will allow


ifdsig(C,M,R,CallerInfo) :-
	inferred_ifdsig(C,M,R,CallerInfo).

ifdsig(C,M,R,CallerInfo) :-
	inheritance_sub(C,S,CallerInfo),
	ifdsig(S,M,R,CallerInfo).


ifdsigdef(C,M,CallerInfo) :-
	inferred_ifdsigdef(C,M,CallerInfo).

ifdsigdef(C,M,CallerInfo) :-
	inheritance_sub(C,S,CallerInfo),
	ifdsigdef(S,M,CallerInfo).

ifdsigdef(C,M,CallerInfo) :-
	ifdsig(C,M,_V,CallerInfo).
	%% Should have a cut here when XSB will allow


mvdsig(O,M,R,CallerInfo) :-
	inferred_mvdsig(O,M,R,CallerInfo).

mvdsig(O,M,R,CallerInfo) :-
	isa(O,C,CallerInfo),
	imvdsig(C,M,R,CallerInfo).


mvdsigdef(O,M,CallerInfo) :-
	inferred_mvdsigdef(O,M,CallerInfo).

mvdsigdef(O,M,CallerInfo) :-
	isa(O,C,CallerInfo),
	imvdsigdef(C,M,CallerInfo).

mvdsigdef(O,M,CallerInfo) :-
	mvdsig(O,M,_V,CallerInfo).
	%% Should have a cut here when XSB will allow


imvdsig(C,M,R,CallerInfo) :-
	inferred_imvdsig(C,M,R,CallerInfo).

imvdsig(C,M,R,CallerInfo) :-
	inheritance_sub(C,S,CallerInfo),
	imvdsig(S,M,R,CallerInfo).


imvdsigdef(C,M,CallerInfo) :-
	inferred_imvdsigdef(C,M,CallerInfo).

imvdsigdef(C,M,CallerInfo) :-
	inheritance_sub(C,S,CallerInfo),
	imvdsigdef(S,M,CallerInfo).

imvdsigdef(C,M,CallerInfo) :-
	imvdsig(C,M,_V,CallerInfo).
	%% Should have a cut here when XSB will allow


/*****************************************************************************
  object existence
*****************************************************************************/
exists(X,CallerInfo) :-
	inferred_exists(X,CallerInfo).


/*****************************************************************************
  equality maintenance
  Here we just treat :=: as an ordinary relation.
*****************************************************************************/
diffobjeql(X,Y,CallerInfo) :-
	inferred_objeql(X,Y,CallerInfo),
	X \= Y.
